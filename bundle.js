(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()({1:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var dl = require("deeplearn");
// const tensorflowReader = new TensorflowLoader(NDArray);
// tensorflowReader.loadRemoteFiles('tf_model/model.ckpt-200').then((vars) => {
//     console.log('Done');
// }); 
// manifest.json lives in the same directory as the mnist demo.
var label_strings = ['bed', 'chair', 'lamp', 'shelf', 'sofa', 'stool', 'table', 'wardrobe'];
var reader = new dl.CheckpointLoader('color_model');
reader.getAllVariables().then(function (vars) {
    // Get sample data.
    var xhr = new XMLHttpRequest();
    xhr.open('GET', 'test_color_data.json');
    xhr.onload = function () { return __awaiter(_this, void 0, void 0, function () {
        var data, numCorrect, _loop_1, i, accuracy;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    data = JSON.parse(xhr.responseText);
                    console.log("Evaluation set: n=" + data.images.length + ".");
                    numCorrect = 0;
                    _loop_1 = function (i) {
                        var inferred, predictedLabel, _a, _b, label;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0:
                                    inferred = dl.tidy(function () {
                                        var x = dl.tensor3d(data.images[i]);
                                        return infer(x, vars);
                                        // Infer through the model to get a prediction.
                                    });
                                    _b = (_a = Math).round;
                                    return [4 /*yield*/, inferred.val()];
                                case 1:
                                    predictedLabel = _b.apply(_a, [_c.sent()]);
                                    inferred.dispose();
                                    console.log("Item " + i + ", predicted label " + predictedLabel + ".");
                                    label = data.labels[i];
                                    if (label === predictedLabel) {
                                        numCorrect++;
                                    }
                                    // Show the image.
                                    dl.tidy(function () {
                                        var result = renderResults(dl.tensor1d(data.images[i]), label_strings[label], label_strings[predictedLabel]);
                                        document.body.appendChild(result);
                                    });
                                    return [2 /*return*/];
                            }
                        });
                    };
                    i = 0;
                    _a.label = 1;
                case 1:
                    if (!(i < data.images.length)) return [3 /*break*/, 4];
                    return [5 /*yield**/, _loop_1(i)];
                case 2:
                    _a.sent();
                    _a.label = 3;
                case 3:
                    i++;
                    return [3 /*break*/, 1];
                case 4:
                    accuracy = numCorrect * 100 / data.images.length;
                    document.getElementById('accuracy').innerHTML = accuracy + "%";
                    return [2 /*return*/];
            }
        });
    }); };
    xhr.onerror = function (err) { return console.error(err); };
    xhr.send();
    console.log("Loaded");
});
/**
 * Infers through a 3-layer fully connected MNIST model using the Math API.
 * This is the lowest level user-facing API in deeplearn.js giving the most
 * control to the user. Math commands execute immediately, like numpy.
 */
function infer(x, vars) {
    var conv1B = vars['ConvNet/conv2d/bias'];
    var conv1W = vars['ConvNet/conv2d/kernel'];
    var conv2B = vars['ConvNet/conv2d_1/bias'];
    var conv2W = vars['ConvNet/conv2d_1/kernel'];
    var hidden1B = vars['ConvNet/dense/bias'];
    var hidden1W = vars['ConvNet/dense/kernel'];
    var hidden2B = vars['ConvNet/dense_1/bias'];
    var hidden2W = vars['ConvNet/dense_1/kernel'];
    // const softmaxW = vars['softmax_linear/weights'] as dl.Tensor2D;
    // const softmaxB = vars['softmax_linear/biases'] as dl.Tensor1D;
    var conv1 = dl.conv2d(x.as4D(-1, 64, 64, 3), conv1W, 1, 'valid');
    var conv1_b = conv1.add(conv1B).relu();
    var conv1_pool = dl.maxPool(conv1_b, 2, 2, 'valid');
    var conv2 = dl.conv2d(conv1_pool, conv2W, 1, 'valid');
    var conv2_b = conv2.add(conv2B).relu();
    var conv2_pool = dl.maxPool(conv2_b, 2, 2, 'valid');
    var hidden1 = conv2_pool.as2D(-1, hidden1W.shape[0]).matMul(hidden1W).add(hidden1B);
    var hidden2 = hidden1.as2D(-1, hidden2W.shape[0]).matMul(hidden2W).add(hidden2B);
    var logits = hidden2.softmax();
    console.log(logits.shape);
    return logits.argMax();
}
exports.infer = infer;
function renderImage(array) {
    var width = 64;
    var height = 64;
    var canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    var float32Array = array.dataSync();
    var imageData = ctx.createImageData(width, height);
    for (var i = 0, j = 0; i < float32Array.length; i += 3, j += 4) {
        var r_value = Math.round(float32Array[i] * 255);
        var g_value = Math.round(float32Array[i + 1] * 255);
        var b_value = Math.round(float32Array[i + 2] * 255);
        imageData.data[j + 0] = r_value;
        imageData.data[j + 1] = g_value;
        imageData.data[j + 2] = b_value;
        imageData.data[j + 3] = 255;
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas;
}
function renderResults(array, label, predictedLabel) {
    var root = document.createElement('div');
    root.appendChild(renderImage(array));
    var actual = document.createElement('div');
    actual.innerHTML = "Actual: " + label;
    root.appendChild(actual);
    var predicted = document.createElement('div');
    predicted.innerHTML = "Predicted: " + predictedLabel;
    root.appendChild(predicted);
    if (label !== predictedLabel) {
        root.classList.add('error');
    }
    root.classList.add('result');
    return root;
}

},{"deeplearn":60}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var BrowserUtil = (function () {
    function BrowserUtil() {
    }
    BrowserUtil.nextFrame = function () {
        return new Promise(function (resolve) { return requestAnimationFrame(function () { return resolve(); }); });
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], BrowserUtil, "nextFrame", null);
    return BrowserUtil;
}());
exports.BrowserUtil = BrowserUtil;

},{"./doc":25}],4:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var tensor_1 = require("../../tensor");
var util = require("../../util");
var BatchDataset = (function () {
    function BatchDataset(base, batchSize, smallLastBatch) {
        if (smallLastBatch === void 0) { smallLastBatch = true; }
        this.base = base;
        this.batchSize = batchSize;
        this.smallLastBatch = smallLastBatch;
    }
    BatchDataset.prototype.getStream = function () {
        return __awaiter(this, void 0, void 0, function () {
            var batchesAsArrays;
            return __generator(this, function (_a) {
                batchesAsArrays = this.base.getStream().batch(this.batchSize, this.smallLastBatch);
                return [2, batchesAsArrays.map(makeDatasetBatch)];
            });
        });
    };
    return BatchDataset;
}());
exports.BatchDataset = BatchDataset;
function makeDatasetBatch(elements) {
    var rotated = {};
    var firstElement = elements[0];
    var keys = Object.keys(firstElement);
    keys.forEach(function (key) {
        rotated[key] = [];
    });
    var _loop_1 = function (e) {
        keys.forEach(function (key) {
            var value = e[key];
            rotated[key].push(value);
        });
    };
    for (var _i = 0, elements_1 = elements; _i < elements_1.length; _i++) {
        var e = elements_1[_i];
        _loop_1(e);
    }
    var result = {};
    keys.forEach(function (key) {
        if (rotated[key].length !== elements.length) {
            throw new Error("Batching failed to get a '" + key + "' value for each element.");
        }
        if (typeof rotated[key][0] === 'string') {
            result[key] = rotated[key];
        }
        else {
            result[key] = batchConcat(rotated[key]);
        }
    });
    elements.forEach(globals_1.dispose);
    return result;
}
function batchConcat(arrays) {
    var elementShape = shapeAndValues(arrays[0])[0];
    var batchShape = [arrays.length].concat(elementShape);
    var resultVals = new Float32Array(batchShape.reduce(function (x, y) { return x * y; }));
    var offset = 0;
    for (var _i = 0, arrays_1 = arrays; _i < arrays_1.length; _i++) {
        var a = arrays_1[_i];
        var _a = shapeAndValues(a), aShape = _a[0], aVals = _a[1];
        if (!util.arraysEqual(aShape, elementShape)) {
            throw new Error('Elements must have the same shape to be batched');
        }
        resultVals.set(aVals, offset);
        offset += aVals.length;
    }
    var result = tensor_1.Tensor.make(batchShape, { values: resultVals });
    return result;
}
function shapeAndValues(array) {
    if (array instanceof tensor_1.Tensor) {
        return [array.shape, array.dataSync()];
    }
    else if (Array.isArray(array)) {
        return [[array.length], array];
    }
    else {
        return [[], [array]];
    }
}

},{"../../globals":28,"../../tensor":137,"../../util":143}],5:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var globals_1 = require("../../globals");
var batch_dataset_1 = require("./batch_dataset");
var statistics_1 = require("./statistics");
var data_stream_1 = require("./streams/data_stream");
var data_stream_2 = require("./streams/data_stream");
var data_stream_3 = require("./streams/data_stream");
var Dataset = (function () {
    function Dataset() {
    }
    Dataset.prototype.computeStatistics = function (sampleSize, shuffleWindowSize) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, statistics_1.computeDatasetStatistics(this, sampleSize, shuffleWindowSize)];
            });
        });
    };
    Dataset.prototype.filter = function (filterer) {
        var base = this;
        return datasetFromStreamFn(function () {
            return base.getStream().filter(function (x) { return globals_1.tidy(function () { return filterer(x); }); });
        });
    };
    Dataset.prototype.map = function (transform) {
        var base = this;
        return datasetFromStreamFn(function () {
            return base.getStream().map(function (x) { return globals_1.tidy(function () { return transform(x); }); });
        });
    };
    Dataset.prototype.batch = function (batchSize, smallLastBatch) {
        if (smallLastBatch === void 0) { smallLastBatch = true; }
        return new batch_dataset_1.BatchDataset(this, batchSize, smallLastBatch);
    };
    Dataset.prototype.concatenate = function (dataset) {
        var base = this;
        return datasetFromStreamFn(function () { return base.getStream().concatenate(dataset.getStream()); });
    };
    Dataset.prototype.repeat = function (count) {
        var base = this;
        return datasetFromStreamFn(function () {
            var streamStream = data_stream_1.streamFromFunction(function () { return ({ value: base.getStream(), done: false }); });
            return data_stream_2.streamFromConcatenated(streamStream.take(count));
        });
    };
    Dataset.prototype.take = function (count) {
        var base = this;
        return datasetFromStreamFn(function () { return base.getStream().take(count); });
    };
    Dataset.prototype.skip = function (count) {
        var base = this;
        return datasetFromStreamFn(function () { return base.getStream().skip(count); });
    };
    Dataset.prototype.shuffle = function (bufferSize, seed, reshuffleEachIteration) {
        if (reshuffleEachIteration === void 0) { reshuffleEachIteration = true; }
        var base = this;
        var random = seedrandom(seed);
        return datasetFromStreamFn(function () {
            var seed2 = random.int32();
            if (reshuffleEachIteration) {
                seed2 += random.int32();
            }
            return base.getStream().shuffle(bufferSize, seed2.toString());
        });
    };
    Dataset.prototype.prefetch = function (bufferSize) {
        var base = this;
        return datasetFromStreamFn(function () { return base.getStream().prefetch(bufferSize); });
    };
    Dataset.prototype.collectAll = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.getStream().collectRemaining()];
            });
        });
    };
    Dataset.prototype.forEach = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.getStream().forEach(f)];
            });
        });
    };
    return Dataset;
}());
exports.Dataset = Dataset;
function datasetFromStreamFn(getStreamFn) {
    return new (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.getStream = function () {
            return getStreamFn();
        };
        return class_1;
    }(Dataset))();
}
exports.datasetFromStreamFn = datasetFromStreamFn;
function datasetFromElements(items) {
    return datasetFromStreamFn(function () { return data_stream_3.streamFromItems(items); });
}
exports.datasetFromElements = datasetFromElements;

},{"../../globals":28,"./batch_dataset":4,"./statistics":11,"./streams/data_stream":13,"seedrandom":146}],6:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var dataset_1 = require("../dataset");
var text_line_dataset_1 = require("./text_line_dataset");
var CsvHeaderConfig;
(function (CsvHeaderConfig) {
    CsvHeaderConfig[CsvHeaderConfig["READ_FIRST_LINE"] = 0] = "READ_FIRST_LINE";
    CsvHeaderConfig[CsvHeaderConfig["NUMBERED"] = 1] = "NUMBERED";
})(CsvHeaderConfig = exports.CsvHeaderConfig || (exports.CsvHeaderConfig = {}));
var CSVDataset = (function (_super) {
    __extends(CSVDataset, _super);
    function CSVDataset(input) {
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.hasHeaderLine = false;
        _this.base = new text_line_dataset_1.TextLineDataset(input, CSVDataset.textColumnName);
        return _this;
    }
    Object.defineProperty(CSVDataset.prototype, "csvColumnNames", {
        get: function () {
            return this._csvColumnNames;
        },
        enumerable: true,
        configurable: true
    });
    CSVDataset.prototype.setCsvColumnNames = function (csvColumnNames) {
        return __awaiter(this, void 0, void 0, function () {
            var stream, firstElement, firstLine, stream, firstElement, firstLine;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(csvColumnNames == null || csvColumnNames === CsvHeaderConfig.NUMBERED)) return [3, 2];
                        stream = this.base.getStream();
                        return [4, stream.next()];
                    case 1:
                        firstElement = _a.sent();
                        if (firstElement.done) {
                            throw new Error('No data was found for CSV parsing.');
                        }
                        firstLine = firstElement.value[CSVDataset.textColumnName];
                        this._csvColumnNames =
                            Array.from(firstLine.split(',').keys()).map(function (x) { return x.toString(); });
                        return [3, 5];
                    case 2:
                        if (!(csvColumnNames === CsvHeaderConfig.READ_FIRST_LINE)) return [3, 4];
                        stream = this.base.getStream();
                        return [4, stream.next()];
                    case 3:
                        firstElement = _a.sent();
                        if (firstElement.done) {
                            throw new Error('No data was found for CSV parsing.');
                        }
                        firstLine = firstElement.value[CSVDataset.textColumnName];
                        this._csvColumnNames = firstLine.split(',');
                        this.hasHeaderLine = true;
                        return [3, 5];
                    case 4:
                        this._csvColumnNames = csvColumnNames;
                        _a.label = 5;
                    case 5: return [2];
                }
            });
        });
    };
    CSVDataset.create = function (input, csvColumnNames) {
        if (csvColumnNames === void 0) { csvColumnNames = CsvHeaderConfig.NUMBERED; }
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = new CSVDataset(input);
                        return [4, result.setCsvColumnNames(csvColumnNames)];
                    case 1:
                        _a.sent();
                        return [2, result];
                }
            });
        });
    };
    CSVDataset.prototype.getStream = function () {
        var _this = this;
        var lines = this.base.getStream();
        if (this.hasHeaderLine) {
            lines = lines.skip(1);
        }
        return lines.map(function (x) { return _this.makeDatasetElement(x); });
    };
    CSVDataset.prototype.makeDatasetElement = function (element) {
        var line = element[CSVDataset.textColumnName];
        var values = line.split(',');
        var result = {};
        for (var i = 0; i < this._csvColumnNames.length; i++) {
            var value = values[i];
            if (value === '') {
                result[this._csvColumnNames[i]] = undefined;
            }
            else {
                var valueAsNum = Number(value);
                if (isNaN(valueAsNum)) {
                    result[this._csvColumnNames[i]] = value;
                }
                else {
                    result[this._csvColumnNames[i]] = valueAsNum;
                }
            }
        }
        return result;
    };
    CSVDataset.textColumnName = 'line';
    return CSVDataset;
}(dataset_1.Dataset));
exports.CSVDataset = CSVDataset;

},{"../dataset":5,"./text_line_dataset":7}],7:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var dataset_1 = require("../dataset");
var TextLineDataset = (function (_super) {
    __extends(TextLineDataset, _super);
    function TextLineDataset(input, columnName) {
        if (columnName === void 0) { columnName = 'line'; }
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.columnName = columnName;
        return _this;
    }
    TextLineDataset.prototype.getStream = function () {
        var _this = this;
        var readStream = this.input.getStream();
        var utf8Stream = readStream.decodeUTF8();
        var lineStream = utf8Stream.split('\n');
        return lineStream.map(function (x) {
            return (_a = {}, _a[_this.columnName] = x, _a);
            var _a;
        });
    };
    return TextLineDataset;
}(dataset_1.Dataset));
exports.TextLineDataset = TextLineDataset;

},{"../dataset":5}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DataSource = (function () {
    function DataSource() {
    }
    return DataSource;
}());
exports.DataSource = DataSource;

},{}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var datasource_1 = require("../datasource");
var filereader_stream_1 = require("../streams/filereader_stream");
var FileDataSource = (function (_super) {
    __extends(FileDataSource, _super);
    function FileDataSource(input, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.input = input;
        _this.options = options;
        return _this;
    }
    FileDataSource.prototype.getStream = function () {
        return new filereader_stream_1.FileReaderStream(this.input, this.options);
    };
    return FileDataSource;
}(datasource_1.DataSource));
exports.FileDataSource = FileDataSource;

},{"../datasource":8,"../streams/filereader_stream":14}],10:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var datasource_1 = require("../datasource");
var url_stream_1 = require("../streams/url_stream");
var URLDataSource = (function (_super) {
    __extends(URLDataSource, _super);
    function URLDataSource(url, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.url = url;
        _this.options = options;
        return _this;
    }
    URLDataSource.prototype.getStream = function () {
        return new url_stream_1.URLStream(this.url, this.options);
    };
    return URLDataSource;
}(datasource_1.DataSource));
exports.URLDataSource = URLDataSource;

},{"../datasource":8,"../streams/url_stream":16}],11:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("../../tensor");
function scaleTo01(min, max) {
    var range = max - min;
    var minTensor = tensor_1.Scalar.new(min);
    var rangeTensor = tensor_1.Scalar.new(range);
    return function (value) {
        if (typeof (value) === 'string') {
            throw new Error('Can\'t scale a string.');
        }
        else {
            if (value instanceof tensor_1.Tensor) {
                var result = value.sub(minTensor).div(rangeTensor);
                return result;
            }
            else if (value instanceof Array) {
                return value.map(function (v) { return (v - min) / range; });
            }
            else {
                return (value - min) / range;
            }
        }
    };
}
exports.scaleTo01 = scaleTo01;
function computeDatasetStatistics(dataset, sampleSize, shuffleWindowSize) {
    return __awaiter(this, void 0, void 0, function () {
        var sampleDataset, result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    sampleDataset = dataset;
                    if (shuffleWindowSize != null) {
                        sampleDataset = sampleDataset.shuffle(shuffleWindowSize);
                    }
                    if (sampleSize != null) {
                        sampleDataset = sampleDataset.take(sampleSize);
                    }
                    result = {};
                    return [4, sampleDataset.forEach(function (e) {
                            for (var key in e) {
                                var value = e[key];
                                if (typeof (value) === 'string') {
                                }
                                else {
                                    var recordMin = void 0;
                                    var recordMax = void 0;
                                    if (value instanceof tensor_1.Tensor) {
                                        recordMin = value.min().dataSync()[0];
                                        recordMax = value.max().dataSync()[0];
                                    }
                                    else if (value instanceof Array) {
                                        recordMin = value.reduce(function (a, b) { return Math.min(a, b); });
                                        recordMax = value.reduce(function (a, b) { return Math.max(a, b); });
                                    }
                                    else if (!isNaN(value) && isFinite(value)) {
                                        recordMin = value;
                                        recordMax = value;
                                    }
                                    else {
                                        throw new Error("Cannot compute statistics: " + key + " = " + value);
                                    }
                                    var columnStats = result[key];
                                    if (columnStats == null) {
                                        columnStats = {
                                            min: Number.POSITIVE_INFINITY,
                                            max: Number.NEGATIVE_INFINITY
                                        };
                                        result[key] = columnStats;
                                    }
                                    columnStats.min = Math.min(columnStats.min, recordMin);
                                    columnStats.max = Math.max(columnStats.max, recordMax);
                                }
                            }
                        })];
                case 1:
                    _a.sent();
                    return [2, result];
            }
        });
    });
}
exports.computeDatasetStatistics = computeDatasetStatistics;

},{"../../tensor":137}],12:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var utf8 = require("utf8");
var data_stream_1 = require("./data_stream");
var string_stream_1 = require("./string_stream");
var ByteStream = (function (_super) {
    __extends(ByteStream, _super);
    function ByteStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ByteStream.prototype.decodeUTF8 = function () {
        return new Utf8Stream(this);
    };
    return ByteStream;
}(data_stream_1.DataStream));
exports.ByteStream = ByteStream;
var Utf8Stream = (function (_super) {
    __extends(Utf8Stream, _super);
    function Utf8Stream(upstream) {
        var _this = _super.call(this) || this;
        _this.impl = new Utf8StreamImpl(upstream);
        return _this;
    }
    Utf8Stream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.impl.next()];
            });
        });
    };
    return Utf8Stream;
}(string_stream_1.StringStream));
var Utf8StreamImpl = (function (_super) {
    __extends(Utf8StreamImpl, _super);
    function Utf8StreamImpl(upstream) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.partial = new Uint8Array([]);
        _this.partialBytesValid = 0;
        return _this;
    }
    Utf8StreamImpl.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunkResult, chunk, partialBytesRemaining, nextIndex, okUpToIndex, splitUtfWidth, bulk, reassembled;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.upstream.next()];
                    case 1:
                        chunkResult = _a.sent();
                        if (chunkResult.done) {
                            if (this.partial.length === 0) {
                                return [2, false];
                            }
                            chunk = new Uint8Array([]);
                        }
                        else {
                            chunk = chunkResult.value;
                        }
                        partialBytesRemaining = this.partial.length - this.partialBytesValid;
                        nextIndex = partialBytesRemaining;
                        okUpToIndex = nextIndex;
                        splitUtfWidth = 0;
                        while (nextIndex < chunk.length) {
                            okUpToIndex = nextIndex;
                            splitUtfWidth = utfWidth(chunk[nextIndex]);
                            nextIndex = okUpToIndex + splitUtfWidth;
                        }
                        if (nextIndex === chunk.length) {
                            okUpToIndex = nextIndex;
                        }
                        bulk = utf8.decode(String.fromCharCode.apply(null, chunk.slice(partialBytesRemaining, okUpToIndex)));
                        if (partialBytesRemaining > 0) {
                            this.partial.set(chunk.slice(0, partialBytesRemaining), this.partialBytesValid);
                            reassembled = utf8.decode(String.fromCharCode.apply(null, this.partial));
                            this.outputQueue.push(reassembled + bulk);
                        }
                        else {
                            this.outputQueue.push(bulk);
                        }
                        if (okUpToIndex === chunk.length) {
                            this.partial = new Uint8Array([]);
                            this.partialBytesValid = 0;
                        }
                        else {
                            this.partial = new Uint8Array(new ArrayBuffer(splitUtfWidth));
                            this.partial.set(chunk.slice(okUpToIndex), 0);
                            this.partialBytesValid = chunk.length - okUpToIndex;
                        }
                        return [2, true];
                }
            });
        });
    };
    return Utf8StreamImpl;
}(data_stream_1.QueueStream));
function utfWidth(firstByte) {
    if (firstByte >= 252) {
        return 6;
    }
    else if (firstByte >= 248) {
        return 5;
    }
    else if (firstByte >= 240) {
        return 4;
    }
    else if (firstByte >= 224) {
        return 3;
    }
    else if (firstByte >= 192) {
        return 2;
    }
    else {
        return 1;
    }
}

},{"./data_stream":13,"./string_stream":15,"utf8":154}],13:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var globals_1 = require("../../../globals");
var util_1 = require("../../../util");
var growing_ring_buffer_1 = require("../util/growing_ring_buffer");
var ring_buffer_1 = require("../util/ring_buffer");
function streamFromItems(items) {
    return new ArrayStream(items);
}
exports.streamFromItems = streamFromItems;
function streamFromIncrementing(start) {
    var i = start;
    return streamFromFunction(function () { return ({ value: i++, done: false }); });
}
exports.streamFromIncrementing = streamFromIncrementing;
function streamFromFunction(func) {
    return new FunctionCallStream(func);
}
exports.streamFromFunction = streamFromFunction;
function streamFromConcatenated(baseStreams) {
    return ChainedStream.create(baseStreams);
}
exports.streamFromConcatenated = streamFromConcatenated;
function streamFromConcatenatedFunction(streamFunc, count) {
    return streamFromConcatenated(streamFromFunction(streamFunc).take(count));
}
exports.streamFromConcatenatedFunction = streamFromConcatenatedFunction;
var DataStream = (function () {
    function DataStream() {
    }
    DataStream.prototype.collectRemaining = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result, x;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        result = [];
                        return [4, this.next()];
                    case 1:
                        x = _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!!x.done) return [3, 4];
                        result.push(x.value);
                        return [4, this.next()];
                    case 3:
                        x = _a.sent();
                        return [3, 2];
                    case 4: return [2, result];
                }
            });
        });
    };
    DataStream.prototype.resolveFully = function () {
        return __awaiter(this, void 0, void 0, function () {
            var x;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.next()];
                    case 1:
                        x = _a.sent();
                        _a.label = 2;
                    case 2:
                        if (!!x.done) return [3, 4];
                        return [4, this.next()];
                    case 3:
                        x = _a.sent();
                        return [3, 2];
                    case 4: return [2];
                }
            });
        });
    };
    DataStream.prototype.filter = function (predicate) {
        return new FilterStream(this, predicate);
    };
    DataStream.prototype.map = function (transform) {
        return new MapStream(this, transform);
    };
    DataStream.prototype.forEach = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.map(f).resolveFully()];
            });
        });
    };
    DataStream.prototype.batch = function (batchSize, smallLastBatch) {
        if (smallLastBatch === void 0) { smallLastBatch = true; }
        return new BatchStream(this, batchSize, smallLastBatch);
    };
    DataStream.prototype.concatenate = function (stream) {
        return ChainedStream.create(streamFromItems([this, stream]));
    };
    DataStream.prototype.take = function (count) {
        if (count < 0 || count == null) {
            return this;
        }
        return new TakeStream(this, count);
    };
    DataStream.prototype.skip = function (count) {
        if (count < 0 || count == null) {
            return this;
        }
        return new SkipStream(this, count);
    };
    DataStream.prototype.prefetch = function (bufferSize) {
        return new PrefetchStream(this, bufferSize);
    };
    DataStream.prototype.shuffle = function (windowSize, seed) {
        return new ShuffleStream(this, windowSize, seed);
    };
    return DataStream;
}());
exports.DataStream = DataStream;
var ArrayStream = (function (_super) {
    __extends(ArrayStream, _super);
    function ArrayStream(items) {
        var _this = _super.call(this) || this;
        _this.items = items;
        _this.trav = 0;
        return _this;
    }
    ArrayStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                if (this.trav >= this.items.length) {
                    return [2, { value: null, done: true }];
                }
                result = this.items[this.trav];
                this.trav++;
                return [2, { value: result, done: false }];
            });
        });
    };
    return ArrayStream;
}(DataStream));
var FunctionCallStream = (function (_super) {
    __extends(FunctionCallStream, _super);
    function FunctionCallStream(nextFn) {
        var _this = _super.call(this) || this;
        _this.nextFn = nextFn;
        return _this;
    }
    FunctionCallStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.nextFn()];
            });
        });
    };
    return FunctionCallStream;
}(DataStream));
var SkipStream = (function (_super) {
    __extends(SkipStream, _super);
    function SkipStream(upstream, maxCount) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.maxCount = maxCount;
        _this.count = 0;
        return _this;
    }
    SkipStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var skipped;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.count++ < this.maxCount)) return [3, 2];
                        return [4, this.upstream.next()];
                    case 1:
                        skipped = _a.sent();
                        if (skipped.done) {
                            return [2, skipped];
                        }
                        globals_1.dispose(skipped.value);
                        return [3, 0];
                    case 2: return [2, this.upstream.next()];
                }
            });
        });
    };
    return SkipStream;
}(DataStream));
var TakeStream = (function (_super) {
    __extends(TakeStream, _super);
    function TakeStream(upstream, maxCount) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.maxCount = maxCount;
        _this.count = 0;
        return _this;
    }
    TakeStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.count++ >= this.maxCount) {
                    return [2, { value: null, done: true }];
                }
                return [2, this.upstream.next()];
            });
        });
    };
    return TakeStream;
}(DataStream));
var QueueStream = (function (_super) {
    __extends(QueueStream, _super);
    function QueueStream() {
        var _this = _super.call(this) || this;
        _this.outputQueue = new growing_ring_buffer_1.GrowingRingBuffer();
        return _this;
    }
    QueueStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.outputQueue.length() === 0)) return [3, 2];
                        return [4, this.pump()];
                    case 1:
                        if (!(_a.sent())) {
                            return [2, { value: null, done: true }];
                        }
                        return [3, 0];
                    case 2: return [2, { value: this.outputQueue.shift(), done: false }];
                }
            });
        });
    };
    return QueueStream;
}(DataStream));
exports.QueueStream = QueueStream;
var BatchStream = (function (_super) {
    __extends(BatchStream, _super);
    function BatchStream(upstream, batchSize, enableSmallLastBatch) {
        if (enableSmallLastBatch === void 0) { enableSmallLastBatch = true; }
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.batchSize = batchSize;
        _this.enableSmallLastBatch = enableSmallLastBatch;
        _this.currentBatch = [];
        return _this;
    }
    BatchStream.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var item;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.upstream.next()];
                    case 1:
                        item = _a.sent();
                        if (item.done) {
                            if (this.enableSmallLastBatch && this.currentBatch.length > 0) {
                                this.outputQueue.push(this.currentBatch);
                                this.currentBatch = [];
                                return [2, true];
                            }
                            return [2, false];
                        }
                        this.currentBatch.push(item.value);
                        if (this.currentBatch.length === this.batchSize) {
                            this.outputQueue.push(this.currentBatch);
                            this.currentBatch = [];
                        }
                        return [2, true];
                }
            });
        });
    };
    return BatchStream;
}(QueueStream));
var FilterStream = (function (_super) {
    __extends(FilterStream, _super);
    function FilterStream(upstream, predicate) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.predicate = predicate;
        return _this;
    }
    FilterStream.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var item;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.upstream.next()];
                    case 1:
                        item = _a.sent();
                        if (item.done) {
                            return [2, false];
                        }
                        if (this.predicate(item.value)) {
                            this.outputQueue.push(item.value);
                        }
                        else {
                            globals_1.dispose(item.value);
                        }
                        return [2, true];
                }
            });
        });
    };
    return FilterStream;
}(QueueStream));
var MapStream = (function (_super) {
    __extends(MapStream, _super);
    function MapStream(upstream, transform) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.transform = transform;
        return _this;
    }
    MapStream.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var item, inputTensors, mapped, outputTensors, _i, inputTensors_1, t;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, this.upstream.next()];
                    case 1:
                        item = _a.sent();
                        if (item.done) {
                            return [2, false];
                        }
                        inputTensors = util_1.extractTensorsFromAny(item.value);
                        mapped = this.transform(item.value);
                        outputTensors = util_1.extractTensorsFromAny(mapped);
                        for (_i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
                            t = inputTensors_1[_i];
                            if (!util_1.isTensorInList(t, outputTensors)) {
                                t.dispose();
                            }
                        }
                        this.outputQueue.push(mapped);
                        return [2, true];
                }
            });
        });
    };
    return MapStream;
}(QueueStream));
var ChainedStream = (function (_super) {
    __extends(ChainedStream, _super);
    function ChainedStream() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.stream = null;
        _this.lastRead = null;
        return _this;
    }
    ChainedStream.create = function (streams) {
        var c = new ChainedStream();
        c.moreStreams = streams;
        return c;
    };
    ChainedStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.lastRead = this.readFromChain(this.lastRead);
                return [2, this.lastRead];
            });
        });
    };
    ChainedStream.prototype.readFromChain = function (lastRead) {
        return __awaiter(this, void 0, void 0, function () {
            var streamResult, itemResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4, lastRead];
                    case 1:
                        _a.sent();
                        if (!(this.stream == null)) return [3, 3];
                        return [4, this.moreStreams.next()];
                    case 2:
                        streamResult = _a.sent();
                        if (streamResult.done) {
                            return [2, { value: null, done: true }];
                        }
                        this.stream = streamResult.value;
                        _a.label = 3;
                    case 3: return [4, this.stream.next()];
                    case 4:
                        itemResult = _a.sent();
                        if (itemResult.done) {
                            this.stream = null;
                            return [2, this.readFromChain(lastRead)];
                        }
                        return [2, itemResult];
                }
            });
        });
    };
    return ChainedStream;
}(DataStream));
exports.ChainedStream = ChainedStream;
var PrefetchStream = (function (_super) {
    __extends(PrefetchStream, _super);
    function PrefetchStream(upstream, bufferSize) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.bufferSize = bufferSize;
        _this.total = 0;
        _this.buffer = new ring_buffer_1.RingBuffer(bufferSize);
        return _this;
    }
    PrefetchStream.prototype.refill = function () {
        while (!this.buffer.isFull()) {
            var v = this.upstream.next();
            this.buffer.push(v);
        }
    };
    PrefetchStream.prototype.next = function () {
        this.refill();
        return this.buffer.shift();
    };
    return PrefetchStream;
}(DataStream));
exports.PrefetchStream = PrefetchStream;
var ShuffleStream = (function (_super) {
    __extends(ShuffleStream, _super);
    function ShuffleStream(upstream, windowSize, seed) {
        var _this = _super.call(this, upstream, windowSize) || this;
        _this.upstream = upstream;
        _this.windowSize = windowSize;
        _this.upstreamExhausted = false;
        _this.random = seedrandom(seed);
        return _this;
    }
    ShuffleStream.prototype.randomInt = function (max) {
        return Math.floor(this.random() * max);
    };
    ShuffleStream.prototype.chooseIndex = function () {
        return this.randomInt(this.buffer.length());
    };
    ShuffleStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chosenIndex, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.upstreamExhausted) {
                            this.refill();
                        }
                        _a.label = 1;
                    case 1:
                        if (!!this.buffer.isEmpty()) return [3, 3];
                        chosenIndex = this.chooseIndex();
                        return [4, this.buffer.shuffleExcise(chosenIndex)];
                    case 2:
                        result = _a.sent();
                        if (result.done) {
                            this.upstreamExhausted = true;
                        }
                        else {
                            this.refill();
                            return [2, result];
                        }
                        return [3, 1];
                    case 3: return [2, { value: null, done: true }];
                }
            });
        });
    };
    return ShuffleStream;
}(PrefetchStream));
exports.ShuffleStream = ShuffleStream;

},{"../../../globals":28,"../../../util":143,"../util/growing_ring_buffer":17,"../util/ring_buffer":18,"seedrandom":146}],14:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var byte_stream_1 = require("./byte_stream");
var FileReaderStream = (function (_super) {
    __extends(FileReaderStream, _super);
    function FileReaderStream(file, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.file = file;
        _this.options = options;
        _this.offset = options.offset || 0;
        _this.chunkSize = options.chunkSize || 1024 * 1024;
        return _this;
    }
    FileReaderStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            var chunk, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (this.offset >= this.file.size) {
                            return [2, { value: null, done: true }];
                        }
                        chunk = new Promise(function (resolve, reject) {
                            var fileReader = new FileReader();
                            fileReader.onload = function (event) {
                                var data = fileReader.result;
                                if (data instanceof ArrayBuffer) {
                                    data = new Uint8Array(data);
                                }
                                if (!(data instanceof Uint8Array)) {
                                    return reject(new TypeError('FileReader returned unknown type.'));
                                }
                                resolve(data);
                            };
                            fileReader.onabort = function (event) {
                                return reject(new Error('Aborted'));
                            };
                            fileReader.onerror = function (event) {
                                return reject(new Error(event.error));
                            };
                            var end = _this.offset + _this.chunkSize;
                            var slice = _this.file.slice(_this.offset, end);
                            fileReader.readAsArrayBuffer(slice);
                            _this.offset = end;
                        });
                        _a = {};
                        return [4, chunk];
                    case 1: return [2, (_a.value = (_b.sent()), _a.done = false, _a)];
                }
            });
        });
    };
    return FileReaderStream;
}(byte_stream_1.ByteStream));
exports.FileReaderStream = FileReaderStream;

},{"./byte_stream":12}],15:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var data_stream_1 = require("./data_stream");
var StringStream = (function (_super) {
    __extends(StringStream, _super);
    function StringStream() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    StringStream.prototype.split = function (separator) {
        return new SplitStream(this, separator);
    };
    return StringStream;
}(data_stream_1.DataStream));
exports.StringStream = StringStream;
var SplitStream = (function (_super) {
    __extends(SplitStream, _super);
    function SplitStream(upstream, separator) {
        var _this = _super.call(this) || this;
        _this.impl = new SplitStreamImpl(upstream, separator);
        return _this;
    }
    SplitStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.impl.next()];
            });
        });
    };
    return SplitStream;
}(StringStream));
var SplitStreamImpl = (function (_super) {
    __extends(SplitStreamImpl, _super);
    function SplitStreamImpl(upstream, separator) {
        var _this = _super.call(this) || this;
        _this.upstream = upstream;
        _this.separator = separator;
        _this.carryover = '';
        return _this;
    }
    SplitStreamImpl.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var chunkResult, lines, _i, _a, line;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4, this.upstream.next()];
                    case 1:
                        chunkResult = _b.sent();
                        if (chunkResult.done) {
                            if (this.carryover === '') {
                                return [2, false];
                            }
                            this.outputQueue.push(this.carryover);
                            this.carryover = '';
                            return [2, true];
                        }
                        lines = chunkResult.value.split(this.separator);
                        lines[0] = this.carryover + lines[0];
                        for (_i = 0, _a = lines.slice(0, -1); _i < _a.length; _i++) {
                            line = _a[_i];
                            this.outputQueue.push(line);
                        }
                        this.carryover = lines[lines.length - 1];
                        return [2, true];
                }
            });
        });
    };
    return SplitStreamImpl;
}(data_stream_1.QueueStream));

},{"./data_stream":13}],16:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var byte_stream_1 = require("./byte_stream");
var data_stream_1 = require("./data_stream");
var filereader_stream_1 = require("./filereader_stream");
var URLStream = (function (_super) {
    __extends(URLStream, _super);
    function URLStream(url, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.impl = new URLStreamImpl(url, options);
        return _this;
    }
    URLStream.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.impl.next()];
            });
        });
    };
    return URLStream;
}(byte_stream_1.ByteStream));
exports.URLStream = URLStream;
var URLStreamImpl = (function (_super) {
    __extends(URLStreamImpl, _super);
    function URLStreamImpl(url, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this.url = url;
        _this.options = options;
        _this.blobPromise = fetch(url, options).then(function (response) {
            if (response.ok) {
                return response.blob();
            }
            else {
                throw new Error(response.statusText);
            }
        });
        return _this;
    }
    URLStreamImpl.prototype.pump = function () {
        return __awaiter(this, void 0, void 0, function () {
            var blob, chunkResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(this.fileReaderStream == null)) return [3, 2];
                        return [4, this.blobPromise];
                    case 1:
                        blob = _a.sent();
                        this.fileReaderStream = new filereader_stream_1.FileReaderStream(blob, this.options);
                        _a.label = 2;
                    case 2: return [4, this.fileReaderStream.next()];
                    case 3:
                        chunkResult = _a.sent();
                        if (chunkResult.done) {
                            return [2, false];
                        }
                        this.outputQueue.push(chunkResult.value);
                        return [2, true];
                }
            });
        });
    };
    return URLStreamImpl;
}(data_stream_1.QueueStream));

},{"./byte_stream":12,"./data_stream":13,"./filereader_stream":14}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var ring_buffer_1 = require("./ring_buffer");
var GrowingRingBuffer = (function (_super) {
    __extends(GrowingRingBuffer, _super);
    function GrowingRingBuffer() {
        return _super.call(this, GrowingRingBuffer.INITIAL_CAPACITY) || this;
    }
    GrowingRingBuffer.prototype.isFull = function () {
        return false;
    };
    GrowingRingBuffer.prototype.push = function (value) {
        if (_super.prototype.isFull.call(this)) {
            this.expand();
        }
        _super.prototype.push.call(this, value);
    };
    GrowingRingBuffer.prototype.unshift = function (value) {
        if (_super.prototype.isFull.call(this)) {
            this.expand();
        }
        _super.prototype.unshift.call(this, value);
    };
    GrowingRingBuffer.prototype.expand = function () {
        var newCapacity = this.capacity * 2;
        var newData = new Array(newCapacity);
        var len = this.length();
        for (var i = 0; i < len; i++) {
            newData[i] = this.get(this.wrap(this.begin + i));
        }
        this.data = newData;
        this.capacity = newCapacity;
        this.doubledCapacity = 2 * this.capacity;
        this.begin = 0;
        this.end = len;
    };
    GrowingRingBuffer.INITIAL_CAPACITY = 32;
    return GrowingRingBuffer;
}(ring_buffer_1.RingBuffer));
exports.GrowingRingBuffer = GrowingRingBuffer;

},{"./ring_buffer":18}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RingBuffer = (function () {
    function RingBuffer(capacity) {
        this.capacity = capacity;
        this.begin = 0;
        this.end = 0;
        if (capacity < 1) {
            throw new RangeError('Can\'t create ring buffer of capacity < 1.');
        }
        this.data = new Array(capacity);
        this.doubledCapacity = 2 * capacity;
    }
    RingBuffer.prototype.wrap = function (index) {
        while (index < 0) {
            index += this.doubledCapacity;
        }
        return index % this.doubledCapacity;
    };
    RingBuffer.prototype.get = function (index) {
        if (index < 0) {
            throw new RangeError('Can\'t get item at a negative index.');
        }
        return this.data[index % this.capacity];
    };
    RingBuffer.prototype.set = function (index, value) {
        if (index < 0) {
            throw new RangeError('Can\'t set item at a negative index.');
        }
        this.data[index % this.capacity] = value;
    };
    RingBuffer.prototype.length = function () {
        var length = this.end - this.begin;
        if (length < 0) {
            length = this.doubledCapacity + length;
        }
        return length;
    };
    RingBuffer.prototype.isFull = function () {
        return this.length() === this.capacity;
    };
    RingBuffer.prototype.isEmpty = function () {
        return this.length() === 0;
    };
    RingBuffer.prototype.push = function (value) {
        if (this.isFull()) {
            throw new RangeError('Ring buffer is full.');
        }
        this.set(this.end, value);
        this.end = this.wrap(this.end + 1);
    };
    RingBuffer.prototype.pop = function () {
        if (this.isEmpty()) {
            throw new RangeError('Ring buffer is empty.');
        }
        this.end = this.wrap(this.end - 1);
        var result = this.get(this.end);
        this.set(this.end, undefined);
        return result;
    };
    RingBuffer.prototype.unshift = function (value) {
        if (this.isFull()) {
            throw new RangeError('Ring buffer is full.');
        }
        this.begin = this.wrap(this.begin - 1);
        this.set(this.begin, value);
    };
    RingBuffer.prototype.shift = function () {
        if (this.isEmpty()) {
            throw new RangeError('Ring buffer is empty.');
        }
        var result = this.get(this.begin);
        this.set(this.begin, undefined);
        this.begin = this.wrap(this.begin + 1);
        return result;
    };
    RingBuffer.prototype.shuffleExcise = function (relativeIndex) {
        if (this.isEmpty()) {
            throw new RangeError('Ring buffer is empty.');
        }
        var index = this.wrap(this.begin + relativeIndex);
        var result = this.get(index);
        this.set(index, this.pop());
        return result;
    };
    return RingBuffer;
}());
exports.RingBuffer = RingBuffer;

},{}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dataset_1 = require("./data/dataset");
exports.Dataset = dataset_1.Dataset;
var dataset_2 = require("./data/dataset");
exports.datasetFromElements = dataset_2.datasetFromElements;
var csv_dataset_1 = require("./data/datasets/csv_dataset");
exports.CSVDataset = csv_dataset_1.CSVDataset;
var text_line_dataset_1 = require("./data/datasets/text_line_dataset");
exports.TextLineDataset = text_line_dataset_1.TextLineDataset;
var file_data_source_1 = require("./data/sources/file_data_source");
exports.FileDataSource = file_data_source_1.FileDataSource;
var url_data_source_1 = require("./data/sources/url_data_source");
exports.URLDataSource = url_data_source_1.URLDataSource;

},{"./data/dataset":5,"./data/datasets/csv_dataset":6,"./data/datasets/text_line_dataset":7,"./data/sources/file_data_source":9,"./data/sources/url_data_source":10}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("../tensor");
var MANIFEST_FILE = 'manifest.json';
var CheckpointLoader = (function () {
    function CheckpointLoader(urlPath) {
        this.urlPath = urlPath;
        if (this.urlPath.charAt(this.urlPath.length - 1) !== '/') {
            this.urlPath += '/';
        }
    }
    CheckpointLoader.prototype.loadManifest = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open('GET', _this.urlPath + MANIFEST_FILE);
            xhr.onload = function () {
                _this.checkpointManifest = JSON.parse(xhr.responseText);
                resolve();
            };
            xhr.onerror = function (error) {
                throw new Error(MANIFEST_FILE + " not found at " + _this.urlPath + ". " + error);
            };
            xhr.send();
        });
    };
    CheckpointLoader.prototype.getCheckpointManifest = function () {
        var _this = this;
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    resolve(_this.checkpointManifest);
                });
            });
        }
        return new Promise(function (resolve, reject) {
            resolve(_this.checkpointManifest);
        });
    };
    CheckpointLoader.prototype.getAllVariables = function () {
        var _this = this;
        if (this.variables != null) {
            return new Promise(function (resolve, reject) {
                resolve(_this.variables);
            });
        }
        return new Promise(function (resolve, reject) {
            _this.getCheckpointManifest().then(function (checkpointDefinition) {
                var variableNames = Object.keys(_this.checkpointManifest);
                var variablePromises = [];
                for (var i = 0; i < variableNames.length; i++) {
                    variablePromises.push(_this.getVariable(variableNames[i]));
                }
                Promise.all(variablePromises).then(function (variables) {
                    _this.variables = {};
                    for (var i = 0; i < variables.length; i++) {
                        _this.variables[variableNames[i]] = variables[i];
                    }
                    resolve(_this.variables);
                });
            });
        });
    };
    CheckpointLoader.prototype.getVariable = function (varName) {
        var _this = this;
        if (!(varName in this.checkpointManifest)) {
            throw new Error('Cannot load non-existant variable ' + varName);
        }
        var variableRequestPromiseMethod = function (resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.responseType = 'arraybuffer';
            var fname = _this.checkpointManifest[varName].filename;
            xhr.open('GET', _this.urlPath + fname);
            xhr.onload = function () {
                if (xhr.status === 404) {
                    throw new Error("Not found variable " + varName);
                }
                var values = new Float32Array(xhr.response);
                var tensor = tensor_1.Tensor.make(_this.checkpointManifest[varName].shape, { values: values });
                resolve(tensor);
            };
            xhr.onerror = function (error) {
                throw new Error("Could not fetch variable " + varName + ": " + error);
            };
            xhr.send();
        };
        if (this.checkpointManifest == null) {
            return new Promise(function (resolve, reject) {
                _this.loadManifest().then(function () {
                    new Promise(variableRequestPromiseMethod).then(resolve);
                });
            });
        }
        return new Promise(variableRequestPromiseMethod);
    };
    return CheckpointLoader;
}());
exports.CheckpointLoader = CheckpointLoader;

},{"../tensor":137}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("../tensor");
var util = require("../util");
var STATS_SAMPLE_PERCENTAGE = 0.1;
var InMemoryDataset = (function () {
    function InMemoryDataset(dataShapes) {
        this.dataShapes = dataShapes;
        this.normalizationInfo = {};
    }
    InMemoryDataset.prototype.getDataShape = function (dataIndex) {
        return this.dataShapes[dataIndex];
    };
    InMemoryDataset.prototype.getData = function () {
        return this.dataset;
    };
    InMemoryDataset.prototype.getStats = function () {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        return this.dataset.map(function (d) { return _this.getStatsForData(d); });
    };
    InMemoryDataset.prototype.getStatsForData = function (data) {
        var inputMin = Number.POSITIVE_INFINITY;
        var inputMax = Number.NEGATIVE_INFINITY;
        var exampleIndices = data.map(function (example, i) { return i; });
        util.shuffle(exampleIndices);
        exampleIndices =
            exampleIndices.slice(exampleIndices.length * STATS_SAMPLE_PERCENTAGE);
        for (var i = 0; i < exampleIndices.length; i++) {
            var inputValues = data[exampleIndices[i]].dataSync();
            for (var j = 0; j < inputValues.length; j++) {
                inputMin = Math.min(inputMin, inputValues[j]);
                inputMax = Math.max(inputMax, inputValues[j]);
            }
        }
        return {
            inputMin: inputMin,
            inputMax: inputMax,
            exampleCount: data.length,
            shape: data[0].shape,
        };
    };
    InMemoryDataset.prototype.normalizeExamplesToRange = function (examples, curLowerBounds, curUpperBounds, newLowerBounds, newUpperBounds) {
        var curBoundsIsPerDimension = (curUpperBounds instanceof Float32Array &&
            curLowerBounds instanceof Float32Array);
        var newBoundsIsPerDimension = (newLowerBounds instanceof Float32Array &&
            newUpperBounds instanceof Float32Array);
        var inputSize = util.sizeFromShape(examples[0].shape);
        var newExamples = [];
        examples.forEach(function (example) {
            var inputValues = example.dataSync();
            var normalizedValues = new Float32Array(inputSize);
            for (var j = 0; j < inputSize; j++) {
                var curLowerBound = curBoundsIsPerDimension ?
                    curLowerBounds[j] :
                    curLowerBounds;
                var curUpperBound = curBoundsIsPerDimension ?
                    curUpperBounds[j] :
                    curUpperBounds;
                var curRange = curUpperBound - curLowerBound;
                var newLowerBound = newBoundsIsPerDimension ?
                    newLowerBounds[j] :
                    newLowerBounds;
                var newUpperBound = newBoundsIsPerDimension ?
                    newUpperBounds[j] :
                    newUpperBounds;
                var newRange = newUpperBound - newLowerBound;
                if (curRange === 0) {
                    normalizedValues[j] = newLowerBound;
                }
                else {
                    normalizedValues[j] = newLowerBound +
                        newRange * (inputValues[j] - curLowerBound) / curRange;
                }
            }
            newExamples.push(tensor_1.Tensor.make(example.shape, { values: normalizedValues }, 'float32'));
        });
        return newExamples;
    };
    InMemoryDataset.prototype.computeBounds = function (dataIndex) {
        var _this = this;
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        var size = util.sizeFromShape(this.dataset[dataIndex][0].shape);
        this.normalizationInfo[dataIndex] = {
            isNormalized: false,
            minValues: new Float32Array(size),
            maxValues: new Float32Array(size)
        };
        for (var i = 0; i < size; i++) {
            this.normalizationInfo[dataIndex].minValues[i] = Number.POSITIVE_INFINITY;
            this.normalizationInfo[dataIndex].maxValues[i] = Number.NEGATIVE_INFINITY;
        }
        this.dataset[dataIndex].forEach(function (example) {
            var inputValues = example.dataSync();
            for (var k = 0; k < size; k++) {
                _this.normalizationInfo[dataIndex].minValues[k] = Math.min(_this.normalizationInfo[dataIndex].minValues[k], inputValues[k]);
                _this.normalizationInfo[dataIndex].maxValues[k] = Math.max(_this.normalizationInfo[dataIndex].maxValues[k], inputValues[k]);
            }
        });
    };
    InMemoryDataset.prototype.normalizeWithinBounds = function (dataIndex, lowerBound, upperBound) {
        if (this.dataset == null) {
            throw new Error('Data is null.');
        }
        if (dataIndex >= this.dataset.length) {
            throw new Error('dataIndex out of bounds.');
        }
        if (this.normalizationInfo[dataIndex] == null) {
            this.computeBounds(dataIndex);
        }
        var curLowerBounds;
        var curUpperBounds;
        if (this.normalizationInfo[dataIndex].isNormalized) {
            curLowerBounds = this.normalizationInfo[dataIndex].lowerBound;
            curUpperBounds = this.normalizationInfo[dataIndex].upperBound;
        }
        else {
            curLowerBounds = this.normalizationInfo[dataIndex].minValues;
            curUpperBounds = this.normalizationInfo[dataIndex].maxValues;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], curLowerBounds, curUpperBounds, lowerBound, upperBound);
        this.normalizationInfo[dataIndex].isNormalized = true;
        this.normalizationInfo[dataIndex].lowerBound = lowerBound;
        this.normalizationInfo[dataIndex].upperBound = upperBound;
    };
    InMemoryDataset.prototype.isNormalized = function (dataIndex) {
        return this.normalizationInfo != null &&
            this.normalizationInfo[dataIndex].isNormalized;
    };
    InMemoryDataset.prototype.removeNormalization = function (dataIndex) {
        if (this.dataset == null) {
            throw new Error('Training or test data is null.');
        }
        if (!this.isNormalized(dataIndex)) {
            return;
        }
        this.dataset[dataIndex] = this.normalizeExamplesToRange(this.dataset[dataIndex], this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
        this.normalizationInfo[dataIndex].isNormalized = false;
    };
    InMemoryDataset.prototype.unnormalizeExamples = function (examples, dataIndex) {
        if (!this.isNormalized(dataIndex)) {
            return examples;
        }
        return this.normalizeExamplesToRange(examples, this.normalizationInfo[dataIndex].lowerBound, this.normalizationInfo[dataIndex].upperBound, this.normalizationInfo[dataIndex].minValues, this.normalizationInfo[dataIndex].maxValues);
    };
    InMemoryDataset.prototype.dispose = function () {
        if (this.dataset == null) {
            return;
        }
        for (var i = 0; i < this.dataset.length; i++) {
            for (var j = 0; j < this.dataset[i].length; j++) {
                this.dataset[i][j].dispose();
            }
        }
        this.dataset = [];
    };
    return InMemoryDataset;
}());
exports.InMemoryDataset = InMemoryDataset;

},{"../tensor":137,"../util":143}],22:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
var InMemoryShuffledInputProviderBuilder = (function () {
    function InMemoryShuffledInputProviderBuilder(inputs) {
        this.inputs = inputs;
        this.idx = 0;
        this.inputCounter = 0;
        this.epoch = 0;
        this.shuffledIndices = util.createShuffledIndices(inputs[0].length);
        this.numInputs = inputs.length;
        var numExamples = this.inputs[0].length;
        for (var i = 0; i < this.numInputs; i++) {
            util.assert(this.inputs[i].length === numExamples, 'Number of examples must match across different inputs.');
        }
        for (var i = 0; i < this.numInputs; i++) {
            var inputShape = this.inputs[i][0].shape;
            for (var j = 0; j < this.inputs[i].length; j++) {
                util.assertShapesMatch(inputShape, this.inputs[i][j].shape);
            }
        }
    }
    InMemoryShuffledInputProviderBuilder.prototype.getCurrentExampleIndex = function () {
        var returnIdx = this.idx;
        this.inputCounter++;
        if (this.inputCounter >= this.numInputs) {
            this.idx++;
            this.inputCounter = 0;
            if (this.idx >= this.inputs[0].length) {
                this.idx = 0;
                this.epoch++;
            }
        }
        return returnIdx;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getNextInput = function (inputId) {
        var currentExampleIndex = this.getCurrentExampleIndex();
        return this.inputs[inputId][this.shuffledIndices[currentExampleIndex]];
    };
    InMemoryShuffledInputProviderBuilder.prototype.getEpoch = function () {
        return this.epoch;
    };
    InMemoryShuffledInputProviderBuilder.prototype.getInputProviders = function () {
        var inputProviders = [];
        for (var i = 0; i < this.numInputs; i++) {
            inputProviders.push(this.getInputProvider(i));
        }
        return inputProviders;
    };
    return InMemoryShuffledInputProviderBuilder;
}());
exports.InMemoryShuffledInputProviderBuilder = InMemoryShuffledInputProviderBuilder;
var InCPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InCPUMemoryShuffledInputProviderBuilder, _super);
    function InCPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InCPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function () {
                return shuffledInputProvider.getNextInput(inputId).clone();
            },
            disposeCopy: function (copy) {
                copy.dispose();
            }
        };
    };
    return InCPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InCPUMemoryShuffledInputProviderBuilder = InCPUMemoryShuffledInputProviderBuilder;
var InGPUMemoryShuffledInputProviderBuilder = (function (_super) {
    __extends(InGPUMemoryShuffledInputProviderBuilder, _super);
    function InGPUMemoryShuffledInputProviderBuilder() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InGPUMemoryShuffledInputProviderBuilder.prototype.getInputProvider = function (inputId) {
        var shuffledInputProvider = this;
        return {
            getNextCopy: function () {
                return shuffledInputProvider.getNextInput(inputId).clone();
            },
            disposeCopy: function (copy) {
                copy.dispose();
            }
        };
    };
    return InGPUMemoryShuffledInputProviderBuilder;
}(InMemoryShuffledInputProviderBuilder));
exports.InGPUMemoryShuffledInputProviderBuilder = InGPUMemoryShuffledInputProviderBuilder;

},{"../util":143}],23:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("../tensor");
var util = require("../util");
var dataset_1 = require("./dataset");
var PARSING_IMAGE_CANVAS_HEIGHT_PX = 1000;
function getXhrDatasetConfig(jsonConfigPath) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', jsonConfigPath);
        xhr.onload = function () {
            resolve(JSON.parse(xhr.responseText));
        };
        xhr.onerror = function (error) {
            reject(error);
        };
        xhr.send();
    });
}
exports.getXhrDatasetConfig = getXhrDatasetConfig;
var XhrDataset = (function (_super) {
    __extends(XhrDataset, _super);
    function XhrDataset(xhrDatasetConfig) {
        var _this = _super.call(this, xhrDatasetConfig.data.map(function (x) { return x.shape; })) || this;
        _this.xhrDatasetConfig = xhrDatasetConfig;
        return _this;
    }
    XhrDataset.prototype.getTensor = function (info) {
        var dataPromise = info.dataType === 'png' ?
            parseTypedArrayFromPng(info, info.shape) :
            parseTypedArrayFromBinary(info);
        var inputSize = util.sizeFromShape(info.shape);
        return dataPromise.then(function (data) {
            var tensors = [];
            for (var i = 0; i < data.length / inputSize; i++) {
                var values = data.subarray(i * inputSize, (i + 1) * inputSize);
                var tensor = tensor_1.Tensor.make(info.shape, { values: new Float32Array(values) }, 'float32');
                tensors.push(tensor);
            }
            return tensors;
        });
    };
    XhrDataset.prototype.fetchData = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var promises = _this.xhrDatasetConfig.data.map(function (x) { return _this.getTensor(x); });
            Promise.all(promises).then(function (data) {
                _this.dataset = data;
                resolve();
            });
        });
    };
    return XhrDataset;
}(dataset_1.InMemoryDataset));
exports.XhrDataset = XhrDataset;
function parseTypedArrayFromBinary(info) {
    return new Promise(function (resolve, reject) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', info.path);
        xhr.responseType = 'arraybuffer';
        xhr.onload = function (event) {
            var data = (info.dataType === 'float32') ?
                new Float32Array(xhr.response) :
                new Uint8Array(xhr.response);
            resolve(data);
        };
        xhr.onerror = function (err) { return reject(err); };
        xhr.send();
    });
}
function parseGrayscaleImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx++] = data[i];
    }
}
function parseRGBImageData(data, result, resultOffset) {
    var idx = resultOffset;
    for (var i = 0; i < data.length; i += 4) {
        result[idx] = data[i];
        result[idx + 1] = data[i + 1];
        result[idx + 2] = data[i + 2];
        idx += 3;
    }
}
function parseImage(img, shape) {
    var canvas = document.createElement('canvas');
    var ctx = canvas.getContext('2d');
    var N = img.height;
    var inputSize = util.sizeFromShape(shape);
    var result = new Uint8Array(N * inputSize);
    if (img.width !== shape[0] * shape[1]) {
        throw new Error("Image width (" + img.width + ") must be multiple of " +
            ("rows*columns (" + shape[0] + "*" + shape[1] + ") of the tensor"));
    }
    canvas.width = img.width;
    canvas.height = PARSING_IMAGE_CANVAS_HEIGHT_PX;
    var sx = 0;
    var sWidth = canvas.width;
    var sHeight = canvas.height;
    var dx = 0;
    var dy = 0;
    var dWidth = sWidth;
    var dHeight = sHeight;
    var depth = shape[2];
    var offset = 0;
    var numPasses = Math.ceil(N / canvas.height);
    for (var pass = 0; pass < numPasses; ++pass) {
        var sy = pass * canvas.height;
        if ((pass === numPasses - 1) && (N % canvas.height > 0)) {
            canvas.height = N % canvas.height;
            sHeight = canvas.height;
            dHeight = sHeight;
        }
        ctx.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
        var data = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        (depth === 1) ? parseGrayscaleImageData(data, result, offset) :
            parseRGBImageData(data, result, offset);
        offset += canvas.height * inputSize;
    }
    return result;
}
function parseTypedArrayFromPng(info, shape) {
    return new Promise(function (resolve, reject) {
        var img = new Image();
        img.setAttribute('crossOrigin', '');
        img.onload = function () {
            var result = parseImage(img, shape);
            img.src = '';
            img = null;
            resolve(result);
        };
        img.src = info.path;
    });
}

},{"../tensor":137,"../util":143,"./dataset":21}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isMobile() {
    var a = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i
        .test(a) ||
        /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i
            .test(a.substr(0, 4));
}
exports.isMobile = isMobile;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function doc(info) {
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
    };
}
exports.doc = doc;

},{}],26:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var ops = require("./ops/ops");
var profiler_1 = require("./profiler");
var tape_1 = require("./tape");
var tensor_1 = require("./tensor");
var util = require("./util");
var Engine = (function () {
    function Engine(backend, customBackend, safeMode) {
        this.backend = backend;
        this.customBackend = customBackend;
        this.safeMode = safeMode;
        this.registeredVariables = {};
        this.refCounter = new WeakMap();
        this.nextTapeNodeId = 0;
        this.numBytes = 0;
        this.numTensors = 0;
        this.numDataBuffers = 0;
        this.gradientScopeCount = 0;
        this.customGradientDepth = 0;
        this.activeScope = { keep: [], track: [] };
        this.scopeStack = [this.activeScope];
        this.profiler = new profiler_1.Profiler(backend);
    }
    Engine.prototype.runKernel = function (forwardFunc, inputs, backwardsFunc) {
        var _this = this;
        var result;
        var saved = [];
        var saveFunc = function (x) {
            saved.push(x);
            return x;
        };
        var scopeName = this.activeScope.name;
        if (!environment_1.ENV.get('DEBUG')) {
            result = forwardFunc(this.backend, saveFunc);
        }
        else {
            result = this.profiler.profileKernel(scopeName, function () { return forwardFunc(_this.backend, saveFunc); });
        }
        var recordKernel = this.activeTape != null && this.customGradientDepth === 0;
        if (recordKernel) {
            var tapeNode = {
                id: this.nextTapeNodeId++,
                name: scopeName,
                inputs: inputs,
                output: result,
            };
            if (backwardsFunc != null) {
                tapeNode.gradient = function (dy) { return backwardsFunc(dy, saved); };
            }
            this.activeTape.push(tapeNode);
        }
        return result;
    };
    Engine.prototype.registerTensor = function (a) {
        var refCount = this.refCounter.has(a.dataId) ? this.refCounter.get(a.dataId) : 0;
        this.numTensors++;
        if (refCount === 0) {
            this.numDataBuffers++;
            this.numBytes +=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
            this.backend.register(a.dataId, a.shape, a.dtype);
        }
        this.refCounter.set(a.dataId, refCount + 1);
        if (!(a instanceof tensor_1.Variable)) {
            this.track(a);
        }
    };
    Engine.prototype.registerVariable = function (v) {
        if (this.registeredVariables[v.name] != null) {
            throw new Error("Variable with name " + v.name + " was already registered");
        }
        this.registeredVariables[v.name] = v;
    };
    Engine.prototype.disposeTensor = function (a) {
        if (!this.refCounter.has(a.dataId)) {
            return;
        }
        this.numTensors--;
        var refCount = this.refCounter.get(a.dataId);
        if (refCount <= 1) {
            this.refCounter.delete(a.dataId);
            this.backend.disposeData(a.dataId);
            this.numDataBuffers--;
            this.numBytes -=
                util.sizeFromShape(a.shape) * util.bytesPerElement(a.dtype);
        }
        else {
            this.refCounter.set(a.dataId, refCount - 1);
        }
    };
    Engine.prototype.memory = function () {
        var info = this.backend.memory();
        info.numTensors = this.numTensors;
        info.numDataBuffers = this.numDataBuffers;
        info.numBytes = this.numBytes;
        return info;
    };
    Engine.prototype.shouldRecord = function () {
        return this.activeTape != null && this.customGradientDepth === 0;
    };
    Engine.prototype.addTapeNode = function (inputs, result, gradientsFunc) {
        var inputsMap = {};
        inputs.forEach(function (input, idx) {
            inputsMap[idx] = input;
        });
        var gradient = function (dy) {
            var res = gradientsFunc(dy);
            var resMap = {};
            res.forEach(function (r, idx) {
                resMap[idx] = function () { return r; };
            });
            return resMap;
        };
        var tapeNode = {
            id: this.nextTapeNodeId++,
            name: this.activeScope.name,
            inputs: inputsMap,
            output: result,
            gradient: gradient
        };
        this.activeTape.push(tapeNode);
    };
    Engine.prototype.keep = function (result) {
        if (this.scopeStack.length === 1 && environment_1.ENV.engine.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside dl.tidy(): ' +
                'dl.tidy(() => {...}) to avoid memory leaks.');
        }
        this.activeScope.keep.push(result);
        return result;
    };
    Engine.prototype.startScope = function (name, gradientsMode) {
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode && this.gradientScopeCount === 0) {
            this.activeTape = [];
        }
        if (gradientsMode) {
            this.gradientScopeCount++;
        }
        var scopeInfo = { keep: [], track: [] };
        if (name) {
            scopeInfo.name = name;
        }
        this.scopeStack.push(scopeInfo);
        this.activeScope = scopeInfo;
    };
    Engine.prototype.endScope = function (result, gradientsMode) {
        var _this = this;
        if (gradientsMode === void 0) { gradientsMode = false; }
        if (gradientsMode) {
            this.gradientScopeCount--;
            if (this.gradientScopeCount === 0) {
                this.activeTape = null;
            }
        }
        var tensorsToKeep = this.activeScope.keep;
        var tensorsToTrackInParent = util.extractTensorsFromContainer(result);
        tensorsToKeep = tensorsToKeep.concat(tensorsToTrackInParent);
        for (var i = 0; i < this.activeScope.track.length; i++) {
            var tensor = this.activeScope.track[i];
            if (util.isTensorInList(tensor, tensorsToKeep)) {
                continue;
            }
            if (this.activeTape != null) {
                tensorsToTrackInParent.push(tensor);
            }
            else {
                tensor.dispose();
            }
        }
        this.scopeStack.pop();
        this.activeScope = this.scopeStack.length === 0 ?
            { keep: [], track: [] } :
            this.scopeStack[this.scopeStack.length - 1];
        tensorsToTrackInParent.forEach(function (tensor) {
            if (!util.isTensorInList(tensor, _this.activeScope.keep)) {
                _this.track(tensor);
            }
        });
    };
    Engine.prototype.dispose = function () {
        if (this.customBackend) {
            this.backend.dispose();
        }
    };
    Engine.prototype.gradients = function (f, xs, dy, allowNoGradients) {
        var _this = this;
        if (allowNoGradients === void 0) { allowNoGradients = false; }
        util.assert(xs.length > 0, 'gradients() received an empty list of xs.');
        return globals_1.tidy('gradients', function () {
            var y = f();
            util.assert(y instanceof tensor_1.Tensor, 'The result y returned by f() must be a tensor.');
            var filteredTape = tape_1.getFilteredNodesXToY(_this.activeTape, xs, y);
            if (!allowNoGradients && filteredTape.length === 0 && xs.length > 0) {
                throw new Error('Cannot compute gradient of y=f(x) with respect to x. Make sure ' +
                    'that the f you passed encloses all operations that lead from x ' +
                    'to y.');
            }
            var accumulatedGradientMap = {};
            accumulatedGradientMap[y.id] = (dy == null) ? ops.ones(y.shape) : dy;
            tape_1.backpropagateGradients(accumulatedGradientMap, filteredTape);
            var grads = xs.map(function (x) { return accumulatedGradientMap[x.id]; });
            return { value: y, grads: grads };
        }, true);
    };
    Engine.prototype.customGrad = function (f) {
        var _this = this;
        util.assert(util.isFunction(f), 'The f passed in customGrad(f) must be a function.');
        return function () {
            var inputs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                inputs[_i] = arguments[_i];
            }
            util.assert(inputs.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The args passed in customGrad(f)(x1, x2,...) must all be tensors');
            _this.customGradientDepth++;
            var gradientsFunc;
            var gradientsMode = true;
            var result = globals_1.tidy(f.name, function () {
                var _a = f.apply(void 0, inputs), value = _a.value, gradFunc = _a.gradFunc;
                util.assert(value instanceof tensor_1.Tensor, 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.value` is a tensor');
                util.assert(util.isFunction(gradFunc), 'The function f passed in customGrad(f) must return an object ' +
                    'where `obj.gradFunc` is a function.');
                gradientsFunc = gradFunc;
                return value;
            }, gradientsMode);
            _this.customGradientDepth--;
            if (_this.shouldRecord()) {
                var gradFunc = function (dy) {
                    var res = gradientsFunc(dy);
                    var grads = Array.isArray(res) ? res : [res];
                    util.assert(grads.length === inputs.length, 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns the same ' +
                        'number of tensors as inputs passed to f(...).');
                    util.assert(grads.every(function (t) { return t instanceof tensor_1.Tensor; }), 'The function f passed in customGrad(f) must return an object ' +
                        'where `obj.gradFunc` is a function that returns a list of ' +
                        'only tensors.');
                    return grads;
                };
                _this.addTapeNode(inputs, result, gradFunc);
            }
            return result;
        };
    };
    Engine.prototype.write = function (dataId, values) {
        this.backend.write(dataId, values);
    };
    Engine.prototype.readSync = function (dataId) {
        return this.backend.readSync(dataId);
    };
    Engine.prototype.read = function (dataId) {
        return this.backend.read(dataId);
    };
    Engine.prototype.fromPixels = function (pixels, numChannels) {
        return this.backend.fromPixels(pixels, numChannels);
    };
    Engine.prototype.time = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var start, timingInfo;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        start = performance.now();
                        return [4, this.backend.time(query)];
                    case 1:
                        timingInfo = _a.sent();
                        timingInfo.wallMs = performance.now() - start;
                        return [2, timingInfo];
                }
            });
        });
    };
    Engine.prototype.track = function (result) {
        if (this.scopeStack.length === 1 && this.safeMode) {
            throw new Error('Safe mode is ON. Enclose all tensor operations inside dl.tidy(): ' +
                'dl.tidy(() => {op();...}); to avoid memory leaks.');
        }
        this.activeScope.track.push(result);
        return result;
    };
    return Engine;
}());
exports.Engine = Engine;

},{"./environment":27,"./globals":28,"./ops/ops":114,"./profiler":135,"./tape":136,"./tensor":137,"./util":143}],27:[function(require,module,exports){
(function (global){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var device_util = require("./device_util");
var doc_1 = require("./doc");
var engine_1 = require("./engine");
var math_1 = require("./math");
var util = require("./util");
var Type;
(function (Type) {
    Type[Type["NUMBER"] = 0] = "NUMBER";
    Type[Type["BOOLEAN"] = 1] = "BOOLEAN";
    Type[Type["STRING"] = 2] = "STRING";
})(Type = exports.Type || (exports.Type = {}));
exports.URL_PROPERTIES = [
    { name: 'DEBUG', type: Type.BOOLEAN },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE', type: Type.BOOLEAN },
    { name: 'WEBGL_VERSION', type: Type.NUMBER },
    { name: 'WEBGL_FLOAT_TEXTURE_ENABLED', type: Type.BOOLEAN }, {
        name: 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED',
        type: Type.BOOLEAN
    },
    { name: 'BACKEND', type: Type.STRING }
];
function hasExtension(gl, extensionName) {
    var ext = gl.getExtension(extensionName);
    return ext != null;
}
function getWebGLRenderingContext(webGLVersion) {
    if (webGLVersion === 0) {
        throw new Error('Cannot get WebGL rendering context, WebGL is disabled.');
    }
    var tempCanvas = document.createElement('canvas');
    if (webGLVersion === 1) {
        return (tempCanvas.getContext('webgl') ||
            tempCanvas.getContext('experimental-webgl'));
    }
    return tempCanvas.getContext('webgl2');
}
function loseContext(gl) {
    if (gl != null) {
        var loseContextExtension = gl.getExtension('WEBGL_lose_context');
        if (loseContextExtension == null) {
            throw new Error('Extension WEBGL_lose_context not supported on this browser.');
        }
        loseContextExtension.loseContext();
    }
}
function isWebGLVersionEnabled(webGLVersion) {
    var gl = getWebGLRenderingContext(webGLVersion);
    if (gl != null) {
        loseContext(gl);
        return true;
    }
    return false;
}
function getWebGLDisjointQueryTimerVersion(webGLVersion) {
    if (webGLVersion === 0) {
        return 0;
    }
    var queryTimerVersion;
    var gl = getWebGLRenderingContext(webGLVersion);
    if (hasExtension(gl, 'EXT_disjoint_timer_query_webgl2') &&
        webGLVersion === 2) {
        queryTimerVersion = 2;
    }
    else if (hasExtension(gl, 'EXT_disjoint_timer_query')) {
        queryTimerVersion = 1;
    }
    else {
        queryTimerVersion = 0;
    }
    if (gl != null) {
        loseContext(gl);
    }
    return queryTimerVersion;
}
function isFloatTextureReadPixelsEnabled(webGLVersion) {
    if (webGLVersion === 0) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    if (webGLVersion === 1) {
        if (!hasExtension(gl, 'OES_texture_float')) {
            return false;
        }
    }
    else {
        if (!hasExtension(gl, 'EXT_color_buffer_float')) {
            return false;
        }
    }
    var frameBuffer = gl.createFramebuffer();
    var texture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, texture);
    var internalFormat = webGLVersion === 2 ? gl.RGBA32F : gl.RGBA;
    gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, 1, 1, 0, gl.RGBA, gl.FLOAT, null);
    gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);
    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
    var frameBufferComplete = (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE);
    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.FLOAT, new Float32Array(4));
    var readPixelsNoError = gl.getError() === gl.NO_ERROR;
    loseContext(gl);
    return frameBufferComplete && readPixelsNoError;
}
function isWebGLGetBufferSubDataAsyncExtensionEnabled(webGLVersion) {
    if (webGLVersion !== 2) {
        return false;
    }
    var gl = getWebGLRenderingContext(webGLVersion);
    var isEnabled = hasExtension(gl, 'WEBGL_get_buffer_sub_data_async');
    loseContext(gl);
    return isEnabled;
}
var SUPPORTED_BACKENDS = ['webgl', 'cpu'];
var Environment = (function () {
    function Environment(features) {
        this.features = {};
        this.BACKEND_REGISTRY = {};
        this.backends = this.BACKEND_REGISTRY;
        if (features != null) {
            this.features = features;
        }
        if (this.get('DEBUG')) {
            console.warn('Debugging mode is ON. The output of every math call will ' +
                'be downloaded to CPU and checked for NaNs. ' +
                'This significantly impacts performance.');
        }
    }
    Environment.setBackend = function (backendType, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        if (!(backendType in exports.ENV.backends)) {
            throw new Error("Backend type '" + backendType + "' not found in registry");
        }
        exports.ENV.globalMath = new math_1.NDArrayMath(backendType, safeMode);
    };
    Environment.getBackend = function () {
        exports.ENV.initEngine();
        return exports.ENV.currentBackendType;
    };
    Environment.memory = function () {
        return exports.ENV.engine.memory();
    };
    Environment.prototype.get = function (feature) {
        if (feature in this.features) {
            return this.features[feature];
        }
        this.features[feature] = this.evaluateFeature(feature);
        return this.features[feature];
    };
    Environment.prototype.set = function (feature, value) {
        this.features[feature] = value;
    };
    Environment.prototype.getBestBackendType = function () {
        for (var i = 0; i < SUPPORTED_BACKENDS.length; ++i) {
            var backendId = SUPPORTED_BACKENDS[i];
            if (backendId in this.backends) {
                return backendId;
            }
        }
        throw new Error('No backend found in registry.');
    };
    Environment.prototype.evaluateFeature = function (feature) {
        if (feature === 'DEBUG') {
            return false;
        }
        else if (feature === 'BACKEND') {
            return this.getBestBackendType();
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') {
            var webGLVersion = this.get('WEBGL_VERSION');
            if (webGLVersion === 0) {
                return 0;
            }
            return getWebGLDisjointQueryTimerVersion(webGLVersion);
        }
        else if (feature === 'WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE') {
            return this.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0 &&
                !device_util.isMobile();
        }
        else if (feature === 'WEBGL_VERSION') {
            if (isWebGLVersionEnabled(2)) {
                return 2;
            }
            else if (isWebGLVersionEnabled(1)) {
                return 1;
            }
            return 0;
        }
        else if (feature === 'WEBGL_FLOAT_TEXTURE_ENABLED') {
            return isFloatTextureReadPixelsEnabled(this.get('WEBGL_VERSION'));
        }
        else if (feature === 'WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED') {
            return isWebGLGetBufferSubDataAsyncExtensionEnabled(this.get('WEBGL_VERSION'));
        }
        throw new Error("Unknown feature " + feature + ".");
    };
    Environment.prototype.setFeatures = function (features) {
        this.reset();
        this.features = features;
        this.backends = {};
    };
    Environment.prototype.reset = function () {
        this.features = getFeaturesFromURL();
        if (this.globalMath != null) {
            this.globalMath.dispose();
            this.globalMath = null;
            this.globalEngine = null;
        }
        if (this.backends !== this.BACKEND_REGISTRY) {
            for (var name_1 in this.backends) {
                this.backends[name_1].dispose();
            }
            this.backends = this.BACKEND_REGISTRY;
        }
    };
    Environment.prototype.setMath = function (math, backend, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        if (this.globalMath === math) {
            return;
        }
        var customBackend = false;
        if (typeof backend === 'string') {
            this.currentBackendType = backend;
            backend = exports.ENV.findBackend(backend);
        }
        else {
            customBackend = true;
            this.currentBackendType = 'custom';
        }
        this.globalEngine = new engine_1.Engine(backend, customBackend, safeMode);
        this.globalMath = math;
    };
    Environment.prototype.findBackend = function (name) {
        return this.backends[name];
    };
    Environment.prototype.addCustomBackend = function (name, factory) {
        if (name in this.backends) {
            throw new Error(name + " backend was already registered");
        }
        try {
            var backend = factory();
            this.backends[name] = backend;
            return true;
        }
        catch (err) {
            return false;
        }
    };
    Environment.prototype.registerBackend = function (name, factory) {
        if (name in this.BACKEND_REGISTRY) {
            throw new Error(name + " backend was already registered as global");
        }
        try {
            var backend = factory();
            this.BACKEND_REGISTRY[name] = backend;
            return true;
        }
        catch (err) {
            return false;
        }
    };
    Object.defineProperty(Environment.prototype, "math", {
        get: function () {
            this.initEngine();
            return this.globalMath;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Environment.prototype, "engine", {
        get: function () {
            this.initEngine();
            return this.globalEngine;
        },
        enumerable: true,
        configurable: true
    });
    Environment.prototype.initEngine = function () {
        if (this.globalEngine == null) {
            this.globalMath =
                new math_1.NDArrayMath(exports.ENV.get('BACKEND'), false);
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "setBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Environment' })
    ], Environment, "getBackend", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Environment, "memory", null);
    return Environment;
}());
exports.Environment = Environment;
var DEEPLEARNJS_FLAGS_PREFIX = 'dljsflags';
function getFeaturesFromURL() {
    var features = {};
    if (typeof window === 'undefined') {
        return features;
    }
    var urlParams = util.getQueryParams(window.location.search);
    if (DEEPLEARNJS_FLAGS_PREFIX in urlParams) {
        var urlFlags_1 = {};
        var keyValues = urlParams[DEEPLEARNJS_FLAGS_PREFIX].split(',');
        keyValues.forEach(function (keyValue) {
            var _a = keyValue.split(':'), key = _a[0], value = _a[1];
            urlFlags_1[key] = value;
        });
        exports.URL_PROPERTIES.forEach(function (urlProperty) {
            if (urlProperty.name in urlFlags_1) {
                console.log("Setting feature override from URL " + urlProperty.name + ": " +
                    ("" + urlFlags_1[urlProperty.name]));
                if (urlProperty.type === Type.NUMBER) {
                    features[urlProperty.name] = +urlFlags_1[urlProperty.name];
                }
                else if (urlProperty.type === Type.BOOLEAN) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name] === 'true';
                }
                else if (urlProperty.type === Type.STRING) {
                    features[urlProperty.name] = urlFlags_1[urlProperty.name];
                }
                else {
                    console.warn("Unknown URL param: " + urlProperty.name + ".");
                }
            }
        });
    }
    return features;
}
function getGlobalNamespace() {
    var ns;
    if (typeof (window) !== 'undefined') {
        ns = window;
    }
    else if (typeof (global) !== 'undefined') {
        ns = global;
    }
    else {
        throw new Error('Could not find a global object');
    }
    return ns;
}
function getOrMakeEnvironment() {
    var ns = getGlobalNamespace();
    ns.ENV = ns.ENV || new Environment(getFeaturesFromURL());
    return ns.ENV;
}
exports.ENV = getOrMakeEnvironment();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./device_util":24,"./doc":25,"./engine":26,"./math":96,"./util":143}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var gradients_1 = require("./gradients");
var tracking_1 = require("./tracking");
exports.tidy = tracking_1.Tracking.tidy;
exports.keep = tracking_1.Tracking.keep;
exports.dispose = tracking_1.Tracking.dispose;
exports.time = tracking_1.Tracking.time;
exports.grad = gradients_1.Gradients.grad;
exports.valueAndGrad = gradients_1.Gradients.valueAndGrad;
exports.grads = gradients_1.Gradients.grads;
exports.valueAndGrads = gradients_1.Gradients.valueAndGrads;
exports.variableGrads = gradients_1.Gradients.variableGrads;
exports.customGrad = gradients_1.Gradients.customGrad;

},{"./gradients":29,"./tracking":140}],29:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var globals_1 = require("./globals");
var tensor_1 = require("./tensor");
var util = require("./util");
var Gradients = (function () {
    function Gradients() {
    }
    Gradients.gradScope = function (nameOrScopeFn, scopeFn) {
        return globals_1.tidy(nameOrScopeFn, scopeFn, true);
    };
    Gradients.grad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in grad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grad(f)(x, dy) must be a tensor');
            var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), value = _a.value, grads = _a.grads;
            if (dy != null) {
                util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grad(f)(x, dy) must match the shape ' +
                    'returned by f(x)');
            }
            value.dispose();
            checkGrads(grads);
            return grads[0];
        };
    };
    Gradients.grads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in grads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in grads(f)(args) must be an array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in grads(f)(args, dy) must be a tensor');
            var _a = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy), value = _a.value, grads = _a.grads;
            if (dy != null) {
                util.assertShapesMatch(value.shape, dy.shape, 'The shape of dy passed in grads(f)([x1,...], dy) must match the ' +
                    'shape returned by f([x1,...])');
            }
            value.dispose();
            checkGrads(grads);
            return grads;
        };
    };
    Gradients.valueAndGrad = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrad(f) must be a function');
        return function (x, dy) {
            util.assert(x instanceof tensor_1.Tensor, 'The x passed in valueAndGrad(f)(x) must be a tensor');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrad(f)(x, dy) must be a tensor');
            var _a = environment_1.ENV.engine.gradients(function () { return f(x); }, [x], dy), grads = _a.grads, value = _a.value;
            checkGrads(grads);
            return { grad: grads[0], value: value };
        };
    };
    Gradients.valueAndGrads = function (f) {
        util.assert(util.isFunction(f), 'The f passed in valueAndGrads(f) must be a function');
        return function (args, dy) {
            util.assert(Array.isArray(args) && args.every(function (arg) { return arg instanceof tensor_1.Tensor; }), 'The args passed in valueAndGrads(f)(args) must be array of tensors');
            util.assert(dy == null || dy instanceof tensor_1.Tensor, 'The dy passed in valueAndGrads(f)(args, dy) must be a tensor');
            var res = environment_1.ENV.engine.gradients(function () { return f.apply(void 0, args); }, args, dy);
            if (dy != null) {
                util.assertShapesMatch(res.value.shape, dy.shape, 'The shape of dy passed in valueAndGrads(f)([x1,...], dy) must ' +
                    'match the shape returned by f([x1,...])');
            }
            checkGrads(res.grads);
            return res;
        };
    };
    Gradients.variableGrads = function (f, varList) {
        util.assert(util.isFunction(f), 'The f passed in variableGrads(f) must be a function');
        util.assert(varList == null ||
            Array.isArray(varList) && varList.every(function (v) { return v instanceof tensor_1.Variable; }), 'The varList passed in variableGrads(f, varList) must be an array ' +
            'of variables');
        if (varList == null) {
            varList = [];
            for (var varName in environment_1.ENV.engine.registeredVariables) {
                varList.push(environment_1.ENV.engine.registeredVariables[varName]);
            }
        }
        var originalVarCount = varList.length;
        varList = varList.filter(function (variable) { return variable.trainable; });
        util.assert(varList.length > 0, "variableGrads() expects at least one of the input variables to be " +
            ("trainable, but none of the " + originalVarCount + " variables is ") +
            "trainable.");
        var allowNoGradients = true;
        var _a = environment_1.ENV.engine.gradients(f, varList, null, allowNoGradients), value = _a.value, grads = _a.grads;
        util.assert(grads.some(function (g) { return g != null; }), 'Cannot find a connection between any variable and the result of the ' +
            'loss function y=f(x). Please make sure the operations that use ' +
            'variables are inside the function f passed to minimize().');
        util.assert(value.rank === 0, "The f passed in variableGrads(f) must return a scalar, but it " +
            ("returned a rank-" + value.rank + " tensor"));
        var namedGrads = {};
        varList.forEach(function (v, i) {
            if (grads[i] != null) {
                namedGrads[v.name] = grads[i];
            }
        });
        return { value: value, grads: namedGrads };
    };
    Gradients.customGrad = function (f) {
        return environment_1.ENV.engine.customGrad(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "grads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrad", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "valueAndGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "variableGrads", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Gradients' })
    ], Gradients, "customGrad", null);
    return Gradients;
}());
exports.Gradients = Gradients;
function checkGrads(grads) {
    var numNullGradients = grads.filter(function (g) { return g == null; }).length;
    if (numNullGradients > 0) {
        throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.");
    }
}

},{"./doc":25,"./environment":27,"./globals":28,"./tensor":137,"./util":143}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var tensor_1 = require("../tensor");
var TanHFunc = (function () {
    function TanHFunc() {
        this.one = tensor_1.Scalar.new(1);
    }
    TanHFunc.prototype.output = function (math, x) {
        return math.tanh(x);
    };
    TanHFunc.prototype.der = function (math, x, y) {
        var _this = this;
        return globals_1.tidy(function () {
            var ySquared = math.multiplyStrict(y, y);
            return math.subtract(_this.one, ySquared);
        });
    };
    TanHFunc.prototype.dispose = function () {
        this.one.dispose();
    };
    return TanHFunc;
}());
exports.TanHFunc = TanHFunc;
var ReLUFunc = (function () {
    function ReLUFunc() {
    }
    ReLUFunc.prototype.output = function (math, x) {
        return math.relu(x);
    };
    ReLUFunc.prototype.der = function (math, x, y) {
        return math.step(x);
    };
    ReLUFunc.prototype.dispose = function () { };
    return ReLUFunc;
}());
exports.ReLUFunc = ReLUFunc;
var LeakyReluFunc = (function () {
    function LeakyReluFunc(alpha) {
        this.alpha = alpha;
    }
    LeakyReluFunc.prototype.output = function (math, x) {
        return math.leakyRelu(x, this.alpha);
    };
    LeakyReluFunc.prototype.der = function (math, x, y) {
        return math.step(x, this.alpha);
    };
    LeakyReluFunc.prototype.dispose = function () { };
    return LeakyReluFunc;
}());
exports.LeakyReluFunc = LeakyReluFunc;
var SigmoidFunc = (function () {
    function SigmoidFunc() {
    }
    SigmoidFunc.prototype.output = function (math, x) {
        return math.sigmoid(x);
    };
    SigmoidFunc.prototype.der = function (math, x, y) {
        return globals_1.tidy(function () {
            var ySquared = math.multiplyStrict(y, y);
            return math.subStrict(y, ySquared);
        });
    };
    SigmoidFunc.prototype.dispose = function () { };
    return SigmoidFunc;
}());
exports.SigmoidFunc = SigmoidFunc;
var SquareFunc = (function () {
    function SquareFunc() {
        this.two = tensor_1.Scalar.new(2);
    }
    SquareFunc.prototype.output = function (math, x) {
        return math.multiplyStrict(x, x);
    };
    SquareFunc.prototype.der = function (math, x, y) {
        return math.multiply(this.two, x);
    };
    SquareFunc.prototype.dispose = function () {
        this.two.dispose();
    };
    return SquareFunc;
}());
exports.SquareFunc = SquareFunc;
var EluFunc = (function () {
    function EluFunc() {
    }
    EluFunc.prototype.output = function (math, x) {
        return math.elu(x);
    };
    EluFunc.prototype.der = function (math, x, y) {
        throw new Error('Not implemented');
    };
    EluFunc.prototype.dispose = function () { };
    return EluFunc;
}());
exports.EluFunc = EluFunc;

},{"../globals":28,"../tensor":137}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var ops = require("../ops/ops");
var SquareCostFunc = (function () {
    function SquareCostFunc() {
        this.halfOne = globals_1.keep(ops.scalar(0.5));
    }
    SquareCostFunc.prototype.cost = function (x1, x2) {
        var diff = x1.subStrict(x2);
        var diffSquared = diff.square();
        var result = this.halfOne.mul(diffSquared);
        diff.dispose();
        diffSquared.dispose();
        return result;
    };
    SquareCostFunc.prototype.der = function (x1, x2) {
        return x1.subStrict(x2);
    };
    SquareCostFunc.prototype.dispose = function () {
        this.halfOne.dispose();
    };
    return SquareCostFunc;
}());
exports.SquareCostFunc = SquareCostFunc;

},{"../globals":28,"../ops/ops":114}],32:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../ops/concat_util");
var conv_util = require("../ops/conv_util");
var tensor_1 = require("../tensor");
var util = require("../util");
var initializers_1 = require("./initializers");
var GraphLayers = (function () {
    function GraphLayers(g) {
        this.g = g;
    }
    GraphLayers.prototype.dense = function (name, x, units, activation, useBias, kernelInitializer, biasInitializer) {
        if (activation === void 0) { activation = null; }
        if (useBias === void 0) { useBias = true; }
        if (kernelInitializer === void 0) { kernelInitializer = new initializers_1.VarianceScalingInitializer(); }
        if (biasInitializer === void 0) { biasInitializer = new initializers_1.ZerosInitializer(); }
        var weights = this.g.variable(name + '-weights', kernelInitializer.initialize([x.shape[0], units], x.shape[0], units));
        var out = this.g.matmul(x, weights);
        if (useBias) {
            var bias = this.g.variable(name + '-bias', biasInitializer.initialize([units], x.shape[0], units));
            out = this.g.add(out, bias);
        }
        if (activation != null) {
            out = activation(out);
        }
        return out;
    };
    return GraphLayers;
}());
exports.GraphLayers = GraphLayers;
var Graph = (function () {
    function Graph() {
        this.nodes = [];
        this.layers = new GraphLayers(this);
    }
    Graph.prototype.variable = function (name, data) {
        return this.addNodeAndReturnOutput(new VariableNode(this, name, data));
    };
    Graph.prototype.placeholder = function (name, shape) {
        return this.addNodeAndReturnOutput(new PlaceholderNode(this, name, shape));
    };
    Graph.prototype.constant = function (value) {
        var finalValue;
        if (typeof value === 'number') {
            finalValue = tensor_1.Scalar.new(value);
        }
        else if (value instanceof tensor_1.Tensor) {
            finalValue = value;
        }
        else if (value instanceof Array) {
            var flatValues = util.flatten(value);
            var vals = new Float32Array(flatValues);
            finalValue = tensor_1.Tensor.make(util.inferShape(value), { values: vals });
        }
        else {
            throw new Error('unimplemented constant type.');
        }
        return this.addNodeAndReturnOutput(new ConstantNode(this, finalValue));
    };
    Graph.prototype.reshape = function (x, shape) {
        return this.addNodeAndReturnOutput(new ReshapeNode(this, 'Reshape', x, shape));
    };
    Graph.prototype.fusedLinearCombination = function (x1, x2, c1, c2) {
        return this.addNodeAndReturnOutput(new FusedLinearCombinationNode(this, x1, x2, c1, c2));
    };
    Graph.prototype.add = function (x1, x2) {
        return this.addNodeAndReturnOutput(new AddNode(this, x1, x2));
    };
    Graph.prototype.subtract = function (x1, x2) {
        return this.addNodeAndReturnOutput(new SubtractNode(this, x1, x2));
    };
    Graph.prototype.multiply = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MultiplyNode(this, x1, x2));
    };
    Graph.prototype.divide = function (x1, x2) {
        return this.addNodeAndReturnOutput(new DivideNode(this, x1, x2));
    };
    Graph.prototype.reduceSum = function (x) {
        return this.addNodeAndReturnOutput(new ReduceSumNode(this, x));
    };
    Graph.prototype.concat1d = function (x1, x2) {
        return this.addNodeAndReturnOutput(new Concat1DNode(this, x1, x2));
    };
    Graph.prototype.concat2d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat2DNode(this, x1, x2, axis));
    };
    Graph.prototype.concat3d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat3DNode(this, x1, x2, axis));
    };
    Graph.prototype.concat4d = function (x1, x2, axis) {
        return this.addNodeAndReturnOutput(new Concat4DNode(this, x1, x2, axis));
    };
    Graph.prototype.matmul = function (x1, x2) {
        return this.addNodeAndReturnOutput(new MatMulNode(this, x1, x2));
    };
    Graph.prototype.conv2d = function (x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new Convolution2DNode(this, x, w, b, fieldSize, outputDepth, stride, zeroPad));
    };
    Graph.prototype.maxPool = function (x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        return this.addNodeAndReturnOutput(new MaxPoolNode(this, x, fieldSize, stride, zeroPad));
    };
    Graph.prototype.exp = function (x) {
        return this.addNodeAndReturnOutput(new ExpNode(this, x));
    };
    Graph.prototype.log = function (x) {
        return this.addNodeAndReturnOutput(new LogNode(this, x));
    };
    Graph.prototype.relu = function (x) {
        return this.addNodeAndReturnOutput(new ReLUNode(this, x));
    };
    Graph.prototype.leakyRelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new LeakyReLUNode(this, x, alpha));
    };
    Graph.prototype.prelu = function (x, alpha) {
        return this.addNodeAndReturnOutput(new PReLUNode(this, x, alpha));
    };
    Graph.prototype.elu = function (x) {
        return this.addNodeAndReturnOutput(new EluNode(this, x));
    };
    Graph.prototype.tanh = function (x) {
        return this.addNodeAndReturnOutput(new TanHNode(this, x));
    };
    Graph.prototype.sigmoid = function (x) {
        return this.addNodeAndReturnOutput(new SigmoidNode(this, x));
    };
    Graph.prototype.square = function (x) {
        return this.addNodeAndReturnOutput(new SquareNode(this, x));
    };
    Graph.prototype.softmax = function (x) {
        return this.addNodeAndReturnOutput(new SoftmaxNode(this, x));
    };
    Graph.prototype.softmaxCrossEntropyCost = function (x, target) {
        return this.addNodeAndReturnOutput(new SoftmaxCrossEntropyCostNode(this, x, target));
    };
    Graph.prototype.meanSquaredCost = function (label, prediction) {
        return this.addNodeAndReturnOutput(new MeanSquaredCostNode(this, label, prediction));
    };
    Graph.prototype.argmax = function (x) {
        return this.addNodeAndReturnOutput(new ArgMaxNode(this, x));
    };
    Graph.prototype.argmaxEquals = function (x1, x2) {
        return this.addNodeAndReturnOutput(new ArgMaxEqualsNode(this, x1, x2));
    };
    Graph.prototype.addNodeAndReturnOutput = function (node) {
        this.nodes.push(node);
        node.validate();
        return node.output;
    };
    Graph.prototype.getNodes = function () {
        return this.nodes;
    };
    return Graph;
}());
exports.Graph = Graph;
var SymbolicTensor = (function (_super) {
    __extends(SymbolicTensor, _super);
    function SymbolicTensor(shape) {
        var _this = _super.call(this, [], 'float32') || this;
        _this.shape = shape;
        _this.id = SymbolicTensor.nextID++;
        return _this;
    }
    SymbolicTensor.nextID = 0;
    return SymbolicTensor;
}(tensor_1.Tensor));
exports.SymbolicTensor = SymbolicTensor;
var Node = (function () {
    function Node(graph, name, inputs, output) {
        this.graph = graph;
        this.name = name;
        this.inputs = inputs;
        this.output = output;
        this.id = Node.nextID++;
        output.node = this;
    }
    Node.nextID = 0;
    return Node;
}());
exports.Node = Node;
var VariableNode = (function (_super) {
    __extends(VariableNode, _super);
    function VariableNode(graph, name, data) {
        var _this = _super.call(this, graph, name, {}, new SymbolicTensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    VariableNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding variable op: Data for variable \'' + this.name +
            '\' is null or undefined');
    };
    return VariableNode;
}(Node));
exports.VariableNode = VariableNode;
var PlaceholderNode = (function (_super) {
    __extends(PlaceholderNode, _super);
    function PlaceholderNode(graph, name, shape) {
        return _super.call(this, graph, name, {}, new SymbolicTensor(shape)) || this;
    }
    PlaceholderNode.prototype.validate = function () { };
    return PlaceholderNode;
}(Node));
exports.PlaceholderNode = PlaceholderNode;
var ConstantNode = (function (_super) {
    __extends(ConstantNode, _super);
    function ConstantNode(graph, data) {
        var _this = _super.call(this, graph, 'Constant', {}, new SymbolicTensor(data.shape)) || this;
        _this.data = data;
        return _this;
    }
    ConstantNode.prototype.validate = function () {
        util.assert(this.data != null, 'Error adding constant: data for placeholder \'' + this.name +
            '\' is null or undefined');
    };
    return ConstantNode;
}(Node));
exports.ConstantNode = ConstantNode;
var ReshapeNode = (function (_super) {
    __extends(ReshapeNode, _super);
    function ReshapeNode(graph, name, x, shape) {
        var _this = _super.call(this, graph, name, { x: x }, new SymbolicTensor(shape)) || this;
        _this.name = name;
        _this.x = x;
        _this.shape = shape;
        return _this;
    }
    ReshapeNode.prototype.validate = function () {
        var xSize = util.sizeFromShape(this.x.shape);
        var shapeSize = util.sizeFromShape(this.shape);
        util.assert(xSize === shapeSize, "Error making reshape operation: input to reshape '" + this.name + "'" +
            (" of shape (" + this.x.shape + ") does not match size of ") +
            ("requested shape " + this.shape + "."));
    };
    ReshapeNode.X = 'x';
    return ReshapeNode;
}(Node));
exports.ReshapeNode = ReshapeNode;
var FusedLinearCombinationNode = (function (_super) {
    __extends(FusedLinearCombinationNode, _super);
    function FusedLinearCombinationNode(graph, t1, t2, c1, c2) {
        var _this = _super.call(this, graph, 'Linear Combination', { t1: t1, t2: t2, c1: c1, c2: c2 }, new SymbolicTensor(t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.c1 = c1;
        _this.c2 = c2;
        return _this;
    }
    FusedLinearCombinationNode.prototype.validate = function () {
        util.assertShapesMatch(this.t1.shape, this.t2.shape);
        if (!util.isScalarShape(this.c1.shape)) {
            throw new Error('Error adding fusedLinearCombination: c1 is not a scalar, got ' +
                ("shape: " + this.c1.shape));
        }
        if (!util.isScalarShape(this.c2.shape)) {
            throw new Error('Error adding fusedLinearCombination: c2 is not a scalar, got ' +
                ("shape: " + this.c2.shape));
        }
    };
    FusedLinearCombinationNode.T1 = 't1';
    FusedLinearCombinationNode.T2 = 't2';
    FusedLinearCombinationNode.C1 = 'c1';
    FusedLinearCombinationNode.C2 = 'c2';
    return FusedLinearCombinationNode;
}(Node));
exports.FusedLinearCombinationNode = FusedLinearCombinationNode;
var AddNode = (function (_super) {
    __extends(AddNode, _super);
    function AddNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Add', { t1: t1, t2: t2 }, new SymbolicTensor(util.sizeFromShape(t1.shape) === 1 ?
            t2.shape :
            (t1.shape.length < t2.shape.length ? t2.shape : t1.shape))) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    AddNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape) ||
            (this.t1.shape.length === 2 && this.t2.shape.length === 1 &&
                this.t1.shape[1] === this.t2.shape[0]) ||
            (this.t1.shape.length === 1 && this.t2.shape.length === 2 &&
                this.t1.shape[0] === this.t2.shape[1]), 'Error adding add operation op: one of inputs must be scalar, ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match,") +
            'or one of them can be broadcasted (2D and 1D).');
    };
    AddNode.T1 = 't1';
    AddNode.T2 = 't2';
    return AddNode;
}(Node));
exports.AddNode = AddNode;
var SubtractNode = (function (_super) {
    __extends(SubtractNode, _super);
    function SubtractNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Subtract', { t1: t1, t2: t2 }, new SymbolicTensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    SubtractNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding subtract op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    SubtractNode.T1 = 't1';
    SubtractNode.T2 = 't2';
    return SubtractNode;
}(Node));
exports.SubtractNode = SubtractNode;
var MultiplyNode = (function (_super) {
    __extends(MultiplyNode, _super);
    function MultiplyNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Multiply', { t1: t1, t2: t2 }, new SymbolicTensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    MultiplyNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding multiply op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    MultiplyNode.T1 = 't1';
    MultiplyNode.T2 = 't2';
    return MultiplyNode;
}(Node));
exports.MultiplyNode = MultiplyNode;
var DivideNode = (function (_super) {
    __extends(DivideNode, _super);
    function DivideNode(graph, t1, t2) {
        var _this = _super.call(this, graph, 'Divide', { t1: t1, t2: t2 }, new SymbolicTensor(util.sizeFromShape(t1.shape) === 1 ? t2.shape : t1.shape)) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        return _this;
    }
    DivideNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.t1.shape) === 1 ||
            util.sizeFromShape(this.t2.shape) === 1 ||
            util.arraysEqual(this.t1.shape, this.t2.shape), 'Error adding divide op: one of inputs must be scalar or the ' +
            ("shapes " + this.t1.shape + " and " + this.t2.shape + " must match."));
    };
    DivideNode.T1 = 't1';
    DivideNode.T2 = 't2';
    return DivideNode;
}(Node));
exports.DivideNode = DivideNode;
var ReduceSumNode = (function (_super) {
    __extends(ReduceSumNode, _super);
    function ReduceSumNode(graph, x) {
        return _super.call(this, graph, 'ReduceSum', { x: x }, new SymbolicTensor([])) || this;
    }
    ReduceSumNode.prototype.validate = function () { };
    ReduceSumNode.X = 'x';
    return ReduceSumNode;
}(Node));
exports.ReduceSumNode = ReduceSumNode;
var Concat1DNode = (function (_super) {
    __extends(Concat1DNode, _super);
    function Concat1DNode(graph, x1, x2) {
        return _super.call(this, graph, 'Concat1D', { x1: x1, x2: x2 }, new SymbolicTensor(concat_util.computeOutShape1D(x1.shape, x2.shape))) || this;
    }
    Concat1DNode.prototype.validate = function () { };
    Concat1DNode.X1 = 'x1';
    Concat1DNode.X2 = 'x2';
    return Concat1DNode;
}(Node));
exports.Concat1DNode = Concat1DNode;
var Concat2DNode = (function (_super) {
    __extends(Concat2DNode, _super);
    function Concat2DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat2D', { x1: x1, x2: x2 }, new SymbolicTensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat2DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat2DNode.X1 = 'x1';
    Concat2DNode.X2 = 'x2';
    Concat2DNode.AXIS = 'axis';
    return Concat2DNode;
}(Node));
exports.Concat2DNode = Concat2DNode;
var Concat3DNode = (function (_super) {
    __extends(Concat3DNode, _super);
    function Concat3DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat3D', { x1: x1, x2: x2 }, new SymbolicTensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat3DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat3DNode.X1 = 'x1';
    Concat3DNode.X2 = 'x2';
    Concat3DNode.AXIS = 'axis';
    return Concat3DNode;
}(Node));
exports.Concat3DNode = Concat3DNode;
var Concat4DNode = (function (_super) {
    __extends(Concat4DNode, _super);
    function Concat4DNode(graph, x1, x2, axis) {
        var _this = _super.call(this, graph, 'Concat4D', { x1: x1, x2: x2 }, new SymbolicTensor(concat_util.computeOutShape(x1.shape, x2.shape, axis))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        _this.axis = axis;
        return _this;
    }
    Concat4DNode.prototype.validate = function () {
        concat_util.assertParams(this.x1.shape, this.x2.shape, this.axis);
    };
    Concat4DNode.X1 = 'x1';
    Concat4DNode.X2 = 'x2';
    Concat4DNode.AXIS = 'axis';
    return Concat4DNode;
}(Node));
exports.Concat4DNode = Concat4DNode;
function getMatMulOutputShape(x1Shape, x2Shape) {
    if (x1Shape.length === 1 && x2Shape.length === 1) {
        return [1];
    }
    else if (x1Shape.length === 1 && x2Shape.length === 2) {
        return [x2Shape[1]];
    }
    else if (x1Shape.length === 2 && x2Shape.length === 1) {
        return [x1Shape[0]];
    }
    return [x1Shape[0], x2Shape[1]];
}
var MatMulNode = (function (_super) {
    __extends(MatMulNode, _super);
    function MatMulNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'MatMul', { x1: x1, x2: x2 }, new SymbolicTensor(getMatMulOutputShape(x1.shape, x2.shape))) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    MatMulNode.prototype.validate = function () {
        if (this.x1.shape.length === 2 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: inner shapes of matrices with shapes ' +
                (this.x1.shape + " and " + this.x2.shape + " must match."));
        }
        else if (this.x1.shape.length === 2 && this.x2.shape.length === 1) {
            util.assert(this.x1.shape[1] === this.x2.shape[0], 'Error adding matmul op: second dimension of matrix with shape ' +
                this.x1.shape.toString() +
                (" must match size of vector with shape " + this.x2.shape + "."));
        }
        else if (this.x1.shape.length === 1 && this.x2.shape.length === 2) {
            util.assert(this.x1.shape[0] === this.x2.shape[0], "Error adding matmul op: size of vector with shape " + this.x1.shape +
                " must match first dimension of matrix with " +
                ("shape " + this.x2.shape + "."));
        }
        else {
            throw new Error('Error adding matmul op: inputs must be vectors or matrices.');
        }
    };
    MatMulNode.X1 = 'x1';
    MatMulNode.X2 = 'x2';
    return MatMulNode;
}(Node));
exports.MatMulNode = MatMulNode;
var Convolution2DNode = (function (_super) {
    __extends(Convolution2DNode, _super);
    function Convolution2DNode(graph, x, w, b, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Convolution 2D', { x: x, w: w, b: b }, new SymbolicTensor(conv_util.computeOutputShape3D(x.shape, fieldSize, outputDepth, stride, zeroPad))) || this;
        _this.x = x;
        _this.w = w;
        _this.b = b;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    Convolution2DNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding conv2d op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
        util.assert(this.w.shape.length === 4, 'Error adding conv2d op: weights must be of rank 4, but got shape: ' +
            (this.w.shape + "."));
        util.assert(this.b.shape.length === 1, 'Error adding conv2d op: biases must be of rank 1, but got shape: ' +
            (this.b.shape + "."));
        util.assert(this.x.shape[2] === this.w.shape[2], "Error adding conv2d op: depth of input (" + this.x.shape[2] + ") " +
            ("must match input depth for weights (" + this.w.shape[2] + ")."));
    };
    Convolution2DNode.X = 'x';
    Convolution2DNode.W = 'w';
    Convolution2DNode.B = 'b';
    return Convolution2DNode;
}(Node));
exports.Convolution2DNode = Convolution2DNode;
var MaxPoolNode = (function (_super) {
    __extends(MaxPoolNode, _super);
    function MaxPoolNode(graph, x, fieldSize, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this, graph, 'Max pool', { x: x }, new SymbolicTensor(conv_util.computeOutputShape3D(x.shape, fieldSize, x.shape[2], stride, zeroPad))) || this;
        _this.x = x;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        _this.zeroPad = zeroPad;
        return _this;
    }
    MaxPoolNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 3, 'Error adding maxPool op: input must be of rank 3, but got shape: ' +
            (this.x.shape + "."));
    };
    MaxPoolNode.X = 'x';
    return MaxPoolNode;
}(Node));
exports.MaxPoolNode = MaxPoolNode;
var ReLUNode = (function (_super) {
    __extends(ReLUNode, _super);
    function ReLUNode(graph, x) {
        return _super.call(this, graph, 'ReLU', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    ReLUNode.prototype.validate = function () { };
    ReLUNode.X = 'x';
    return ReLUNode;
}(Node));
exports.ReLUNode = ReLUNode;
var LeakyReLUNode = (function (_super) {
    __extends(LeakyReLUNode, _super);
    function LeakyReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'LeakyReLU', { x: x }, new SymbolicTensor(x.shape)) || this;
        _this.alpha = alpha;
        return _this;
    }
    LeakyReLUNode.prototype.validate = function () { };
    LeakyReLUNode.X = 'x';
    return LeakyReLUNode;
}(Node));
exports.LeakyReLUNode = LeakyReLUNode;
var PReLUNode = (function (_super) {
    __extends(PReLUNode, _super);
    function PReLUNode(graph, x, alpha) {
        var _this = _super.call(this, graph, 'PReLU', { x: x, alpha: alpha }, new SymbolicTensor(x.shape)) || this;
        _this.x = x;
        _this.alpha = alpha;
        return _this;
    }
    PReLUNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.alpha.shape), 'Error adding pRelu op: the ' +
            ("shapes x: " + this.x.shape + " and alpha: " + this.alpha.shape + " must match."));
    };
    PReLUNode.X = 'x';
    PReLUNode.ALPHA = 'alpha';
    return PReLUNode;
}(Node));
exports.PReLUNode = PReLUNode;
var EluNode = (function (_super) {
    __extends(EluNode, _super);
    function EluNode(graph, x) {
        return _super.call(this, graph, 'Elu', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    EluNode.prototype.validate = function () { };
    EluNode.X = 'x';
    return EluNode;
}(Node));
exports.EluNode = EluNode;
var ExpNode = (function (_super) {
    __extends(ExpNode, _super);
    function ExpNode(graph, x) {
        return _super.call(this, graph, 'Exp', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    ExpNode.prototype.validate = function () { };
    ExpNode.X = 'x';
    return ExpNode;
}(Node));
exports.ExpNode = ExpNode;
var LogNode = (function (_super) {
    __extends(LogNode, _super);
    function LogNode(graph, x) {
        return _super.call(this, graph, 'Log', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    LogNode.prototype.validate = function () { };
    LogNode.X = 'x';
    return LogNode;
}(Node));
exports.LogNode = LogNode;
var TanHNode = (function (_super) {
    __extends(TanHNode, _super);
    function TanHNode(graph, x) {
        return _super.call(this, graph, 'TanH', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    TanHNode.prototype.validate = function () { };
    TanHNode.X = 'x';
    return TanHNode;
}(Node));
exports.TanHNode = TanHNode;
var SigmoidNode = (function (_super) {
    __extends(SigmoidNode, _super);
    function SigmoidNode(graph, x) {
        return _super.call(this, graph, 'Sigmoid', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    SigmoidNode.prototype.validate = function () { };
    SigmoidNode.X = 'x';
    return SigmoidNode;
}(Node));
exports.SigmoidNode = SigmoidNode;
var SquareNode = (function (_super) {
    __extends(SquareNode, _super);
    function SquareNode(graph, x) {
        return _super.call(this, graph, 'Square', { x: x }, new SymbolicTensor(x.shape)) || this;
    }
    SquareNode.prototype.validate = function () { };
    SquareNode.X = 'x';
    return SquareNode;
}(Node));
exports.SquareNode = SquareNode;
var SoftmaxCrossEntropyCostNode = (function (_super) {
    __extends(SoftmaxCrossEntropyCostNode, _super);
    function SoftmaxCrossEntropyCostNode(graph, x, target) {
        var _this = _super.call(this, graph, 'SoftmaxCrossEntropyCost', { x: x, target: target }, new SymbolicTensor([])) || this;
        _this.x = x;
        _this.target = target;
        return _this;
    }
    SoftmaxCrossEntropyCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x.shape, this.target.shape), "Error adding softmaxCrossEntropyCost op: x shape (" + this.x.shape + ") " +
            ("must match target shape (" + this.target.shape + ")."));
    };
    SoftmaxCrossEntropyCostNode.X = 'x';
    SoftmaxCrossEntropyCostNode.TARGET = 'target';
    return SoftmaxCrossEntropyCostNode;
}(Node));
exports.SoftmaxCrossEntropyCostNode = SoftmaxCrossEntropyCostNode;
var SoftmaxNode = (function (_super) {
    __extends(SoftmaxNode, _super);
    function SoftmaxNode(graph, x) {
        var _this = _super.call(this, graph, 'Softmax', { x: x }, new SymbolicTensor(x.shape)) || this;
        _this.x = x;
        return _this;
    }
    SoftmaxNode.prototype.validate = function () {
        util.assert(this.x.shape.length === 1, 'The input to a softmax must be a 1-D tensor');
        util.assert(this.x.shape[0] >= 2, 'The input to a softmax must have at least 2 values');
    };
    SoftmaxNode.X = 'x';
    return SoftmaxNode;
}(Node));
exports.SoftmaxNode = SoftmaxNode;
var MeanSquaredCostNode = (function (_super) {
    __extends(MeanSquaredCostNode, _super);
    function MeanSquaredCostNode(graph, label, prediction) {
        var _this = _super.call(this, graph, 'Mean Squared Cost', { label: label, prediction: prediction }, new SymbolicTensor([])) || this;
        _this.label = label;
        _this.prediction = prediction;
        return _this;
    }
    MeanSquaredCostNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.label.shape, this.prediction.shape), "Error adding meanSquaredCost op: label shape (" + this.label.shape + ") " +
            ("must match prediction shape (" + this.prediction.shape + ")."));
    };
    MeanSquaredCostNode.LABEL = 'label';
    MeanSquaredCostNode.PREDICTION = 'prediction';
    return MeanSquaredCostNode;
}(Node));
exports.MeanSquaredCostNode = MeanSquaredCostNode;
var ArgMaxNode = (function (_super) {
    __extends(ArgMaxNode, _super);
    function ArgMaxNode(graph, x) {
        var _this = _super.call(this, graph, 'ArgMax', { x: x }, new SymbolicTensor([1])) || this;
        _this.x = x;
        return _this;
    }
    ArgMaxNode.prototype.validate = function () {
        util.assert(util.sizeFromShape(this.x.shape) > 0, 'Error adding argmax op: input tensor must have at least one entry.');
    };
    ArgMaxNode.X = 'x';
    return ArgMaxNode;
}(Node));
exports.ArgMaxNode = ArgMaxNode;
var ArgMaxEqualsNode = (function (_super) {
    __extends(ArgMaxEqualsNode, _super);
    function ArgMaxEqualsNode(graph, x1, x2) {
        var _this = _super.call(this, graph, 'ArgMaxEquals', { x1: x1, x2: x2 }, new SymbolicTensor([1])) || this;
        _this.x1 = x1;
        _this.x2 = x2;
        return _this;
    }
    ArgMaxEqualsNode.prototype.validate = function () {
        util.assert(util.arraysEqual(this.x1.shape, this.x2.shape), "Error adding ArgMaxEquals op: x1 shape (" + this.x1.shape + ") " +
            ("must match x2 shape (" + this.x2.shape + ")."));
    };
    ArgMaxEqualsNode.X1 = 'x1';
    ArgMaxEqualsNode.X2 = 'x2';
    return ArgMaxEqualsNode;
}(Node));
exports.ArgMaxEqualsNode = ArgMaxEqualsNode;

},{"../ops/concat_util":104,"../ops/conv_util":106,"../tensor":137,"../util":143,"./initializers":35}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var tensor_1 = require("../tensor");
var session_1 = require("./session");
var DEFAULT_EVAL_INTERVAL_MS = 1500;
var DEFAULT_COST_INTERVAL_MS = 500;
var DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS = 3000;
var MetricReduction;
(function (MetricReduction) {
    MetricReduction[MetricReduction["SUM"] = 0] = "SUM";
    MetricReduction[MetricReduction["MEAN"] = 1] = "MEAN";
})(MetricReduction = exports.MetricReduction || (exports.MetricReduction = {}));
var GraphRunner = (function () {
    function GraphRunner(math, session, eventObserver) {
        this.math = math;
        this.session = session;
        this.eventObserver = eventObserver;
        this.lastCostTimestamp = 0;
        this.lastEvalTimestamp = 0;
        this.resetStatistics();
        this.zeroScalar = tensor_1.Scalar.new(0);
    }
    GraphRunner.prototype.resetStatistics = function () {
        this.totalBatchesTrained = 0;
    };
    GraphRunner.prototype.train = function (costTensor, trainFeedEntries, batchSize, optimizer, numBatches, metricTensor, metricFeedEntries, metricBatchSize, metricReduction, evalIntervalMs, costIntervalMs) {
        if (metricReduction === void 0) { metricReduction = MetricReduction.MEAN; }
        if (evalIntervalMs === void 0) { evalIntervalMs = DEFAULT_EVAL_INTERVAL_MS; }
        if (costIntervalMs === void 0) { costIntervalMs = DEFAULT_COST_INTERVAL_MS; }
        this.costTensor = costTensor;
        this.trainFeedEntries = trainFeedEntries;
        this.metricTensor = metricTensor;
        this.metricFeedEntries = metricFeedEntries;
        if (metricBatchSize != null && this.metricBatchSize !== metricBatchSize) {
            if (this.metricBatchSizeScalar != null) {
                this.metricBatchSizeScalar.dispose();
            }
            this.metricBatchSizeScalar = tensor_1.Scalar.new(metricBatchSize);
        }
        this.metricBatchSize = metricBatchSize;
        this.metricReduction = metricReduction;
        this.batchSize = batchSize;
        this.optimizer = optimizer;
        this.metricIntervalMs = evalIntervalMs;
        this.costIntervalMs = costIntervalMs;
        this.currentTrainLoopNumBatches = numBatches;
        this.batchesTrainedThisRun = 0;
        this.isTraining = true;
        this.trainStartTimestamp = performance.now();
        this.trainNetwork();
    };
    GraphRunner.prototype.stopTraining = function () {
        this.isTraining = false;
    };
    GraphRunner.prototype.resumeTraining = function () {
        this.isTraining = true;
        this.trainNetwork();
    };
    GraphRunner.prototype.trainNetwork = function () {
        var _this = this;
        if (this.batchesTrainedThisRun === this.currentTrainLoopNumBatches) {
            this.stopTraining();
        }
        if (!this.isTraining) {
            if (this.eventObserver.doneTrainingCallback != null) {
                this.eventObserver.doneTrainingCallback();
            }
            return;
        }
        var start = performance.now();
        var shouldComputeCost = this.eventObserver.avgCostCallback != null &&
            (start - this.lastCostTimestamp > this.costIntervalMs);
        if (shouldComputeCost) {
            this.lastCostTimestamp = start;
        }
        var costReduction = shouldComputeCost ? session_1.CostReduction.MEAN : session_1.CostReduction.NONE;
        globals_1.tidy(function () {
            var avgCost = _this.session.train(_this.costTensor, _this.trainFeedEntries, _this.batchSize, _this.optimizer, costReduction);
            if (shouldComputeCost) {
                var trainTime = performance.now() - start;
                _this.eventObserver.avgCostCallback(avgCost);
                if (_this.eventObserver.trainExamplesPerSecCallback != null) {
                    var examplesPerSec = (_this.batchSize * 1000 / trainTime);
                    _this.eventObserver.trainExamplesPerSecCallback(examplesPerSec);
                }
            }
            if (_this.eventObserver.metricCallback != null &&
                _this.metricFeedEntries != null &&
                start - _this.lastEvalTimestamp > _this.metricIntervalMs) {
                _this.lastEvalTimestamp = start;
                if (_this.lastComputedMetric != null) {
                    _this.lastComputedMetric.dispose();
                }
                _this.lastComputedMetric = _this.computeMetric();
                _this.eventObserver.metricCallback(_this.lastComputedMetric);
            }
            if (_this.eventObserver.totalTimeCallback != null) {
                _this.eventObserver.totalTimeCallback((start - _this.trainStartTimestamp) / 1000);
            }
            _this.batchesTrainedThisRun++;
            _this.totalBatchesTrained++;
            if (_this.eventObserver.batchesTrainedCallback != null) {
                _this.eventObserver.batchesTrainedCallback(_this.totalBatchesTrained);
            }
        });
        requestAnimationFrame(function () { return _this.trainNetwork(); });
    };
    GraphRunner.prototype.infer = function (inferenceTensor, inferenceFeedEntries, inferenceExampleIntervalMs, inferenceExampleCount, numPasses) {
        var _this = this;
        if (inferenceExampleIntervalMs === void 0) { inferenceExampleIntervalMs = DEFAULT_INFERENCE_EXAMPLE_INTERVAL_MS; }
        if (inferenceExampleCount === void 0) { inferenceExampleCount = 5; }
        if (this.eventObserver.inferenceExamplesCallback == null &&
            this.eventObserver.inferenceExamplesPerSecCallback == null) {
            throw new Error('Cannot start inference loop, no inference example or ' +
                'examples/sec observer provided.');
        }
        for (var i = 0; i < inferenceFeedEntries.length; i++) {
            var feedEntry = inferenceFeedEntries[i];
            if (feedEntry.data instanceof tensor_1.Tensor) {
                throw new Error('Cannot start inference on the model runner with feed entries of ' +
                    'type NDArray. Please use InputProviders.');
            }
        }
        this.inferenceExampleIntervalMs = inferenceExampleIntervalMs;
        this.inferenceTensor = inferenceTensor;
        this.inferenceFeedEntries = inferenceFeedEntries;
        this.inferenceExampleCount = inferenceExampleCount;
        this.currentInferenceLoopNumPasses = numPasses;
        if (!this.isInferring) {
            this.inferencePassesThisRun = 0;
            requestAnimationFrame(function () { return _this.inferNetwork(); });
        }
        this.isInferring = true;
    };
    GraphRunner.prototype.inferNetwork = function () {
        var _this = this;
        if (!this.isInferring ||
            this.inferencePassesThisRun === this.currentInferenceLoopNumPasses) {
            return;
        }
        globals_1.tidy(function () {
            var feeds = [];
            var inferenceValues = [];
            var start = performance.now();
            for (var i = 0; i < _this.inferenceExampleCount; i++) {
                var ndarrayFeedEntries = [];
                for (var j = 0; j < _this.inferenceFeedEntries.length; j++) {
                    var feedEntry = _this.inferenceFeedEntries[j];
                    var nextCopy = feedEntry.data.getNextCopy();
                    ndarrayFeedEntries.push({ tensor: feedEntry.tensor, data: nextCopy });
                }
                feeds.push(ndarrayFeedEntries);
                inferenceValues.push(_this.session.eval(_this.inferenceTensor, ndarrayFeedEntries));
            }
            if (_this.eventObserver.inferenceExamplesPerSecCallback != null) {
                inferenceValues[inferenceValues.length - 1].dataSync();
                var inferenceExamplesPerSecTime = performance.now() - start;
                var examplesPerSec = (_this.inferenceExampleCount * 1000 / inferenceExamplesPerSecTime);
                _this.eventObserver.inferenceExamplesPerSecCallback(examplesPerSec);
            }
            if (_this.eventObserver.inferenceExamplesCallback != null) {
                _this.eventObserver.inferenceExamplesCallback(feeds, inferenceValues);
            }
            _this.inferencePassesThisRun++;
        });
        this.lastInferTimeoutID = window.setTimeout(function () { return _this.inferNetwork(); }, this.inferenceExampleIntervalMs);
    };
    GraphRunner.prototype.stopInferring = function () {
        this.isInferring = false;
        window.clearTimeout(this.lastInferTimeoutID);
    };
    GraphRunner.prototype.isInferenceRunning = function () {
        return this.isInferring;
    };
    GraphRunner.prototype.computeMetric = function () {
        var _this = this;
        if (this.metricFeedEntries == null) {
            throw new Error('Cannot compute metric, no metric FeedEntries provided.');
        }
        var metric = this.zeroScalar;
        return globals_1.tidy(function () {
            for (var i = 0; i < _this.metricBatchSize; i++) {
                var metricValue = _this.session.eval(_this.metricTensor, _this.metricFeedEntries);
                metric = _this.math.add(metric, metricValue.toFloat());
            }
            if (_this.metricReduction === MetricReduction.MEAN) {
                metric = _this.math.divide(metric, _this.metricBatchSizeScalar);
            }
            return metric;
        });
    };
    GraphRunner.prototype.getTotalBatchesTrained = function () {
        return this.totalBatchesTrained;
    };
    GraphRunner.prototype.getLastComputedMetric = function () {
        return this.lastComputedMetric;
    };
    GraphRunner.prototype.setMath = function (math) {
        this.math = math;
    };
    GraphRunner.prototype.setSession = function (session) {
        this.session = session;
    };
    GraphRunner.prototype.setInferenceTensor = function (inferenceTensor) {
        this.inferenceTensor = inferenceTensor;
    };
    GraphRunner.prototype.setInferenceExampleCount = function (inferenceExampleCount) {
        this.inferenceExampleCount = inferenceExampleCount;
    };
    return GraphRunner;
}());
exports.GraphRunner = GraphRunner;

},{"../globals":28,"../tensor":137,"./session":57}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var priority_queue = require("./priority_queue");
var priority_queue_1 = require("./priority_queue");
function getUnorderedEvaluationSet(nodes, terminatingNodes) {
    var terminatingNodeMap = {};
    var seen = {};
    var set = [];
    var visit = nodes.slice();
    terminatingNodes.forEach(function (node) { return terminatingNodeMap[node.id] = node; });
    var _loop_1 = function () {
        var cur = visit.pop();
        if (seen[cur.id] == null) {
            if (terminatingNodeMap[cur.id] == null) {
                Object.keys(cur.inputs)
                    .map(function (inputName) { return cur.inputs[inputName]; })
                    .forEach(function (input) { return visit.push(input.node); });
            }
            set.push(cur);
            seen[cur.id] = cur;
        }
    };
    while (visit.length !== 0) {
        _loop_1();
    }
    return set;
}
exports.getUnorderedEvaluationSet = getUnorderedEvaluationSet;
function getOrderedEvaluationSet(unorderedEvaluationSet) {
    var set = [];
    var nodeIndices = {};
    var pendingDependencies = {};
    var nodeQueue = new priority_queue_1.PriorityQueue(function (a, b) { return priority_queue.defaultCompare(pendingDependencies[a.id], pendingDependencies[b.id]); }, function (node, newIndex) { return nodeIndices[node.id] = newIndex; });
    unorderedEvaluationSet.forEach(function (node) { return pendingDependencies[node.id] = 0; });
    unorderedEvaluationSet.forEach(function (node) { return Object.keys(node.inputs)
        .map(function (key) { return node.inputs[key]; })
        .forEach(function (input) {
        if (unorderedEvaluationSet.indexOf(input.node) !== -1) {
            pendingDependencies[input.node.id]++;
        }
    }); });
    unorderedEvaluationSet.forEach(function (node) { return nodeQueue.enqueue(node); });
    while (!nodeQueue.empty()) {
        set.unshift(nodeQueue.dequeue());
        Object.keys(set[0].inputs).map(function (key) { return set[0].inputs[key]; }).forEach(function (input) {
            if (unorderedEvaluationSet.indexOf(input.node) === -1) {
                return;
            }
            pendingDependencies[input.node.id]--;
            nodeQueue.update(input.node, nodeIndices[input.node.id]);
        });
    }
    return set;
}
exports.getOrderedEvaluationSet = getOrderedEvaluationSet;
function isInputNode(node) {
    return Object.keys(node.inputs).length === 0;
}
exports.isInputNode = isInputNode;
function shouldBackProp(t) {
    return !(t.node instanceof graph_1.ConstantNode);
}
exports.shouldBackProp = shouldBackProp;
function isPassthroughNode(node, map) {
    var keys = Object.keys(node.inputs);
    for (var i = 0; i < keys.length; i++) {
        var input = node.inputs[keys[i]];
        if (map.get(input, true) === map.get(node.output, true)) {
            return true;
        }
    }
    return false;
}
exports.isPassthroughNode = isPassthroughNode;

},{"./graph":32,"./priority_queue":56}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ops = require("../ops/ops");
var VarianceScalingInitializer = (function () {
    function VarianceScalingInitializer(scale, mode, distribution) {
        if (scale === void 0) { scale = 1.0; }
        if (mode === void 0) { mode = 'fan_in'; }
        if (distribution === void 0) { distribution = 'normal'; }
        this.scale = scale;
        this.mode = mode;
        this.distribution = distribution;
    }
    VarianceScalingInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        var n = 0;
        if (this.mode === 'fan_in') {
            n = inputUnits;
        }
        else if (this.mode === 'fan_out') {
            n = outputUnits;
        }
        else if (this.mode === 'fan_avg') {
            n = (inputUnits + outputUnits) / 2;
        }
        else {
            throw new Error("Unexpected mode for variance scaling initializer: " + this.mode);
        }
        if (this.distribution === 'normal') {
            return ops.truncatedNormal(weightsShape, 0.0, Math.sqrt(this.scale / n));
        }
        else if (this.distribution === 'uniform') {
            return ops.randomUniform(weightsShape, 0.0, Math.sqrt(3 * this.scale / n));
        }
        else {
            throw new Error("Unexpected distribution for variance scaling initializer: " +
                ("" + this.distribution));
        }
    };
    return VarianceScalingInitializer;
}());
exports.VarianceScalingInitializer = VarianceScalingInitializer;
var ZerosInitializer = (function () {
    function ZerosInitializer() {
    }
    ZerosInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.zeros(weightsShape);
    };
    return ZerosInitializer;
}());
exports.ZerosInitializer = ZerosInitializer;
var OnesInitializer = (function () {
    function OnesInitializer() {
    }
    OnesInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.ones(weightsShape);
    };
    return OnesInitializer;
}());
exports.OnesInitializer = OnesInitializer;
var ConstantInitializer = (function () {
    function ConstantInitializer(value) {
        if (value === void 0) { value = 0; }
        this.value = value;
    }
    ConstantInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.fill(weightsShape, this.value);
    };
    return ConstantInitializer;
}());
exports.ConstantInitializer = ConstantInitializer;
var TensorInitializer = (function () {
    function TensorInitializer(tensor) {
        this.tensor = tensor;
    }
    TensorInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return this.tensor;
    };
    return TensorInitializer;
}());
exports.TensorInitializer = TensorInitializer;
var RandomNormalInitializer = (function () {
    function RandomNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.randomNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomNormalInitializer;
}());
exports.RandomNormalInitializer = RandomNormalInitializer;
var RandomTruncatedNormalInitializer = (function () {
    function RandomTruncatedNormalInitializer(mean, stdev) {
        if (mean === void 0) { mean = 0; }
        if (stdev === void 0) { stdev = .05; }
        this.mean = mean;
        this.stdev = stdev;
    }
    RandomTruncatedNormalInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.truncatedNormal(weightsShape, this.mean, this.stdev);
    };
    return RandomTruncatedNormalInitializer;
}());
exports.RandomTruncatedNormalInitializer = RandomTruncatedNormalInitializer;
var RandomUniformInitializer = (function () {
    function RandomUniformInitializer(minval, maxval) {
        if (minval === void 0) { minval = -.05; }
        if (maxval === void 0) { maxval = .05; }
        this.minval = minval;
        this.maxval = maxval;
    }
    RandomUniformInitializer.prototype.initialize = function (weightsShape, inputUnits, outputUnits) {
        return ops.randomUniform(weightsShape, this.minval, this.maxval);
    };
    return RandomUniformInitializer;
}());
exports.RandomUniformInitializer = RandomUniformInitializer;

},{"../ops/ops":114}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
var add_1 = require("./ops/add");
var argmax_1 = require("./ops/argmax");
var argmaxequals_1 = require("./ops/argmaxequals");
var concat_1 = require("./ops/concat");
var convolution_1 = require("./ops/convolution");
var divide_1 = require("./ops/divide");
var element_wise_activation_1 = require("./ops/element_wise_activation");
var element_wise_cost_1 = require("./ops/element_wise_cost");
var exp_1 = require("./ops/exp");
var linear_combination_1 = require("./ops/linear_combination");
var log_1 = require("./ops/log");
var matmul_1 = require("./ops/matmul");
var max_pool_1 = require("./ops/max_pool");
var multiply_1 = require("./ops/multiply");
var reduce_sum_1 = require("./ops/reduce_sum");
var reshape_1 = require("./ops/reshape");
var softmax_1 = require("./ops/softmax");
var subtract_1 = require("./ops/subtract");
function emitFromGraphNodes(nodes) {
    var ops = [];
    nodes.forEach(function (node) { return Array.prototype.push.apply(ops, emitOpFromNode(node)); });
    return ops;
}
exports.emitFromGraphNodes = emitFromGraphNodes;
function emitOpFromNode(node) {
    if (node instanceof graph_1.ReshapeNode) {
        return [new reshape_1.Reshape(node.inputs[graph_1.ReshapeNode.X], node.output)];
    }
    else if (node instanceof graph_1.MatMulNode) {
        var x1 = node.inputs[graph_1.MatMulNode.X1];
        var x2 = node.inputs[graph_1.MatMulNode.X2];
        return [new matmul_1.MatMul(x1, x2, node.output)];
    }
    else if (node instanceof graph_1.Convolution2DNode) {
        var w = node.inputs[graph_1.Convolution2DNode.W];
        var x = node.inputs[graph_1.Convolution2DNode.X];
        var b = node.inputs[graph_1.Convolution2DNode.B];
        return [new convolution_1.Convolution2D(w, x, b, node.output, node.fieldSize, node.outputDepth, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.MaxPoolNode) {
        var x = node.inputs[graph_1.MaxPoolNode.X];
        return [new max_pool_1.MaxPool(x, node.output, node.fieldSize, node.stride, node.zeroPad)];
    }
    else if (node instanceof graph_1.ExpNode) {
        return [new exp_1.Exp(node.inputs[graph_1.ExpNode.X], node.output)];
    }
    else if (node instanceof graph_1.LogNode) {
        return [new log_1.Log(node.inputs[graph_1.LogNode.X], node.output)];
    }
    else if (node instanceof graph_1.ReLUNode) {
        return [new element_wise_activation_1.ReLU(node.inputs[graph_1.ReLUNode.X], node.output)];
    }
    else if (node instanceof graph_1.LeakyReLUNode) {
        return [new element_wise_activation_1.LeakyReLU(node.inputs[graph_1.LeakyReLUNode.X], node.output, node.alpha)];
    }
    else if (node instanceof graph_1.PReLUNode) {
        return [new element_wise_activation_1.PReLU(node.inputs[graph_1.PReLUNode.X], node.inputs[graph_1.PReLUNode.ALPHA], node.output)];
    }
    else if (node instanceof graph_1.EluNode) {
        return [new element_wise_activation_1.Elu(node.inputs[graph_1.EluNode.X], node.output)];
    }
    else if (node instanceof graph_1.TanHNode) {
        return [new element_wise_activation_1.TanH(node.inputs[graph_1.TanHNode.X], node.output)];
    }
    else if (node instanceof graph_1.SigmoidNode) {
        return [new element_wise_activation_1.Sigmoid(node.inputs[graph_1.SigmoidNode.X], node.output)];
    }
    else if (node instanceof graph_1.SoftmaxCrossEntropyCostNode) {
        var x = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.X];
        var target = node.inputs[graph_1.SoftmaxCrossEntropyCostNode.TARGET];
        return [new softmax_1.SoftmaxCrossEntropyCost(x, target, node.output)];
    }
    else if (node instanceof graph_1.SoftmaxNode) {
        return [new softmax_1.Softmax(node.inputs[graph_1.SoftmaxNode.X], node.output)];
    }
    else if (node instanceof graph_1.MeanSquaredCostNode) {
        var label = node.inputs[graph_1.MeanSquaredCostNode.LABEL];
        var prediction = node.inputs[graph_1.MeanSquaredCostNode.PREDICTION];
        return [new element_wise_cost_1.MeanSquaredCost(label, prediction, node.output)];
    }
    else if (node instanceof graph_1.ArgMaxEqualsNode) {
        return [new argmaxequals_1.ArgMaxEquals(node.inputs[graph_1.ArgMaxEqualsNode.X1], node.inputs[graph_1.ArgMaxEqualsNode.X2], node.output)];
    }
    else if (node instanceof graph_1.ArgMaxNode) {
        return [new argmax_1.ArgMax(node.x, node.output)];
    }
    else if (node instanceof graph_1.FusedLinearCombinationNode) {
        return [new linear_combination_1.LinearCombination(node.inputs[graph_1.FusedLinearCombinationNode.T1], node.inputs[graph_1.FusedLinearCombinationNode.T2], node.inputs[graph_1.FusedLinearCombinationNode.C1], node.inputs[graph_1.FusedLinearCombinationNode.C2], node.output)];
    }
    else if (node instanceof graph_1.Concat1DNode) {
        return [new concat_1.Concat1D(node.inputs[graph_1.Concat1DNode.X1], node.inputs[graph_1.Concat1DNode.X2], node.output)];
    }
    else if (node instanceof graph_1.Concat2DNode) {
        return [new concat_1.Concat2D(node.inputs[graph_1.Concat2DNode.X1], node.inputs[graph_1.Concat2DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.Concat3DNode) {
        return [new concat_1.Concat3D(node.inputs[graph_1.Concat3DNode.X1], node.inputs[graph_1.Concat3DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.Concat4DNode) {
        return [new concat_1.Concat4D(node.inputs[graph_1.Concat4DNode.X1], node.inputs[graph_1.Concat4DNode.X2], node.axis, node.output)];
    }
    else if (node instanceof graph_1.SquareNode) {
        return [new element_wise_activation_1.Square(node.inputs[graph_1.SquareNode.X], node.output)];
    }
    else if (node instanceof graph_1.AddNode) {
        return [new add_1.Add(node.inputs[graph_1.AddNode.T1], node.inputs[graph_1.AddNode.T2], node.output)];
    }
    else if (node instanceof graph_1.SubtractNode) {
        return [new subtract_1.Subtract(node.inputs[graph_1.SubtractNode.T1], node.inputs[graph_1.SubtractNode.T2], node.output)];
    }
    else if (node instanceof graph_1.MultiplyNode) {
        return [new multiply_1.Multiply(node.inputs[graph_1.MultiplyNode.T1], node.inputs[graph_1.MultiplyNode.T2], node.output)];
    }
    else if (node instanceof graph_1.DivideNode) {
        return [new divide_1.Divide(node.inputs[graph_1.DivideNode.T1], node.inputs[graph_1.DivideNode.T2], node.output)];
    }
    else if (node instanceof graph_1.ReduceSumNode) {
        return [new reduce_sum_1.ReduceSum(node.inputs[graph_1.ReduceSumNode.X], node.output)];
    }
    else if (graph_util.isInputNode(node)) {
        return [];
    }
    else {
        throw Error("Unsupported node type: " + node.constructor.name);
    }
}

},{"./graph":32,"./graph_util":34,"./ops/add":37,"./ops/argmax":38,"./ops/argmaxequals":39,"./ops/concat":40,"./ops/convolution":41,"./ops/divide":42,"./ops/element_wise_activation":43,"./ops/element_wise_cost":44,"./ops/exp":45,"./ops/linear_combination":46,"./ops/log":47,"./ops/matmul":48,"./ops/max_pool":49,"./ops/multiply":50,"./ops/reduce_sum":52,"./ops/reshape":53,"./ops/softmax":54,"./ops/subtract":55}],37:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Add = (function (_super) {
    __extends(Add, _super);
    function Add(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape) ||
            (x1Tensor.shape.length === 2 && x2Tensor.shape.length === 1 &&
                x1Tensor.shape[1] === x2Tensor.shape[0]) ||
            (x1Tensor.shape.length === 1 && x2Tensor.shape.length === 2 &&
                x1Tensor.shape[0] === x2Tensor.shape[1]), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape, ' +
            'or one of them can be broadcasted (2D and 1D).');
        return _this;
    }
    Add.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var result;
            if (util.isScalarShape(x1.shape)) {
                result = math.scalarPlusArray(x1, x2);
            }
            else if (util.isScalarShape(x2.shape)) {
                result = math.scalarPlusArray(x2, x1);
            }
            else {
                result = math.add(x1, x2);
            }
            inferenceArrays.set(_this.yTensor, globals_1.keep(result));
        });
    };
    Add.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (_this.x1Tensor.shape.length === 1 &&
                    _this.x2Tensor.shape.length === 2 &&
                    _this.x1Tensor.shape[0] === _this.x2Tensor.shape[1]) {
                    var sum = math.sum(dy, 0);
                    gradientArrays.add(_this.x1Tensor, sum);
                }
                else if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.x1Tensor, sum);
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (_this.x1Tensor.shape.length === 2 &&
                    _this.x2Tensor.shape.length === 1 &&
                    _this.x1Tensor.shape[1] === _this.x2Tensor.shape[0]) {
                    var sum = math.sum(dy, 0);
                    gradientArrays.add(_this.x2Tensor, sum);
                }
                else if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.x2Tensor, sum);
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.clone(dy));
                }
            }
        });
    };
    Add.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Add;
}(op_1.Operation));
exports.Add = Add;

},{"../../globals":28,"../../util":143,"../graph_util":34,"./op":51}],38:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var op_1 = require("./op");
var ArgMax = (function (_super) {
    __extends(ArgMax, _super);
    function ArgMax(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.argMax(x)));
        });
    };
    ArgMax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMax backprop unimplemented');
    };
    return ArgMax;
}(op_1.Operation));
exports.ArgMax = ArgMax;

},{"../../globals":28,"./op":51}],39:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var op_1 = require("./op");
var ArgMaxEquals = (function (_super) {
    __extends(ArgMaxEquals, _super);
    function ArgMaxEquals(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    ArgMaxEquals.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.argMaxEquals(x1, x2)));
        });
    };
    ArgMaxEquals.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('ArgMaxEquals backprop unimplemented');
    };
    return ArgMaxEquals;
}(op_1.Operation));
exports.ArgMaxEquals = ArgMaxEquals;

},{"../../globals":28,"./op":51}],40:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var concat_util = require("../../ops/concat_util");
var util = require("../../util");
var op_1 = require("./op");
var Concat1D = (function (_super) {
    __extends(Concat1D, _super);
    function Concat1D(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Concat1D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var concatResult = math.concat1D(x1, x2);
            inferecenArrays.set(_this.yTensor, globals_1.keep(concatResult));
        });
    };
    Concat1D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        globals_1.tidy(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, 0, gradientArrays, inferenceArrays);
        });
    };
    return Concat1D;
}(op_1.Operation));
exports.Concat1D = Concat1D;
var Concat2D = (function (_super) {
    __extends(Concat2D, _super);
    function Concat2D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat2D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var concatResult = math.concat2D(x1, x2, _this.axis);
            inferecenArrays.set(_this.yTensor, globals_1.keep(concatResult));
        });
    };
    Concat2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        globals_1.tidy(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat2D;
}(op_1.Operation));
exports.Concat2D = Concat2D;
var Concat3D = (function (_super) {
    __extends(Concat3D, _super);
    function Concat3D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat3D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var concatResult = math.concat3D(x1, x2, _this.axis);
            inferenceArrays.set(_this.yTensor, globals_1.keep(concatResult));
        });
    };
    Concat3D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        globals_1.tidy(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat3D;
}(op_1.Operation));
exports.Concat3D = Concat3D;
var Concat4D = (function (_super) {
    __extends(Concat4D, _super);
    function Concat4D(x1Tensor, x2Tensor, axis, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.axis = axis;
        _this.yTensor = yTensor;
        concat_util.assertParams(x1Tensor.shape, x2Tensor.shape, axis);
        return _this;
    }
    Concat4D.prototype.feedForward = function (math, inferecenArrays) {
        var _this = this;
        var x1 = inferecenArrays.get(this.x1Tensor);
        var x2 = inferecenArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var concatResult = math.concat4D(x1, x2, _this.axis);
            inferecenArrays.set(_this.yTensor, globals_1.keep(concatResult));
        });
    };
    Concat4D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        globals_1.tidy(function () {
            concatBackProp(math, _this.x1Tensor, _this.x2Tensor, _this.yTensor, _this.axis, gradientArrays, inferenceArrays);
        });
    };
    return Concat4D;
}(op_1.Operation));
exports.Concat4D = Concat4D;
function concatBackProp(math, aTensor, bTensor, yTensor, axis, gradArrays, infArrays) {
    var dy = gradArrays.get(yTensor);
    var a = infArrays.get(aTensor);
    var b = infArrays.get(bTensor);
    var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
    var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
    var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
    var dy2D = dy.as2D(-1, a2D.shape[1] + b2D.shape[1]);
    var slice1Result = math.slice2D(dy2D, aBegin, aSize).reshapeAs(a);
    var slice2Result = math.slice2D(dy2D, bBegin, bSize).reshapeAs(b);
    gradArrays.add(aTensor, slice1Result);
    gradArrays.add(bTensor, slice2Result);
}

},{"../../globals":28,"../../ops/concat_util":104,"../../util":143,"./op":51}],41:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var conv_util = require("../../ops/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var Convolution2D = (function (_super) {
    __extends(Convolution2D, _super);
    function Convolution2D(wTensor, xTensor, bTensor, yTensor, fieldSize, outputDepth, stride, zeroPad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.wTensor = wTensor;
        _this.xTensor = xTensor;
        _this.bTensor = bTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.outputDepth = outputDepth;
        _this.stride = stride;
        _this.assertWeightsShape(wTensor.shape);
        _this.zeroPad = zeroPad != null ?
            zeroPad :
            conv_util.computeDefaultPad(_this.xTensor.shape, _this.fieldSize, _this.stride);
        util.assert(util.isInt(_this.zeroPad), "The zero padding (" + _this.zeroPad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    Convolution2D.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var weights = inferenceArrays.get(this.wTensor);
        var biases = inferenceArrays.get(this.bTensor);
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.conv2d(x, weights, biases, _this.stride, _this.zeroPad)));
        });
    };
    Convolution2D.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var filter = inferenceArrays.get(this.wTensor);
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            var dw = math.conv2dDerFilter(x, dy, filter.shape, _this.stride, _this.zeroPad);
            var db = math.sum(dy, [0, 1]);
            var dx = math.conv2dDerInput(x.shape, dy, filter, _this.stride, _this.zeroPad);
            gradientArrays.add(_this.wTensor, dw);
            gradientArrays.add(_this.bTensor, db);
            gradientArrays.add(_this.xTensor, dx);
        });
    };
    Convolution2D.prototype.assertWeightsShape = function (weightsShape) {
        util.assert(weightsShape[0] === this.fieldSize &&
            weightsShape[1] === this.fieldSize &&
            weightsShape[2] === this.xTensor.shape[2] &&
            weightsShape[3] === this.outputDepth, "weights must be of shape [" + this.fieldSize + "," + this.fieldSize + "," +
            (this.xTensor.shape[2] + "," + this.outputDepth + "] but they are of") +
            ("shape [" + weightsShape + "]"));
    };
    return Convolution2D;
}(op_1.Operation));
exports.Convolution2D = Convolution2D;

},{"../../globals":28,"../../ops/conv_util":106,"../../util":143,"./op":51}],42:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Divide = (function (_super) {
    __extends(Divide, _super);
    function Divide(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Divide.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarDividedByArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayDividedByScalar(t1, t2);
            }
            else {
                result = math.divide(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, globals_1.keep(result));
        });
    };
    Divide.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        var x1IsScalar = util.isScalarShape(x1.shape);
        var x2IsScalar = util.isScalarShape(x2.shape);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (x1IsScalar) {
                    var div = math.divide(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(div));
                    div.dispose();
                }
                else if (x2IsScalar) {
                    gradientArrays.add(_this.x1Tensor, math.arrayDividedByScalar(dy, x2));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.divide(dy, x2));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var x2Squared = math.elementWiseMul(x2, x2);
                var x1OverX2Squared = void 0;
                if (x2IsScalar) {
                    x1OverX2Squared = math.arrayDividedByScalar(x1, x2Squared);
                }
                else if (x1IsScalar) {
                    x1OverX2Squared = math.scalarDividedByArray(x1, x2Squared);
                }
                else {
                    x1OverX2Squared = math.divide(x1, x2Squared);
                }
                var dx2 = math.neg(x1OverX2Squared);
                var dyTimesDerivative = math.elementWiseMul(dy, dx2);
                if (x2IsScalar) {
                    gradientArrays.add(_this.x2Tensor, math.sum(dyTimesDerivative));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, dyTimesDerivative);
                }
            }
        });
    };
    return Divide;
}(op_1.Operation));
exports.Divide = Divide;

},{"../../globals":28,"../../util":143,"../graph_util":34,"./op":51}],43:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var activation_functions_1 = require("../activation_functions");
var op_1 = require("./op");
var ElementWiseActivation = (function (_super) {
    __extends(ElementWiseActivation, _super);
    function ElementWiseActivation(xTensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.func = func;
        return _this;
    }
    ElementWiseActivation.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(_this.func.output(math, x)));
        });
    };
    ElementWiseActivation.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            var dydx = _this.func.der(math, x, y);
            gradientArrays.add(_this.xTensor, math.elementWiseMul(dy, dydx));
            dydx.dispose();
        });
    };
    ElementWiseActivation.prototype.dispose = function () {
        this.func.dispose();
    };
    return ElementWiseActivation;
}(op_1.Operation));
exports.ElementWiseActivation = ElementWiseActivation;
var ReLU = (function (_super) {
    __extends(ReLU, _super);
    function ReLU(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.ReLUFunc()) || this;
    }
    return ReLU;
}(ElementWiseActivation));
exports.ReLU = ReLU;
var LeakyReLU = (function (_super) {
    __extends(LeakyReLU, _super);
    function LeakyReLU(xTensor, yTensor, alpha) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.LeakyReluFunc(alpha)) || this;
    }
    return LeakyReLU;
}(ElementWiseActivation));
exports.LeakyReLU = LeakyReLU;
var TanH = (function (_super) {
    __extends(TanH, _super);
    function TanH(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.TanHFunc()) || this;
    }
    return TanH;
}(ElementWiseActivation));
exports.TanH = TanH;
var Sigmoid = (function (_super) {
    __extends(Sigmoid, _super);
    function Sigmoid(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SigmoidFunc()) || this;
    }
    return Sigmoid;
}(ElementWiseActivation));
exports.Sigmoid = Sigmoid;
var Square = (function (_super) {
    __extends(Square, _super);
    function Square(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.SquareFunc()) || this;
    }
    return Square;
}(ElementWiseActivation));
exports.Square = Square;
var Elu = (function (_super) {
    __extends(Elu, _super);
    function Elu(xTensor, yTensor) {
        return _super.call(this, xTensor, yTensor, new activation_functions_1.EluFunc()) || this;
    }
    return Elu;
}(ElementWiseActivation));
exports.Elu = Elu;
var PReLU = (function (_super) {
    __extends(PReLU, _super);
    function PReLU(xTensor, alphaTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.alphaTensor = alphaTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    PReLU.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var alpha = inferenceArrays.get(this.alphaTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.prelu(x, alpha)));
        });
    };
    PReLU.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        throw new Error('Not implemented');
    };
    return PReLU;
}(op_1.Operation));
exports.PReLU = PReLU;

},{"../../globals":28,"../activation_functions":30,"./op":51}],44:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var globals_1 = require("../../globals");
var tensor_1 = require("../../tensor");
var util = require("../../util");
var cost_functions_1 = require("../cost_functions");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ElementWiseCost = (function (_super) {
    __extends(ElementWiseCost, _super);
    function ElementWiseCost(x1Tensor, x2Tensor, yTensor, func) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        _this.func = func;
        _this.oneOverNScalar =
            environment_1.ENV.math.keep(tensor_1.Scalar.new(1 / util.sizeFromShape(x1Tensor.shape)));
        return _this;
    }
    ElementWiseCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var elementWiseCost = _this.func.cost(x1, x2);
            var sum = math.sum(elementWiseCost);
            var result = math.scalarTimesArray(_this.oneOverNScalar, sum);
            inferenceArrays.set(_this.yTensor, globals_1.keep(result));
        });
    };
    ElementWiseCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, _this.func.der(x1, x2));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, _this.func.der(x2, x1));
            }
        });
    };
    ElementWiseCost.prototype.dispose = function () {
        this.func.dispose();
        this.oneOverNScalar.dispose();
    };
    return ElementWiseCost;
}(op_1.Operation));
exports.ElementWiseCost = ElementWiseCost;
var MeanSquaredCost = (function (_super) {
    __extends(MeanSquaredCost, _super);
    function MeanSquaredCost(x1Tensor, x2Tensor, yTensor) {
        return _super.call(this, x1Tensor, x2Tensor, yTensor, new cost_functions_1.SquareCostFunc()) || this;
    }
    return MeanSquaredCost;
}(ElementWiseCost));
exports.MeanSquaredCost = MeanSquaredCost;

},{"../../environment":27,"../../globals":28,"../../tensor":137,"../../util":143,"../cost_functions":31,"../graph_util":34,"./op":51}],45:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Exp = (function (_super) {
    __extends(Exp, _super);
    function Exp(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Exp.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.exp(x)));
        });
    };
    Exp.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.yTensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.elementWiseMul(y, dy));
            }
        });
    };
    return Exp;
}(op_1.Operation));
exports.Exp = Exp;

},{"../../globals":28,"../graph_util":34,"./op":51}],46:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var LinearCombination = (function (_super) {
    __extends(LinearCombination, _super);
    function LinearCombination(x1Tensor, x2Tensor, c1Tensor, c2Tensor, outTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.c1Tensor = c1Tensor;
        _this.c2Tensor = c2Tensor;
        _this.outTensor = outTensor;
        return _this;
    }
    LinearCombination.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor).asScalar();
        var c2 = inferenceArrays.get(this.c2Tensor).asScalar();
        globals_1.tidy(function () {
            inferenceArrays.set(_this.outTensor, globals_1.keep(math.scaledArrayAdd(c1, x1, c2, x2)));
        });
    };
    LinearCombination.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var c1 = inferenceArrays.get(this.c1Tensor);
        var c2 = inferenceArrays.get(this.c2Tensor);
        var dy = gradientArrays.get(this.outTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(c1, dy));
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(c2, dy));
            }
            if (graph_util.shouldBackProp(_this.c1Tensor)) {
                var dotProduct1 = math.elementWiseMul(x1, dy);
                gradientArrays.add(_this.c1Tensor, math.sum(dotProduct1));
            }
            if (graph_util.shouldBackProp(_this.c2Tensor)) {
                var dotProduct2 = math.elementWiseMul(x2, dy);
                gradientArrays.add(_this.c2Tensor, math.sum(dotProduct2));
            }
        });
    };
    return LinearCombination;
}(op_1.Operation));
exports.LinearCombination = LinearCombination;

},{"../../globals":28,"../graph_util":34,"./op":51}],47:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Log = (function (_super) {
    __extends(Log, _super);
    function Log(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        return _this;
    }
    Log.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.log(x)));
        });
    };
    Log.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.xTensor)) {
                gradientArrays.add(_this.xTensor, math.divide(dy, x));
            }
        });
    };
    return Log;
}(op_1.Operation));
exports.Log = Log;

},{"../../globals":28,"../graph_util":34,"./op":51}],48:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var MatMul = (function (_super) {
    __extends(MatMul, _super);
    function MatMul(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        return _this;
    }
    MatMul.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            if (x1.shape.length === 2 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, globals_1.keep(math.matMul(x1, x2)));
            }
            else if (x1.shape.length === 2 && x2.shape.length === 1) {
                inferenceArrays.set(_this.yTensor, globals_1.keep(math.matrixTimesVector(x1, x2)));
            }
            else if (x1.shape.length === 1 && x2.shape.length === 2) {
                inferenceArrays.set(_this.yTensor, globals_1.keep(math.vectorTimesMatrix(x1, x2)));
            }
        });
    };
    MatMul.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        if (x1.shape.length === 1) {
            x1 = x1.reshape([1, x1.size]);
            dy = dy.reshape([1, dy.size]);
        }
        if (x2.shape.length === 1) {
            x2 = x2.reshape([x2.size, 1]);
            dy = dy.reshape([dy.size, 1]);
        }
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                var dx1 = math.matMul(dy, x2, false, true);
                gradientArrays.add(_this.x1Tensor, _this.x1Tensor.shape.length === 1 ? dx1.as1D() : dx1);
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                var dx2 = math.matMul(x1, dy, true, false);
                gradientArrays.add(_this.x2Tensor, _this.x2Tensor.shape.length === 1 ? dx2.as1D() : dx2);
            }
        });
    };
    return MatMul;
}(op_1.Operation));
exports.MatMul = MatMul;

},{"../../globals":28,"../graph_util":34,"./op":51}],49:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var conv_util = require("../../ops/conv_util");
var util = require("../../util");
var op_1 = require("./op");
var MaxPool = (function (_super) {
    __extends(MaxPool, _super);
    function MaxPool(xTensor, yTensor, fieldSize, stride, pad) {
        if (stride === void 0) { stride = 1; }
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        _this.fieldSize = fieldSize;
        _this.stride = stride;
        if (pad != null) {
            _this.pad = pad;
        }
        else {
            _this.pad = conv_util.computeDefaultPad(xTensor.shape, _this.fieldSize, _this.stride);
        }
        util.assert(util.isInt(_this.pad), "The zero padding (" + _this.pad + ") must be an integer. Change the " +
            "stride and/or zero pad parameters");
        return _this;
    }
    MaxPool.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(math.maxPool(x, _this.fieldSize, _this.stride, _this.pad)));
        });
    };
    MaxPool.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            gradientArrays.add(_this.xTensor, math.maxPoolBackprop(dy, x, _this.fieldSize, _this.stride, _this.pad));
        });
    };
    return MaxPool;
}(op_1.Operation));
exports.MaxPool = MaxPool;

},{"../../globals":28,"../../ops/conv_util":106,"../../util":143,"./op":51}],50:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Multiply = (function (_super) {
    __extends(Multiply, _super);
    function Multiply(x1Tensor, x2Tensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.x1Tensor = x1Tensor;
        _this.x2Tensor = x2Tensor;
        _this.yTensor = yTensor;
        util.assert(util.sizeFromShape(x1Tensor.shape) === 1 ||
            util.sizeFromShape(x2Tensor.shape) === 1 ||
            util.arraysEqual(x1Tensor.shape, x2Tensor.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Multiply.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.x1Tensor);
        var t2 = inferenceArrays.get(this.x2Tensor);
        globals_1.tidy(function () {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarTimesArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.scalarTimesArray(t2, t1);
            }
            else {
                result = math.elementWiseMul(t1, t2);
            }
            inferenceArrays.set(_this.yTensor, globals_1.keep(result));
        });
    };
    Multiply.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var x1 = inferenceArrays.get(this.x1Tensor);
        var x2 = inferenceArrays.get(this.x2Tensor);
        var dy = gradientArrays.get(this.yTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.x1Tensor)) {
                if (util.isScalarShape(_this.x1Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x2);
                    gradientArrays.add(_this.x1Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x2.shape)) {
                    gradientArrays.add(_this.x1Tensor, math.scalarTimesArray(x2, dy));
                }
                else {
                    gradientArrays.add(_this.x1Tensor, math.elementWiseMul(x2, dy));
                }
            }
            if (graph_util.shouldBackProp(_this.x2Tensor)) {
                if (util.isScalarShape(_this.x2Tensor.shape)) {
                    var mul = math.elementWiseMul(dy, x1);
                    gradientArrays.add(_this.x2Tensor, math.sum(mul));
                }
                else if (util.isScalarShape(x1.shape)) {
                    gradientArrays.add(_this.x2Tensor, math.scalarTimesArray(x1, dy));
                }
                else {
                    gradientArrays.add(_this.x2Tensor, math.elementWiseMul(x1, dy));
                }
            }
        });
    };
    return Multiply;
}(op_1.Operation));
exports.Multiply = Multiply;

},{"../../globals":28,"../../util":143,"../graph_util":34,"./op":51}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Operation = (function () {
    function Operation() {
    }
    Operation.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) { };
    Operation.prototype.dispose = function () { };
    return Operation;
}());
exports.Operation = Operation;

},{}],52:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var globals_1 = require("../../globals");
var tensor_1 = require("../../tensor");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var ReduceSum = (function (_super) {
    __extends(ReduceSum, _super);
    function ReduceSum(x, outTensor) {
        var _this = _super.call(this) || this;
        _this.x = x;
        _this.outTensor = outTensor;
        util.assertShapesMatch(outTensor.shape, []);
        _this.ones = environment_1.ENV.math.keep(tensor_1.Tensor.ones(x.shape));
        return _this;
    }
    ReduceSum.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.x);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.outTensor, globals_1.keep(math.sum(x)));
        });
    };
    ReduceSum.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        if (!graph_util.shouldBackProp(this.x)) {
            return;
        }
        globals_1.tidy(function () {
            var dy = gradientArrays.get(_this.outTensor);
            gradientArrays.add(_this.x, math.scalarTimesArray(dy, _this.ones));
        });
    };
    ReduceSum.prototype.dispose = function () {
        this.ones.dispose();
    };
    return ReduceSum;
}(op_1.Operation));
exports.ReduceSum = ReduceSum;

},{"../../environment":27,"../../globals":28,"../../tensor":137,"../../util":143,"../graph_util":34,"./op":51}],53:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var util = require("../../util");
var op_1 = require("./op");
var Reshape = (function (_super) {
    __extends(Reshape, _super);
    function Reshape(xTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.xTensor = xTensor;
        _this.yTensor = yTensor;
        var xSize = util.sizeFromShape(xTensor.shape);
        var ySize = util.sizeFromShape(yTensor.shape);
        util.assert(xSize === ySize, "The input size (" + xSize + ") and output size (" + ySize + ") must match");
        return _this;
    }
    Reshape.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var x = inferenceArrays.get(this.xTensor);
        var clone = math.clone(x);
        globals_1.tidy(function () {
            inferenceArrays.set(_this.yTensor, globals_1.keep(clone.reshape(_this.yTensor.shape)));
        });
    };
    Reshape.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.yTensor);
        var clone = math.clone(dy);
        globals_1.tidy(function () {
            gradientArrays.add(_this.xTensor, clone.reshape(_this.xTensor.shape));
        });
    };
    return Reshape;
}(op_1.Operation));
exports.Reshape = Reshape;

},{"../../globals":28,"../../util":143,"./op":51}],54:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var globals_1 = require("../../globals");
var tensor_1 = require("../../tensor");
var util = require("../../util");
var graph_1 = require("../graph");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Softmax = (function (_super) {
    __extends(Softmax, _super);
    function Softmax(logitsTensor, output) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.output = output;
        return _this;
    }
    Softmax.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        return globals_1.tidy(function () {
            inferenceArrays.set(_this.output, globals_1.keep(math.softmax(logits)));
        });
    };
    Softmax.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var y = inferenceArrays.get(this.output);
        var dy = gradientArrays.get(this.output);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.logitsTensor)) {
                var dlogits = math.elementWiseMul(math.subtract(dy, math.sum(math.elementWiseMul(dy, y))), y);
                gradientArrays.add(_this.logitsTensor, dlogits);
            }
        });
    };
    return Softmax;
}(op_1.Operation));
exports.Softmax = Softmax;
var SoftmaxCrossEntropyCost = (function (_super) {
    __extends(SoftmaxCrossEntropyCost, _super);
    function SoftmaxCrossEntropyCost(logitsTensor, labelTensor, yTensor) {
        var _this = _super.call(this) || this;
        _this.logitsTensor = logitsTensor;
        _this.labelTensor = labelTensor;
        _this.yTensor = yTensor;
        _this.softmaxTensor = new graph_1.SymbolicTensor(logitsTensor.shape);
        _this.epsilon = environment_1.ENV.math.keep(tensor_1.Scalar.new(1e-5));
        return _this;
    }
    SoftmaxCrossEntropyCost.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var logits = inferenceArrays.get(this.logitsTensor);
        var label = inferenceArrays.get(this.labelTensor);
        globals_1.tidy(function () {
            var softmaxResult = math.softmax(logits);
            inferenceArrays.set(_this.softmaxTensor, globals_1.keep(softmaxResult));
            inferenceArrays.set(_this.yTensor, globals_1.keep(crossEntropyCost(math, softmaxResult, label, _this.epsilon)));
        });
    };
    SoftmaxCrossEntropyCost.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var softmax = inferenceArrays.get(this.softmaxTensor);
        var label = inferenceArrays.get(this.labelTensor);
        globals_1.tidy(function () {
            gradientArrays.add(_this.logitsTensor, math.subtract(softmax, label));
        });
    };
    SoftmaxCrossEntropyCost.prototype.disposeTransientArrays = function (inferenceArrays, gradientArrays) {
        inferenceArrays.disposeArray(this.softmaxTensor);
    };
    SoftmaxCrossEntropyCost.prototype.dispose = function () {
        this.epsilon.dispose();
    };
    return SoftmaxCrossEntropyCost;
}(op_1.Operation));
exports.SoftmaxCrossEntropyCost = SoftmaxCrossEntropyCost;
function crossEntropyCost(math, y, target, epsilon) {
    util.assert(y.size === target.size, 'The output and target must be the same size');
    return globals_1.tidy(function () {
        var yPlusEps = math.scalarPlusArray(epsilon, y);
        var logOutput = math.log(yPlusEps);
        var tarLogOutput = math.elementWiseMul(target, logOutput);
        var costVector = math.neg(tarLogOutput);
        return math.sum(costVector);
    });
}
exports.crossEntropyCost = crossEntropyCost;

},{"../../environment":27,"../../globals":28,"../../tensor":137,"../../util":143,"../graph":32,"../graph_util":34,"./op":51}],55:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../../globals");
var util = require("../../util");
var graph_util = require("../graph_util");
var op_1 = require("./op");
var Subtract = (function (_super) {
    __extends(Subtract, _super);
    function Subtract(t1, t2, outTensor) {
        var _this = _super.call(this) || this;
        _this.t1 = t1;
        _this.t2 = t2;
        _this.outTensor = outTensor;
        util.assert(util.sizeFromShape(t1.shape) === 1 ||
            util.sizeFromShape(t2.shape) === 1 ||
            util.arraysEqual(t1.shape, t2.shape), 'One of t1 or t2 must be a scalar, or t1 and t2 must have ' +
            'the same shape');
        return _this;
    }
    Subtract.prototype.feedForward = function (math, inferenceArrays) {
        var _this = this;
        var t1 = inferenceArrays.get(this.t1);
        var t2 = inferenceArrays.get(this.t2);
        globals_1.tidy(function () {
            var result;
            if (util.isScalarShape(t1.shape)) {
                result = math.scalarMinusArray(t1, t2);
            }
            else if (util.isScalarShape(t2.shape)) {
                result = math.arrayMinusScalar(t1, t2);
            }
            else {
                result = math.subtract(t1, t2);
            }
            inferenceArrays.set(_this.outTensor, globals_1.keep(result));
        });
    };
    Subtract.prototype.backProp = function (math, inferenceArrays, gradientArrays) {
        var _this = this;
        var dy = gradientArrays.get(this.outTensor);
        globals_1.tidy(function () {
            if (graph_util.shouldBackProp(_this.t1)) {
                if (util.isScalarShape(_this.t1.shape)) {
                    var sum = math.sum(dy);
                    gradientArrays.add(_this.t1, sum);
                }
                else {
                    gradientArrays.add(_this.t1, math.clone(dy));
                }
            }
            if (graph_util.shouldBackProp(_this.t2)) {
                if (util.isScalarShape(_this.t2.shape)) {
                    var sum = math.sum(dy);
                    var negSum = math.neg(sum);
                    gradientArrays.add(_this.t2, negSum);
                }
                else {
                    gradientArrays.add(_this.t2, math.neg(dy));
                }
            }
        });
    };
    Subtract.prototype.dispose = function () {
        if (this.dySizeScalar != null) {
            this.dySizeScalar.dispose();
        }
    };
    return Subtract;
}(op_1.Operation));
exports.Subtract = Subtract;

},{"../../globals":28,"../../util":143,"../graph_util":34,"./op":51}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function defaultCompare(a, b) {
    if (a === b) {
        return 0;
    }
    else if (a < b) {
        return -1;
    }
    else {
        return 1;
    }
}
exports.defaultCompare = defaultCompare;
var PriorityQueue = (function () {
    function PriorityQueue(comparator, indexObserver) {
        this.comparator = comparator;
        this.indexObserver = indexObserver;
        this.heap = [];
    }
    PriorityQueue.prototype.enqueue = function (t) {
        this.heap.push(t);
        this.onIndexChanged(t, this.heap.length - 1);
        this.siftUp(this.heap.length - 1);
    };
    PriorityQueue.prototype.dequeue = function () {
        if (this.empty()) {
            throw new Error('dequeue called on empty priority queue.');
        }
        var t = this.heap[0];
        this.swap(0, this.heap.length - 1);
        this.heap.pop();
        this.siftDown(0);
        return t;
    };
    PriorityQueue.prototype.update = function (newT, index) {
        var last = (index === this.heap.length - 1);
        if (!last) {
            this.swap(index, this.heap.length - 1);
        }
        this.heap.pop();
        if (!last) {
            if (this.siftUpIndex(index) !== -1) {
                this.siftUp(index);
            }
            else if (this.siftDownIndex(index) !== -1) {
                this.siftDown(index);
            }
        }
        this.enqueue(newT);
    };
    PriorityQueue.prototype.empty = function () {
        return this.heap.length === 0;
    };
    PriorityQueue.prototype.onIndexChanged = function (t, newIndex) {
        if (this.indexObserver) {
            this.indexObserver(t, newIndex);
        }
    };
    PriorityQueue.prototype.getParentIndex = function (index) {
        if (index === 0) {
            return -1;
        }
        return Math.floor((index - 1) / 2);
    };
    PriorityQueue.prototype.getLeftChildIndex = function (index) {
        var candidate = index * 2 + 1;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.getRightChildIndex = function (index) {
        var candidate = index * 2 + 2;
        return candidate < this.heap.length ? candidate : -1;
    };
    PriorityQueue.prototype.siftUpIndex = function (index) {
        var parentIndex = this.getParentIndex(index);
        if (parentIndex === -1) {
            return -1;
        }
        if (this.compare(parentIndex, index) > 0) {
            return parentIndex;
        }
        return -1;
    };
    PriorityQueue.prototype.siftUp = function (index) {
        var siftIndex = this.siftUpIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftUpIndex(index);
        }
    };
    PriorityQueue.prototype.siftDownIndex = function (index) {
        if (index >= this.heap.length) {
            return -1;
        }
        var largestChildIndex = index;
        var leftChildIndex = this.getLeftChildIndex(index);
        if ((leftChildIndex !== -1) &&
            (this.compare(leftChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = leftChildIndex;
        }
        var rightChildIndex = this.getRightChildIndex(index);
        if ((rightChildIndex !== -1) &&
            (this.compare(rightChildIndex, largestChildIndex) < 0)) {
            largestChildIndex = rightChildIndex;
        }
        return (largestChildIndex === index) ? -1 : largestChildIndex;
    };
    PriorityQueue.prototype.siftDown = function (index) {
        var siftIndex = this.siftDownIndex(index);
        while (siftIndex !== -1) {
            this.swap(index, siftIndex);
            index = siftIndex;
            siftIndex = this.siftDownIndex(index);
        }
    };
    PriorityQueue.prototype.compare = function (aIndex, bIndex) {
        return this.comparator(this.heap[aIndex], this.heap[bIndex]);
    };
    PriorityQueue.prototype.swap = function (a, b) {
        var temp = this.heap[a];
        this.heap[a] = this.heap[b];
        this.heap[b] = temp;
        this.onIndexChanged(this.heap[a], a);
        this.onIndexChanged(this.heap[b], b);
    };
    return PriorityQueue;
}());
exports.PriorityQueue = PriorityQueue;

},{}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
var tensor_1 = require("../tensor");
var util = require("../util");
var operation_emitter = require("./operation_emitter");
var session_util = require("./session_util");
var tensor_array_map_1 = require("./tensor_array_map");
var FeedDictionary = (function () {
    function FeedDictionary(feedEntries) {
        var _this = this;
        this.dict = {};
        if (feedEntries) {
            feedEntries.forEach(function (entry) { return _this.dict[entry.tensor.id] = entry; });
        }
    }
    return FeedDictionary;
}());
exports.FeedDictionary = FeedDictionary;
var CostReduction;
(function (CostReduction) {
    CostReduction[CostReduction["NONE"] = 0] = "NONE";
    CostReduction[CostReduction["SUM"] = 1] = "SUM";
    CostReduction[CostReduction["MEAN"] = 2] = "MEAN";
})(CostReduction = exports.CostReduction || (exports.CostReduction = {}));
var Session = (function () {
    function Session(graph, math) {
        this.math = math;
        this.activationArrayMap = new tensor_array_map_1.TensorArrayMap();
        this.runtimeCache = {};
        this.oneScalar = tensor_1.Scalar.new(1);
        this.gradientArrayMap = new tensor_array_map_1.SummedTensorArrayMap(this.math);
    }
    Session.prototype.dispose = function () {
        var _this = this;
        this.activationArrayMap.dispose();
        Object.keys(this.runtimeCache).forEach(function (key) {
            var runtime = _this.runtimeCache[key];
            if (runtime.operations) {
                runtime.operations.forEach(function (op) { return op.dispose(); });
            }
        });
        this.runtimeCache = {};
        if (this.batchSizeScalar != null) {
            this.batchSizeScalar.dispose();
        }
        this.oneScalar.dispose();
    };
    Session.prototype.evalAll = function (tensors, feedEntries) {
        var _this = this;
        return globals_1.tidy(function () {
            var feed = new FeedDictionary(feedEntries);
            var runtime = _this.getOrCreateRuntime(tensors, feed);
            var activations = _this.activationArrayMap;
            session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
            session_util.disposeTransientOperationArrays(runtime.operations, _this.activationArrayMap, _this.gradientArrayMap);
            session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
            session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
            runtime.operations.forEach(function (op) { return op.feedForward(_this.math, activations); });
            var results = tensors.map(function (x) { return activations.get(x); });
            tensors.forEach(function (x) { return activations.delete(x); });
            session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
            return results;
        });
    };
    Session.prototype.eval = function (tensor, feedEntries) {
        return this.evalAll([tensor], feedEntries)[0];
    };
    Session.prototype.train = function (costTensor, feedEntries, batchSize, optimizer, costReduction) {
        var _this = this;
        if (costReduction === void 0) { costReduction = CostReduction.NONE; }
        util.assert(util.isScalarShape(costTensor.shape), 'Cost tensor for training must be a scalar value.');
        if (this.prevBatchSize !== batchSize) {
            this.prevBatchSize = batchSize;
            if (this.batchSizeScalar != null) {
                this.batchSizeScalar.dispose();
            }
            this.batchSizeScalar = this.math.keep(tensor_1.Scalar.new(batchSize));
        }
        var feed = new FeedDictionary(feedEntries);
        session_util.throwIfFeedDictionaryContainsNDArrays(feed);
        var runtime = this.getOrCreateRuntime([costTensor], feed);
        var inferenceOperations = runtime.operations;
        var backPropOperations = runtime.operations.slice().reverse();
        var activations = this.activationArrayMap;
        var gradients = this.gradientArrayMap;
        gradients.nullify(costTensor);
        gradients.add(costTensor, this.oneScalar);
        session_util.addPersistentArraysToTensorArrayMap(runtime.nodes, activations);
        optimizer.beforeBatch(this.math, batchSize, runtime, activations, gradients);
        return globals_1.tidy(function () {
            var cost = tensor_1.Scalar.new(0);
            for (var i = 0; i < batchSize; ++i) {
                session_util.disposeAndInitializeOperationOutputs(runtime.nodes, activations);
                session_util.disposeAndInitializeOperationInputGradients(runtime.nodes, gradients);
                session_util.disposeTransientOperationArrays(runtime.operations, activations, gradients);
                session_util.loadInputsFromFeedDictionaryToTensorArrayMap(feed, activations, _this.math);
                inferenceOperations.forEach(function (op) { return op.feedForward(_this.math, activations); });
                backPropOperations.forEach(function (op) { return op.backProp(_this.math, activations, gradients); });
                optimizer.afterExample(_this.math, runtime, activations, gradients);
                session_util.releaseFeedDictionaryInputsFromTensorArrayMap(feed, activations, _this.math);
                cost = _this.updateCostForExample(cost, activations.get(costTensor), costReduction);
            }
            optimizer.afterBatch(_this.math, batchSize, runtime, activations, gradients);
            return _this.updateCostForBatch(cost, costReduction);
        });
    };
    Session.prototype.updateCostForExample = function (totalCost, currCost, costReduction) {
        if (costReduction === CostReduction.MEAN ||
            costReduction === CostReduction.SUM) {
            return this.math.add(totalCost, currCost);
        }
        return totalCost;
    };
    Session.prototype.updateCostForBatch = function (totalCost, costReduction) {
        if (costReduction === CostReduction.MEAN) {
            return this.math.divide(totalCost, this.batchSizeScalar);
        }
        return totalCost;
    };
    Session.prototype.getOrCreateRuntime = function (tensors, feed) {
        var key = this.makeRuntimeCacheKey(tensors, feed);
        var runtime = this.runtimeCache[key];
        if (runtime === undefined) {
            var nodes = session_util.getOrderedEvaluationSetFromEvalTensor(tensors, feed);
            session_util.removeFeedDictionaryNodesFromEvaluationSet(feed, nodes);
            session_util.throwErrorIfEvaluationSetContainsPlaceholderNodes(nodes);
            var operations = operation_emitter.emitFromGraphNodes(nodes);
            runtime = { nodes: nodes, operations: operations };
            this.runtimeCache[key] = runtime;
        }
        return runtime;
    };
    Session.prototype.makeRuntimeCacheKey = function (tensors, feed) {
        return tensors.map(function (x) { return x.id; }).sort().join('_') + '__' +
            Object.keys(feed.dict).sort().join('_');
    };
    return Session;
}());
exports.Session = Session;

},{"../globals":28,"../tensor":137,"../util":143,"./operation_emitter":36,"./session_util":58,"./tensor_array_map":59}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("../tensor");
var util = require("../util");
var graph_1 = require("./graph");
var graph_util = require("./graph_util");
function getTerminatingNodesFromFeedDictionary(feedDictionary) {
    return Object.keys(feedDictionary.dict)
        .map(function (tensorID) { return feedDictionary.dict[+tensorID].tensor.node; });
}
exports.getTerminatingNodesFromFeedDictionary = getTerminatingNodesFromFeedDictionary;
function getOrderedEvaluationSetFromEvalTensor(evalTensors, feedDictionary) {
    var terminatingNodes = getTerminatingNodesFromFeedDictionary(feedDictionary);
    var evalNodes = evalTensors.map(function (x) { return x.node; });
    var unorderedEvaluationSet = graph_util.getUnorderedEvaluationSet(evalNodes, terminatingNodes);
    var orderedEvaluationSet = graph_util.getOrderedEvaluationSet(unorderedEvaluationSet);
    return orderedEvaluationSet;
}
exports.getOrderedEvaluationSetFromEvalTensor = getOrderedEvaluationSetFromEvalTensor;
function addPersistentArraysToTensorArrayMap(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode || node instanceof graph_1.ConstantNode) {
            tensorArrayMap.set(node.output, node.data);
        }
    });
}
exports.addPersistentArraysToTensorArrayMap = addPersistentArraysToTensorArrayMap;
function getVariableNodesFromEvaluationSet(evaluationSet) {
    var nodes = [];
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.VariableNode) {
            nodes.push(node);
        }
    });
    return nodes;
}
exports.getVariableNodesFromEvaluationSet = getVariableNodesFromEvaluationSet;
function throwIfFeedDictionaryContainsNDArrays(feedDictionary) {
    Object.keys(feedDictionary.dict).forEach(function (tensorID) {
        if (feedDictionary.dict[+tensorID].data instanceof tensor_1.Tensor) {
            throw new Error('training requires FeedDictionary entries to be InputProviders' +
                'and not NDArrays.');
        }
    });
}
exports.throwIfFeedDictionaryContainsNDArrays = throwIfFeedDictionaryContainsNDArrays;
function loadInputsFromFeedDictionaryToTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        var data;
        if (feedEntry.data instanceof tensor_1.Tensor) {
            data = feedEntry.data;
        }
        else {
            var provider = feedEntry.data;
            data = provider.getNextCopy();
        }
        util.assert(util.arraysEqual(feedEntry.tensor.shape, data.shape), "Error loading FeedEntry: feeding NDArray of shape " + data.shape + " " +
            ("does not match Tensor (id: " + feedEntry.tensor.id + ") shape: ") +
            (feedEntry.tensor.shape + "."));
        activations.set(feedEntry.tensor, data);
    });
}
exports.loadInputsFromFeedDictionaryToTensorArrayMap = loadInputsFromFeedDictionaryToTensorArrayMap;
function releaseFeedDictionaryInputsFromTensorArrayMap(batchFeed, activations, math) {
    Object.keys(batchFeed.dict).forEach(function (tensorID) {
        var feedEntry = batchFeed.dict[+tensorID];
        if (!(feedEntry.data instanceof tensor_1.Tensor)) {
            var provider = feedEntry.data;
            var feedEntryArray = activations.get(feedEntry.tensor);
            provider.disposeCopy(feedEntryArray);
        }
        activations.delete(feedEntry.tensor);
    });
}
exports.releaseFeedDictionaryInputsFromTensorArrayMap = releaseFeedDictionaryInputsFromTensorArrayMap;
function removeFeedDictionaryNodesFromEvaluationSet(feedDictionary, evaluationSet) {
    var i = 0;
    while (i < evaluationSet.length) {
        var node = evaluationSet[i];
        if (feedDictionary.dict[node.output.id] != null) {
            evaluationSet.splice(i, 1);
        }
        else {
            ++i;
        }
    }
}
exports.removeFeedDictionaryNodesFromEvaluationSet = removeFeedDictionaryNodesFromEvaluationSet;
function disposeAndInitializeOperationOutputs(evaluationSet, tensorArrayMap) {
    evaluationSet.forEach(function (node) {
        if (!graph_util.isInputNode(node)) {
            if (!graph_util.isPassthroughNode(node, tensorArrayMap)) {
                tensorArrayMap.disposeArray(node.output);
            }
            tensorArrayMap.set(node.output, null);
        }
    });
}
exports.disposeAndInitializeOperationOutputs = disposeAndInitializeOperationOutputs;
function disposeAndInitializeOperationInputGradients(evaluationSet, gradients) {
    evaluationSet.forEach(function (node) {
        Object.keys(node.inputs).forEach(function (inputName) {
            var input = node.inputs[inputName];
            if (gradients.get(input, true) !== gradients.get(node.output, true)) {
                gradients.disposeArray(input);
            }
            gradients.nullify(input);
        });
    });
}
exports.disposeAndInitializeOperationInputGradients = disposeAndInitializeOperationInputGradients;
function disposeTransientOperationArrays(operations, activations, gradients) {
    operations.forEach(function (op) { return op.disposeTransientArrays(activations, gradients); });
}
exports.disposeTransientOperationArrays = disposeTransientOperationArrays;
function throwErrorIfEvaluationSetContainsPlaceholderNodes(evaluationSet) {
    evaluationSet.forEach(function (node) {
        if (node instanceof graph_1.PlaceholderNode) {
            var shape = '[' + node.output.shape.join(', ') + ']';
            throw new Error('Placeholder node "' + node.name + '" ' + shape +
                ' not present in feed dictionary.');
        }
    });
}
exports.throwErrorIfEvaluationSetContainsPlaceholderNodes = throwErrorIfEvaluationSetContainsPlaceholderNodes;

},{"../tensor":137,"../util":143,"./graph":32,"./graph_util":34}],59:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var TensorArrayMapBase = (function () {
    function TensorArrayMapBase() {
        this.dict = {};
    }
    TensorArrayMapBase.prototype.get = function (tensor, skipChecks) {
        if (skipChecks === void 0) { skipChecks = false; }
        if (!skipChecks && this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        var nda = this.dict[tensor.id];
        if (!skipChecks && nda === null) {
            throw new Error("tensor " + tensor.id + " has null array.");
        }
        return nda;
    };
    TensorArrayMapBase.prototype.delete = function (tensor) {
        delete this.dict[tensor.id];
    };
    TensorArrayMapBase.prototype.nullify = function (tensor) {
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.disposeArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            return;
        }
        var nda = this.dict[tensor.id];
        if (nda === null) {
            return;
        }
        nda.dispose();
        this.dict[tensor.id] = null;
    };
    TensorArrayMapBase.prototype.size = function () {
        return Object.keys(this.dict).length;
    };
    TensorArrayMapBase.prototype.dispose = function () {
        var _this = this;
        Object.keys(this.dict).forEach(function (tensorID) {
            var nda = _this.dict[+tensorID];
            if (nda) {
                nda.dispose();
            }
        });
        this.dict = {};
    };
    TensorArrayMapBase.prototype.hasNullArray = function (tensor) {
        if (this.dict[tensor.id] === undefined) {
            throw new Error("tensor " + tensor.id + " not in array map.");
        }
        return this.dict[tensor.id] === null;
    };
    return TensorArrayMapBase;
}());
exports.TensorArrayMapBase = TensorArrayMapBase;
var TensorArrayMap = (function (_super) {
    __extends(TensorArrayMap, _super);
    function TensorArrayMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    TensorArrayMap.prototype.set = function (tensor, array) {
        this.dict[tensor.id] = array;
    };
    return TensorArrayMap;
}(TensorArrayMapBase));
exports.TensorArrayMap = TensorArrayMap;
var SummedTensorArrayMap = (function (_super) {
    __extends(SummedTensorArrayMap, _super);
    function SummedTensorArrayMap(math) {
        var _this = _super.call(this) || this;
        _this.math = math;
        return _this;
    }
    SummedTensorArrayMap.prototype.add = function (tensor, array) {
        if (this.dict[tensor.id] == null) {
            this.dict[tensor.id] = this.math.keep(array);
        }
        else {
            var oldValue = this.get(tensor);
            var newValue = this.math.keep(this.math.addStrict(oldValue, array));
            this.dict[tensor.id] = newValue;
            oldValue.dispose();
        }
    };
    return SummedTensorArrayMap;
}(TensorArrayMapBase));
exports.SummedTensorArrayMap = SummedTensorArrayMap;

},{}],60:[function(require,module,exports){
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var browser_util_1 = require("./browser_util");
var contrib = require("./contrib");
exports.contrib = contrib;
var xhr_dataset = require("./data/xhr-dataset");
exports.xhr_dataset = xhr_dataset;
var environment = require("./environment");
exports.environment = environment;
var environment_1 = require("./environment");
var gpgpu_util = require("./kernels/webgl/gpgpu_util");
exports.gpgpu_util = gpgpu_util;
var webgl_util = require("./kernels/webgl/webgl_util");
exports.webgl_util = webgl_util;
var conv_util = require("./ops/conv_util");
exports.conv_util = conv_util;
var test_util = require("./test_util");
exports.test_util = test_util;
var util = require("./util");
exports.util = util;
var version_1 = require("./version");
exports.version = version_1.version;
var checkpoint_loader_1 = require("./data/checkpoint_loader");
exports.CheckpointLoader = checkpoint_loader_1.CheckpointLoader;
var dataset_1 = require("./data/dataset");
exports.InMemoryDataset = dataset_1.InMemoryDataset;
var input_provider_1 = require("./data/input_provider");
exports.InCPUMemoryShuffledInputProviderBuilder = input_provider_1.InCPUMemoryShuffledInputProviderBuilder;
exports.InGPUMemoryShuffledInputProviderBuilder = input_provider_1.InGPUMemoryShuffledInputProviderBuilder;
var xhr_dataset_1 = require("./data/xhr-dataset");
exports.XhrDataset = xhr_dataset_1.XhrDataset;
var environment_2 = require("./environment");
exports.ENV = environment_2.ENV;
exports.Environment = environment_2.Environment;
var graph_1 = require("./graph/graph");
exports.Graph = graph_1.Graph;
exports.SymbolicTensor = graph_1.SymbolicTensor;
var graph_runner_1 = require("./graph/graph_runner");
exports.GraphRunner = graph_runner_1.GraphRunner;
exports.MetricReduction = graph_runner_1.MetricReduction;
var initializers_1 = require("./graph/initializers");
exports.ConstantInitializer = initializers_1.ConstantInitializer;
exports.OnesInitializer = initializers_1.OnesInitializer;
exports.RandomNormalInitializer = initializers_1.RandomNormalInitializer;
exports.RandomTruncatedNormalInitializer = initializers_1.RandomTruncatedNormalInitializer;
exports.RandomUniformInitializer = initializers_1.RandomUniformInitializer;
exports.TensorInitializer = initializers_1.TensorInitializer;
exports.VarianceScalingInitializer = initializers_1.VarianceScalingInitializer;
exports.ZerosInitializer = initializers_1.ZerosInitializer;
var session_1 = require("./graph/session");
exports.CostReduction = session_1.CostReduction;
exports.Session = session_1.Session;
var backend_cpu_1 = require("./kernels/backend_cpu");
exports.MathBackendCPU = backend_cpu_1.MathBackendCPU;
exports.NDArrayMathCPU = backend_cpu_1.NDArrayMathCPU;
var backend_webgl_1 = require("./kernels/backend_webgl");
exports.MathBackendWebGL = backend_webgl_1.MathBackendWebGL;
exports.NDArrayMathGPU = backend_webgl_1.NDArrayMathGPU;
var gpgpu_context_1 = require("./kernels/webgl/gpgpu_context");
exports.GPGPUContext = gpgpu_context_1.GPGPUContext;
var math_1 = require("./math");
exports.NDArrayMath = math_1.NDArrayMath;
var matmul_1 = require("./ops/matmul");
exports.MatrixOrientation = matmul_1.MatrixOrientation;
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
exports.AdadeltaOptimizer = adadelta_optimizer_1.AdadeltaOptimizer;
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
exports.AdagradOptimizer = adagrad_optimizer_1.AdagradOptimizer;
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
exports.AdamOptimizer = adam_optimizer_1.AdamOptimizer;
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
exports.AdamaxOptimizer = adamax_optimizer_1.AdamaxOptimizer;
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
exports.MomentumOptimizer = momentum_optimizer_1.MomentumOptimizer;
var optimizer_1 = require("./optimizers/optimizer");
exports.Optimizer = optimizer_1.Optimizer;
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
exports.RMSPropOptimizer = rmsprop_optimizer_1.RMSPropOptimizer;
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
exports.SGDOptimizer = sgd_optimizer_1.SGDOptimizer;
var tensor_1 = require("./tensor");
exports.Array1D = tensor_1.Array1D;
exports.Array2D = tensor_1.Array2D;
exports.Array3D = tensor_1.Array3D;
exports.Array4D = tensor_1.Array4D;
exports.NDArray = tensor_1.NDArray;
exports.Scalar = tensor_1.Scalar;
exports.Tensor = tensor_1.Tensor;
exports.Tensor1D = tensor_1.Tensor1D;
exports.Tensor2D = tensor_1.Tensor2D;
exports.Tensor3D = tensor_1.Tensor3D;
exports.Tensor4D = tensor_1.Tensor4D;
exports.variable = tensor_1.variable;
exports.Variable = tensor_1.Variable;
var types_1 = require("./types");
exports.Rank = types_1.Rank;
var weights_loader_1 = require("./weights_loader");
exports.loadWeights = weights_loader_1.loadWeights;
__export(require("./ops/ops"));
__export(require("./train"));
__export(require("./globals"));
exports.setBackend = environment_1.Environment.setBackend;
exports.getBackend = environment_1.Environment.getBackend;
exports.memory = environment_1.Environment.memory;
exports.nextFrame = browser_util_1.BrowserUtil.nextFrame;

},{"./browser_util":3,"./contrib":19,"./data/checkpoint_loader":20,"./data/dataset":21,"./data/input_provider":22,"./data/xhr-dataset":23,"./environment":27,"./globals":28,"./graph/graph":32,"./graph/graph_runner":33,"./graph/initializers":35,"./graph/session":57,"./kernels/backend_cpu":61,"./kernels/backend_webgl":62,"./kernels/webgl/gpgpu_context":74,"./kernels/webgl/gpgpu_util":76,"./kernels/webgl/webgl_util":95,"./math":96,"./ops/conv_util":106,"./ops/matmul":111,"./ops/ops":114,"./optimizers/adadelta_optimizer":126,"./optimizers/adagrad_optimizer":127,"./optimizers/adam_optimizer":128,"./optimizers/adamax_optimizer":129,"./optimizers/momentum_optimizer":130,"./optimizers/optimizer":131,"./optimizers/rmsprop_optimizer":133,"./optimizers/sgd_optimizer":134,"./tensor":137,"./test_util":139,"./train":141,"./types":142,"./util":143,"./version":144,"./weights_loader":145}],61:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var environment_1 = require("../environment");
var math_1 = require("../math");
var axis_util = require("../ops/axis_util");
var broadcast_util = require("../ops/broadcast_util");
var concat_util = require("../ops/concat_util");
var ops = require("../ops/ops");
var ops_1 = require("../ops/ops");
var selu_util = require("../ops/selu_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var MathBackendCPU = (function () {
    function MathBackendCPU() {
        this.data = new WeakMap();
        if (typeof document !== 'undefined') {
            this.canvas = document.createElement('canvas');
        }
    }
    MathBackendCPU.prototype.register = function (dataId, shape, dtype) {
        if (this.data.has(dataId)) {
            throw new Error("Data buffer is already registered");
        }
        this.data.set(dataId, null);
    };
    MathBackendCPU.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendCPU.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        this.data.set(dataId, values);
    };
    MathBackendCPU.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendCPU.writePixels(): pixels can not be null');
        }
        var vals;
        if (pixels instanceof ImageData) {
            vals = pixels.data;
        }
        else if (pixels instanceof HTMLCanvasElement) {
            vals = pixels.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else if (pixels instanceof HTMLImageElement ||
            pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            vals = this.canvas.getContext('2d')
                .getImageData(0, 0, pixels.width, pixels.height)
                .data;
        }
        else {
            throw new Error("pixels is of unknown type: " + pixels.constructor.name);
        }
        var values;
        if (numChannels === 4) {
            values = new Int32Array(vals);
        }
        else {
            var numPixels = pixels.width * pixels.height;
            values = new Int32Array(numPixels * numChannels);
            for (var i = 0; i < numPixels; i++) {
                for (var channel = 0; channel < numChannels; ++channel) {
                    values[i * numChannels + channel] = vals[i * 4 + channel];
                }
            }
        }
        var outShape = [pixels.height, pixels.width, numChannels];
        return ops_1.tensor3d(values, outShape, 'int32');
    };
    MathBackendCPU.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2, this.readSync(dataId)];
            });
        });
    };
    MathBackendCPU.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        return this.data.get(dataId);
    };
    MathBackendCPU.prototype.disposeData = function (dataId) {
        if (this.data.has(dataId)) {
            this.data.delete(dataId);
        }
    };
    MathBackendCPU.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var start, kernelMs;
            return __generator(this, function (_a) {
                start = performance.now();
                f();
                kernelMs = performance.now() - start;
                return [2, { kernelMs: kernelMs }];
            });
        });
    };
    MathBackendCPU.prototype.memory = function () {
        return {
            unreliable: true
        };
    };
    MathBackendCPU.prototype.throwIfNoData = function (dataId) {
        if (!this.data.has(dataId)) {
            throw new Error("CPU backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendCPU.prototype.slice = function (x, begin, size) {
        var buffer = ops.buffer(size, x.dtype);
        for (var i = 0; i < buffer.size; ++i) {
            var loc = buffer.indexToLoc(i);
            var xLoc = loc.map(function (idx, j) { return idx + begin[j]; });
            buffer.set.apply(buffer, [x.get.apply(x, xLoc)].concat(loc));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.reverse = function (x, axis) {
        var buffer = ops.buffer(x.shape, x.dtype);
        var xBuffer = x.buffer();
        var _loop_1 = function (i) {
            var outLoc = buffer.indexToLoc(i);
            var inLoc = outLoc.slice();
            axis.forEach(function (ax) { return inLoc[ax] = x.shape[ax] - 1 - inLoc[ax]; });
            buffer.set.apply(buffer, [xBuffer.get.apply(xBuffer, inLoc)].concat(outLoc));
        };
        for (var i = 0; i < buffer.size; i++) {
            _loop_1(i);
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.concat = function (a, b) {
        var outShape = concat_util.computeOutShape(a.shape, b.shape, 1);
        var buffer = ops.buffer(outShape, a.dtype);
        if (a.shape[0] === 1 && b.shape[0] === 1) {
            var aVals = a.dataSync();
            var bVals = b.dataSync();
            var vals = buffer.values;
            vals.set(aVals, 0);
            vals.set(bVals, a.size);
            return buffer.toTensor();
        }
        for (var i = 0; i < outShape[0]; ++i) {
            for (var j = 0; j < a.shape[1]; ++j) {
                buffer.set(a.get(i, j), i, j);
            }
            for (var j = 0; j < b.shape[1]; ++j) {
                buffer.set(b.get(i, j), i, j + a.shape[1]);
            }
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.neg = function (x) {
        return this.multiply(ops.scalar(-1), x);
    };
    MathBackendCPU.prototype.add = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue + bValue; });
    };
    MathBackendCPU.prototype.subtract = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue - bValue; });
    };
    MathBackendCPU.prototype.pow = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aValue, bValue) { return Math.pow(aValue, bValue); });
    };
    MathBackendCPU.prototype.matMul = function (a, b, transposeA, transposeB) {
        var sharedDim = transposeA ? a.shape[0] : a.shape[1];
        var leftDim = transposeA ? a.shape[1] : a.shape[0];
        var rightDim = transposeB ? b.shape[0] : b.shape[1];
        var normalGetter = function (matrix, i, j) {
            return matrix.get(i, j);
        };
        var transposedGetter = function (matrix, i, j) {
            return matrix.get(j, i);
        };
        var aGetter = transposeA ? transposedGetter : normalGetter;
        var bGetter = transposeB ? transposedGetter : normalGetter;
        var values = new Float32Array(leftDim * rightDim);
        var index = 0;
        for (var i = 0; i < leftDim; ++i) {
            for (var j = 0; j < rightDim; ++j) {
                var sum = 0;
                for (var k = 0; k < sharedDim; ++k) {
                    sum += aGetter(a, i, k) * bGetter(b, k, j);
                }
                values[index++] = sum;
            }
        }
        return ops.tensor2d(values, [leftDim, rightDim]);
    };
    MathBackendCPU.prototype.multiply = function (a, b) {
        return this.broadcastedBinaryOp(a, b, types.upcastType(a.dtype, b.dtype), function (aValue, bValue) { return aValue * bValue; });
    };
    MathBackendCPU.prototype.divide = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'float32', function (aValue, bValue) { return aValue / bValue; });
    };
    MathBackendCPU.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var resultDtype = types.upcastType(x.dtype, 'int32');
        var result = ops.zeros(outShape, resultDtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var sum = 0;
            for (var j = 0; j < reduceSize; ++j) {
                sum += aVals[offset + j];
            }
            vals[i] = sum;
        }
        return result;
    };
    MathBackendCPU.prototype.argMin = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[offset];
            var minIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    minIndex = util.NAN_INT32;
                    break;
                }
                if (value < min) {
                    min = value;
                    minIndex = j;
                }
            }
            vals[i] = minIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.argMax = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, 'int32');
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            var maxIndex = 0;
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    maxIndex = util.NAN_INT32;
                    break;
                }
                if (value > max) {
                    max = value;
                    maxIndex = j;
                }
            }
            vals[i] = maxIndex;
        }
        return result;
    };
    MathBackendCPU.prototype.equal = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal === bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.notEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal !== bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.less = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal < bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.lessEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal <= bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.greater = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal > bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.greaterEqual = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return (aVal >= bVal) ? 1 : 0;
            }
        });
    };
    MathBackendCPU.prototype.logicalNot = function (x) {
        var values = x.dataSync();
        var newValues = new Int32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            if (util.isValNaN(values[i], x.dtype)) {
                newValues[i] = util.getNaN('bool');
            }
            else {
                newValues[i] = values[i] ? 0 : 1;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues }, 'bool');
    };
    MathBackendCPU.prototype.logicalAnd = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return aVal && bVal;
            }
        });
    };
    MathBackendCPU.prototype.logicalOr = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return aVal || bVal;
            }
        });
    };
    MathBackendCPU.prototype.logicalXor = function (a, b) {
        return this.broadcastedBinaryOp(a, b, 'bool', function (aVal, bVal) {
            if (util.isValNaN(aVal, a.dtype) || util.isValNaN(bVal, b.dtype)) {
                return util.getNaN('bool');
            }
            else {
                return aVal ^ bVal;
            }
        });
    };
    MathBackendCPU.prototype.where = function (condition, a, b, dtype) {
        var values = condition.dataSync();
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var result = ops.zeros(a.shape, dtype);
        var newValues = result.dataSync();
        var index = 0;
        var offset = condition.rank === 0 || condition.rank > 1 || a.rank === 1 ?
            1 :
            a.shape[1];
        for (var i = 0; i < values.length; i++) {
            for (var j = 0; j < offset; j++) {
                if (values[i] === 1) {
                    newValues[index++] = aValues[i];
                }
                else {
                    newValues[index++] = bValues[i];
                }
            }
        }
        return result;
    };
    MathBackendCPU.prototype.topKValues = function (x, k) {
        return this.topK(x, k).values;
    };
    MathBackendCPU.prototype.topKIndices = function (x, k) {
        return this.topK(x, k).indices;
    };
    MathBackendCPU.prototype.topK = function (x, k) {
        var values = x.dataSync();
        var valuesAndIndices = [];
        for (var i = 0; i < values.length; i++) {
            valuesAndIndices.push({ value: values[i], index: i });
        }
        valuesAndIndices.sort(function (a, b) {
            return b.value - a.value;
        });
        var topkValues = util.getTypedArrayFromDType(x.dtype, k);
        var topkIndices = new Int32Array(k);
        for (var i = 0; i < k; i++) {
            topkValues[i] = valuesAndIndices[i].value;
            topkIndices[i] = valuesAndIndices[i].index;
        }
        return {
            values: ops.tensor1d(topkValues, x.dtype),
            indices: tensor_1.Tensor1D.new(topkIndices)
        };
    };
    MathBackendCPU.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var min = aVals[0];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    min = Number.NaN;
                    break;
                }
                if (value < min) {
                    min = value;
                }
            }
            vals[i] = min;
        }
        return result;
    };
    MathBackendCPU.prototype.minimum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.min(aVal, bVal); });
    };
    MathBackendCPU.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var result = ops.zeros(outShape, x.dtype);
        var reduceSize = util.sizeFromShape(reduceShape);
        var vals = result.dataSync();
        var aVals = x.dataSync();
        for (var i = 0; i < vals.length; ++i) {
            var offset = i * reduceSize;
            var max = aVals[offset];
            for (var j = 0; j < reduceSize; ++j) {
                var value = aVals[offset + j];
                if (isNaN(value)) {
                    max = Number.NaN;
                    break;
                }
                if (value > max) {
                    max = value;
                }
            }
            vals[i] = max;
        }
        return result;
    };
    MathBackendCPU.prototype.maximum = function (a, b) {
        return this.broadcastedBinaryOp(a, b, a.dtype, function (aVal, bVal) { return Math.max(aVal, bVal); });
    };
    MathBackendCPU.prototype.ceil = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.ceil(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.floor = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.floor(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.exp = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            newValues[i] = Math.exp(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.log = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.log(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.sqrt = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = Math.sqrt(value);
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.square = function (x) {
        var values = x.dataSync();
        var newValues = new Float32Array(values.length);
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            newValues[i] = value * value;
        }
        return tensor_1.Tensor.make(x.shape, { values: newValues });
    };
    MathBackendCPU.prototype.relu = function (x) {
        var res = ops.zeros(x.shape, x.dtype);
        var resVals = res.dataSync();
        var inVals = x.dataSync();
        for (var i = 0; i < inVals.length; ++i) {
            var val = inVals[i];
            if (util.isValNaN(val, x.dtype)) {
                resVals[i] = util.getNaN(res.dtype);
            }
            else {
                resVals[i] = Math.max(0, inVals[i]);
            }
        }
        return res;
    };
    MathBackendCPU.prototype.elu = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.eluDer = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = 1;
            }
            else {
                resultValues[i] = Math.exp(v);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.selu = function (x) {
        var scaleAlpha = selu_util.SELU_SCALEALPHA;
        var scale = selu_util.SELU_SCALE;
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = scale * v;
            }
            else {
                resultValues[i] = scaleAlpha * (Math.exp(v) - 1);
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.leakyRelu = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alpha * v;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.prelu = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var alphas = alpha.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v >= 0) {
                resultValues[i] = v;
            }
            else {
                resultValues[i] = alphas[i] * v;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.preluDer = function (x, alpha) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var alphas = alpha.dataSync();
        for (var i = 0; i < values.length; i++) {
            var v = values[i];
            if (v > 0) {
                resultValues[i] = 1;
            }
            else if (v < 0) {
                resultValues[i] = alphas[i];
            }
            else {
                resultValues[i] = v;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.clip = function (x, min, max) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.min(max, Math.max(min, values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.abs = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.abs(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.int = function (x) {
        var resultValues = new Int32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = values[i];
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues }, 'int32');
    };
    MathBackendCPU.prototype.sigmoid = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = 1 / (1 + Math.exp(-values[i]));
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.tan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.asin = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.asin(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.acos = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.acos(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.atan = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.atan(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.sinh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.sinh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.cosh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = Math.cosh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.tanh = function (x) {
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            resultValues[i] = util.tanh(values[i]);
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0; }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        for (var i = 0; i < values.length; ++i) {
            var value = values[i];
            if (util.isValNaN(value, x.dtype)) {
                resultValues[i] = util.getNaN(x.dtype);
            }
            else {
                resultValues[i] = value > 0 ? 1 : alpha;
            }
        }
        return tensor_1.Tensor.make(x.shape, { values: resultValues });
    };
    MathBackendCPU.prototype.conv2d = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var dotProd = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        y.set(dotProd, b, yR, yC, d2);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var topPad = filterHeight - 1 - convInfo.padInfo.top;
        var leftPad = filterWidth - 1 - convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var dx = ops.buffer(convInfo.inShape, 'float32');
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var xR = 0; xR < convInfo.inHeight; ++xR) {
                    var xRCorner = xR - leftPad;
                    var xRMin = Math.max(0, Math.ceil(xRCorner / strideHeight));
                    var yRMax = Math.min(convInfo.outHeight, (filterHeight + xRCorner) / strideHeight);
                    for (var xC = 0; xC < convInfo.inWidth; ++xC) {
                        var xCCorner = xC - topPad;
                        var xCMin = Math.max(0, Math.ceil(xCCorner / strideWidth));
                        var yCMax = Math.min(convInfo.outWidth, (filterWidth + xCCorner) / strideWidth);
                        var dotProd = 0;
                        for (var yR = xRMin; yR < yRMax; ++yR) {
                            var wR = yR * strideHeight - xRCorner;
                            for (var yC = xCMin; yC < yCMax; ++yC) {
                                var wC = yC * strideWidth - xCCorner;
                                for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                                    var pixel = dy.get(b, yR, yC, d2);
                                    var weight = filter.get(filterHeight - 1 - wR, filterWidth - 1 - wC, d1, d2);
                                    dotProd += pixel * weight;
                                }
                            }
                        }
                        dx.set(dotProd, b, xR, xC, d1);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var dW = ops.buffer(convInfo.filterShape, 'float32');
        var leftPad = convInfo.padInfo.left;
        var topPad = convInfo.padInfo.top;
        for (var wR = 0; wR < filterHeight; ++wR) {
            var yRMin = Math.max(0, Math.ceil((topPad - wR) / strideHeight));
            var yRMax = Math.min(convInfo.outHeight, (convInfo.inHeight + topPad - wR) / strideHeight);
            for (var wC = 0; wC < filterWidth; ++wC) {
                var yCMin = Math.max(0, Math.ceil((leftPad - wC) / strideWidth));
                var yCMax = Math.min(convInfo.outWidth, (convInfo.inWidth + leftPad - wC) / strideWidth);
                for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                    for (var d2 = 0; d2 < convInfo.outChannels; ++d2) {
                        var dotProd = 0;
                        for (var b = 0; b < convInfo.batchSize; ++b) {
                            for (var yR = yRMin; yR < yRMax; ++yR) {
                                var xR = wR + yR * strideHeight - topPad;
                                for (var yC = yCMin; yC < yCMax; ++yC) {
                                    var xC = wC + yC * strideWidth - leftPad;
                                    dotProd += x.get(b, xR, xC, d1) * dy.get(b, yR, yC, d2);
                                }
                            }
                        }
                        dW.set(dotProd, wR, wC, d1, d2);
                    }
                }
            }
        }
        return dW.toTensor();
    };
    MathBackendCPU.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = convInfo.padInfo.left;
        var padTop = convInfo.padInfo.top;
        var chMul = convInfo.outChannels / convInfo.inChannels;
        var y = ops.buffer(convInfo.outShape, x.dtype);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d1 = 0; d1 < convInfo.inChannels; ++d1) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * convInfo.strideHeight - padLeft;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * convInfo.strideWidth - padTop;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        for (var q = 0; q < chMul; ++q) {
                            var dotProd = 0;
                            for (var xR = xRMin; xR < xRMax; ++xR) {
                                var wR = xR - xRCorner;
                                for (var xC = xCMin; xC < xCMax; ++xC) {
                                    var wC = xC - xCCorner;
                                    var pixel = x.get(b, xR, xC, d1);
                                    var weight = filter.get(wR, wC, d1, q);
                                    dotProd += pixel * weight;
                                }
                            }
                            y.set(dotProd, b, yR, yC, d1 * chMul + q);
                        }
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.tile = function (x, reps) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[i] * reps[i];
        }
        var result = ops.buffer(newShape, x.dtype);
        var values = x.dataSync();
        for (var i = 0; i < result.values.length; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = new Array(x.rank);
            for (var i_1 = 0; i_1 < originalLoc.length; i_1++) {
                originalLoc[i_1] = newLoc[i_1] % x.shape[i_1];
            }
            var originalIndex = x.locToIndex(originalLoc);
            result.values[i] = values[originalIndex];
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.pad = function (x, paddings, constantValue) {
        var outShape = paddings.map(function (p, i) { return p[0] + x.shape[i] + p[1]; });
        var start = paddings.map(function (p) { return p[0]; });
        var xBuffer = x.buffer();
        var buffer = ops.buffer(outShape, x.dtype);
        if (constantValue !== 0) {
            buffer.values.fill(constantValue);
        }
        for (var i = 0; i < x.size; i++) {
            var coords = xBuffer.indexToLoc(i);
            var outCoords = coords.map(function (c, i) { return c + start[i]; });
            buffer.set.apply(buffer, [x.get.apply(x, coords)].concat(outCoords));
        }
        return buffer.toTensor();
    };
    MathBackendCPU.prototype.transpose = function (x, perm) {
        var newShape = new Array(x.rank);
        for (var i = 0; i < newShape.length; i++) {
            newShape[i] = x.shape[perm[i]];
        }
        var resultValues = new Float32Array(x.size);
        var values = x.dataSync();
        var result = tensor_1.Tensor.make(newShape, { values: resultValues });
        for (var i = 0; i < x.size; ++i) {
            var loc = x.indexToLoc(i);
            var newLoc = new Array(loc.length);
            for (var i_2 = 0; i_2 < newLoc.length; i_2++) {
                newLoc[i_2] = loc[perm[i_2]];
            }
            var newIndex = result.locToIndex(newLoc);
            resultValues[newIndex] = values[i];
        }
        return result;
    };
    MathBackendCPU.prototype.gather = function (x, indices, axis) {
        var newShape = x.shape.slice();
        var indicesValues = indices.dataSync();
        newShape[axis] = indicesValues.length;
        var result = ops.zeros(newShape, x.dtype);
        var values = x.dataSync();
        var resultValues = result.dataSync();
        for (var i = 0; i < result.size; ++i) {
            var newLoc = result.indexToLoc(i);
            var originalLoc = newLoc.slice();
            originalLoc[axis] = indicesValues[newLoc[axis]];
            var originalIndex = x.locToIndex(originalLoc);
            resultValues[i] = values[originalIndex];
        }
        return result;
    };
    MathBackendCPU.prototype.pool = function (x, convInfo, poolType) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var y = ops.buffer(convInfo.outShape, 'float32');
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var minMaxValue = (poolType === 'max' ? Number.NEGATIVE_INFINITY :
                            Number.POSITIVE_INFINITY);
                        var avgValue = 0;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var pixel = x.get(b, xR, xC, d);
                                if (isNaN(pixel)) {
                                    minMaxValue = NaN;
                                    avgValue = NaN;
                                    break;
                                }
                                if ((poolType === 'max' && pixel > minMaxValue) ||
                                    (poolType === 'min' && pixel < minMaxValue)) {
                                    minMaxValue = pixel;
                                }
                                else if (poolType === 'avg') {
                                    avgValue += pixel / (filterHeight * filterWidth);
                                }
                            }
                            if (isNaN(minMaxValue)) {
                                break;
                            }
                        }
                        y.set(poolType === 'avg' ? avgValue : minMaxValue, b, yR, yC, d);
                    }
                }
            }
        }
        return y.toTensor();
    };
    MathBackendCPU.prototype.maxPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'max');
    };
    MathBackendCPU.prototype.maxPoolPositions = function (x, convInfo) {
        var maxPositions = ops.buffer(convInfo.outShape, 'int32');
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var yR = 0; yR < convInfo.outHeight; ++yR) {
                    var xRCorner = yR * strideHeight - padTop;
                    var xRMin = Math.max(0, xRCorner);
                    var xRMax = Math.min(convInfo.inHeight, filterHeight + xRCorner);
                    for (var yC = 0; yC < convInfo.outWidth; ++yC) {
                        var xCCorner = yC * strideWidth - padLeft;
                        var xCMin = Math.max(0, xCCorner);
                        var xCMax = Math.min(convInfo.inWidth, filterWidth + xCCorner);
                        var maxValue = Number.NEGATIVE_INFINITY;
                        var maxPosition = -1;
                        for (var xR = xRMin; xR < xRMax; ++xR) {
                            var wR = xR - xRCorner;
                            for (var xC = xCMin; xC < xCMax; ++xC) {
                                var wC = xC - xCCorner;
                                var pixel = x.get(b, xR, xC, d);
                                if (pixel > maxValue) {
                                    maxValue = pixel;
                                    maxPosition = wR * filterWidth + wC;
                                }
                            }
                        }
                        maxPositions.set(maxPosition, b, yR, yC, d);
                    }
                }
            }
        }
        return maxPositions.toTensor();
    };
    MathBackendCPU.prototype.maxPoolBackprop = function (dy, x, convInfo) {
        var maxPositions = this.maxPoolPositions(x, convInfo);
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var maxPos = filterHeight * filterWidth - 1 -
                                    maxPositions.get(b, dyR, dyC, d);
                                var curPos = wR * filterWidth + wC;
                                var mask = maxPos === curPos ? 1 : 0;
                                if (mask === 0) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel * mask;
                            }
                        }
                        dx.set(dotProd, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var dx = ops.buffer(x.shape, 'float32');
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        for (var b = 0; b < convInfo.batchSize; ++b) {
            for (var d = 0; d < convInfo.inChannels; ++d) {
                for (var dxR = 0; dxR < convInfo.inHeight; ++dxR) {
                    for (var dxC = 0; dxC < convInfo.inWidth; ++dxC) {
                        var dyRCorner = dxR - padTop;
                        var dyCCorner = dxC - padLeft;
                        var dotProd = 0;
                        for (var wR = 0; wR < filterHeight; ++wR) {
                            var dyR = (dyRCorner + wR) / strideHeight;
                            if (dyR < 0 || dyR >= convInfo.outHeight ||
                                Math.floor(dyR) !== dyR) {
                                continue;
                            }
                            for (var wC = 0; wC < filterWidth; ++wC) {
                                var dyC = (dyCCorner + wC) / strideWidth;
                                if (dyC < 0 || dyC >= convInfo.outWidth ||
                                    Math.floor(dyC) !== dyC) {
                                    continue;
                                }
                                var pixel = dy.get(b, dyR, dyC, d);
                                dotProd += pixel;
                            }
                        }
                        dx.set(dotProd * avgMultiplier, b, dxR, dxC, d);
                    }
                }
            }
        }
        return dx.toTensor();
    };
    MathBackendCPU.prototype.minPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'min');
    };
    MathBackendCPU.prototype.avgPool = function (x, convInfo) {
        return this.pool(x, convInfo, 'avg').toFloat();
    };
    MathBackendCPU.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var _a = x.shape, batch = _a[0], oldHeight = _a[1], oldWidth = _a[2], numChannels = _a[3];
        var output = ops.buffer([batch, newHeight, newWidth, numChannels], x.dtype);
        var effectiveInputSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutputSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        for (var b = 0; b < batch; b++) {
            for (var r = 0; r < newHeight; r++) {
                for (var c = 0; c < newWidth; c++) {
                    for (var d = 0; d < numChannels; d++) {
                        var sourceFracRow = (effectiveInputSize[0]) * r / (effectiveOutputSize[0]);
                        var sourceFracCol = (effectiveInputSize[1]) * c / (effectiveOutputSize[1]);
                        var sourceRowFloor = Math.floor(sourceFracRow);
                        var sourceRowCeil = Math.min(oldHeight - 1, Math.ceil(sourceFracRow));
                        var sourceColFloor = Math.floor(sourceFracCol);
                        var sourceColCeil = Math.min(oldWidth - 1, Math.ceil(sourceFracCol));
                        var topLeft = x.get(b, sourceRowFloor, sourceColFloor, d);
                        var bottomLeft = x.get(b, sourceRowCeil, sourceColFloor, d);
                        var topRight = x.get(b, sourceRowFloor, sourceColCeil, d);
                        var bottomRight = x.get(b, sourceRowCeil, sourceColCeil, d);
                        var rowFrac = sourceFracRow - sourceRowFloor;
                        var colFrac = sourceFracCol - sourceColFloor;
                        var top_1 = topLeft + (topRight - topLeft) * colFrac;
                        var bottom = bottomLeft + (bottomRight - bottomLeft) * colFrac;
                        var newValue = top_1 + (bottom - top_1) * rowFrac;
                        output.set(newValue, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.batchNormalization4D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var xValues = x.dataSync();
        var meanValues = mean.dataSync();
        var varianceValues = variance.dataSync();
        var scaleValues = scale ? scale.dataSync() : new Float32Array([1]);
        var offsetValues = offset ? offset.dataSync() : new Float32Array([0]);
        var outValues = new Float32Array(xValues.length);
        for (var i = 0; i < xValues.length; i++) {
            outValues[i] = offsetValues[i % offsetValues.length] +
                (xValues[i] - meanValues[i % meanValues.length]) *
                    scaleValues[i % scaleValues.length] /
                    Math.sqrt(varianceValues[i % varianceValues.length] + varianceEpsilon);
        }
        return ops_1.tensor4d(outValues, x.shape);
    };
    MathBackendCPU.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta, normRegion) {
        var output = ops.buffer(x.shape, 'float32');
        var rad = radius;
        var maxW = output.shape[1] - 1;
        var maxH = output.shape[2] - 1;
        var maxD = output.shape[3] - 1;
        var sumAcrossChannels = function (b, r, c, d) {
            var sum = 0.0;
            for (var j = Math.max(0, d - rad); j <= Math.min(d + rad, maxD); j++) {
                var z = x.get(b, r, c, j);
                sum += z * z;
            }
            return sum;
        };
        var sumWithinChannel = function (b, r, c, d) {
            var sum = 0.0;
            for (var u = Math.max(0, r - rad); u <= Math.min(r + rad, maxW); u++) {
                for (var v = Math.max(0, c - rad); v <= Math.min(c + rad, maxH); v++) {
                    sum += Math.pow(x.get(b, u, v, d), 2);
                }
            }
            return sum;
        };
        for (var b = 0; b < output.shape[0]; b++) {
            for (var r = 0; r <= output.shape[1]; r++) {
                for (var c = 0; c < output.shape[2]; c++) {
                    for (var d = 0; d < output.shape[3]; d++) {
                        var sum = normRegion === 'withinChannel' ?
                            sumWithinChannel(b, r, c, d) :
                            sumAcrossChannels(b, r, c, d);
                        var val = x.get(b, r, c, d) * Math.pow(bias + alpha * sum, -beta);
                        output.set(val, b, r, c, d);
                    }
                }
            }
        }
        return output.toTensor();
    };
    MathBackendCPU.prototype.multinomial = function (probabilities, numSamples, seed) {
        var batchSize = probabilities.shape[0];
        var numEvents = probabilities.shape[1];
        var res = ops.zeros([batchSize, numSamples], 'int32');
        var resVals = res.dataSync();
        var probVals = probabilities.dataSync();
        for (var b = 0; b < batchSize; ++b) {
            var offset = b * numEvents;
            var cdf = new Float32Array(numEvents - 1);
            cdf[0] = probVals[offset];
            for (var event_1 = 1; event_1 < cdf.length; ++event_1) {
                cdf[event_1] = cdf[event_1 - 1] + probVals[offset + event_1];
            }
            var random = seedrandom.alea(seed.toString());
            var outOffset = b * numSamples;
            for (var sampleId = 0; sampleId < numSamples; ++sampleId) {
                var r = random();
                resVals[outOffset + sampleId] = cdf.length;
                for (var event_2 = 0; event_2 < cdf.length; event_2++) {
                    if (r < cdf[event_2]) {
                        resVals[outOffset + sampleId] = event_2;
                        break;
                    }
                }
            }
        }
        return res;
    };
    MathBackendCPU.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var res = new Float32Array(indices.size * depth);
        res.fill(offValue);
        for (var event_3 = 0; event_3 < indices.size; ++event_3) {
            res[event_3 * depth + indices.get(event_3)] = onValue;
        }
        return ops.tensor2d(res, [indices.size, depth]);
    };
    MathBackendCPU.prototype.broadcastedBinaryOp = function (a, b, dtype, op) {
        var newShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var result = ops.buffer(newShape, dtype);
        var aValues = a.dataSync();
        var bValues = b.dataSync();
        var aBroadcastDims = broadcast_util.getBroadcastDims(a.shape, newShape);
        var bBroadcastDims = broadcast_util.getBroadcastDims(b.shape, newShape);
        var _loop_2 = function (i) {
            var loc = result.indexToLoc(i);
            var aLoc = loc.slice(-a.rank);
            aBroadcastDims.forEach(function (d) { return aLoc[d] = 0; });
            var aIndex = a.locToIndex(aLoc);
            var bLoc = loc.slice(-b.rank);
            bBroadcastDims.forEach(function (d) { return bLoc[d] = 0; });
            var bIndex = b.locToIndex(bLoc);
            result.values[i] = op(aValues[aIndex], bValues[bIndex]);
        };
        for (var i = 0; i < result.values.length; ++i) {
            _loop_2(i);
        }
        return result.toTensor();
    };
    MathBackendCPU.prototype.dispose = function () { };
    return MathBackendCPU;
}());
exports.MathBackendCPU = MathBackendCPU;
environment_1.ENV.registerBackend('cpu', function () { return new MathBackendCPU(); });
var NDArrayMathCPU = (function (_super) {
    __extends(NDArrayMathCPU, _super);
    function NDArrayMathCPU(safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = this;
        console.warn('new NDArrayMathCPU() is deprecated. Please use ' +
            'dl.setBackend(\'cpu\').');
        _this = _super.call(this, 'cpu', safeMode) || this;
        return _this;
    }
    return NDArrayMathCPU;
}(math_1.NDArrayMath));
exports.NDArrayMathCPU = NDArrayMathCPU;

},{"../environment":27,"../math":96,"../ops/axis_util":98,"../ops/broadcast_util":101,"../ops/concat_util":104,"../ops/ops":114,"../ops/selu_util":120,"../tensor":137,"../types":142,"../util":143,"seedrandom":146}],62:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var math_1 = require("../math");
var axis_util = require("../ops/axis_util");
var reduce_util = require("../ops/reduce_util");
var tensor_1 = require("../tensor");
var types = require("../types");
var util = require("../util");
var argminmax_gpu_1 = require("./webgl/argminmax_gpu");
var avg_pool_backprop_gpu_1 = require("./webgl/avg_pool_backprop_gpu");
var batchnorm_gpu_1 = require("./webgl/batchnorm_gpu");
var binaryop_gpu = require("./webgl/binaryop_gpu");
var binaryop_gpu_1 = require("./webgl/binaryop_gpu");
var clip_gpu_1 = require("./webgl/clip_gpu");
var concat_gpu_1 = require("./webgl/concat_gpu");
var conv_backprop_gpu_1 = require("./webgl/conv_backprop_gpu");
var conv_gpu_1 = require("./webgl/conv_gpu");
var conv_gpu_depthwise_1 = require("./webgl/conv_gpu_depthwise");
var from_pixels_gpu_1 = require("./webgl/from_pixels_gpu");
var gather_gpu_1 = require("./webgl/gather_gpu");
var gpgpu_context_1 = require("./webgl/gpgpu_context");
var gpgpu_math = require("./webgl/gpgpu_math");
var logical_gpu_1 = require("./webgl/logical_gpu");
var lrn_gpu_1 = require("./webgl/lrn_gpu");
var max_pool_backprop_gpu_1 = require("./webgl/max_pool_backprop_gpu");
var mulmat_gpu_1 = require("./webgl/mulmat_gpu");
var multinomial_gpu_1 = require("./webgl/multinomial_gpu");
var onehot_gpu_1 = require("./webgl/onehot_gpu");
var pad_gpu_1 = require("./webgl/pad_gpu");
var pool_gpu_1 = require("./webgl/pool_gpu");
var reduce_gpu_1 = require("./webgl/reduce_gpu");
var resize_bilinear_gpu_1 = require("./webgl/resize_bilinear_gpu");
var reverse_gpu_1 = require("./webgl/reverse_gpu");
var slice_gpu_1 = require("./webgl/slice_gpu");
var tex_util_1 = require("./webgl/tex_util");
var texture_manager_1 = require("./webgl/texture_manager");
var tile_gpu_1 = require("./webgl/tile_gpu");
var transpose_gpu_1 = require("./webgl/transpose_gpu");
var unary_op = require("./webgl/unaryop_gpu");
var unaryop_gpu_1 = require("./webgl/unaryop_gpu");
var webgl_util = require("./webgl/webgl_util");
var MathBackendWebGL = (function () {
    function MathBackendWebGL(gpgpu, delayedStorage) {
        if (delayedStorage === void 0) { delayedStorage = true; }
        this.gpgpu = gpgpu;
        this.delayedStorage = delayedStorage;
        this.texData = new WeakMap();
        this.uploadWaitMs = 0;
        this.downloadWaitMs = 0;
        this.binaryCache = {};
        this.disposed = false;
        if (environment_1.ENV.get('WEBGL_VERSION') < 1) {
            throw new Error('WebGL is not supported on this device');
        }
        if (gpgpu == null) {
            this.gpgpu = new gpgpu_context_1.GPGPUContext();
            this.gpgpuCreatedLocally = true;
        }
        else {
            this.gpgpuCreatedLocally = false;
        }
        if (typeof document !== 'undefined') {
            this.canvas = document.createElement('canvas');
        }
        this.textureManager = new texture_manager_1.TextureManager(this.gpgpu);
    }
    MathBackendWebGL.prototype.register = function (dataId, shape, dtype) {
        if (this.texData.has(dataId)) {
            throw new Error('Data buffer is already registered');
        }
        this.texData.set(dataId, {
            shape: shape,
            dtype: dtype,
            values: null,
            texture: null,
            texShape: null,
            texType: tex_util_1.TextureType.FLOAT
        });
    };
    MathBackendWebGL.prototype.fromPixels = function (pixels, numChannels) {
        if (pixels == null) {
            throw new Error('MathBackendWebGL.writePixels(): pixels can not be null');
        }
        var texShape = [pixels.height, pixels.width];
        var outShape = [pixels.height, pixels.width, numChannels];
        if (pixels instanceof HTMLVideoElement) {
            if (this.canvas == null) {
                throw new Error('Can\'t read pixels from HTMLImageElement outside ' +
                    'the browser.');
            }
            this.canvas.width = pixels.width;
            this.canvas.height = pixels.height;
            this.canvas.getContext('2d').drawImage(pixels, 0, 0, pixels.width, pixels.height);
            pixels = this.canvas;
        }
        var tempPixelArray = tensor_1.Tensor.make(texShape, {}, 'int32');
        this.texData.get(tempPixelArray.dataId).texType = tex_util_1.TextureType.UNSIGNED_BYTE;
        this.gpgpu.uploadPixelDataToTexture(this.getTexture(tempPixelArray.dataId), pixels);
        var program = new from_pixels_gpu_1.FromPixelsProgram(outShape);
        var res = this.compileAndRun(program, [tempPixelArray]);
        tempPixelArray.dispose();
        return res;
    };
    MathBackendWebGL.prototype.write = function (dataId, values) {
        if (values == null) {
            throw new Error('MathBackendWebGL.write(): values can not be null');
        }
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, texType = texData.texType;
        if (texture != null) {
            this.textureManager.releaseTexture(texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        texData.values = values;
        if (!this.delayedStorage) {
            this.uploadToGPU(dataId);
        }
    };
    MathBackendWebGL.prototype.readSync = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var texture = texData.texture, values = texData.values, texShape = texData.texShape;
        if (values != null) {
            this.cacheOnCPU(dataId);
            return values;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var float32Values = this.gpgpu.downloadMatrixFromTexture(texture, texShape[0], texShape[1]);
        if (shouldTimeProgram) {
            this.downloadWaitMs += performance.now() - start;
        }
        this.cacheOnCPU(dataId, float32Values);
        return texData.values;
    };
    MathBackendWebGL.prototype.read = function (dataId) {
        return __awaiter(this, void 0, void 0, function () {
            var texData, texture, values, texShape, float32Values;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.throwIfNoData(dataId);
                        texData = this.texData.get(dataId);
                        texture = texData.texture, values = texData.values, texShape = texData.texShape;
                        if (values != null) {
                            this.cacheOnCPU(dataId);
                            return [2, values];
                        }
                        if (!environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) return [3, 2];
                        return [4, this.gpgpu.downloadMatrixFromTextureAsync(texture, texShape[0], texShape[1])];
                    case 1:
                        float32Values = _a.sent();
                        this.cacheOnCPU(dataId, float32Values);
                        return [2, texData.values];
                    case 2:
                        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 0) {
                            return [2, this.readSync(dataId)];
                        }
                        return [4, this.gpgpu.runQuery(function () { })];
                    case 3:
                        _a.sent();
                        return [2, this.readSync(dataId)];
                }
            });
        });
    };
    MathBackendWebGL.prototype.time = function (f) {
        return __awaiter(this, void 0, void 0, function () {
            var oldActiveTimers, newActiveTimers, outerMostTime, flattenedActiveTimers, kernelMs, res;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        oldActiveTimers = this.activeTimers;
                        newActiveTimers = [];
                        outerMostTime = false;
                        if (this.programTimersStack == null) {
                            this.programTimersStack = newActiveTimers;
                            outerMostTime = true;
                        }
                        else {
                            this.activeTimers.push(newActiveTimers);
                        }
                        this.activeTimers = newActiveTimers;
                        f();
                        flattenedActiveTimers = util.flatten(this.activeTimers);
                        this.activeTimers = oldActiveTimers;
                        if (outerMostTime) {
                            this.programTimersStack = null;
                        }
                        return [4, Promise.all(flattenedActiveTimers).then(function (results) {
                                var sum = 0;
                                results.forEach(function (result) { return sum += result; });
                                return sum;
                            })];
                    case 1:
                        kernelMs = _a.sent();
                        res = {
                            uploadWaitMs: this.uploadWaitMs,
                            downloadWaitMs: this.downloadWaitMs,
                            kernelMs: kernelMs,
                            wallMs: null
                        };
                        this.uploadWaitMs = 0;
                        this.downloadWaitMs = 0;
                        return [2, res];
                }
            });
        });
    };
    MathBackendWebGL.prototype.memory = function () {
        return { unreliable: false };
    };
    MathBackendWebGL.prototype.startTimer = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            return this.gpgpu.beginQuery();
        }
        return { startMs: performance.now(), endMs: null };
    };
    MathBackendWebGL.prototype.endTimer = function (query) {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
            this.gpgpu.endQuery();
            return query;
        }
        query.endMs = performance.now();
        return query;
    };
    MathBackendWebGL.prototype.getQueryTime = function (query) {
        return __awaiter(this, void 0, void 0, function () {
            var timerQuery;
            return __generator(this, function (_a) {
                if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') > 0) {
                    return [2, this.gpgpu.pollQueryTime(query)];
                }
                timerQuery = query;
                return [2, timerQuery.endMs - timerQuery.startMs];
            });
        });
    };
    MathBackendWebGL.prototype.disposeData = function (dataId) {
        if (this.texData.has(dataId)) {
            var _a = this.texData.get(dataId), texture = _a.texture, texShape = _a.texShape, texType = _a.texType;
            if (texture != null) {
                this.textureManager.releaseTexture(texture, texShape, texType);
            }
            this.texData.delete(dataId);
        }
    };
    MathBackendWebGL.prototype.getTexture = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId).texture;
    };
    MathBackendWebGL.prototype.getTextureData = function (dataId) {
        this.uploadToGPU(dataId);
        return this.texData.get(dataId);
    };
    MathBackendWebGL.prototype.getGPGPUContext = function () {
        return this.gpgpu;
    };
    MathBackendWebGL.prototype.slice = function (x, begin, size) {
        var program = new slice_gpu_1.SliceProgram(size);
        var customSetup = program.getCustomSetupFunc(begin);
        return this.compileAndRun(program, [x], null, customSetup);
    };
    MathBackendWebGL.prototype.reverse = function (x, axis) {
        var program = new reverse_gpu_1.ReverseProgram(x.shape, axis);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.concat = function (a, b) {
        var program = new concat_gpu_1.ConcatProgram(a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.neg = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.NEG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.matMul = function (a, b, transposeA, transposeB) {
        var program = new mulmat_gpu_1.MatMulProgram(a.shape, b.shape, transposeA, transposeB);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.multiply = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MUL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.batchNormalization4D = function (x, mean, variance, varianceEpsilon, scale, offset) {
        var inputs = [x, mean, variance];
        var offsetShape = null;
        if (offset != null) {
            offsetShape = offset.shape;
            inputs.push(offset);
        }
        var scaleShape = null;
        if (scale != null) {
            scaleShape = scale.shape;
            inputs.push(scale);
        }
        var program = new batchnorm_gpu_1.BatchNormProgram(x.shape, mean.shape, variance.shape, offsetShape, scaleShape, varianceEpsilon);
        return this.compileAndRun(program, inputs);
    };
    MathBackendWebGL.prototype.localResponseNormalization4D = function (x, radius, bias, alpha, beta, normRegion) {
        var program = new lrn_gpu_1.LRNProgram(x.shape, radius, bias, alpha, beta, normRegion);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tile = function (x, reps) {
        var program = new tile_gpu_1.TileProgram(x.shape, reps);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.pad = function (x, paddings, constantValue) {
        var program = new pad_gpu_1.PadProgram(x.shape, paddings, constantValue);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.transpose = function (x, perm) {
        var program = new transpose_gpu_1.TransposeProgram(x.shape, perm);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.gather = function (x, indices, axis) {
        var program = new gather_gpu_1.GatherProgram(x.shape, indices.size, axis);
        return this.compileAndRun(program, [x, indices]);
    };
    MathBackendWebGL.prototype.reduce = function (x, reduceType, dtype) {
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new reduce_gpu_1.ReduceProgram(reduceInfo, reduceType);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], dtype);
        this.compileAndRun(program, [x], output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.reduce(output, reduceType, dtype);
    };
    MathBackendWebGL.prototype.argReduce = function (x, reduceType, bestIndicesA) {
        if (bestIndicesA === void 0) { bestIndicesA = null; }
        var batchSize = x.shape[0];
        var inSize = x.shape[1];
        if (bestIndicesA != null) {
            batchSize = bestIndicesA.shape[0];
            inSize = bestIndicesA.shape[1];
        }
        var windowSize = reduce_util.computeOptimalWindowSize(inSize);
        var reduceInfo = { windowSize: windowSize, inSize: inSize, batchSize: batchSize };
        var program = new argminmax_gpu_1.ArgMinMaxProgram(reduceInfo, reduceType, bestIndicesA == null);
        var _a = program.outputShape, rows = _a[0], cols = _a[1];
        var output = this.makeOutputArray([rows, cols], 'int32');
        var inputs = [x];
        if (bestIndicesA != null) {
            inputs.push(bestIndicesA);
        }
        this.compileAndRun(program, inputs, output);
        if (output.shape[1] === 1) {
            return output;
        }
        return this.argReduce(x, reduceType, output);
    };
    MathBackendWebGL.prototype.sum = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('sum', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        var outputDType = types.sumOutType(x.dtype);
        return this.reduce(a2D, 'sum', outputDType).reshape(outShape);
    };
    MathBackendWebGL.prototype.argMin = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMin', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'min').reshape(outShape);
    };
    MathBackendWebGL.prototype.argMax = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('argMax', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.argReduce(a2D, 'max').reshape(outShape);
    };
    MathBackendWebGL.prototype.equal = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.notEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.NOT_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.less = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.lessEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LESS_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greater = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.greaterEqual = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.GREATER_EQUAL, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalNot = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOGICAL_NOT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.logicalAnd = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_AND, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalOr = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_OR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.logicalXor = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.LOGICAL_XOR, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'bool');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.where = function (condition, a, b, dtype) {
        var program = new logical_gpu_1.WhereProgram(condition.rank, a.shape, a.rank);
        var output = this.makeOutputArray(program.outputShape, dtype);
        return this.compileAndRun(program, [condition, a, b], output);
    };
    MathBackendWebGL.prototype.topKValues = function (x, k) {
        throw new Error('topKValues GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.topKIndices = function (x, k) {
        throw new Error('topKIndices GPU not yet implemented!');
    };
    MathBackendWebGL.prototype.min = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('min', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'min', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.minimum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MIN, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.max = function (x, axes) {
        axis_util.assertAxesAreInnerMostDims('max', axes, x.rank);
        var _a = axis_util.computeOutAndReduceShapes(x.shape, axes), outShape = _a[0], reduceShape = _a[1];
        var inSize = util.sizeFromShape(reduceShape);
        var a2D = x.as2D(-1, inSize);
        return this.reduce(a2D, 'max', a2D.dtype).reshape(outShape);
    };
    MathBackendWebGL.prototype.maximum = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.MAX, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.divide = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.DIV, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.add = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.ADD, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.subtract = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.SUB, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.pow = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.POW, a.shape, b.shape);
        var output = this.makeOutputArray(program.outputShape, types.upcastType(a.dtype, b.dtype));
        return this.compileAndRun(program, [a, b], output);
    };
    MathBackendWebGL.prototype.ceil = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.CEIL);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.floor = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.FLOOR);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.exp = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.EXP);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.log = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LOG);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sqrt = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQRT);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.square = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SQUARE);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.relu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.RELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.elu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.eluDer = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ELU_DER);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.selu = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SELU);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.leakyRelu = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.LEAKY_RELU(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.prelu = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.preluDer = function (a, b) {
        var program = new binaryop_gpu_1.BinaryOpProgram(binaryop_gpu.PRELU_DER, a.shape, b.shape);
        return this.compileAndRun(program, [a, b]);
    };
    MathBackendWebGL.prototype.int = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TO_INT);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.clip = function (x, min, max) {
        var program = new clip_gpu_1.ClipProgram(x.shape, min, max);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.abs = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ABS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sigmoid = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIGMOID);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.asin = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ASIN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.acos = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ACOS);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.atan = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.ATAN);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.sinh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.SINH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.cosh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.COSH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.tanh = function (x) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.TANH);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.step = function (x, alpha) {
        var program = new unaryop_gpu_1.UnaryOpProgram(x.shape, unary_op.STEP(alpha));
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.conv2d = function (x, filter, convInfo) {
        var program = new conv_gpu_1.Conv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerInput = function (dy, filter, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerInputProgram(convInfo);
        return this.compileAndRun(program, [dy, filter]);
    };
    MathBackendWebGL.prototype.conv2dDerFilter = function (x, dy, convInfo) {
        var program = new conv_backprop_gpu_1.Conv2DDerFilterProgram(convInfo);
        return this.compileAndRun(program, [x, dy]);
    };
    MathBackendWebGL.prototype.depthwiseConv2D = function (x, filter, convInfo) {
        var program = new conv_gpu_depthwise_1.DepthwiseConv2DProgram(convInfo);
        return this.compileAndRun(program, [x, filter]);
    };
    MathBackendWebGL.prototype.maxPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'max', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.minPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'min', false);
        var output = this.makeOutputArray(program.outputShape, x.dtype);
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.avgPool = function (x, convInfo) {
        var program = new pool_gpu_1.Pool2DProgram(convInfo, 'avg', false);
        var output = this.makeOutputArray(program.outputShape, 'float32');
        return this.compileAndRun(program, [x], output);
    };
    MathBackendWebGL.prototype.maxPoolBackprop = function (dy, x, convInfo) {
        var getPositions = true;
        var maxPoolPositionsProgram = new pool_gpu_1.Pool2DProgram(convInfo, 'max', getPositions);
        var maxPoolPositions = this.compileAndRun(maxPoolPositionsProgram, [x]);
        var maxPoolBackPropProgram = new max_pool_backprop_gpu_1.MaxPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(maxPoolBackPropProgram.outputShape, x.dtype);
        var result = this.compileAndRun(maxPoolBackPropProgram, [dy, maxPoolPositions], output);
        maxPoolPositions.dispose();
        return result;
    };
    MathBackendWebGL.prototype.avgPoolBackprop = function (dy, x, convInfo) {
        var avgPoolBackpropProgram = new avg_pool_backprop_gpu_1.AvgPool2DBackpropProgram(convInfo);
        var output = this.makeOutputArray(avgPoolBackpropProgram.outputShape, x.dtype);
        return this.compileAndRun(avgPoolBackpropProgram, [dy], output);
    };
    MathBackendWebGL.prototype.resizeBilinear = function (x, newHeight, newWidth, alignCorners) {
        var program = new resize_bilinear_gpu_1.ResizeBilinearProgram(x.shape, newHeight, newWidth, alignCorners);
        return this.compileAndRun(program, [x]);
    };
    MathBackendWebGL.prototype.multinomial = function (probs, numSamples, seed) {
        var batchSize = probs.shape[0];
        var numOutcomes = probs.shape[1];
        var program = new multinomial_gpu_1.MultinomialProgram(batchSize, numOutcomes, numSamples);
        var output = this.makeOutputArray(program.outputShape, 'int32');
        var customSetup = program.getCustomSetupFunc(seed);
        return this.compileAndRun(program, [probs], output, customSetup);
    };
    MathBackendWebGL.prototype.oneHot = function (indices, depth, onValue, offValue) {
        var program = new onehot_gpu_1.OneHotProgram(indices.size, depth, onValue, offValue);
        return this.compileAndRun(program, [indices]);
    };
    MathBackendWebGL.prototype.makeOutputArray = function (shape, dtype) {
        return tensor_1.Tensor.make(shape, {}, dtype);
    };
    MathBackendWebGL.prototype.compileAndRun = function (program, inputs, output, customSetup) {
        var _this = this;
        if (output == null) {
            output = this.makeOutputArray(program.outputShape, inputs[0].dtype);
        }
        var inputsData = inputs.map(function (input) {
            _this.uploadToGPU(input.dataId);
            return { tensor: input, texData: _this.texData.get(input.dataId) };
        });
        this.uploadToGPU(output.dataId);
        var outputData = {
            tensor: output,
            texData: this.texData.get(output.dataId)
        };
        var key = gpgpu_math.makeShaderKey(program, inputsData, outputData);
        var binary = this.getAndSaveBinary(key, function () {
            return gpgpu_math.compileProgram(_this.gpgpu, program, inputsData, outputData);
        });
        var shouldTimeProgram = this.activeTimers != null;
        var query;
        if (shouldTimeProgram) {
            query = this.startTimer();
        }
        gpgpu_math.runProgram(binary, inputsData, outputData, customSetup);
        if (shouldTimeProgram) {
            query = this.endTimer(query);
            this.activeTimers.push(this.getQueryTime(query));
        }
        return output;
    };
    MathBackendWebGL.prototype.getAndSaveBinary = function (key, getBinary) {
        if (!(key in this.binaryCache)) {
            this.binaryCache[key] = getBinary();
        }
        return this.binaryCache[key];
    };
    MathBackendWebGL.prototype.getTextureManager = function () {
        return this.textureManager;
    };
    MathBackendWebGL.prototype.dispose = function () {
        if (this.disposed) {
            return;
        }
        for (var key in this.binaryCache) {
            this.gpgpu.deleteProgram(this.binaryCache[key].webGLProgram);
        }
        this.textureManager.dispose();
        this.canvas.remove();
        if (this.gpgpuCreatedLocally) {
            this.gpgpu.dispose();
        }
        this.disposed = true;
    };
    MathBackendWebGL.prototype.throwIfNoData = function (dataId) {
        if (!this.texData.has(dataId)) {
            throw new Error("WebGL backend: No data found for this tensor. " +
                "Did you change your backend in the middle of the program? " +
                "New backends can't use Tensors created with previous backends");
        }
    };
    MathBackendWebGL.prototype.uploadToGPU = function (dataId) {
        this.throwIfNoData(dataId);
        var texData = this.texData.get(dataId);
        var shape = texData.shape, values = texData.values, texture = texData.texture, dtype = texData.dtype, texType = texData.texType;
        if (texture != null) {
            return;
        }
        var shouldTimeProgram = this.activeTimers != null;
        var start;
        if (shouldTimeProgram) {
            start = performance.now();
        }
        var texShape = webgl_util.getTextureShapeFromLogicalShape(this.gpgpu.gl, shape);
        texData.texShape = texShape;
        var newTexture = this.textureManager.acquireTexture(texShape, texType);
        texData.texture = newTexture;
        if (values != null) {
            this.gpgpu.uploadMatrixToTexture(newTexture, texShape[0], texShape[1], typedArrayToFloat32(values, dtype));
            texData.values = null;
            if (shouldTimeProgram) {
                this.uploadWaitMs += performance.now() - start;
            }
        }
    };
    MathBackendWebGL.prototype.cacheOnCPU = function (dataId, float32Values) {
        var dontKeepCopyOnGPU = this.delayedStorage;
        var texData = this.texData.get(dataId);
        var texture = texData.texture, texShape = texData.texShape, dtype = texData.dtype, texType = texData.texType;
        if (dontKeepCopyOnGPU && texture != null) {
            this.textureManager.releaseTexture(texture, texShape, texType);
            texData.texture = null;
            texData.texShape = null;
        }
        if (float32Values != null) {
            texData.values = float32ToTypedArray(float32Values, dtype);
        }
    };
    return MathBackendWebGL;
}());
exports.MathBackendWebGL = MathBackendWebGL;
environment_1.ENV.registerBackend('webgl', function () { return new MathBackendWebGL(); });
var NDArrayMathGPU = (function (_super) {
    __extends(NDArrayMathGPU, _super);
    function NDArrayMathGPU(gpgpu, safeMode) {
        if (safeMode === void 0) { safeMode = false; }
        var _this = this;
        console.warn('new NDArrayMathGPU() is deprecated. Please use ' +
            'dl.setBackend(\'webgl\').');
        _this = _super.call(this, new MathBackendWebGL(gpgpu), safeMode) || this;
        return _this;
    }
    return NDArrayMathGPU;
}(math_1.NDArrayMath));
exports.NDArrayMathGPU = NDArrayMathGPU;
function float32ToTypedArray(a, dtype) {
    if (dtype === 'float32') {
        return a;
    }
    else if (dtype === 'int32' || dtype === 'bool') {
        var result = (dtype === 'int32') ? new Int32Array(a.length) :
            new Uint8Array(a.length);
        for (var i = 0; i < result.length; ++i) {
            var val = a[i];
            val = isNaN(val) ? util.getNaN(dtype) : Math.round(val);
            result[i] = val;
        }
        return result;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
function typedArrayToFloat32(a, dtype) {
    if (a instanceof Float32Array) {
        return a;
    }
    else {
        var res = new Float32Array(a.length);
        for (var i = 0; i < res.length; i++) {
            var val = a[i];
            res[i] = util.isValNaN(val, dtype) ? NaN : val;
        }
        return res;
    }
}

},{"../environment":27,"../math":96,"../ops/axis_util":98,"../ops/reduce_util":117,"../tensor":137,"../types":142,"../util":143,"./webgl/argminmax_gpu":63,"./webgl/avg_pool_backprop_gpu":64,"./webgl/batchnorm_gpu":65,"./webgl/binaryop_gpu":66,"./webgl/clip_gpu":67,"./webgl/concat_gpu":68,"./webgl/conv_backprop_gpu":69,"./webgl/conv_gpu":70,"./webgl/conv_gpu_depthwise":71,"./webgl/from_pixels_gpu":72,"./webgl/gather_gpu":73,"./webgl/gpgpu_context":74,"./webgl/gpgpu_math":75,"./webgl/logical_gpu":77,"./webgl/lrn_gpu":78,"./webgl/max_pool_backprop_gpu":79,"./webgl/mulmat_gpu":80,"./webgl/multinomial_gpu":81,"./webgl/onehot_gpu":82,"./webgl/pad_gpu":83,"./webgl/pool_gpu":84,"./webgl/reduce_gpu":85,"./webgl/resize_bilinear_gpu":86,"./webgl/reverse_gpu":87,"./webgl/slice_gpu":89,"./webgl/tex_util":90,"./webgl/texture_manager":91,"./webgl/tile_gpu":92,"./webgl/transpose_gpu":93,"./webgl/unaryop_gpu":94,"./webgl/webgl_util":95}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ArgMinMaxProgram = (function () {
    function ArgMinMaxProgram(reduceInfo, op, firstPass) {
        this.variableNames = ['A'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        if (!firstPass) {
            this.variableNames.push('bestIndicesA');
        }
        this.outputShape = [batchSize, outSize];
        var compOp = (op === 'max') ? '>' : '<';
        var indexSnippet = firstPass ?
            'inOffset + i;' :
            'round(getBestIndicesA(batch, inOffset + i));';
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        int bestIndex = 0;\n        float bestValue = getA(batch, inOffset);\n\n        for (int i = 0; i < " + windowSize + "; i++) {\n          int inIdx = " + indexSnippet + ";\n          float candidate = getA(batch, inIdx);\n          if (isNaN(candidate)) {\n            setOutput(candidate);\n            return;\n          }\n          if (candidate " + compOp + " bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ";
    }
    return ArgMinMaxProgram;
}());
exports.ArgMinMaxProgram = ArgMinMaxProgram;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AvgPool2DBackpropProgram = (function () {
    function AvgPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var avgMultiplier = 1 / (filterHeight * filterWidth);
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float avgMultiplier = float(" + avgMultiplier + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return AvgPool2DBackpropProgram;
}());
exports.AvgPool2DBackpropProgram = AvgPool2DBackpropProgram;

},{}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var BatchNormProgram = (function () {
    function BatchNormProgram(xShape, meanShape, varianceShape, offsetShape, scaleShape, varianceEpsilon) {
        this.outputShape = [];
        this.supportsBroadcasting = true;
        this.variableNames = ['x', 'mean', 'variance'];
        broadcast_util.assertAndGetBroadcastShape(xShape, meanShape);
        broadcast_util.assertAndGetBroadcastShape(xShape, varianceShape);
        var offsetSnippet = '0.0';
        if (offsetShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, offsetShape);
            this.variableNames.push('offset');
            offsetSnippet = 'getOffsetAtOutCoords()';
        }
        var scaleSnippet = '1.0';
        if (scaleShape != null) {
            broadcast_util.assertAndGetBroadcastShape(xShape, scaleShape);
            this.variableNames.push('scale');
            scaleSnippet = 'getScaleAtOutCoords()';
        }
        this.outputShape = xShape;
        this.userCode = "\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = " + offsetSnippet + ";\n        float scale = " + scaleSnippet + ";\n        float inv = scale / sqrt(variance + float(" + varianceEpsilon + "));\n        setOutput((x - mean) * inv + offset);\n      }\n    ";
    }
    return BatchNormProgram;
}());
exports.BatchNormProgram = BatchNormProgram;

},{"../../ops/broadcast_util":101}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var broadcast_util = require("../../ops/broadcast_util");
var CHECK_NAN_SNIPPET = "\n  if (isNaN(a)) return a;\n  if (isNaN(b)) return b;\n";
exports.ADD = 'return a + b;';
exports.SUB = 'return a - b;';
exports.MUL = 'return a * b;';
exports.DIV = 'return a / b;';
exports.POW = "\n  return (round(mod(b, 2.0)) == 0 || round(mod(b, 2.0)) == 2) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
exports.EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a == b);\n";
exports.NOT_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a != b);\n";
exports.LESS = CHECK_NAN_SNIPPET + "\n  return float(a < b);\n";
exports.LESS_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a <= b);\n";
exports.GREATER = CHECK_NAN_SNIPPET + "\n  return float(a > b);\n";
exports.GREATER_EQUAL = CHECK_NAN_SNIPPET + "\n  return float(a >= b);\n";
exports.LOGICAL_AND = CHECK_NAN_SNIPPET + "\n  return float(a >= 1.0 && b >= 1.0);\n";
exports.LOGICAL_OR = CHECK_NAN_SNIPPET + "\n  return float(a >= 1.0 || b >= 1.0);\n";
exports.LOGICAL_XOR = CHECK_NAN_SNIPPET + "\n  return float(a >= 1.0 ^^ b >= 1.0);\n";
exports.PRELU = "\n  return (a >= 0.0) ? a : b * a;\n";
exports.PRELU_DER = "\n  return (a > 0.0) ? 1.0 : ((a < 0.0) ? b : a);\n";
exports.MAX = CHECK_NAN_SNIPPET + "\n  return max(a, b);\n";
exports.MIN = CHECK_NAN_SNIPPET + "\n  return min(a, b);\n";
var BinaryOpProgram = (function () {
    function BinaryOpProgram(op, aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.supportsBroadcasting = true;
        this.outputShape =
            broadcast_util.assertAndGetBroadcastShape(aShape, bShape);
        this.userCode = "\n      float binaryOperation(float a, float b) {\n        " + op + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
    }
    return BinaryOpProgram;
}());
exports.BinaryOpProgram = BinaryOpProgram;

},{"../../ops/broadcast_util":101}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ClipProgram = (function () {
    function ClipProgram(aShape, min, max) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        var minFixed = min.toFixed(20);
        var maxFixed = max.toFixed(20);
        this.userCode = "\n      void main() {\n        float value = getAAtOutCoords();\n        if (isNaN(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, " + minFixed + ", " + maxFixed + "));\n      }\n    ";
    }
    return ClipProgram;
}());
exports.ClipProgram = ClipProgram;

},{}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var concat_util = require("../../ops/concat_util");
var ConcatProgram = (function () {
    function ConcatProgram(aShape, bShape) {
        this.variableNames = ['A', 'B'];
        this.outputShape = [];
        this.outputShape =
            concat_util.computeOutShape(aShape, bShape, 1);
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        float value = 0.0;\n        if (yC < " + aShape[1] + ") {\n          value = getA(yR, yC);\n        } else {\n          yC -= " + aShape[1] + ";\n          value = getB(yR, yC);\n        }\n\n        setOutput(value);\n      }\n    ";
    }
    return ConcatProgram;
}());
exports.ConcatProgram = ConcatProgram;

},{"../../ops/concat_util":104}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DDerFilterProgram = (function () {
    function Conv2DDerFilterProgram(convInfo) {
        this.variableNames = ['x', 'dy'];
        this.outputShape = convInfo.filterShape;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.userCode = "\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < " + convInfo.batchSize + "; b++) {\n          for (int yR = 0; yR < " + convInfo.outHeight + "; yR++) {\n            int xR = wR + yR * " + strideHeight + " - " + padTop + ";\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int yC = 0; yC < " + convInfo.outWidth + "; yC++) {\n              int xC = wC + yC * " + strideWidth + " - " + padLeft + ";\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerFilterProgram;
}());
exports.Conv2DDerFilterProgram = Conv2DDerFilterProgram;
var Conv2DDerInputProgram = (function () {
    function Conv2DDerInputProgram(convInfo) {
        this.variableNames = ['dy', 'W'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + filterHeight + " - 1 - wR;\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + filterWidth + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + convInfo.outChannels + "; d2++) {\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, d2);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DDerInputProgram;
}());
exports.Conv2DDerInputProgram = Conv2DDerInputProgram;

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Conv2DProgram = (function () {
    function Conv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var inputDepthNearestVec4 = Math.floor(convInfo.inChannels / 4) * 4;
        var inputDepthVec4Remainder = convInfo.inChannels % 4;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + inputDepthNearestVec4 + "; d1 += 4) {\n              vec4 xValues = vec4(\n                getX(batch, xR, xC, d1),\n                getX(batch, xR, xC, d1 + 1),\n                getX(batch, xR, xC, d1 + 2),\n                getX(batch, xR, xC, d1 + 3)\n              );\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              dotProd += dot(xValues, wValues);\n            }\n\n            if (" + (inputDepthVec4Remainder === 1) + ") {\n              dotProd +=\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + ") *\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2);\n            } else if (" + (inputDepthVec4Remainder === 2) + ") {\n              vec2 xValues = vec2(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1)\n              );\n              vec2 wValues = vec2(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            } else if (" + (inputDepthVec4Remainder === 3) + ") {\n              vec3 xValues = vec3(\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + "),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 1),\n                getX(batch, xR, xC, " + inputDepthNearestVec4 + " + 2)\n              );\n              vec3 wValues = vec3(\n                getW(wR, wC, " + inputDepthNearestVec4 + ", d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 1, d2),\n                getW(wR, wC, " + inputDepthNearestVec4 + " + 2, d2)\n              );\n              dotProd += dot(xValues, wValues);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return Conv2DProgram;
}());
exports.Conv2DProgram = Conv2DProgram;

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DepthwiseConv2DProgram = (function () {
    function DepthwiseConv2DProgram(convInfo) {
        this.variableNames = ['x', 'W'];
        this.outputShape = convInfo.outShape;
        var xNumRows = convInfo.inHeight;
        var xNumCols = convInfo.inWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var channelMul = convInfo.outChannels / convInfo.inChannels;
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + channelMul + ";\n        int q = d2 - d1 * " + channelMul + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TODO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + xNumRows + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            int xC = xCCorner + wC;\n\n            if (xC < 0 || xC >= " + xNumCols + ") {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return DepthwiseConv2DProgram;
}());
exports.DepthwiseConv2DProgram = DepthwiseConv2DProgram;

},{}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FromPixelsProgram = (function () {
    function FromPixelsProgram(outputShape) {
        this.variableNames = ['A'];
        var height = outputShape[0], width = outputShape[1];
        this.outputShape = outputShape;
        this.userCode = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + width + ".0, " + height + ".0);\n\n        vec4 values = texture2D(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
    }
    return FromPixelsProgram;
}());
exports.FromPixelsProgram = FromPixelsProgram;

},{}],73:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var GatherProgram = (function () {
    function GatherProgram(aShape, indicesLength, axis) {
        this.variableNames = ['A', 'indices'];
        var outputShape = aShape.slice();
        outputShape[axis] = indicesLength;
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape, axis);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return GatherProgram;
}());
exports.GatherProgram = GatherProgram;
function getSourceCoords(aShape, axis) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Gather for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "int(getIndices(resRC))";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        if (i === axis) {
            sourceCoords.push("int(getIndices(" + currentCoords[i] + "))");
        }
        else {
            sourceCoords.push("" + currentCoords[i]);
        }
    }
    return sourceCoords.join();
}

},{"./shader_compiler":88}],74:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var gpgpu_util = require("./gpgpu_util");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
var GPGPUContext = (function () {
    function GPGPUContext(gl) {
        this.outputTexture = null;
        this.program = null;
        this.disposed = false;
        this.autoDebugValidate = false;
        this.firstProgram = true;
        if (gl != null) {
            this.gl = gl;
        }
        else {
            this.gl = gpgpu_util.createWebGLContext();
        }
        if (environment_1.ENV.get('WEBGL_VERSION') === 1) {
            this.textureFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'OES_texture_float');
            this.colorBufferFloatExtension =
                this.gl.getExtension('WEBGL_color_buffer_float');
        }
        else {
            this.colorBufferFloatExtension =
                webgl_util.getExtensionOrThrow(this.gl, 'EXT_color_buffer_float');
        }
        this.loseContextExtension =
            webgl_util.getExtensionOrThrow(this.gl, 'WEBGL_lose_context');
        if (environment_1.ENV.get('WEBGL_GET_BUFFER_SUB_DATA_ASYNC_EXTENSION_ENABLED')) {
            this.getBufferSubDataAsyncExtension =
                this.gl.getExtension('WEBGL_get_buffer_sub_data_async');
        }
        this.vertexBuffer = gpgpu_util.createVertexBuffer(this.gl);
        this.indexBuffer = gpgpu_util.createIndexBuffer(this.gl);
        this.framebuffer = webgl_util.createFramebuffer(this.gl);
    }
    GPGPUContext.prototype.dispose = function () {
        var _this = this;
        if (this.disposed) {
            return;
        }
        if (this.program != null) {
            console.warn('Disposing a GPGPUContext that still has a bound WebGLProgram.' +
                ' This is probably a resource leak, delete the program with ' +
                'GPGPUContext.deleteProgram before disposing.');
        }
        if (this.outputTexture != null) {
            console.warn('Disposing a GPGPUContext that still has a bound output matrix ' +
                'texture.  This is probably a resource leak, delete the output ' +
                'matrix texture with GPGPUContext.deleteMatrixTexture before ' +
                'disposing.');
        }
        var gl = this.gl;
        webgl_util.callAndCheck(gl, function () { return gl.finish(); });
        webgl_util.callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteFramebuffer(_this.framebuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.vertexBuffer); });
        webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null); });
        webgl_util.callAndCheck(gl, function () { return gl.deleteBuffer(_this.indexBuffer); });
        this.loseContextExtension.loseContext();
        this.disposed = true;
    };
    GPGPUContext.prototype.enableAutomaticDebugValidation = function (enabled) {
        this.autoDebugValidate = enabled;
        webgl_util.enableDebugWebGLErrorChecking(enabled);
    };
    GPGPUContext.prototype.createMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.uploadPixelDataToTexture = function (texture, pixels) {
        this.throwIfDisposed();
        gpgpu_util.uploadPixelDataToTexture(this.gl, texture, pixels);
    };
    GPGPUContext.prototype.createPackedMatrixTexture = function (rows, columns) {
        this.throwIfDisposed();
        return gpgpu_util.createPackedMatrixTexture(this.gl, rows, columns);
    };
    GPGPUContext.prototype.deleteMatrixTexture = function (texture) {
        var _this = this;
        this.throwIfDisposed();
        if (this.outputTexture === texture) {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
            this.outputTexture = null;
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteTexture(texture); });
    };
    GPGPUContext.prototype.uploadMatrixToTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        var numChannels = 1;
        return gpgpu_util.uploadMatrixToTexture(this.gl, texture, rows, columns, matrix, numChannels);
    };
    GPGPUContext.prototype.uploadMatrixToPackedTexture = function (texture, rows, columns, matrix) {
        this.throwIfDisposed();
        return gpgpu_util.uploadMatrixToPackedTexture(this.gl, texture, rows, columns, matrix);
    };
    GPGPUContext.prototype.downloadMatrixFromTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () {
            return gpgpu_util.downloadMatrixFromOutputTexture(_this.gl, rows, columns);
        });
    };
    GPGPUContext.prototype.downloadMatrixFromTextureAsync = function (texture, rows, columns) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                if (this.getBufferSubDataAsyncExtension == null) {
                    throw new Error("Cannot download matrix from output texture asynchronously, " +
                        "WEBGL_get_buffer_sub_data_async is not enabled.");
                }
                return [2, this.downloadMatrixDriverAsync(texture, function () { return gpgpu_util.downloadMatrixFromOutputTextureAsync(_this.gl, _this.getBufferSubDataAsyncExtension, rows, columns); })];
            });
        });
    };
    GPGPUContext.prototype.downloadMatrixFromRGBAColorTexture = function (texture, rows, columns, channels) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromRGBAColorTexture(_this.gl, rows, columns, channels); });
    };
    GPGPUContext.prototype.downloadMatrixFromPackedTexture = function (texture, rows, columns) {
        var _this = this;
        return this.downloadMatrixDriver(texture, function () { return gpgpu_util.downloadMatrixFromPackedOutputTexture(_this.gl, rows, columns); });
    };
    GPGPUContext.prototype.createProgram = function (fragmentShaderSource) {
        this.throwIfDisposed();
        var gl = this.gl;
        var fragmentShader = webgl_util.createFragmentShader(gl, fragmentShaderSource);
        var vertexShader = gpgpu_util.createVertexShader(gl);
        var program = webgl_util.createProgram(gl);
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, vertexShader); });
        webgl_util.callAndCheck(gl, function () { return gl.attachShader(program, fragmentShader); });
        webgl_util.linkProgram(gl, program);
        if (this.autoDebugValidate) {
            webgl_util.validateProgram(gl, program);
        }
        if (this.firstProgram) {
            this.firstProgram = false;
            this.setProgram(program);
            gpgpu_util.bindVertexProgramAttributeStreams(gl, this.program, this.vertexBuffer);
        }
        return program;
    };
    GPGPUContext.prototype.deleteProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        if (program === this.program) {
            this.program = null;
        }
        if (program != null) {
            webgl_util.callAndCheck(this.gl, function () { return _this.gl.deleteProgram(program); });
        }
    };
    GPGPUContext.prototype.setProgram = function (program) {
        var _this = this;
        this.throwIfDisposed();
        this.program = program;
        if ((this.program != null) && this.autoDebugValidate) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.useProgram(program); });
    };
    GPGPUContext.prototype.getUniformLocation = function (program, uniformName, shouldThrow) {
        if (shouldThrow === void 0) { shouldThrow = true; }
        this.throwIfDisposed();
        if (shouldThrow) {
            return webgl_util.getProgramUniformLocationOrThrow(this.gl, program, uniformName);
        }
        else {
            return webgl_util.getProgramUniformLocation(this.gl, program, uniformName);
        }
    };
    GPGPUContext.prototype.getAttributeLocation = function (program, attribute) {
        var _this = this;
        this.throwIfDisposed();
        return webgl_util.callAndCheck(this.gl, function () { return _this.gl.getAttribLocation(program, attribute); });
    };
    GPGPUContext.prototype.getUniformLocationNoThrow = function (program, uniformName) {
        this.throwIfDisposed();
        return this.gl.getUniformLocation(program, uniformName);
    };
    GPGPUContext.prototype.setInputMatrixTexture = function (inputMatrixTexture, uniformLocation, textureUnit) {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        webgl_util.bindTextureToProgramUniformSampler(this.gl, this.program, inputMatrixTexture, uniformLocation, textureUnit);
    };
    GPGPUContext.prototype.setOutputMatrixTexture = function (outputMatrixTexture, rows, columns) {
        this.setOutputMatrixTextureDriver(outputMatrixTexture, columns, rows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixTexture = function (outputPackedMatrixTexture, rows, columns) {
        this.throwIfDisposed();
        var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
        this.setOutputMatrixTextureDriver(outputPackedMatrixTexture, width, height);
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        this.setOutputMatrixWriteRegionDriver(startColumn, startRow, numColumns, numRows);
    };
    GPGPUContext.prototype.setOutputPackedMatrixWriteRegion = function (startRow, numRows, startColumn, numColumns) {
        throw new Error('setOutputPackedMatrixWriteRegion not implemented.');
    };
    GPGPUContext.prototype.debugValidate = function () {
        if (this.program != null) {
            webgl_util.validateProgram(this.gl, this.program);
        }
        webgl_util.validateFramebuffer(this.gl);
    };
    GPGPUContext.prototype.executeProgram = function () {
        this.throwIfDisposed();
        this.throwIfNoProgram();
        var gl = this.gl;
        if (this.autoDebugValidate) {
            this.debugValidate();
        }
        webgl_util.callAndCheck(gl, function () { return gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0); });
    };
    GPGPUContext.prototype.blockUntilAllProgramsCompleted = function () {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.finish(); });
    };
    GPGPUContext.prototype.getQueryTimerExtension = function () {
        if (this.disjointQueryTimerExtension == null) {
            this.disjointQueryTimerExtension =
                webgl_util.getExtensionOrThrow(this.gl, environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2 ?
                    'EXT_disjoint_timer_query_webgl2' :
                    'EXT_disjoint_timer_query');
        }
        return this.disjointQueryTimerExtension;
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL2 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.getQueryTimerExtensionWebGL1 = function () {
        return this.getQueryTimerExtension();
    };
    GPGPUContext.prototype.runQuery = function (queryFn) {
        var query = this.beginQuery();
        queryFn();
        this.endQuery();
        return this.pollQueryTime(query);
    };
    GPGPUContext.prototype.beginQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_1 = this.getQueryTimerExtensionWebGL2();
            var query_1 = gl2.createQuery();
            gl2.beginQuery(ext_1.TIME_ELAPSED_EXT, query_1);
            return query_1;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        var query = ext.createQueryEXT();
        ext.beginQueryEXT(ext.TIME_ELAPSED_EXT, query);
        return query;
    };
    GPGPUContext.prototype.endQuery = function () {
        if (environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION') === 2) {
            var gl2 = this.gl;
            var ext_2 = this.getQueryTimerExtensionWebGL2();
            gl2.endQuery(ext_2.TIME_ELAPSED_EXT);
            return;
        }
        var ext = this.getQueryTimerExtensionWebGL1();
        ext.endQueryEXT(ext.TIME_ELAPSED_EXT);
    };
    GPGPUContext.prototype.isQueryAvailable = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return true;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var ext = this.getQueryTimerExtensionWebGL2();
            var available = gl2.getQueryParameter(query, gl2.QUERY_RESULT_AVAILABLE);
            var disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            return available && !disjoint;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var available = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_AVAILABLE_EXT);
            var disjoint = this.gl.getParameter(ext.GPU_DISJOINT_EXT);
            return available && !disjoint;
        }
    };
    GPGPUContext.prototype.pollQueryTime = function (query) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var resolveWithWarning = function () {
                console.warn('Disjoint query timer never available.');
                resolve(-1);
            };
            var queryTimerVersion = environment_1.ENV.get('WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION');
            util.repeatedTry(function () { return _this.isQueryAvailable(query, queryTimerVersion); })
                .then(function () { return resolve(_this.getQueryTime(query, queryTimerVersion)); })
                .catch(resolveWithWarning);
        });
    };
    GPGPUContext.prototype.getQueryTime = function (query, queryTimerVersion) {
        if (queryTimerVersion === 0) {
            return null;
        }
        if (queryTimerVersion === 2) {
            var gl2 = this.gl;
            var timeElapsedNanos = gl2.getQueryParameter(query, gl2.QUERY_RESULT);
            return timeElapsedNanos / 1000000;
        }
        else {
            var ext = this.getQueryTimerExtensionWebGL1();
            var timeElapsedNanos = ext.getQueryObjectEXT(query, ext.QUERY_RESULT_EXT);
            return timeElapsedNanos / 1000000;
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverSetup = function (texture) {
        this.throwIfDisposed();
        webgl_util.bindColorTextureToFramebuffer(this.gl, texture, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(this.gl);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriverTeardown = function () {
        if (this.outputTexture != null) {
            webgl_util.bindColorTextureToFramebuffer(this.gl, this.outputTexture, this.framebuffer);
            if (this.autoDebugValidate) {
                webgl_util.validateFramebuffer(this.gl);
            }
        }
        else {
            webgl_util.unbindColorTextureFromFramebuffer(this.gl, this.framebuffer);
        }
    };
    GPGPUContext.prototype.downloadMatrixDriver = function (texture, downloadAndDecode) {
        this.downloadMatrixDriverSetup(texture);
        var result = downloadAndDecode();
        this.downloadMatrixDriverTeardown();
        return result;
    };
    GPGPUContext.prototype.downloadMatrixDriverAsync = function (texture, downloadAndDecode) {
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.downloadMatrixDriverSetup(texture);
                        return [4, downloadAndDecode()];
                    case 1:
                        result = _a.sent();
                        this.downloadMatrixDriverTeardown();
                        return [2, result];
                }
            });
        });
    };
    GPGPUContext.prototype.setOutputMatrixTextureDriver = function (outputMatrixTextureMaybePacked, width, height) {
        this.throwIfDisposed();
        var gl = this.gl;
        webgl_util.bindColorTextureToFramebuffer(gl, outputMatrixTextureMaybePacked, this.framebuffer);
        if (this.autoDebugValidate) {
            webgl_util.validateFramebuffer(gl);
        }
        this.outputTexture = outputMatrixTextureMaybePacked;
        webgl_util.callAndCheck(gl, function () { return gl.viewport(0, 0, width, height); });
        webgl_util.callAndCheck(gl, function () { return gl.scissor(0, 0, width, height); });
    };
    GPGPUContext.prototype.setOutputMatrixWriteRegionDriver = function (x, y, width, height) {
        var _this = this;
        this.throwIfDisposed();
        webgl_util.callAndCheck(this.gl, function () { return _this.gl.scissor(x, y, width, height); });
    };
    GPGPUContext.prototype.throwIfDisposed = function () {
        if (this.disposed) {
            throw new Error('Attempted to use disposed GPGPUContext.');
        }
    };
    GPGPUContext.prototype.throwIfNoProgram = function () {
        if (this.program == null) {
            throw new Error('No GPU program is currently set.');
        }
    };
    return GPGPUContext;
}());
exports.GPGPUContext = GPGPUContext;

},{"../../environment":27,"../../util":143,"./gpgpu_util":76,"./tex_util":90,"./webgl_util":95}],75:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var shader_compiler = require("./shader_compiler");
var NAN_UNIFORM_NAME = 'NaN';
function shouldUploadNaNUniform() {
    return !environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
}
function compileProgram(gpgpu, program, inputs, output) {
    var userCode = program.userCode;
    var inputInfos = inputs.map(function (input, i) {
        var shapeInfo = {
            logicalShape: input.tensor.shape,
            texShape: input.texData.texShape
        };
        return { name: program.variableNames[i], shapeInfo: shapeInfo };
    });
    var inShapeInfos = inputInfos.map(function (x) { return x.shapeInfo; });
    var outShapeInfo = {
        logicalShape: output.tensor.shape,
        texShape: output.texData.texShape
    };
    var source = shader_compiler.makeShader(inputInfos, outShapeInfo, userCode, program.supportsBroadcasting === true);
    var webGLProgram = gpgpu.createProgram(source);
    var uniformLocations = {};
    for (var i = 0; i < program.variableNames.length; i++) {
        var uniformName = program.variableNames[i];
        uniformLocations[uniformName] =
            gpgpu.getUniformLocation(webGLProgram, uniformName);
    }
    if (shouldUploadNaNUniform()) {
        var throwIfNaNUniformIsNotUsed = false;
        uniformLocations[NAN_UNIFORM_NAME] = gpgpu.getUniformLocation(webGLProgram, NAN_UNIFORM_NAME, throwIfNaNUniformIsNotUsed);
    }
    return {
        program: program,
        source: source,
        webGLProgram: webGLProgram,
        uniformLocations: uniformLocations,
        gpgpu: gpgpu,
        inShapeInfos: inShapeInfos,
        outShapeInfo: outShapeInfo
    };
}
exports.compileProgram = compileProgram;
function validateBinaryAndProgram(shapeInfos, inputs) {
    if (shapeInfos.length !== inputs.length) {
        throw Error("Binary was compiled with " + shapeInfos.length + " inputs, but " +
            ("was executed with " + inputs.length + " inputs"));
    }
    shapeInfos.forEach(function (s, i) {
        var shapeA = s.logicalShape;
        var texShapeA = s.texShape;
        var shapeB = inputs[i].tensor.shape;
        var texShapeB = inputs[i].texData.texShape;
        if (!util.arraysEqual(shapeA, shapeB)) {
            throw Error("Binary was compiled with different shapes than " +
                ("the current args. Shapes " + shapeA + " and " + shapeB + " must match"));
        }
        if (!util.arraysEqual(texShapeA, texShapeB)) {
            throw Error("Binary was compiled with different texture shapes than the" +
                (" current args. Shape " + texShapeA + " and " + texShapeB + " must match"));
        }
    });
}
function runProgram(binary, inputs, output, customSetup) {
    validateBinaryAndProgram(binary.inShapeInfos, inputs);
    validateBinaryAndProgram([binary.outShapeInfo], [output]);
    var outTex = output.texData.texture;
    var outTexShape = output.texData.texShape;
    var gpgpu = binary.gpgpu;
    gpgpu.setOutputMatrixTexture(outTex, outTexShape[0], outTexShape[1]);
    gpgpu.setProgram(binary.webGLProgram);
    inputs.forEach(function (input, i) {
        var tex = input.texData.texture;
        var variableName = binary.program.variableNames[i];
        var variableUniformLocation = binary.uniformLocations[variableName];
        gpgpu.setInputMatrixTexture(tex, variableUniformLocation, i);
    });
    if (shouldUploadNaNUniform()) {
        gpgpu.gl.uniform1f(binary.uniformLocations[NAN_UNIFORM_NAME], NaN);
    }
    if (customSetup != null) {
        customSetup(gpgpu, binary.webGLProgram);
    }
    gpgpu.executeProgram();
}
exports.runProgram = runProgram;
function makeShaderKey(program, inputs, output) {
    var keyInputs = '';
    inputs.concat(output).forEach(function (x) {
        keyInputs += x.tensor.shape + "_" + x.texData.texShape;
    });
    var keyUserCode = program.userCode;
    var keyBroadcast = (program.supportsBroadcasting === true).toString();
    var key = program.constructor.name;
    key += '_' + keyBroadcast + '_' + keyInputs + '_' + keyUserCode;
    return key;
}
exports.makeShaderKey = makeShaderKey;

},{"../../environment":27,"../../util":143,"./shader_compiler":88}],76:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var tex_util = require("./tex_util");
var webgl_util = require("./webgl_util");
function getWebGLContextAttributes() {
    return {
        alpha: false,
        antialias: false,
        premultipliedAlpha: false,
        preserveDrawingBuffer: false,
        depth: false,
        stencil: false,
        failIfMajorPerformanceCaveat: true
    };
}
exports.getWebGLContextAttributes = getWebGLContextAttributes;
function createWebGLContext(canvas) {
    var attributes = getWebGLContextAttributes();
    var gl;
    if (canvas != null) {
        gl = webgl_util.createWebGLRenderingContextFromCanvas(canvas, attributes);
    }
    else {
        gl = webgl_util.createWebGLRenderingContext(attributes);
    }
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DEPTH_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.STENCIL_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.BLEND); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.DITHER); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.POLYGON_OFFSET_FILL); });
    webgl_util.callAndCheck(gl, function () { return gl.disable(gl.SAMPLE_COVERAGE); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.SCISSOR_TEST); });
    webgl_util.callAndCheck(gl, function () { return gl.enable(gl.CULL_FACE); });
    webgl_util.callAndCheck(gl, function () { return gl.cullFace(gl.BACK); });
    return gl;
}
exports.createWebGLContext = createWebGLContext;
function createVertexShader(gl) {
    var vertexShaderSource = "\n    precision highp float;\n    attribute vec3 clipSpacePos;\n    attribute vec2 uv;\n    varying vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
    return webgl_util.createVertexShader(gl, vertexShaderSource);
}
exports.createVertexShader = createVertexShader;
function createVertexBuffer(gl) {
    var vertexArray = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
    return webgl_util.createStaticVertexBuffer(gl, vertexArray);
}
exports.createVertexBuffer = createVertexBuffer;
function createIndexBuffer(gl) {
    var triangleVertexIndices = new Uint16Array([0, 1, 2, 2, 1, 3]);
    return webgl_util.createStaticIndexBuffer(gl, triangleVertexIndices);
}
exports.createIndexBuffer = createIndexBuffer;
function getTextureInternalFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA32F;
        }
        return gl.R32F;
    }
    return gl.RGBA;
}
function getTextureFormat(gl, numChannels) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.RGBA;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        if (numChannels === 4) {
            return gl.RGBA;
        }
        return gl.RED;
    }
    return gl.RGBA;
}
function getTextureType(gl) {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return gl.UNSIGNED_BYTE;
    }
    return gl.FLOAT;
}
function createAndConfigureTexture(gl, width, height, numChannels) {
    webgl_util.validateTextureSize(gl, width, height);
    var texture = webgl_util.createTexture(gl);
    var tex2d = gl.TEXTURE_2D;
    var internalFormat = getTextureInternalFormat(gl, numChannels);
    var format = getTextureFormat(gl, numChannels);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(tex2d, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MIN_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texParameteri(tex2d, gl.TEXTURE_MAG_FILTER, gl.NEAREST); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(tex2d, 0, internalFormat, width, height, 0, format, getTextureType(gl), null); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
    return texture;
}
function createMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 1;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createMatrixTexture = createMatrixTexture;
function createColorMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getColorMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createColorMatrixTexture = createColorMatrixTexture;
function createPackedMatrixTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), width = _a[0], height = _a[1];
    var numChannels = 4;
    return createAndConfigureTexture(gl, width, height, numChannels);
}
exports.createPackedMatrixTexture = createPackedMatrixTexture;
function bindVertexProgramAttributeStreams(gl, program, vertexBuffer) {
    var posOffset = 0;
    var uvOffset = 3 * 4;
    var stride = (3 * 4) + (2 * 4);
    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer); });
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'clipSpacePos', vertexBuffer, 3, stride, posOffset);
    webgl_util.bindVertexBufferToProgramAttribute(gl, program, 'uv', vertexBuffer, 2, stride, uvOffset);
}
exports.bindVertexProgramAttributeStreams = bindVertexProgramAttributeStreams;
function uploadPixelDataToTexture(gl, texture, pixels) {
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, pixels); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.uploadPixelDataToTexture = uploadPixelDataToTexture;
function uploadDataToTexture(gl, texture, width, height, data, numChannels) {
    var textureFormat = getTextureFormat(gl, numChannels);
    webgl_util.validateTextureSize(gl, width, height);
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
    webgl_util.callAndCheck(gl, function () { return gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, width, height, textureFormat, getTextureType(gl), data); });
    webgl_util.callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
function uploadMatrixToTexture(gl, texture, rows, columns, matrix, numChannels) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var unpackedArray;
    if (environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        var channelsPerTexture = numChannels === 1 ? webgl_util.getChannelsPerTexture() : numChannels;
        if (channelsPerTexture === 1) {
            unpackedArray = matrix;
        }
        else {
            unpackedArray =
                new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture));
            tex_util.encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture);
        }
    }
    else {
        unpackedArray = tex_util.encodeFloatArray(matrix);
    }
    uploadDataToTexture(gl, texture, w, h, unpackedArray, numChannels);
}
exports.uploadMatrixToTexture = uploadMatrixToTexture;
function uploadMatrixToPackedTexture(gl, texture, rows, columns, matrix) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    tex_util.encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA);
    var numChannels = 4;
    uploadDataToTexture(gl, texture, w, h, packedRGBA, numChannels);
}
exports.uploadMatrixToPackedTexture = uploadMatrixToPackedTexture;
function getDownloadTargetArrayBuffer(rows, columns, channelsPerTexture) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    var downloadTarget;
    if (isFloatTexture) {
        downloadTarget =
            new Float32Array(tex_util.getUnpackedArraySizeFromMatrixSize(rows * columns, channelsPerTexture));
    }
    else {
        downloadTarget = new Uint8Array(rows * columns * channelsPerTexture);
    }
    return downloadTarget;
}
function decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel) {
    var isFloatTexture = environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED');
    if (isFloatTexture) {
        var matrix = new Float32Array(rows * columns);
        tex_util.decodeMatrixFromUnpackedArray(downloadTarget, matrix, channelsPerPixel);
        return matrix;
    }
    else {
        return tex_util.decodeToFloatArray(downloadTarget);
    }
}
function downloadMatrixFromOutputTextureAsync(gl, getBufferSubDataAsyncExtension, rows, columns) {
    return __awaiter(this, void 0, void 0, function () {
        var gl2, channelsPerPixel, downloadTarget, bufferSizeBytes, buffer;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    gl2 = gl;
                    channelsPerPixel = 4;
                    downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
                    bufferSizeBytes = downloadTarget instanceof Float32Array ?
                        downloadTarget.length * 4 :
                        downloadTarget;
                    buffer = gl.createBuffer();
                    webgl_util.callAndCheck(gl, function () { return gl.bindBuffer(gl2.PIXEL_PACK_BUFFER, buffer); });
                    webgl_util.callAndCheck(gl, function () { return gl.bufferData(gl2.PIXEL_PACK_BUFFER, bufferSizeBytes, gl.STATIC_DRAW); });
                    webgl_util.callAndCheck(gl, function () {
                        return gl2.readPixels(0, 0, columns, rows, gl.RGBA, getTextureType(gl), 0);
                    });
                    return [4, getBufferSubDataAsyncExtension.getBufferSubDataAsync(gl2.PIXEL_PACK_BUFFER, 0, downloadTarget)];
                case 1:
                    _a.sent();
                    return [2, decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel)];
            }
        });
    });
}
exports.downloadMatrixFromOutputTextureAsync = downloadMatrixFromOutputTextureAsync;
function downloadMatrixFromOutputTexture(gl, rows, columns) {
    var _a = tex_util.getUnpackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var channelsPerPixel = 4;
    var downloadTarget = getDownloadTargetArrayBuffer(rows, columns, channelsPerPixel);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), downloadTarget); });
    return decodeDownloadTargetArrayBuffer(downloadTarget, rows, columns, channelsPerPixel);
}
exports.downloadMatrixFromOutputTexture = downloadMatrixFromOutputTexture;
function downloadMatrixFromRGBAColorTexture(gl, rows, columns, channels) {
    var size = rows * columns * 4;
    var downloadTarget = new Uint8Array(size);
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, columns, rows, gl.RGBA, gl.UNSIGNED_BYTE, downloadTarget); });
    var packedRGBA = new Float32Array(size);
    for (var i = 0; i < downloadTarget.length; i++) {
        packedRGBA[i] = downloadTarget[i];
    }
    var matrix = new Float32Array(rows * columns * channels);
    tex_util.decodeMatrixFromUnpackedColorRGBAArray(packedRGBA, matrix, channels);
    return matrix;
}
exports.downloadMatrixFromRGBAColorTexture = downloadMatrixFromRGBAColorTexture;
function downloadMatrixFromPackedOutputTexture(gl, rows, columns) {
    var _a = tex_util.getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    var packedRGBA = new Float32Array(tex_util.getPackedRGBAArraySizeFromMatrixShape(rows, columns));
    webgl_util.callAndCheck(gl, function () { return gl.readPixels(0, 0, w, h, gl.RGBA, getTextureType(gl), packedRGBA); });
    var matrix = new Float32Array(rows * columns);
    return tex_util.decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix);
}
exports.downloadMatrixFromPackedOutputTexture = downloadMatrixFromPackedOutputTexture;

},{"../../environment":27,"./tex_util":90,"./webgl_util":95}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var WhereProgram = (function () {
    function WhereProgram(cRank, shape, rank) {
        this.variableNames = ['c', 'a', 'b'];
        this.outputShape = shape;
        var cCoords;
        var abCoords;
        if (rank > 4) {
            throw Error("Where for rank " + rank + " is not yet supported");
        }
        if (rank === 1) {
            abCoords = "resRC";
            cCoords = "resRC";
        }
        else {
            var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
            var cCoordVars = [];
            var abCoordVars = [];
            for (var i = 0; i < shape.length; i++) {
                abCoordVars.push("" + currentCoords[i]);
                if (i < cRank) {
                    cCoordVars.push("" + currentCoords[i]);
                }
            }
            cCoords = cCoordVars.join();
            abCoords = abCoordVars.join();
        }
        var dtype = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        float cVal = getC(" + cCoords + ");\n        if (cVal >= 1.0) {\n          setOutput(getA(" + abCoords + "));\n        } else {\n          setOutput(getB(" + abCoords + "));\n        }\n      }\n    ";
    }
    return WhereProgram;
}());
exports.WhereProgram = WhereProgram;

},{"./shader_compiler":88}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var LRNProgram = (function () {
    function LRNProgram(xShape, radius, bias, alpha, beta, normRegion) {
        this.variableNames = ['x'];
        this.outputShape = [];
        var rad = radius;
        var maxW = xShape[1] - 1;
        var maxH = xShape[2] - 1;
        var maxD = xShape[3] - 1;
        this.outputShape = xShape;
        var powOperator;
        var basis = "float(" + bias + ") + float(" + alpha + ") * sum";
        if (beta === 0.5) {
            powOperator = "inversesqrt(" + basis + ")";
        }
        else if (beta === 1.0) {
            powOperator = "1.0/(" + basis + ")";
        }
        else {
            powOperator = "exp(log(" + basis + ") * float(-" + beta + "));";
        }
        if (normRegion === 'withinChannel') {
            this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int b = coords[0];\n          int r = coords[1];\n          int c = coords[2];\n          int d = coords[3];\n          float x = getX(b, r, c, d);\n          float sum = 0.0;\n          for (int u = -" + rad + "; u <= " + rad + "; u++) {\n            for (int v = -" + rad + "; v <= " + rad + "; v++) {\n              int idx = r + u;\n              int idy = c + v;\n              if (idx >= 0 && idx <= " + maxW + " && idy >= 0 && idy <= " + maxH + ") {\n                float z = getX(b, idx, idy, d);\n                sum += z * z;\n              }\n            }\n          }\n          float val = x * " + powOperator + ";\n          setOutput(val);\n        }\n      ";
        }
        else {
            this.userCode = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int b = coords[0];\n          int r = coords[1];\n          int c = coords[2];\n          int d = coords[3];\n          float x = getX(b, r, c, d);\n          float sum = 0.0;\n          for (int j = -" + rad + "; j <= " + rad + "; j++) {\n            int idx = d + j;\n            if (idx >= 0 && idx <=  " + maxD + ") {\n              float z = getX(b, r, c, idx);\n              sum += z * z;\n            }\n          }\n          float val = x * " + powOperator + ";\n          setOutput(val);\n        }\n      ";
        }
    }
    return LRNProgram;
}());
exports.LRNProgram = LRNProgram;

},{}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MaxPool2DBackpropProgram = (function () {
    function MaxPool2DBackpropProgram(convInfo) {
        this.variableNames = ['dy', 'maxPos'];
        this.outputShape = convInfo.inShape;
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = filterHeight - 1 - convInfo.padInfo.top;
        var padLeft = filterWidth - 1 - convInfo.padInfo.left;
        var lastIndex = filterHeight * filterWidth - 1;
        this.userCode = "\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + strideHeight + ".0;\n\n          if (dyR < 0.0 || dyR >= " + convInfo.outHeight + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < " + filterWidth + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + strideWidth + ".0;\n\n            if (dyC < 0.0 || dyC >= " + convInfo.outWidth + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = " + lastIndex + " - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * " + filterWidth + " + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
    }
    return MaxPool2DBackpropProgram;
}());
exports.MaxPool2DBackpropProgram = MaxPool2DBackpropProgram;

},{}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MatMulProgram = (function () {
    function MatMulProgram(aShape, bShape, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.variableNames = ['matrixA', 'matrixB'];
        var outerShapeA = transposeA ? aShape[1] : aShape[0];
        var outerShapeB = transposeB ? bShape[0] : bShape[1];
        var sharedDim = transposeA ? aShape[0] : aShape[1];
        this.outputShape = [outerShapeA, outerShapeB];
        var aSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeA ? indexVar + " + " + vec4Offset + ", aRow" :
                "aRow, " + indexVar + " + " + vec4Offset;
        };
        var bSnippetFromOffset = function (vec4Offset, indexVar) {
            return transposeB ? "bCol, " + indexVar + " + " + vec4Offset :
                indexVar + " + " + vec4Offset + ", bCol";
        };
        var sharedDimNearestVec4 = Math.floor(sharedDim / 4) * 4;
        var sharedDimVec4Remainder = sharedDim % 4;
        this.userCode = " float dotARowBCol(int aRow, int bCol) {\n      float result = 0.0;\n      for (int i = 0; i < " + sharedDimNearestVec4 + "; i += 4) {\n        vec4 a = vec4(\n          getMatrixA(" + aSnippetFromOffset(0, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(1, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(2, 'i') + "),\n          getMatrixA(" + aSnippetFromOffset(3, 'i') + ")\n        );\n        vec4 b = vec4(\n          getMatrixB(" + bSnippetFromOffset(0, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(1, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(2, 'i') + "),\n          getMatrixB(" + bSnippetFromOffset(3, 'i') + ")\n        );\n\n        result += dot(a, b);\n      }\n\n      if (" + (sharedDimVec4Remainder === 1) + ") {\n        result += getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + ") *\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + ");\n      } else if (" + (sharedDimVec4Remainder === 2) + ") {\n        vec2 a = vec2(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        vec2 b = vec2(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      } else if (" + (sharedDimVec4Remainder === 3) + ") {\n        vec3 a = vec3(\n          getMatrixA(" + aSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixA(" + aSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        vec3 b = vec3(\n          getMatrixB(" + bSnippetFromOffset(0, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(1, sharedDimNearestVec4) + "),\n          getMatrixB(" + bSnippetFromOffset(2, sharedDimNearestVec4) + ")\n        );\n        result += dot(a, b);\n      }\n\n      return result;\n    }\n\n    void main() {\n      ivec2 resRC = getOutputCoords();\n      setOutput(dotARowBCol(resRC.x, resRC.y));\n    }\n    ";
    }
    return MatMulProgram;
}());
exports.MatMulProgram = MatMulProgram;

},{}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MultinomialProgram = (function () {
    function MultinomialProgram(batchSize, numOutcomes, numSamples) {
        this.variableNames = ['probs'];
        this.outputShape = [batchSize, numSamples];
        this.userCode = "\n      uniform float seed;\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < " + (numOutcomes - 1) + "; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(" + (numOutcomes - 1) + "));\n      }\n    ";
    }
    MultinomialProgram.prototype.getCustomSetupFunc = function (seed) {
        var _this = this;
        return function (gpgpu, webGLProgram) {
            if (_this.seedLoc == null) {
                _this.seedLoc = gpgpu.getUniformLocation(webGLProgram, 'seed');
            }
            gpgpu.gl.uniform1f(_this.seedLoc, seed);
        };
    };
    return MultinomialProgram;
}());
exports.MultinomialProgram = MultinomialProgram;

},{}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var OneHotProgram = (function () {
    function OneHotProgram(numIndices, depth, onValue, offValue) {
        this.variableNames = ['indices'];
        this.outputShape = [numIndices, depth];
        this.userCode = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(" + offValue + "), float(" + onValue + "),\n                      float(index == coords.y)));\n      }\n    ";
    }
    return OneHotProgram;
}());
exports.OneHotProgram = OneHotProgram;

},{}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var PadProgram = (function () {
    function PadProgram(xShape, paddings, constantValue) {
        this.variableNames = ['x'];
        this.outputShape = paddings.map(function (p, i) { return p[0] + xShape[i] + p[1]; });
        var rank = xShape.length;
        var type = shader_compiler_1.getCoordsDataType(rank);
        var start = paddings.map(function (p) { return p[0]; }).join(',');
        var end = paddings.map(function (p, i) { return p[0] + xShape[i]; }).join(',');
        var unpackedCoords = ['coords[0]', 'coords[1]', 'coords[2]', 'coords[3]'].slice(0, rank);
        if (rank === 1) {
            this.userCode = "\n        int start = " + start + ";\n        int end = " + end + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(float(" + constantValue + "));\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
            return;
        }
        this.userCode = "\n      " + type + " start = " + type + "(" + start + ");\n      " + type + " end = " + type + "(" + end + ");\n\n      void main() {\n        " + type + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(float(" + constantValue + "));\n        } else {\n          " + type + " coords = outC - start;\n          setOutput(getX(" + unpackedCoords + "));\n        }\n      }\n    ";
    }
    return PadProgram;
}());
exports.PadProgram = PadProgram;

},{"./shader_compiler":88}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Pool2DProgram = (function () {
    function Pool2DProgram(convInfo, poolType, computePositions) {
        this.variableNames = ['x'];
        if (poolType === 'avg' && computePositions) {
            throw new Error('Cannot compute positions for average pool.');
        }
        var filterHeight = convInfo.filterHeight;
        var filterWidth = convInfo.filterWidth;
        var strideHeight = convInfo.strideHeight;
        var strideWidth = convInfo.strideWidth;
        var padTop = convInfo.padInfo.top;
        var padLeft = convInfo.padInfo.left;
        this.outputShape = convInfo.outShape;
        var isAvgPool = poolType === 'avg';
        var initializationValue = '0.0';
        if (!isAvgPool) {
            if (poolType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        if (computePositions) {
            var compareOp_1 = poolType === 'min' ? '<=' : '>=';
            this.userCode = "\n        const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n        const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + filterHeight + "; wR++) {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + filterWidth + "; wC++) {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              if (isNaN(value)) {\n                setOutput(value);\n                return;\n              }\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + compareOp_1 + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = wR * " + filterWidth + " + wC;\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
            return;
        }
        var compareOp = poolType === 'min' ? 'min' : 'max';
        var returnValue = poolType + "(" + poolType + "(" + poolType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (poolType === 'avg') {
            returnValue = "avgValue / " + filterHeight * filterWidth + ".0";
        }
        var filterWidthNearestVec4 = Math.floor(filterWidth / 4) * 4;
        var filterWidthVec4Remainder = filterWidth % 4;
        var updateSnippet = "\n      if (hasNaN(values)) {\n        setOutput(getNaN(values));\n        return;\n      }\n      if (" + isAvgPool + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        this.userCode = "\n      const ivec2 strides = ivec2(" + strideHeight + ", " + strideWidth + ");\n      const ivec2 pads = ivec2(" + padTop + ", " + padLeft + ");\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + convInfo.inWidth + ") {\n          return initializationValue;\n        }\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float avgValue = 0.0;\n\n        for (int wR = 0; wR < " + filterHeight + "; wR++) {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + convInfo.inHeight + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + filterWidthNearestVec4 + "; wC += 4) {\n            int xC = xCCorner + wC;\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              getValue(batch, xR, xC + 3, d)\n            );\n\n            " + updateSnippet + "\n          }\n\n          int xC = xCCorner + " + filterWidthNearestVec4 + ";\n          if (" + (filterWidthVec4Remainder === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          } else if (" + (filterWidthVec4Remainder === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + 1, d),\n              getValue(batch, xR, xC + 2, d),\n              initializationValue\n            );\n\n            " + updateSnippet + "\n          }\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return Pool2DProgram;
}());
exports.Pool2DProgram = Pool2DProgram;

},{}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ReduceProgram = (function () {
    function ReduceProgram(reduceInfo, reduceType) {
        this.variableNames = ['x'];
        var windowSize = reduceInfo.windowSize;
        var batchSize = reduceInfo.batchSize;
        var inSize = reduceInfo.inSize;
        var outSize = Math.ceil(inSize / windowSize);
        this.outputShape = [batchSize, outSize];
        var isReduceSum = reduceType === 'sum';
        var initializationValue = '0.0';
        if (!isReduceSum) {
            if (reduceType === 'min') {
                initializationValue = '1.0 / 0.0';
            }
            else {
                initializationValue = '-1.0 / 0.0';
            }
        }
        var compareOp = reduceType === 'min' ? 'min' : 'max';
        var returnValue = reduceType + "(" + reduceType + "(" + reduceType + "(" +
            'minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])';
        if (reduceType === 'sum') {
            returnValue = "sumValue";
        }
        var windowSizeNearestVec4 = Math.floor(windowSize / 4) * 4;
        var windowSizeVec4Remainder = windowSize % 4;
        var updateSnippet = "\n      if (" + isReduceSum + ") {\n        sumValue += dot(values, ones);\n      } else {\n        if (hasNaN(values)) {\n          setOutput(getNaN(values));\n          return;\n        }\n        minMaxValue = " + compareOp + "(values, minMaxValue);\n      }\n    ";
        var checkOutOfBounds = '';
        if (inSize % windowSize > 0) {
            checkOutOfBounds = "\n        if (inIdx < 0 || inIdx >= " + inSize + ") {\n          return initializationValue;\n        }\n      ";
        }
        this.userCode = "\n      const float initializationValue = " + initializationValue + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + checkOutOfBounds + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + windowSize + ";\n\n        vec4 minMaxValue = vec4(" + initializationValue + ");\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + windowSizeNearestVec4 + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + updateSnippet + "\n        }\n\n        int inIdx = inOffset + " + windowSizeNearestVec4 + ";\n        if (" + (windowSizeVec4Remainder === 1) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n          " + updateSnippet + "\n        } else if (" + (windowSizeVec4Remainder === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n          " + updateSnippet + "\n        }\n        setOutput(" + returnValue + ");\n      }\n    ";
    }
    return ReduceProgram;
}());
exports.ReduceProgram = ReduceProgram;

},{}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ResizeBilinearProgram = (function () {
    function ResizeBilinearProgram(inputShape, newHeight, newWidth, alignCorners) {
        this.variableNames = ['A'];
        this.outputShape = [];
        var batch = inputShape[0], oldHeight = inputShape[1], oldWidth = inputShape[2], depth = inputShape[3];
        this.outputShape = [batch, newHeight, newWidth, depth];
        var effectiveInSize = alignCorners ? [oldHeight - 1, oldWidth - 1] : [oldHeight, oldWidth];
        var effectiveOutSize = alignCorners ? [newHeight - 1, newWidth - 1] : [newHeight, newWidth];
        this.userCode = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + effectiveInSize[0] / effectiveOutSize[0] + ",\n          " + effectiveInSize[1] / effectiveOutSize[1] + ");\n      const vec2 inputShapeRC = vec2(" + oldHeight + ".0, " + oldWidth + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = vec2(yRC) * effectiveInputOverOutputRatioRC;\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(sourceFracIndexRC);\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
    }
    return ResizeBilinearProgram;
}());
exports.ResizeBilinearProgram = ResizeBilinearProgram;

},{}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var ReverseProgram = (function () {
    function ReverseProgram(xShape, axis) {
        this.variableNames = ['x'];
        var rank = xShape.length;
        if (rank > 4) {
            throw new Error("WebGL backend: Reverse of rank-" + rank + " tensor is not yet supported");
        }
        this.outputShape = xShape;
        if (rank === 1) {
            this.userCode = "\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(" + xShape[0] + " - coord - 1));\n        }\n      ";
            return;
        }
        var getInCoord = function (i) {
            if (axis.indexOf(i) !== -1 && xShape[i] !== 1) {
                return xShape[i] + " - coords[" + i + "] - 1";
            }
            return "coords[" + i + "]";
        };
        var inCoords = xShape.map(function (_, i) { return getInCoord(i); }).join(',');
        var type = shader_compiler_1.getCoordsDataType(rank);
        this.userCode = "\n      void main() {\n        " + type + " coords = getOutputCoords();\n        setOutput(getX(" + inCoords + "));\n      }\n    ";
    }
    return ReverseProgram;
}());
exports.ReverseProgram = ReverseProgram;

},{"./shader_compiler":88}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../../environment");
var util = require("../../util");
var broadcast_util = require("../../ops/broadcast_util");
var tex_util = require("./tex_util");
function makeShader(inputsInfo, outputShape, userCode, broadcast) {
    var sampleSnippet = getSampleSnippet();
    var setOutputSnippet = getSetOutputSnippet();
    var inputPrefixSnippet = inputsInfo.map(function (x) { return "uniform sampler2D " + x.name + ";"; }).join('\n');
    var inputSamplingSnippet = inputsInfo.map(function (x) { return getInputSamplingSnippet(x, outputShape, broadcast); })
        .join('\n');
    var outTexShape = outputShape.texShape;
    var outputSamplingSnippet = getOutputSamplingSnippet(outputShape.logicalShape, outTexShape);
    var source = [
        SHADER_PREFIX, sampleSnippet, setOutputSnippet, inputPrefixSnippet,
        outputSamplingSnippet, inputSamplingSnippet, userCode
    ].join('\n');
    return source;
}
exports.makeShader = makeShader;
function getSampleSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SAMPLE_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET;
}
function getSetOutputSnippet() {
    return environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED') ?
        FLOAT_TEXTURE_SETOUTPUT_SNIPPET :
        UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET;
}
function getSamplerFromInInfo(inInfo) {
    var shape = inInfo.shapeInfo.logicalShape;
    switch (shape.length) {
        case 0:
            return getSamplerScalar(inInfo);
        case 1:
            return getSampler1D(inInfo);
        case 2:
            return getSampler2D(inInfo);
        case 3:
            return getSampler3D(inInfo);
        case 4:
            return getSampler4D(inInfo);
        default:
            throw new Error(shape.length + "-D input sampling" +
                " is not yet supported");
    }
}
function getInputSamplingSnippet(inInfo, outShapeInfo, broadcast) {
    var res = getSamplerFlat(inInfo);
    res += getSamplerFromInInfo(inInfo);
    if (broadcast ||
        util.arraysEqual(inInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape)) {
        res += getSamplerAtOutputCoords(inInfo, outShapeInfo, broadcast);
    }
    return res;
}
function getOutputSamplingSnippet(outShape, outTexShape) {
    switch (outShape.length) {
        case 0:
            return getOutputScalarCoords();
        case 1:
            return getOutput1DCoords(outShape, outTexShape);
        case 2:
            return getOutput2DCoords(outShape, outTexShape);
        case 3:
            return getOutput3DCoords(outShape, outTexShape);
        case 4:
            return getOutput4DCoords(outShape, outTexShape);
        default:
            throw new Error(outShape.length + "-D output sampling is not yet supported");
    }
}
var SAMPLE_1D_SNIPPET = "\nvec2 UVfrom1D(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_2D_SNIPPET = "\nvec2 UVfrom2D(int texNumR, int texNumC, int numC, int row, int col) {\n  int index = row * numC + col;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_3D_SNIPPET = "\nvec2 UVfrom3D(int texNumR, int texNumC, int stride0,\n    int stride1, int row, int col, int depth) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var SAMPLE_4D_SNIPPET = "\nvec2 UVfrom4D(int texNumR, int texNumC, int stride0,\n    int stride1, int stride2, int row, int col, int depth,\n    int depth2) {\n  // Explicitly use integer operations as dot() only works on floats.\n  int index = row * stride0 + col * stride1 + depth * stride2 + depth2;\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var UNSIGNED_BYTE_TEXTURE_SAMPLE_SNIPPET = "\n  uniform float NaN;\n\n  const vec4 floatDeltas = vec4(\n      1.0,\n      1.0 / 255.0,\n      1.0 / (255.0 * 255.0),\n      1.0 / (255.0 * 255.0 * 255.0)\n  );\n  const float minValue = " + tex_util.FLOAT_MIN + ".0;\n  const float maxValue = " + tex_util.FLOAT_MAX + ".0;\n  const float range = (maxValue - minValue) / 255.0;\n  const vec2 dotRange = vec2(1.0, range);\n\n  float sample(sampler2D texture, vec2 uv) {\n    vec4 sampleValue = texture2D(texture, uv);\n    if (all(equal(sampleValue, vec4(" + tex_util.BYTE_NAN_VALUE + ")))) {\n      return NaN;\n    }\n\n    vec4 encValue = floor(sampleValue * 255.0 + 0.5);\n    float decodedValue = dot(encValue, floatDeltas);\n    return dot(vec2(minValue, decodedValue), dotRange);\n  }\n";
var UNSIGNED_BYTE_TEXTURE_SETOUTPUT_SNIPPET = "\n  const vec4 floatPowers = vec4(\n    1.0,\n    255.0,\n    255.0 * 255.0,\n    255.0 * 255.0 * 255.0\n  );\n  const vec2 recipRange = vec2(1.0/range);\n  const vec2 recipRange255 = vec2(1.0/(maxValue - minValue));\n\n  void setOutput(float decodedValue) {\n    if (isNaN(decodedValue)) {\n      gl_FragColor = vec4(" + tex_util.BYTE_NAN_VALUE + ");\n      return;\n    }\n\n    float a = dot(vec2(decodedValue, -minValue), recipRange);\n    float b = fract(a) * 255.0;\n    float c = fract(b) * 255.0;\n    float d = fract(c) * 255.0;\n    gl_FragColor = floor(vec4(a, b, c, d)) / 255.0;\n\n    // TODO(dsmilkov): Version above gets better accuracy but probably slower\n    // than the version below. Benchmark to determine if the accuracy is worth\n    // the cost.\n\n    // float normValue = dot(vec2(decodedValue, -minValue), recipRange255);\n    // vec4 f = normValue * floatPowers;\n    // gl_FragColor = floor(fract(f) * 255.0) / 255.0;\n  }\n";
var FLOAT_TEXTURE_SAMPLE_SNIPPET = "\n  float sample(sampler2D texture, vec2 uv) {\n    return texture2D(texture, uv).r;\n  }\n";
var FLOAT_TEXTURE_SETOUTPUT_SNIPPET = "\n  void setOutput(float val) {\n    gl_FragColor = vec4(val, 0, 0, 0);\n  }\n";
var SHADER_PREFIX = "\n  precision highp float;\n  precision highp int;\n  varying vec2 resultUV;\n  const vec2 halfCR = vec2(0.5, 0.5);\n\n  bool isNaN(float val) {\n    float v1 = val * val;\n    float v2 = val * val;\n    return v1 == v2 ? false : true;\n  }\n\n  bool hasNaN(vec4 values) {\n    vec4 v1 = values * values;\n    vec4 v2 = values * values;\n    return any(notEqual(v1, v2));\n  }\n\n  float getNaN(vec4 values) {\n    return dot(vec4(1), values);\n  }\n\n  int round(float value) {\n    return int(floor(value + 0.5));\n  }\n\n  int imod(int x, int y) {\n    return x - y * (x / y);\n  }\n\n  const vec2 randomConst = vec2(\n    23.14069263277926, // e^pi (Gelfond's constant)\n     2.665144142690225 // 2^sqrt(2) (Gelfond\u2013Schneider constant)\n  );\n\n  float random(float seed) {\n      return fract(cos(dot(resultUV * seed, randomConst)) * 12345.6789);\n  }\n\n  " + SAMPLE_1D_SNIPPET + "\n  " + SAMPLE_2D_SNIPPET + "\n  " + SAMPLE_3D_SNIPPET + "\n  " + SAMPLE_4D_SNIPPET + "\n";
function getOutputScalarCoords() {
    return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function getOutput1DCoords(shape, texShape) {
    if (texShape[0] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.x * " + texShape[1] + ".0);\n      }\n    ";
    }
    if (texShape[1] === 1) {
        return "\n      int getOutputCoords() {\n        return int(resultUV.y * " + texShape[0] + ".0);\n      }\n    ";
    }
    return "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      return resTexRC.x * " + texShape[1] + " + resTexRC.y;\n    }\n  ";
}
function getOutput3DCoords(shape, texShape) {
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n      int c = index / " + stride1 + ";\n      int d = index - c * " + stride1 + ";\n      return ivec3(r, c, d);\n    }\n  ";
}
function getOutput4DCoords(shape, texShape) {
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n\n      int r = index / " + stride0 + ";\n      index -= r * " + stride0 + ";\n\n      int c = index / " + stride1 + ";\n      index -= c * " + stride1 + ";\n\n      int d = index / " + stride2 + ";\n      int d2 = index - d * " + stride2 + ";\n\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function getOutput2DCoords(shape, texShape) {
    if (util.arraysEqual(shape, texShape)) {
        return "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + texShape[0] + ", " + texShape[1] + "));\n      }\n    ";
    }
    if (shape[1] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ";
    }
    if (shape[0] === 1) {
        return "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + texShape[0] + ", " + texShape[1] + "));\n        int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ";
    }
    return "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + texShape[0] + ", " + texShape[1] + "));\n      int index = resTexRC.x * " + texShape[1] + " + resTexRC.y;\n      int r = index / " + shape[1] + ";\n      int c = index - r * " + shape[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function getSamplerScalar(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "() {\n      return sample(" + texName + ", halfCR);\n    }\n  ";
}
function getSampler1D(inputInfo) {
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    return "\n    float " + funcName + "(int index) {\n      return " + funcName + "Flat(index);\n    }\n  ";
}
function getSampler2D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    if (util.arraysEqual(shape, texShape)) {
        return "\n    float " + funcName + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2(0.5, (float(index) + 0.5) / " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    if (texNumR === 1) {
        return "\n    float " + funcName + "(int row, int col) {\n      int index = row * " + shape[1] + " + col;\n      vec2 uv = vec2((float(index) + 0.5) / " + texNumC + ".0, 0.5);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n  float " + funcName + "(int row, int col) {\n    vec2 uv = UVfrom2D(" + texNumR + ", " + texNumC + ", " + shape[1] + ", row, col);\n    return sample(" + texName + ", uv);\n  }\n";
}
function getSampler3D(inputInfo) {
    var texShape = inputInfo.shapeInfo.texShape;
    var shape = inputInfo.shapeInfo.logicalShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride0 = shape[1] * shape[2];
    var stride1 = shape[2];
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    var squeezedShape = newShape;
    if (squeezedShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, squeezedShape);
        var params = ['row', 'col', 'depth'];
        return "\n        " + getSamplerFromInInfo(newInputInfo) + "\n        float " + funcName + "(int row, int col, int depth) {\n          return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n        }\n      ";
    }
    if (texNumC === stride0) {
        return "\n        float " + funcName + "(int row, int col, int depth) {\n          int texR = row;\n          int texC = col * " + stride1 + " + depth;\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + texNumC + ".0, " + texNumR + ".0);\n          return sample(" + texName + ", uv);\n        }\n      ";
    }
    if (texNumC === stride1) {
        return "\n    float " + funcName + "(int row, int col, int depth) {\n      int texR = row * " + shape[1] + " + col;\n      int texC = depth;\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + texNumC + ".0, " + texNumR + ".0);\n      return sample(" + texName + ", uv);\n    }\n  ";
    }
    return "\n      float " + funcName + "(int row, int col, int depth) {\n        vec2 uv = UVfrom3D(\n            " + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ", row, col, depth);\n        return sample(" + texName + ", uv);\n      }\n  ";
}
function getSampler4D(inputInfo) {
    var shape = inputInfo.shapeInfo.logicalShape;
    var texShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1);
    var texNumR = texShape[0];
    var texNumC = texShape[1];
    var stride2 = shape[3];
    var stride1 = shape[2] * stride2;
    var stride0 = shape[1] * stride1;
    var _a = util.squeezeShape(shape), newShape = _a.newShape, keptDims = _a.keptDims;
    if (newShape.length < shape.length) {
        var newInputInfo = squeezeInputInfo(inputInfo, newShape);
        var params = ['row', 'col', 'depth', 'depth2'];
        return "\n      " + getSamplerFromInInfo(newInputInfo) + "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        return " + funcName + "(" + getSqueezedParams(params, keptDims) + ");\n      }\n    ";
    }
    if (texNumC === stride0) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row;\n        int texC = col * " + stride1 + " + depth * " + stride2 + " + depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (texNumC === stride2) {
        return "\n      float " + funcName + "(int row, int col, int depth, int depth2) {\n        int texR = row * " + shape[1] * shape[2] + " + col * " + shape[2] + " + depth;\n        int texC = depth2;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + texNumC + ".0, " + texNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int row, int col, int depth, int depth2) {\n      vec2 uv = UVfrom4D(" + texNumR + ", " + texNumC + ", " + stride0 + ", " + stride1 + ",\n          " + stride2 + ", row, col, depth, depth2);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getSamplerFlat(inputInfo) {
    var texName = inputInfo.name;
    var texShape = inputInfo.shapeInfo.texShape;
    var funcName = 'get' + texName.charAt(0).toUpperCase() + texName.slice(1) + 'Flat';
    var tNumR = texShape[0];
    var tNumC = texShape[1];
    if (tNumC === 1 && tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        return sample(" + texName + ", halfCR);\n      }\n    ";
    }
    if (tNumC === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2(0.5, (float(index) + 0.5) / " + tNumR + ".0);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    if (tNumR === 1) {
        return "\n      float " + funcName + "(int index) {\n        vec2 uv = vec2((float(index) + 0.5) / " + tNumC + ".0, 0.5);\n        return sample(" + texName + ", uv);\n      }\n    ";
    }
    return "\n    float " + funcName + "(int index) {\n      vec2 uv = UVfrom1D(" + tNumR + ", " + tNumC + ", index);\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName) {
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var type = 'int';
    if (outRank === 2) {
        type = 'ivec2';
    }
    else if (outRank === 3) {
        type = 'ivec3';
    }
    else if (outRank === 4) {
        type = 'ivec4';
    }
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var rankDiff = outRank - inRank;
    var coordsSnippet;
    if (inRank === 0) {
        coordsSnippet = '';
    }
    else if (outRank < 2 && broadcastDims.length >= 1) {
        coordsSnippet = 'coords = 0;';
    }
    else {
        coordsSnippet =
            broadcastDims.map(function (d) { return "coords[" + (d + rankDiff) + "] = 0;"; }).join('\n');
    }
    var unpackedCoordsSnippet = '';
    if (outRank < 2 && inRank > 0) {
        unpackedCoordsSnippet = 'coords';
    }
    else {
        unpackedCoordsSnippet = inputInfo.shapeInfo.logicalShape
            .map(function (s, i) { return "coords[" + (i + rankDiff) + "]"; })
            .join(', ');
    }
    return "\n    float " + funcName + "() {\n      " + type + " coords = getOutputCoords();\n      " + coordsSnippet + "\n      return get" + texFuncSnippet + "(" + unpackedCoordsSnippet + ");\n    }\n  ";
}
function getSamplerAtOutputCoords(inputInfo, outShapeInfo, supportsBroadcasting) {
    var inTexShape = inputInfo.shapeInfo.texShape;
    var texName = inputInfo.name;
    var texFuncSnippet = texName.charAt(0).toUpperCase() + texName.slice(1);
    var funcName = 'get' + texFuncSnippet + 'AtOutCoords';
    var broadcastDims = broadcast_util.getBroadcastDims(inputInfo.shapeInfo.logicalShape, outShapeInfo.logicalShape);
    var inRank = inputInfo.shapeInfo.logicalShape.length;
    var outRank = outShapeInfo.logicalShape.length;
    var doBroadcast = supportsBroadcasting && ((outRank > inRank) || broadcastDims.length > 0);
    var broadcastOverOuter = broadcast_util.broadcastDimsAreOuter(broadcastDims);
    if (doBroadcast && !broadcastOverOuter) {
        return getBroadcastOutputCoordsSampler(inputInfo, outShapeInfo, texFuncSnippet, funcName);
    }
    var outTexShape = outShapeInfo.texShape;
    if (util.arraysEqual(inTexShape, outTexShape)) {
        return "\n      float " + funcName + "() {\n        return sample(" + texName + ", resultUV);\n      }\n    ";
    }
    var inSize = util.sizeFromShape(inTexShape);
    var broadcastSnippet = '';
    if (doBroadcast && broadcastOverOuter) {
        broadcastSnippet = "\n        int mainPart = index / " + inSize + ";\n        index -= mainPart * " + inSize + ";\n      ";
    }
    return "\n    float " + funcName + "() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + outTexShape[0] + ", " + outTexShape[1] + "));\n      int index = resTexRC.x * " + outTexShape[1] + " + resTexRC.y;\n      " + broadcastSnippet + "\n      int texR = index / " + inTexShape[1] + ";\n      int texC = index - texR * " + inTexShape[1] + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) /\n                 vec2(" + inTexShape[1] + ".0, " + inTexShape[0] + ".0);\n\n      return sample(" + texName + ", uv);\n    }\n  ";
}
function getCoordsDataType(rank) {
    if (rank <= 1) {
        return 'int';
    }
    else if (rank === 2) {
        return 'ivec2';
    }
    else if (rank === 3) {
        return 'ivec3';
    }
    else if (rank === 4) {
        return 'ivec4';
    }
    else {
        throw Error("GPU for rank " + rank + " is not yet supported");
    }
}
exports.getCoordsDataType = getCoordsDataType;
function squeezeInputInfo(inInfo, squeezedShape) {
    var newInputInfo = JSON.parse(JSON.stringify(inInfo));
    newInputInfo.shapeInfo.logicalShape = squeezedShape;
    return newInputInfo;
}
function getSqueezedParams(params, keptDims) {
    return keptDims.map(function (d) { return params[d]; }).join(', ');
}

},{"../../environment":27,"../../ops/broadcast_util":101,"../../util":143,"./tex_util":90}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var SliceProgram = (function () {
    function SliceProgram(destSize) {
        this.variableNames = ['source'];
        this.outputShape = destSize;
        this.rank = destSize.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getCoords(this.rank);
        this.userCode = "\n      uniform " + dtype + " start;\n\n      void main() {\n        " + dtype + " sourceLoc = start + getOutputCoords();\n        setOutput(getSource(" + sourceCoords + "));\n      }\n    ";
    }
    SliceProgram.prototype.getCustomSetupFunc = function (start) {
        var _this = this;
        if (start.length !== this.rank) {
            throw Error("The rank (" + this.rank + ") of the program must match the " +
                ("length of start (" + start.length + ")"));
        }
        return function (gpgpu, webGLProgram) {
            if (_this.startLoc == null) {
                _this.startLoc = gpgpu.getUniformLocationNoThrow(webGLProgram, 'start');
                if (_this.startLoc == null) {
                    return;
                }
            }
            if (_this.rank === 1) {
                gpgpu.gl.uniform1i(_this.startLoc, start[0]);
            }
            else if (_this.rank === 2) {
                gpgpu.gl.uniform2i(_this.startLoc, start[0], start[1]);
            }
            else if (_this.rank === 3) {
                gpgpu.gl.uniform3i(_this.startLoc, start[0], start[1], start[2]);
            }
            else if (_this.rank === 4) {
                gpgpu.gl.uniform4i(_this.startLoc, start[0], start[1], start[2], start[3]);
            }
            else {
                throw Error("Slicing for rank " + _this.rank + " is not yet supported");
            }
        };
    };
    return SliceProgram;
}());
exports.SliceProgram = SliceProgram;
function getCoords(rank) {
    if (rank === 1) {
        return 'sourceLoc';
    }
    else if (rank === 2) {
        return 'sourceLoc.x, sourceLoc.y';
    }
    else if (rank === 3) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z';
    }
    else if (rank === 4) {
        return 'sourceLoc.x, sourceLoc.y, sourceLoc.z, sourceLoc.w';
    }
    else {
        throw Error("Slicing for rank " + rank + " is not yet supported");
    }
}

},{"./shader_compiler":88}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var TextureType;
(function (TextureType) {
    TextureType[TextureType["FLOAT"] = 0] = "FLOAT";
    TextureType[TextureType["UNSIGNED_BYTE"] = 1] = "UNSIGNED_BYTE";
})(TextureType = exports.TextureType || (exports.TextureType = {}));
function getUnpackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns, rows];
}
exports.getUnpackedMatrixTextureShapeWidthHeight = getUnpackedMatrixTextureShapeWidthHeight;
function getUnpackedArraySizeFromMatrixSize(matrixSize, channelsPerTexture) {
    return matrixSize * channelsPerTexture;
}
exports.getUnpackedArraySizeFromMatrixSize = getUnpackedArraySizeFromMatrixSize;
function getColorMatrixTextureShapeWidthHeight(rows, columns) {
    return [columns * 4, rows];
}
exports.getColorMatrixTextureShapeWidthHeight = getColorMatrixTextureShapeWidthHeight;
function getMatrixSizeFromUnpackedArraySize(unpackedSize, channelsPerTexture) {
    if (unpackedSize % channelsPerTexture !== 0) {
        throw new Error("unpackedSize (" + unpackedSize + ") must be a multiple of " +
            ("" + channelsPerTexture));
    }
    return unpackedSize / channelsPerTexture;
}
exports.getMatrixSizeFromUnpackedArraySize = getMatrixSizeFromUnpackedArraySize;
function encodeMatrixToUnpackedArray(matrix, unpackedArray, channelsPerTexture) {
    var requiredSize = getUnpackedArraySizeFromMatrixSize(matrix.length, channelsPerTexture);
    if (unpackedArray.length < requiredSize) {
        throw new Error("unpackedArray length (" + unpackedArray.length + ") must be >= " +
            ("" + requiredSize));
    }
    var dst = 0;
    for (var src = 0; src < matrix.length; ++src) {
        unpackedArray[dst] = matrix[src];
        dst += channelsPerTexture;
    }
}
exports.encodeMatrixToUnpackedArray = encodeMatrixToUnpackedArray;
exports.FLOAT_MAX = 20000;
exports.FLOAT_MIN = -exports.FLOAT_MAX;
var FLOAT_RANGE = (exports.FLOAT_MAX - exports.FLOAT_MIN) / 255;
var FLOAT_DELTAS = [1, 1 / 255, 1 / (255 * 255), 1 / (255 * 255 * 255)];
var FLOAT_POWERS = [1, 255, 255 * 255];
exports.BYTE_NAN_VALUE = 0;
function encodeFloatArray(floatArray) {
    var uintArray = new Uint8Array(floatArray.length * 4);
    var _loop_1 = function (i) {
        var value = floatArray[i / 4];
        if (isNaN(value)) {
            uintArray[i] = exports.BYTE_NAN_VALUE;
            uintArray[i + 1] = exports.BYTE_NAN_VALUE;
            uintArray[i + 2] = exports.BYTE_NAN_VALUE;
            uintArray[i + 3] = exports.BYTE_NAN_VALUE;
            return "continue";
        }
        var normalizedValue = (value - exports.FLOAT_MIN) / FLOAT_RANGE;
        var enc = FLOAT_POWERS.map(function (pow) { return pow * normalizedValue; });
        var buckets = enc.map(function (value) { return Math.floor((value % 1) * 255); });
        uintArray[i] = Math.floor(normalizedValue);
        uintArray[i + 1] = buckets[0];
        uintArray[i + 2] = buckets[1];
        uintArray[i + 3] = buckets[2];
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_1(i);
    }
    return uintArray;
}
exports.encodeFloatArray = encodeFloatArray;
function decodeToFloatArray(uintArray) {
    var floatArray = new Float32Array(uintArray.length / 4);
    var _loop_2 = function (i) {
        if (uintArray[i] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 1] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 2] === exports.BYTE_NAN_VALUE &&
            uintArray[i + 3] === exports.BYTE_NAN_VALUE) {
            floatArray[i / 4] = NaN;
            return "continue";
        }
        var dot = 0;
        FLOAT_DELTAS.forEach(function (delta, j) {
            dot += delta * uintArray[i + j];
        });
        var value = dot * FLOAT_RANGE + exports.FLOAT_MIN;
        floatArray[i / 4] = value;
    };
    for (var i = 0; i < uintArray.length; i += 4) {
        _loop_2(i);
    }
    return floatArray;
}
exports.decodeToFloatArray = decodeToFloatArray;
function decodeMatrixFromUnpackedArray(unpackedArray, matrix, channelsPerTexture) {
    var requiredSize = getMatrixSizeFromUnpackedArraySize(unpackedArray.length, channelsPerTexture);
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += channelsPerTexture) {
        matrix[dst++] = unpackedArray[src];
    }
}
exports.decodeMatrixFromUnpackedArray = decodeMatrixFromUnpackedArray;
function decodeMatrixFromUnpackedColorRGBAArray(unpackedArray, matrix, channels) {
    var requiredSize = unpackedArray.length * channels / 4;
    if (matrix.length < requiredSize) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var dst = 0;
    for (var src = 0; src < unpackedArray.length; src += 4) {
        for (var c = 0; c < channels; c++) {
            matrix[dst++] = unpackedArray[src + c];
        }
    }
}
exports.decodeMatrixFromUnpackedColorRGBAArray = decodeMatrixFromUnpackedColorRGBAArray;
function getPackedMatrixTextureShapeWidthHeight(rows, columns) {
    return [Math.ceil(columns / 2), Math.ceil(rows / 2)];
}
exports.getPackedMatrixTextureShapeWidthHeight = getPackedMatrixTextureShapeWidthHeight;
function getPackedRGBAArraySizeFromMatrixShape(rows, columns) {
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), w = _a[0], h = _a[1];
    return w * h * 4;
}
exports.getPackedRGBAArraySizeFromMatrixShape = getPackedRGBAArraySizeFromMatrixShape;
function encodeMatrixToPackedRGBA(matrix, rows, columns, packedRGBA) {
    var requiredSize = getPackedRGBAArraySizeFromMatrixShape(rows, columns);
    if (packedRGBA.length < requiredSize) {
        throw new Error("packedRGBA length (" + packedRGBA.length + ") must be >= " + requiredSize);
    }
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    {
        var dstStride = (oddWidth ? 4 : 0);
        var oneRow = columns;
        var dst = 0;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            var matrixSrcRow = (blockY * 2 * columns);
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                var matrixSrcCol = blockX * 2;
                var src = matrixSrcRow + matrixSrcCol;
                packedRGBA[dst] = matrix[src];
                packedRGBA[dst + 1] = matrix[src + 1];
                packedRGBA[dst + 2] = matrix[src + oneRow];
                packedRGBA[dst + 3] = matrix[src + oneRow + 1];
                dst += 4;
            }
            dst += dstStride;
        }
    }
    if (oddWidth) {
        var src = columns - 1;
        var dst = (textureWidth - 1) * 4;
        var srcStride = 2 * columns;
        var dstStride = textureWidth * 4;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            packedRGBA[dst] = matrix[src];
            packedRGBA[dst + 2] = matrix[src + columns];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (rows - 1) * columns;
        var dst = (textureHeight - 1) * textureWidth * 4;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            packedRGBA[dst++] = matrix[src++];
            packedRGBA[dst++] = matrix[src++];
            dst += 2;
        }
    }
    if (oddWidth && oddHeight) {
        packedRGBA[packedRGBA.length - 4] = matrix[matrix.length - 1];
    }
    return packedRGBA;
}
exports.encodeMatrixToPackedRGBA = encodeMatrixToPackedRGBA;
function decodeMatrixFromPackedRGBA(packedRGBA, rows, columns, matrix) {
    var requiredSize = rows * columns;
    if (requiredSize < matrix.length) {
        throw new Error("matrix length (" + matrix.length + ") must be >= " + requiredSize);
    }
    var oddWidth = (columns % 2) === 1;
    var oddHeight = (rows % 2) === 1;
    var widthInFullBlocks = Math.floor(columns / 2);
    var heightInFullBlocks = Math.floor(rows / 2);
    var _a = getPackedMatrixTextureShapeWidthHeight(rows, columns), textureWidth = _a[0], textureHeight = _a[1];
    {
        var srcStride = oddWidth ? 4 : 0;
        var dstStride = columns + (oddWidth ? 1 : 0);
        var src = 0;
        var dstRow1 = 0;
        var dstRow2 = columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow1++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
                matrix[dstRow2++] = packedRGBA[src++];
            }
            src += srcStride;
            dstRow1 += dstStride;
            dstRow2 += dstStride;
        }
    }
    if (oddWidth) {
        var src = (textureWidth - 1) * 4;
        var dst = columns - 1;
        var srcStride = textureWidth * 4;
        var dstStride = 2 * columns;
        for (var blockY = 0; blockY < heightInFullBlocks; ++blockY) {
            matrix[dst] = packedRGBA[src];
            matrix[dst + columns] = packedRGBA[src + 2];
            src += srcStride;
            dst += dstStride;
        }
    }
    if (oddHeight) {
        var src = (textureHeight - 1) * textureWidth * 4;
        var dst = (rows - 1) * columns;
        for (var blockX = 0; blockX < widthInFullBlocks; ++blockX) {
            matrix[dst++] = packedRGBA[src++];
            matrix[dst++] = packedRGBA[src++];
            src += 2;
        }
    }
    if (oddWidth && oddHeight) {
        matrix[matrix.length - 1] = packedRGBA[packedRGBA.length - 4];
    }
    return matrix;
}
exports.decodeMatrixFromPackedRGBA = decodeMatrixFromPackedRGBA;

},{}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tex_util_1 = require("./tex_util");
var TextureManager = (function () {
    function TextureManager(gpgpu) {
        this.gpgpu = gpgpu;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
        this.freeTextures = {};
        this.logEnabled = false;
        this.allocatedTextures = [];
        this.usedTextureCount = {};
    }
    TextureManager.prototype.acquireTexture = function (shapeRC, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shapeRC, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        if (!(shapeKey in this.usedTextureCount)) {
            this.usedTextureCount[shapeKey] = 0;
        }
        this.usedTextureCount[shapeKey]++;
        if (this.freeTextures[shapeKey].length > 0) {
            this.numFreeTextures--;
            this.numUsedTextures++;
            this.log();
            return this.freeTextures[shapeKey].shift();
        }
        this.numUsedTextures++;
        this.log();
        var newTexture = this.gpgpu.createMatrixTexture(shapeRC[0], shapeRC[1]);
        this.allocatedTextures.push(newTexture);
        return newTexture;
    };
    TextureManager.prototype.releaseTexture = function (texture, shape, texType) {
        if (texType === void 0) { texType = tex_util_1.TextureType.FLOAT; }
        var shapeKey = getKeyFromTextureShape(shape, texType);
        if (!(shapeKey in this.freeTextures)) {
            this.freeTextures[shapeKey] = [];
        }
        this.freeTextures[shapeKey].push(texture);
        this.numFreeTextures++;
        this.numUsedTextures--;
        this.usedTextureCount[shapeKey]--;
        this.log();
    };
    TextureManager.prototype.log = function () {
        if (!this.logEnabled) {
            return;
        }
        var total = this.numFreeTextures + this.numUsedTextures;
        console.log('Free/Used', this.numFreeTextures + " / " + this.numUsedTextures, "(" + total + ")");
    };
    TextureManager.prototype.getNumUsedTextures = function () {
        return this.numUsedTextures;
    };
    TextureManager.prototype.getNumFreeTextures = function () {
        return this.numFreeTextures;
    };
    TextureManager.prototype.dispose = function () {
        var _this = this;
        if (this.allocatedTextures == null) {
            return;
        }
        this.allocatedTextures.forEach(function (texture) {
            _this.gpgpu.deleteMatrixTexture(texture);
        });
        this.freeTextures = null;
        this.allocatedTextures = null;
        this.usedTextureCount = null;
        this.numUsedTextures = 0;
        this.numFreeTextures = 0;
    };
    return TextureManager;
}());
exports.TextureManager = TextureManager;
function getKeyFromTextureShape(shapeRowsCol, texType) {
    return shapeRowsCol[0] + "_" + shapeRowsCol[1] + "_" + texType;
}

},{"./tex_util":90}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TileProgram = (function () {
    function TileProgram(aShape, reps) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[i] * reps[i];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var sourceCoords = getSourceCoords(aShape);
        this.userCode = "\n      void main() {\n        " + dtype + " resRC = getOutputCoords();\n        setOutput(getA(" + sourceCoords + "));\n      }\n    ";
    }
    return TileProgram;
}());
exports.TileProgram = TileProgram;
function getSourceCoords(aShape) {
    var rank = aShape.length;
    if (rank > 4) {
        throw Error("Tile for rank " + rank + " is not yet supported");
    }
    if (rank === 1) {
        return "imod(resRC, " + aShape[0] + ")";
    }
    var currentCoords = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var sourceCoords = [];
    for (var i = 0; i < aShape.length; i++) {
        sourceCoords.push("imod(" + currentCoords[i] + ", " + aShape[i] + ")");
    }
    return sourceCoords.join();
}

},{"./shader_compiler":88}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var shader_compiler_1 = require("./shader_compiler");
var TransposeProgram = (function () {
    function TransposeProgram(aShape, newDim) {
        this.variableNames = ['A'];
        var outputShape = new Array(aShape.length);
        for (var i = 0; i < outputShape.length; i++) {
            outputShape[i] = aShape[newDim[i]];
        }
        this.outputShape = outputShape;
        this.rank = outputShape.length;
        var dtype = shader_compiler_1.getCoordsDataType(this.rank);
        var switched = getSwitchedCoords(newDim);
        this.userCode = "\n    void main() {\n      " + dtype + " resRC = getOutputCoords();\n      setOutput(getA(" + switched + "));\n    }\n    ";
    }
    return TransposeProgram;
}());
exports.TransposeProgram = TransposeProgram;
function getSwitchedCoords(newDim) {
    var rank = newDim.length;
    if (rank > 4) {
        throw Error("Transpose for rank " + rank + " is not yet supported");
    }
    var originalOrder = ['resRC.x', 'resRC.y', 'resRC.z', 'resRC.w'];
    var switchedCoords = new Array(rank);
    for (var i = 0; i < newDim.length; i++) {
        switchedCoords[newDim[i]] = originalOrder[i];
    }
    return switchedCoords.join();
}

},{"./shader_compiler":88}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var selu_util = require("../../ops/selu_util");
var UnaryOpProgram = (function () {
    function UnaryOpProgram(aShape, opSnippet) {
        this.variableNames = ['A'];
        this.outputShape = aShape;
        this.userCode = "\n      float unaryOperation(float x) {\n        " + opSnippet + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
    }
    return UnaryOpProgram;
}());
exports.UnaryOpProgram = UnaryOpProgram;
var CHECK_NAN_SNIPPET = "\n  if (isNaN(x)) return x;\n";
exports.ABS = "\n  return abs(x);\n";
exports.RELU = CHECK_NAN_SNIPPET + "\n  return (x < 0.0) ? 0.0 : x;\n";
exports.ELU = "\n  return (x >= 0.0) ? x : (exp(x) - 1.0);\n";
exports.ELU_DER = "\n  return (x >= 0.0) ? 1.0 : exp(x);\n";
exports.SELU = "\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = " + selu_util.SELU_SCALEALPHA + ";\n  float scale = " + selu_util.SELU_SCALE + ";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n";
function LEAKY_RELU(alpha) {
    return "\n    return (x >= 0.0) ? x : " + alpha + " * x;\n  ";
}
exports.LEAKY_RELU = LEAKY_RELU;
function STEP(alpha) {
    if (alpha === void 0) { alpha = 0.0; }
    return CHECK_NAN_SNIPPET + ("\n    return x > 0.0 ? 1.0 : float(" + alpha + ");\n  ");
}
exports.STEP = STEP;
exports.NEG = "\n  return -x;\n";
exports.CEIL = "\n  return ceil(x);\n";
exports.FLOOR = "\n  return floor(x);\n";
exports.EXP = "\n  return exp(x);\n";
exports.LOG = "\n  return log(x);\n";
exports.SQRT = CHECK_NAN_SNIPPET + "\n  return sqrt(x);\n";
exports.SIGMOID = "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
exports.SIN = CHECK_NAN_SNIPPET + "\n  return sin(x);\n";
exports.COS = CHECK_NAN_SNIPPET + "\n  return cos(x);\n";
exports.TAN = "\n  return tan(x);\n";
exports.ASIN = CHECK_NAN_SNIPPET + "\n  return asin(x);\n";
exports.ACOS = CHECK_NAN_SNIPPET + "\n  return acos(x);\n";
exports.ATAN = CHECK_NAN_SNIPPET + "\n  return atan(x);\n";
exports.SINH = "\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n";
exports.COSH = "\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n";
exports.TANH = "\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n";
exports.SQUARE = "\n  return x * x;\n";
exports.LOGICAL_NOT = CHECK_NAN_SNIPPET + "\n  return float(!(x >= 1.0));\n";
exports.TO_INT = "\n  return float(int(x));\n";

},{"../../ops/selu_util":120}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MAX_TEXTURE_SIZE = null;
var util = require("../../util");
var environment_1 = require("../../environment");
function createWebGLRenderingContext(attributes) {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return createWebGLRenderingContextFromCanvas(canvas, attributes);
}
exports.createWebGLRenderingContext = createWebGLRenderingContext;
function createWebGLRenderingContextFromCanvas(canvas, attributes) {
    var gl;
    var webglVersion = environment_1.ENV.get('WEBGL_VERSION');
    if (webglVersion === 2) {
        gl = canvas.getContext('webgl2', attributes);
    }
    else if (webglVersion === 1) {
        gl = (canvas.getContext('webgl', attributes) ||
            canvas.getContext('experimental-webgl', attributes));
    }
    if (webglVersion === 0 || gl == null) {
        throw new Error('This browser does not support WebGL.');
    }
    return gl;
}
exports.createWebGLRenderingContextFromCanvas = createWebGLRenderingContextFromCanvas;
function callAndCheck(gl, func) {
    var returnValue = func();
    checkWebGLError(gl);
    return returnValue;
}
exports.callAndCheck = callAndCheck;
var webGLDebugErrorCheckingEnabled = false;
function enableDebugWebGLErrorChecking(enabled) {
    webGLDebugErrorCheckingEnabled = enabled;
}
exports.enableDebugWebGLErrorChecking = enableDebugWebGLErrorChecking;
function checkWebGLError(gl) {
    if (webGLDebugErrorCheckingEnabled) {
        var error = gl.getError();
        if (error !== gl.NO_ERROR) {
            throw new Error('WebGL Error: ' + getWebGLErrorMessage(gl, error));
        }
    }
}
exports.checkWebGLError = checkWebGLError;
function getWebGLErrorMessage(gl, status) {
    switch (status) {
        case gl.NO_ERROR:
            return 'NO_ERROR';
        case gl.INVALID_ENUM:
            return 'INVALID_ENUM';
        case gl.INVALID_VALUE:
            return 'INVALID_VALUE';
        case gl.INVALID_OPERATION:
            return 'INVALID_OPERATION';
        case gl.INVALID_FRAMEBUFFER_OPERATION:
            return 'INVALID_FRAMEBUFFER_OPERATION';
        case gl.OUT_OF_MEMORY:
            return 'OUT_OF_MEMORY';
        case gl.CONTEXT_LOST_WEBGL:
            return 'CONTEXT_LOST_WEBGL';
        default:
            return "Unknown error code " + status;
    }
}
exports.getWebGLErrorMessage = getWebGLErrorMessage;
function getExtensionOrThrow(gl, extensionName) {
    return throwIfNull(gl, function () { return gl.getExtension(extensionName); }, 'Extension "' + extensionName + '" not supported on this browser.');
}
exports.getExtensionOrThrow = getExtensionOrThrow;
function createVertexShader(gl, vertexShaderSource) {
    var vertexShader = throwIfNull(gl, function () { return gl.createShader(gl.VERTEX_SHADER); }, 'Unable to create vertex WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(vertexShader, vertexShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(vertexShader); });
    if (gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS) === false) {
        console.log(gl.getShaderInfoLog(vertexShader));
        throw new Error('Failed to compile vertex shader.');
    }
    return vertexShader;
}
exports.createVertexShader = createVertexShader;
function createFragmentShader(gl, fragmentShaderSource) {
    var fragmentShader = throwIfNull(gl, function () { return gl.createShader(gl.FRAGMENT_SHADER); }, 'Unable to create fragment WebGLShader.');
    callAndCheck(gl, function () { return gl.shaderSource(fragmentShader, fragmentShaderSource); });
    callAndCheck(gl, function () { return gl.compileShader(fragmentShader); });
    if (gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS) === false) {
        logShaderSourceAndInfoLog(fragmentShaderSource, gl.getShaderInfoLog(fragmentShader));
        throw new Error('Failed to compile fragment shader.');
    }
    return fragmentShader;
}
exports.createFragmentShader = createFragmentShader;
var lineNumberRegex = /ERROR: [0-9]+:([0-9]+):/g;
function logShaderSourceAndInfoLog(shaderSource, shaderInfoLog) {
    var lineNumberRegexResult = lineNumberRegex.exec(shaderInfoLog);
    if (lineNumberRegexResult == null) {
        console.log("Couldn't parse line number in error: " + shaderInfoLog);
        console.log(shaderSource);
        return;
    }
    var lineNumber = +lineNumberRegexResult[1];
    var shaderLines = shaderSource.split('\n');
    var pad = shaderLines.length.toString().length + 2;
    var linesWithLineNumbers = shaderLines.map(function (line, lineNumber) {
        return util.rightPad((lineNumber + 1).toString(), pad) + line;
    });
    var maxLineLength = 0;
    for (var i = 0; i < linesWithLineNumbers.length; i++) {
        maxLineLength = Math.max(linesWithLineNumbers[i].length, maxLineLength);
    }
    var beforeErrorLines = linesWithLineNumbers.slice(0, lineNumber - 1);
    var errorLine = linesWithLineNumbers.slice(lineNumber - 1, lineNumber);
    var afterErrorLines = linesWithLineNumbers.slice(lineNumber);
    console.log(beforeErrorLines.join('\n'));
    console.log(shaderInfoLog.split('\n')[0]);
    console.log("%c " + util.rightPad(errorLine[0], maxLineLength), 'border:1px solid red; background-color:#e3d2d2; color:#a61717');
    console.log(afterErrorLines.join('\n'));
}
function createProgram(gl) {
    return throwIfNull(gl, function () { return gl.createProgram(); }, 'Unable to create WebGLProgram.');
}
exports.createProgram = createProgram;
function linkProgram(gl, program) {
    callAndCheck(gl, function () { return gl.linkProgram(program); });
    if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Failed to link vertex and fragment shaders.');
    }
}
exports.linkProgram = linkProgram;
function validateProgram(gl, program) {
    callAndCheck(gl, function () { return gl.validateProgram(program); });
    if (gl.getProgramParameter(program, gl.VALIDATE_STATUS) === false) {
        console.log(gl.getProgramInfoLog(program));
        throw new Error('Shader program validation failed.');
    }
}
exports.validateProgram = validateProgram;
function createStaticVertexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticVertexBuffer = createStaticVertexBuffer;
function createStaticIndexBuffer(gl, data) {
    var buffer = throwIfNull(gl, function () { return gl.createBuffer(); }, 'Unable to create WebGLBuffer');
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data, gl.STATIC_DRAW); });
    return buffer;
}
exports.createStaticIndexBuffer = createStaticIndexBuffer;
function queryMaxTextureSize(gl) {
    if (MAX_TEXTURE_SIZE != null) {
        return MAX_TEXTURE_SIZE;
    }
    MAX_TEXTURE_SIZE =
        callAndCheck(gl, function () { return gl.getParameter(gl.MAX_TEXTURE_SIZE); });
    return MAX_TEXTURE_SIZE;
}
exports.queryMaxTextureSize = queryMaxTextureSize;
function getChannelsPerTexture() {
    if (!environment_1.ENV.get('WEBGL_FLOAT_TEXTURE_ENABLED')) {
        return 4;
    }
    if (environment_1.ENV.get('WEBGL_VERSION') === 2) {
        return 1;
    }
    return 4;
}
exports.getChannelsPerTexture = getChannelsPerTexture;
function createTexture(gl) {
    return throwIfNull(gl, function () { return gl.createTexture(); }, 'Unable to create WebGLTexture.');
}
exports.createTexture = createTexture;
function validateTextureSize(gl, width, height) {
    var maxTextureSize = queryMaxTextureSize(gl);
    if ((width <= 0) || (height <= 0)) {
        var requested = "[" + width + "x" + height + "]";
        throw new Error('Requested texture size ' + requested + ' is invalid.');
    }
    if ((width > maxTextureSize) || (height > maxTextureSize)) {
        var requested = "[" + width + "x" + height + "]";
        var max = "[" + maxTextureSize + "x" + maxTextureSize + "]";
        throw new Error('Requested texture size ' + requested +
            ' greater than WebGL maximum on this browser / GPU ' + max + '.');
    }
}
exports.validateTextureSize = validateTextureSize;
function createFramebuffer(gl) {
    return throwIfNull(gl, function () { return gl.createFramebuffer(); }, 'Unable to create WebGLFramebuffer.');
}
exports.createFramebuffer = createFramebuffer;
function bindVertexBufferToProgramAttribute(gl, program, attribute, buffer, arrayEntriesPerItem, itemStrideInBytes, itemOffsetInBytes) {
    var loc = gl.getAttribLocation(program, attribute);
    if (loc === -1) {
        return;
    }
    callAndCheck(gl, function () { return gl.bindBuffer(gl.ARRAY_BUFFER, buffer); });
    callAndCheck(gl, function () { return gl.vertexAttribPointer(loc, arrayEntriesPerItem, gl.FLOAT, false, itemStrideInBytes, itemOffsetInBytes); });
    callAndCheck(gl, function () { return gl.enableVertexAttribArray(loc); });
}
exports.bindVertexBufferToProgramAttribute = bindVertexBufferToProgramAttribute;
function bindTextureUnit(gl, texture, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, texture); });
}
exports.bindTextureUnit = bindTextureUnit;
function unbindTextureUnit(gl, textureUnit) {
    validateTextureUnit(gl, textureUnit);
    callAndCheck(gl, function () { return gl.activeTexture(gl.TEXTURE0 + textureUnit); });
    callAndCheck(gl, function () { return gl.bindTexture(gl.TEXTURE_2D, null); });
}
exports.unbindTextureUnit = unbindTextureUnit;
function getProgramUniformLocationOrThrow(gl, program, uniformName) {
    return throwIfNull(gl, function () { return gl.getUniformLocation(program, uniformName); }, 'uniform "' + uniformName + '" not present in program.');
}
exports.getProgramUniformLocationOrThrow = getProgramUniformLocationOrThrow;
function getProgramUniformLocation(gl, program, uniformName) {
    return gl.getUniformLocation(program, uniformName);
}
exports.getProgramUniformLocation = getProgramUniformLocation;
function bindTextureToProgramUniformSampler(gl, program, texture, uniformSamplerLocation, textureUnit) {
    callAndCheck(gl, function () { return bindTextureUnit(gl, texture, textureUnit); });
    callAndCheck(gl, function () { return gl.uniform1i(uniformSamplerLocation, textureUnit); });
}
exports.bindTextureToProgramUniformSampler = bindTextureToProgramUniformSampler;
function bindCanvasToFramebuffer(gl) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, null); });
    callAndCheck(gl, function () { return gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); });
    callAndCheck(gl, function () { return gl.scissor(0, 0, gl.canvas.width, gl.canvas.height); });
}
exports.bindCanvasToFramebuffer = bindCanvasToFramebuffer;
function bindColorTextureToFramebuffer(gl, texture, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0); });
}
exports.bindColorTextureToFramebuffer = bindColorTextureToFramebuffer;
function unbindColorTextureFromFramebuffer(gl, framebuffer) {
    callAndCheck(gl, function () { return gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer); });
    callAndCheck(gl, function () { return gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, null, 0); });
}
exports.unbindColorTextureFromFramebuffer = unbindColorTextureFromFramebuffer;
function validateFramebuffer(gl) {
    var status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
        throw new Error('Error binding framebuffer: ' + getFramebufferErrorMessage(gl, status));
    }
}
exports.validateFramebuffer = validateFramebuffer;
function getFramebufferErrorMessage(gl, status) {
    switch (status) {
        case gl.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
            return 'FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT';
        case gl.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:
            return 'FRAMEBUFFER_INCOMPLETE_DIMENSIONS';
        case gl.FRAMEBUFFER_UNSUPPORTED:
            return 'FRAMEBUFFER_UNSUPPORTED';
        default:
            return "unknown error " + status;
    }
}
exports.getFramebufferErrorMessage = getFramebufferErrorMessage;
function throwIfNull(gl, returnTOrNull, failureMessage) {
    var tOrNull = callAndCheck(gl, function () { return returnTOrNull(); });
    if (tOrNull == null) {
        throw new Error(failureMessage);
    }
    return tOrNull;
}
function validateTextureUnit(gl, textureUnit) {
    var maxTextureUnit = gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS - 1;
    var glTextureUnit = textureUnit + gl.TEXTURE0;
    if (glTextureUnit < gl.TEXTURE0 || glTextureUnit > maxTextureUnit) {
        var textureUnitRange = "[gl.TEXTURE0, gl.TEXTURE" + maxTextureUnit + "]";
        throw new Error("textureUnit must be in " + textureUnitRange + ".");
    }
}
function getTextureShapeFromLogicalShape(gl, logShape) {
    if (logShape.length !== 2) {
        var squeezeResult = util.squeezeShape(logShape);
        logShape = squeezeResult.newShape;
    }
    var maxTexSize = queryMaxTextureSize(gl);
    var size = util.sizeFromShape(logShape);
    if (logShape.length <= 1 && size <= maxTexSize) {
        return [size, 1];
    }
    else if (logShape.length === 2 && logShape[0] <= maxTexSize &&
        logShape[1] <= maxTexSize) {
        return logShape;
    }
    else if (logShape.length === 3 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2]];
    }
    else if (logShape.length === 4 && logShape[0] <= maxTexSize &&
        logShape[1] * logShape[2] * logShape[3] <= maxTexSize) {
        return [logShape[0], logShape[1] * logShape[2] * logShape[3]];
    }
    else {
        return util.sizeToSquarishShape(size);
    }
}
exports.getTextureShapeFromLogicalShape = getTextureShapeFromLogicalShape;

},{"../../environment":27,"../../util":143}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var array_ops_1 = require("./ops/array_ops");
var batchnorm_1 = require("./ops/batchnorm");
var binary_ops_1 = require("./ops/binary_ops");
var compare_1 = require("./ops/compare");
var conv_1 = require("./ops/conv");
var image_ops_1 = require("./ops/image_ops");
var logical_ops_1 = require("./ops/logical_ops");
var lrn_1 = require("./ops/lrn");
var lstm_1 = require("./ops/lstm");
var matmul_1 = require("./ops/matmul");
var norm_1 = require("./ops/norm");
var ops = require("./ops/ops");
var pool_1 = require("./ops/pool");
var reduction_ops_1 = require("./ops/reduction_ops");
var reverse_1 = require("./ops/reverse");
var slice_1 = require("./ops/slice");
var softmax_1 = require("./ops/softmax");
var transpose_1 = require("./ops/transpose");
var unary_ops_1 = require("./ops/unary_ops");
var tracking_1 = require("./tracking");
var util = require("./util");
var tidy = tracking_1.Tracking.tidy;
var keep = tracking_1.Tracking.keep;
var NDArrayMath = (function () {
    function NDArrayMath(backend, safeMode) {
        this.matMul = matmul_1.MatmulOps.matMul;
        this.vectorTimesMatrix = matmul_1.MatmulOps.vectorTimesMatrix;
        this.outerProduct = matmul_1.MatmulOps.outerProduct;
        this.matrixTimesVector = matmul_1.MatmulOps.matrixTimesVector;
        this.dotProduct = matmul_1.MatmulOps.dotProduct;
        this.slice = slice_1.SliceOps.slice;
        this.slice1D = slice_1.SliceOps.slice1d;
        this.slice2D = slice_1.SliceOps.slice2d;
        this.slice3D = slice_1.SliceOps.slice3d;
        this.slice4D = slice_1.SliceOps.slice4d;
        this.reverse = reverse_1.ReverseOps.reverse;
        this.reverse1D = reverse_1.ReverseOps.reverse1d;
        this.reverse2D = reverse_1.ReverseOps.reverse2d;
        this.reverse3D = reverse_1.ReverseOps.reverse3d;
        this.reverse4D = reverse_1.ReverseOps.reverse4d;
        this.batchNormalization = batchnorm_1.BatchNormOps.batchNormalization;
        this.batchNormalization2D = batchnorm_1.BatchNormOps.batchNormalization2d;
        this.batchNormalization3D = batchnorm_1.BatchNormOps.batchNormalization3d;
        this.batchNormalization4D = batchnorm_1.BatchNormOps.batchNormalization4d;
        this.avgPool = pool_1.PoolOps.avgPool;
        this.maxPool = pool_1.PoolOps.maxPool;
        this.minPool = pool_1.PoolOps.minPool;
        this.maxPoolBackprop = pool_1.PoolOps.maxPoolBackprop;
        this.conv2dTranspose = conv_1.ConvOps.conv2dTranspose;
        this.depthwiseConv2D = conv_1.ConvOps.depthwiseConv2d;
        this.conv2dDerFilter = conv_1.ConvOps.conv2dDerFilter;
        this.conv2dDerInput = conv_1.ConvOps.conv2dDerInput;
        this.argMax = reduction_ops_1.ReductionOps.argMax;
        this.argMin = reduction_ops_1.ReductionOps.argMin;
        this.logSumExp = reduction_ops_1.ReductionOps.logSumExp;
        this.max = reduction_ops_1.ReductionOps.max;
        this.mean = reduction_ops_1.ReductionOps.mean;
        this.min = reduction_ops_1.ReductionOps.min;
        this.moments = reduction_ops_1.ReductionOps.moments;
        this.sum = reduction_ops_1.ReductionOps.sum;
        this.add = binary_ops_1.BinaryOps.add;
        this.addStrict = binary_ops_1.BinaryOps.addStrict;
        this.div = binary_ops_1.BinaryOps.div;
        this.divide = this.div;
        this.divStrict = binary_ops_1.BinaryOps.divStrict;
        this.divideStrict = this.divStrict;
        this.maximum = binary_ops_1.BinaryOps.maximum;
        this.maximumStrict = binary_ops_1.BinaryOps.maximumStrict;
        this.minimum = binary_ops_1.BinaryOps.minimum;
        this.minimumStrict = binary_ops_1.BinaryOps.minimumStrict;
        this.mul = binary_ops_1.BinaryOps.mul;
        this.multiply = this.mul;
        this.mulStrict = binary_ops_1.BinaryOps.mulStrict;
        this.multiplyStrict = this.mulStrict;
        this.pow = binary_ops_1.BinaryOps.pow;
        this.powStrict = binary_ops_1.BinaryOps.powStrict;
        this.sub = binary_ops_1.BinaryOps.sub;
        this.subtract = this.sub;
        this.subStrict = binary_ops_1.BinaryOps.subStrict;
        this.logicalNot = logical_ops_1.LogicalOps.logicalNot;
        this.logicalAnd = logical_ops_1.LogicalOps.logicalAnd;
        this.logicalOr = logical_ops_1.LogicalOps.logicalOr;
        this.logicalXor = logical_ops_1.LogicalOps.logicalXor;
        this.where = logical_ops_1.LogicalOps.where;
        this.transpose = transpose_1.TransposeOps.transpose;
        this.equal = compare_1.CompareOps.equal;
        this.equalStrict = compare_1.CompareOps.equalStrict;
        this.greater = compare_1.CompareOps.greater;
        this.greaterStrict = compare_1.CompareOps.greaterStrict;
        this.greaterEqual = compare_1.CompareOps.greaterEqual;
        this.greaterEqualStrict = compare_1.CompareOps.greaterEqualStrict;
        this.less = compare_1.CompareOps.less;
        this.lessStrict = compare_1.CompareOps.lessStrict;
        this.lessEqual = compare_1.CompareOps.lessEqual;
        this.lessEqualStrict = compare_1.CompareOps.lessEqualStrict;
        this.notEqual = compare_1.CompareOps.notEqual;
        this.notEqualStrict = compare_1.CompareOps.notEqualStrict;
        this.abs = unary_ops_1.UnaryOps.abs;
        this.acos = unary_ops_1.UnaryOps.acos;
        this.asin = unary_ops_1.UnaryOps.asin;
        this.atan = unary_ops_1.UnaryOps.atan;
        this.ceil = unary_ops_1.UnaryOps.ceil;
        this.clip = unary_ops_1.UnaryOps.clipByValue;
        this.cos = unary_ops_1.UnaryOps.cos;
        this.cosh = unary_ops_1.UnaryOps.cosh;
        this.elu = unary_ops_1.UnaryOps.elu;
        this.exp = unary_ops_1.UnaryOps.exp;
        this.floor = unary_ops_1.UnaryOps.floor;
        this.leakyRelu = unary_ops_1.UnaryOps.leakyRelu;
        this.log = unary_ops_1.UnaryOps.log;
        this.neg = unary_ops_1.UnaryOps.neg;
        this.prelu = unary_ops_1.UnaryOps.prelu;
        this.relu = unary_ops_1.UnaryOps.relu;
        this.selu = unary_ops_1.UnaryOps.selu;
        this.sigmoid = unary_ops_1.UnaryOps.sigmoid;
        this.sin = unary_ops_1.UnaryOps.sin;
        this.sinh = unary_ops_1.UnaryOps.sinh;
        this.sqrt = unary_ops_1.UnaryOps.sqrt;
        this.square = unary_ops_1.UnaryOps.square;
        this.step = unary_ops_1.UnaryOps.step;
        this.tan = unary_ops_1.UnaryOps.tan;
        this.tanh = unary_ops_1.UnaryOps.tanh;
        this.norm = norm_1.NormOps.norm;
        this.basicLSTMCell = lstm_1.LSTMOps.basicLSTMCell;
        this.multiRNNCell = lstm_1.LSTMOps.multiRNNCell;
        this.softmax = softmax_1.SoftmaxOps.softmax;
        this.softmaxCrossEntropy = softmax_1.SoftmaxOps.softmaxCrossEntropy;
        this.cast = array_ops_1.ArrayOps.cast;
        this.clone = array_ops_1.ArrayOps.clone;
        this.gather = array_ops_1.ArrayOps.gather;
        this.reshape = array_ops_1.ArrayOps.reshape;
        this.tile = array_ops_1.ArrayOps.tile;
        this.oneHot = array_ops_1.ArrayOps.oneHot;
        this.multinomial = array_ops_1.ArrayOps.multinomial;
        this.pad1D = array_ops_1.ArrayOps.pad1d;
        this.pad2D = array_ops_1.ArrayOps.pad2d;
        this.resizeBilinear3D = image_ops_1.ImageOps.resizeBilinear;
        this.localResponseNormalization3D = lrn_1.LRNOps.localResponseNormalization;
        this.localResponseNormalization4D = lrn_1.LRNOps.localResponseNormalization;
        this.keep = tracking_1.Tracking.keep;
        environment_1.ENV.setMath(this, backend, safeMode);
        this.engine = environment_1.ENV.engine;
        this.dispose = environment_1.ENV.engine.dispose.bind(environment_1.ENV.engine);
        this.registeredVariables = environment_1.ENV.engine.registeredVariables;
        this.startScope = environment_1.ENV.engine.startScope.bind(environment_1.ENV.engine);
        this.endScope = environment_1.ENV.engine.endScope.bind(environment_1.ENV.engine);
    }
    NDArrayMath.prototype.scope = function (scopeFn) {
        var keepFn = function (tensor) { return keep(tensor); };
        var trackFn = function (tensor) { return tensor; };
        return tidy(function () { return scopeFn(keepFn, trackFn); });
    };
    NDArrayMath.prototype.track = function (result) {
        return result;
    };
    NDArrayMath.prototype.topK = function (x, k) {
        util.assert(k <= x.size, "Error in topK: k value (" + k + ") must be less than size of input " +
            ("tensor, got shape " + x.shape + "."));
        var values;
        var indices;
        tidy('topK', function () {
            values = environment_1.ENV.engine.runKernel(function (backend) { return backend.topKValues(x, k); }, { x: x });
            indices = environment_1.ENV.engine.runKernel(function (backend) { return backend.topKIndices(x, k); }, { x: x });
            return values;
        });
        var result = { values: values, indices: indices };
        return result;
    };
    NDArrayMath.prototype.elementWiseMul = function (a, b) {
        return a.mulStrict(b);
    };
    NDArrayMath.prototype.scalarDividedByArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarDividedByArray: first argument must be rank 0, but " +
            ("got Tensor of rank " + c.rank + "."));
        return c.div(a);
    };
    NDArrayMath.prototype.arrayDividedByScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: second argument must be rank 0, " +
            ("but got Tensor of rank " + c.rank + "."));
        return a.div(c);
    };
    NDArrayMath.prototype.switchDim = function (x, perm) {
        return ops.transpose(x, perm);
    };
    NDArrayMath.prototype.scalarPlusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarPlusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.add(c, a);
    };
    NDArrayMath.prototype.scalarMinusArray = function (c, a) {
        util.assert(c.size === 1, "Error in scalarMinusArray: first argument must be rank 0, but got " +
            ("rank " + c.rank + "."));
        return this.subtract(c, a);
    };
    NDArrayMath.prototype.arrayMinusScalar = function (a, c) {
        util.assert(c.size === 1, "Error in arrayMinusScalar: second argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.subtract(a, c);
    };
    NDArrayMath.prototype.scaledArrayAdd = function (c1, a, c2, b) {
        var _this = this;
        util.assert(c1.size === 1, "Error in scaledArrayAdd: first argument must rank 0, but got " +
            (" rank " + c1.rank + "."));
        util.assert(c2.size === 1, "Error in scaledArrayAdd: third argument must be rank 0, but got " +
            ("Tensor of rank " + c2.rank + "."));
        util.assertShapesMatch(a.shape, b.shape, 'Error in scaledArrayAdd: ');
        return tidy('scaledArrayAdd', function () {
            return _this.add(_this.multiply(c1, a), _this.multiply(c2, b));
        });
    };
    NDArrayMath.prototype.scalarTimesArray = function (c, a) {
        util.assert(c.size === 1, "Error in arrayDividedByScalar: first argument must be rank 0, but " +
            ("got rank " + c.rank + "."));
        return this.multiply(c, a);
    };
    NDArrayMath.prototype.concat = function (a, b, axis) {
        return ops.concat([a, b], axis);
    };
    NDArrayMath.prototype.concat1D = function (a, b) {
        return ops.concat1d([a, b]);
    };
    NDArrayMath.prototype.concat2D = function (a, b, axis) {
        return ops.concat2d([a, b], axis);
    };
    NDArrayMath.prototype.concat3D = function (a, b, axis) {
        return ops.concat3d([a, b], axis);
    };
    NDArrayMath.prototype.concat4D = function (a, b, axis) {
        return ops.concat4d([a, b], axis);
    };
    NDArrayMath.prototype.conv1d = function (input, filter, bias, stride, pad, dimRoundingMode) {
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv1d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        var res = ops.conv1d(input, filter, stride, pad, dimRoundingMode);
        return res.add(bias);
    };
    NDArrayMath.prototype.conv2d = function (x, filter, bias, strides, pad, dimRoundingMode) {
        if (bias != null) {
            util.assert(bias.rank === 1, "Error in conv2d: bias must be rank 1, but got rank " +
                (bias.rank + "."));
        }
        var res = ops.conv2d(x, filter, strides, pad, dimRoundingMode);
        return res.add(bias);
    };
    NDArrayMath.prototype.argMaxEquals = function (x1, x2) {
        util.assertShapesMatch(x1.shape, x2.shape, 'Error in argMaxEquals: ');
        return x1.argMax().equal(x2.argMax());
    };
    return NDArrayMath;
}());
exports.NDArrayMath = NDArrayMath;

},{"./environment":27,"./ops/array_ops":97,"./ops/batchnorm":99,"./ops/binary_ops":100,"./ops/compare":102,"./ops/conv":105,"./ops/image_ops":107,"./ops/logical_ops":108,"./ops/lrn":109,"./ops/lstm":110,"./ops/matmul":111,"./ops/norm":112,"./ops/ops":114,"./ops/pool":115,"./ops/reduction_ops":118,"./ops/reverse":119,"./ops/slice":121,"./ops/softmax":123,"./ops/transpose":124,"./ops/unary_ops":125,"./tracking":140,"./util":143}],97:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var tensor_1 = require("../tensor");
var tensor_util = require("../tensor_util");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_1 = require("./concat");
var operation_1 = require("./operation");
var rand_1 = require("./rand");
var ArrayOps = (function () {
    function ArrayOps() {
    }
    ArrayOps.tensor = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (shape != null && inferredShape.length !== 1) {
            util.assertShapesMatch(shape, inferredShape, "Error creating a new Tensor. " +
                ("Inferred shape (" + inferredShape + ") does not match the ") +
                ("provided shape (" + shape + "). "));
        }
        if (!util.isTypedArray(values) && !Array.isArray(values)) {
            values = [values];
        }
        shape = shape || inferredShape;
        return tensor_1.Tensor.make(shape, { values: toTypedArray(values, dtype) }, dtype);
    };
    ArrayOps.scalar = function (value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        if (util.isTypedArray(value) || Array.isArray(value)) {
            throw new Error('Error creating a new Scalar: value must be a primitive ' +
                '(number|boolean)');
        }
        return ArrayOps.tensor(value, [], dtype);
    };
    ArrayOps.tensor1d = function (values, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 1) {
            throw new Error('Error creating a new Tensor1D: values must be a flat/TypedArray');
        }
        return ArrayOps.tensor(values, inferredShape, dtype);
    };
    ArrayOps.tensor2d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 2 && inferredShape.length !== 1) {
            throw new Error('Error creating a new Tensor2D: values must be number[][] ' +
                'or flat/TypedArray');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor3d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 3 && inferredShape.length !== 1) {
            throw new Error('Error creating a new Tensor3D: values must be number[][][]' +
                'or flat/TypedArray');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.tensor4d = function (values, shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var inferredShape = util.inferShape(values);
        if (inferredShape.length !== 4 && inferredShape.length !== 1) {
            throw new Error('Error creating a new Tensor4D: values must be number[][][][]' +
                'or flat/TypedArray');
        }
        shape = shape || inferredShape;
        return ArrayOps.tensor(values, shape, dtype);
    };
    ArrayOps.ones = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeOnesTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.zeros = function (shape, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = makeZerosTypedArray(util.sizeFromShape(shape), dtype);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.fill = function (shape, value, dtype) {
        if (dtype === void 0) { dtype = 'float32'; }
        var values = util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        values.fill(value);
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.onesLike = function (x) {
        return ArrayOps.ones(x.shape, x.dtype);
    };
    ArrayOps.zerosLike = function (x) {
        return ArrayOps.zeros(x.shape, x.dtype);
    };
    ArrayOps.clone = function (x) {
        return tensor_1.Tensor.make(x.shape, { dataId: x.dataId }, x.dtype);
    };
    ArrayOps.randomNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, false, seed);
        return tensor_1.Tensor.rand(shape, function () { return randGauss.nextValue(); }, dtype);
    };
    ArrayOps.truncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        if (dtype != null && dtype === 'bool') {
            throw new Error("Unsupported data type " + dtype);
        }
        var randGauss = new rand_1.MPRandGauss(mean, stdDev, dtype, true, seed);
        return tensor_1.Tensor.rand(shape, function () { return randGauss.nextValue(); }, dtype);
    };
    ArrayOps.randomUniform = function (shape, minval, maxval, dtype) {
        if (minval === void 0) { minval = 0; }
        if (maxval === void 0) { maxval = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        return tensor_1.Tensor.rand(shape, function () { return util.randUniform(minval, maxval); }, dtype);
    };
    ArrayOps.rand = function (shape, randFunction, dtype) {
        var size = util.sizeFromShape(shape);
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        for (var i = 0; i < size; i++) {
            values[i] = randFunction();
        }
        return tensor_1.Tensor.make(shape, { values: values }, dtype);
    };
    ArrayOps.multinomial = function (probabilities, numSamples, seed) {
        var numOutcomes = probabilities.size;
        var origRank = probabilities.rank;
        if (numOutcomes < 2) {
            throw new Error("Error in multinomial: you need at least 2 outcomes, but got " +
                (numOutcomes + "."));
        }
        if (origRank > 2) {
            throw new Error("Rank of probabilities must be 1 or 2, but is " + origRank);
        }
        seed = seed || Math.random();
        var prob2D = origRank === 1 ? probabilities.as2D(1, -1) : probabilities;
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.multinomial(prob2D, numSamples, seed); }, { prob2D: prob2D });
        return origRank === 1 ? res.as1D() : res;
    };
    ArrayOps.oneHot = function (indices, depth, onValue, offValue) {
        if (onValue === void 0) { onValue = 1; }
        if (offValue === void 0) { offValue = 0; }
        if (depth < 2) {
            throw new Error("Error in oneHot: depth must be >=2, but it is " + depth);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.oneHot(indices, depth, onValue, offValue); }, { indices: indices });
    };
    ArrayOps.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        if (numChannels > 4) {
            throw new Error('Cannot construct Tensor with more than 4 channels from pixels.');
        }
        return environment_1.ENV.engine.fromPixels(pixels, numChannels);
    };
    ArrayOps.reshape = function (x, shape) {
        shape = util.inferFromImplicitShape(shape, x.size);
        util.assert(x.size === util.sizeFromShape(shape), 'new shape and old shape must have the same number of elements.');
        var grad = function (dy) {
            return { x: function () { return dy.reshape(x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return tensor_1.Tensor.make(shape, { dataId: x.dataId }, x.dtype); }, { x: x }, grad);
    };
    ArrayOps.squeeze = function (x, axis) {
        return ArrayOps.reshape(x, util.squeezeShape(x.shape, axis).newShape);
    };
    ArrayOps.cast = function (x, dtype) {
        var forw = function (backend) {
            if (!util.hasEncodingLoss(x.dtype, dtype)) {
                return tensor_1.Tensor.make(x.shape, { dataId: x.dataId }, dtype);
            }
            if (dtype === 'int32') {
                return backend.int(x);
            }
            else if (dtype === 'bool') {
                return backend.notEqual(x, ArrayOps.scalar(0, x.dtype));
            }
            else {
                throw new Error("Error in Cast: unknown dtype argument (" + dtype + ")");
            }
        };
        var grad = function (dy) {
            return { x: function () { return dy.clone(); } };
        };
        return environment_1.ENV.engine.runKernel(forw, { x: x }, grad);
    };
    ArrayOps.tile = function (x, reps) {
        util.assert(x.rank === reps.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of reps " + reps + "."));
        var grad = function (dy) {
            var derX = function () {
                var xGrad = ArrayOps.zerosLike(x);
                if (x.rank === 1) {
                    for (var i = 0; i < reps[0]; ++i) {
                        xGrad = xGrad.add(dy.slice([i * x.shape[0]], [x.shape[0]]));
                    }
                }
                else if (x.rank === 2) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1]], [x.shape[0], x.shape[1]]));
                        }
                    }
                }
                else if (x.rank === 3) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2]], [x.shape[0], x.shape[1], x.shape[2]]));
                            }
                        }
                    }
                }
                else if (x.rank === 4) {
                    for (var i = 0; i < reps[0]; ++i) {
                        for (var j = 0; j < reps[1]; ++j) {
                            for (var k = 0; k < reps[2]; ++k) {
                                for (var l = 0; l < reps[3]; ++l) {
                                    xGrad = xGrad.add(dy.slice([i * x.shape[0], j * x.shape[1], k * x.shape[2],
                                        l * x.shape[3]], [x.shape[0], x.shape[1], x.shape[2], x.shape[3]]));
                                }
                            }
                        }
                    }
                }
                else {
                    throw new Error("Gradient for tile operation is not implemented for rank-" +
                        (x.rank + " tensors yet."));
                }
                return xGrad;
            };
            return { x: derX };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tile(x, reps); }, { x: x }, grad);
    };
    ArrayOps.gather = function (x, indices, axis) {
        if (axis === void 0) { axis = 0; }
        var axes = axis_util_1.parseAxisParam(axis, x.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.gather(x, indices, axes[0]); }, { x: x, indices: indices });
    };
    ArrayOps.pad1d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2, 'Invalid number of paddings. Must be length of 2.');
        return ArrayOps.pad(x, [paddings], constantValue);
    };
    ArrayOps.pad2d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 2 && paddings[0].length === 2 &&
            paddings[1].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad3d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 3 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad4d = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        util.assert(paddings.length === 4 && paddings[0].length === 2 &&
            paddings[1].length === 2 && paddings[2].length === 2 &&
            paddings[3].length === 2, 'Invalid number of paddings. Must be length of 2 each.');
        return ArrayOps.pad(x, paddings, constantValue);
    };
    ArrayOps.pad = function (x, paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        if (x.rank === 0) {
            throw new Error('pad(scalar) is not defined. Pass non-scalar to pad');
        }
        var begin = paddings.map(function (p) { return p[0]; });
        var grad = function (dy) {
            return { x: function () { return dy.slice(begin, x.shape); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.pad(x, paddings, constantValue); }, { x: x }, grad);
    };
    ArrayOps.stack = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assert(tensors.length >= 2, 'Pass at least two tensors to dl.stack');
        var rank = tensors[0].rank;
        var shape = tensors[0].shape;
        var dtype = tensors[0].dtype;
        util.assert(axis <= rank, 'Axis must be <= rank of the tensor');
        tensors.forEach(function (t) {
            util.assertShapesMatch(shape, t.shape, 'All tensors passed to stack must have matching shapes');
        });
        tensors.forEach(function (t) {
            util.assert(dtype === t.dtype, 'All tensors passed to stack must have matching dtypes');
        });
        var expandedTensors = tensors.map(function (t) { return t.expandDims(axis); });
        return concat_1.ConcatOps.concat(expandedTensors, axis);
    };
    ArrayOps.expandDims = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        util.assert(axis <= x.rank, 'Axis must be <= rank of the tensor');
        var newShape = x.shape.slice();
        newShape.splice(axis, 0, 1);
        return ArrayOps.reshape(x, newShape);
    };
    ArrayOps.linspace = function (start, stop, num) {
        if (num === 0) {
            throw new Error('Cannot request zero samples');
        }
        var step = (stop - start) / (num - 1);
        var values = makeZerosTypedArray(num, 'float32');
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return tensor_1.Tensor1D.new(values, 'float32');
    };
    ArrayOps.range = function (start, stop, step, dtype) {
        if (step === void 0) { step = 1; }
        if (dtype === void 0) { dtype = 'float32'; }
        if (step === 0) {
            throw new Error('Cannot have a step of zero');
        }
        var sameStartStop = start === stop;
        var increasingRangeNegativeStep = start < stop && step < 0;
        var decreasingRangePositiveStep = stop < start && step > 1;
        if (sameStartStop || increasingRangeNegativeStep ||
            decreasingRangePositiveStep) {
            return ArrayOps.zeros([0], dtype);
        }
        var numElements = Math.abs(Math.ceil((stop - start) / step));
        var values = makeZerosTypedArray(numElements, dtype);
        if (stop < start && step === 1) {
            step = -1;
        }
        values[0] = start;
        for (var i = 1; i < values.length; i++) {
            values[i] = values[i - 1] + step;
        }
        return ArrayOps.tensor1d(values, dtype);
    };
    ArrayOps.buffer = function (shape, dtype, values) {
        if (dtype === void 0) { dtype = 'float32'; }
        return new tensor_1.TensorBuffer(shape, dtype, values);
    };
    ArrayOps.print = function (x, verbose) {
        if (verbose === void 0) { verbose = false; }
        console.log(tensor_util.tensorToString(x, verbose));
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "scalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor1d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor2d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor3d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "tensor4d", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "ones", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zeros", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fill", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "onesLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "zerosLike", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "truncatedNormal", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "randomUniform", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "rand", null);
    __decorate([
        operation_1.operation
    ], ArrayOps, "multinomial", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "oneHot", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' }),
        operation_1.operation
    ], ArrayOps, "fromPixels", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' })
    ], ArrayOps, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "cast", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "tile", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "gather", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "pad", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ArrayOps, "stack", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Transformations' }),
        operation_1.operation
    ], ArrayOps, "expandDims", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "linspace", null);
    __decorate([
        operation_1.operation,
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "range", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], ArrayOps, "print", null);
    return ArrayOps;
}());
exports.ArrayOps = ArrayOps;
function makeZerosTypedArray(size, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(size);
    }
    else if (dtype === 'int32') {
        return new Int32Array(size);
    }
    else if (dtype === 'bool') {
        return new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type $ {dtype}");
    }
}
function makeOnesTypedArray(size, dtype) {
    var array = makeZerosTypedArray(size, dtype);
    for (var i = 0; i < array.length; i++) {
        array[i] = 1;
    }
    return array;
}
function toTypedArray(a, dtype) {
    if (noConversionNeeded(a, dtype)) {
        return a;
    }
    if (Array.isArray(a)) {
        a = util.flatten(a);
    }
    return util.copyTypedArray(a, dtype);
}
function noConversionNeeded(a, dtype) {
    return (a instanceof Float32Array && dtype === 'float32') ||
        (a instanceof Int32Array && dtype === 'int32') ||
        (a instanceof Uint8Array && dtype === 'bool');
}

},{"../doc":25,"../environment":27,"../tensor":137,"../tensor_util":138,"../util":143,"./axis_util":98,"./concat":103,"./operation":113,"./rand":116}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function axesAreInnerMostDims(axes, rank) {
    for (var i = 0; i < axes.length; ++i) {
        if (axes[axes.length - i - 1] !== rank - 1 - i) {
            return false;
        }
    }
    return true;
}
exports.axesAreInnerMostDims = axesAreInnerMostDims;
function combineLocations(outputLoc, reduceLoc, axes) {
    var rank = outputLoc.length + reduceLoc.length;
    var loc = [];
    var outIdx = 0;
    var reduceIdx = 0;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            loc.push(outputLoc[outIdx++]);
        }
        else {
            loc.push(reduceLoc[reduceIdx++]);
        }
    }
    return loc;
}
exports.combineLocations = combineLocations;
function computeOutAndReduceShapes(aShape, axes) {
    var outShape = [];
    var rank = aShape.length;
    for (var dim = 0; dim < rank; dim++) {
        if (axes.indexOf(dim) === -1) {
            outShape.push(aShape[dim]);
        }
    }
    var reduceShape = axes.map(function (dim) { return aShape[dim]; });
    return [outShape, reduceShape];
}
exports.computeOutAndReduceShapes = computeOutAndReduceShapes;
function expandShapeToKeepDim(shape, axes) {
    var reduceSubShape = axes.map(function (x) { return 1; });
    return combineLocations(shape, reduceSubShape, axes);
}
exports.expandShapeToKeepDim = expandShapeToKeepDim;
function parseAxisParam(axis, shape) {
    var rank = shape.length;
    axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
    util.assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
        ("got axis " + axis));
    util.assert(axis.every(function (ax) { return util.isInt(ax); }), "All values in axis param must be integers but " +
        ("got axis " + axis));
    return axis.map(function (a) { return a < 0 ? rank + a : a; });
}
exports.parseAxisParam = parseAxisParam;
function assertAxesAreInnerMostDims(msg, axes, rank) {
    util.assert(axesAreInnerMostDims(axes, rank), msg + " supports only inner-most axes for now. " +
        ("Got axes " + axes + " and rank-" + rank + " input."));
}
exports.assertAxesAreInnerMostDims = assertAxesAreInnerMostDims;
function getAxesPermutation(axes, rank) {
    if (axesAreInnerMostDims(axes, rank)) {
        return null;
    }
    var result = [];
    for (var i = 0; i < rank; ++i) {
        if (axes.indexOf(i) === -1) {
            result.push(i);
        }
    }
    axes.forEach(function (axis) { return result.push(axis); });
    return result;
}
exports.getAxesPermutation = getAxesPermutation;
function getUndoAxesPermutation(axes) {
    return axes.map(function (axis, i) { return [i, axis]; })
        .sort(function (a, b) { return a[1] - b[1]; })
        .map(function (x) { return x[0]; });
}
exports.getUndoAxesPermutation = getUndoAxesPermutation;
function getInnerMostAxes(numAxes, rank) {
    var res = [];
    for (var i = rank - numAxes; i < rank; ++i) {
        res.push(i);
    }
    return res;
}
exports.getInnerMostAxes = getInnerMostAxes;

},{"../util":143}],99:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var BatchNormOps = (function () {
    function BatchNormOps() {
    }
    BatchNormOps.batchNormalization2d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 2, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 2 || mean.rank === 1, "Error in batchNormalization2D: mean must be rank 2 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 2 || variance.rank === 1, "Error in batchNormalization2D: variance must be rank 2 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 2 || scale.rank === 1, "Error in batchNormalization2D: scale must be rank 2 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 2 || offset.rank === 1, "Error in batchNormalization2D: offset must be rank 2 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization3d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 3, "Error in batchNormalization3D: x must be rank 3 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 3 || mean.rank === 1, "Error in batchNormalization3D: mean must be rank 3 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 3 || variance.rank === 1, "Error in batchNormalization3D: variance must be rank 3 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 3 || scale.rank === 1, "Error in batchNormalization3D: scale must be rank 3 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 3 || offset.rank === 1, "Error in batchNormalization3D: offset must be rank 3 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization4d = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        util.assert(x.rank === 4, "Error in batchNormalization4D: x must be rank 4 but got rank " +
            (x.rank + "."));
        util.assert(mean.rank === 4 || mean.rank === 1, "Error in batchNormalization4D: mean must be rank 4 or rank 1 but " +
            ("got rank " + mean.rank + "."));
        util.assert(variance.rank === 4 || variance.rank === 1, "Error in batchNormalization4D: variance must be rank 4 or rank 1 " +
            ("but got rank " + variance.rank + "."));
        if (scale != null) {
            util.assert(scale.rank === 4 || scale.rank === 1, "Error in batchNormalization4D: scale must be rank 4 or rank 1 " +
                ("but got rank " + scale.rank + "."));
        }
        if (offset != null) {
            util.assert(offset.rank === 4 || offset.rank === 1, "Error in batchNormalization4D: offset must be rank 4 or rank 1 " +
                ("but got rank " + offset.rank + "."));
        }
        return BatchNormOps.batchNormalization(x, mean, variance, varianceEpsilon, scale, offset);
    };
    BatchNormOps.batchNormalization = function (x, mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        var x4D;
        if (x.rank === 0 || x.rank === 1) {
            x4D = x.as4D(1, 1, 1, x.size);
        }
        else if (x.rank === 2) {
            x4D = x.as4D(1, 1, x.shape[0], x.shape[1]);
        }
        else if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        else {
            x4D = x;
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.batchNormalization4D(x4D, batchnormReshape4D(mean), batchnormReshape4D(variance), varianceEpsilon, batchnormReshape4D(scale), batchnormReshape4D(offset)); }, { x: x, mean: mean, variance: variance });
        return res.reshape(x.shape);
    };
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization2d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization3d", null);
    __decorate([
        operation_1.operation
    ], BatchNormOps, "batchNormalization4d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' })
    ], BatchNormOps, "batchNormalization", null);
    return BatchNormOps;
}());
exports.BatchNormOps = BatchNormOps;
function batchnormReshape4D(x) {
    if (x == null) {
        return null;
    }
    if (x.rank === 0) {
        return x.as1D();
    }
    else if (x.rank === 1) {
        return x;
    }
    else if (x.rank === 2) {
        return x.as4D(1, 1, x.shape[0], x.shape[1]);
    }
    else if (x.rank === 3) {
        return x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
    }
    return x;
}

},{"../doc":25,"../environment":27,"../util":143,"./operation":113}],100:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var ops_1 = require("./ops");
var BinaryOps = (function () {
    function BinaryOps() {
    }
    BinaryOps.add = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.add(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.addStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in addStrict: ');
        return a.add(b);
    };
    BinaryOps.sub = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.reshape(a.shape);
            };
            var derB = function () {
                var res = dy;
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes);
                }
                return res.neg().reshape(b.shape);
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.subtract(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.subStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in subStrict: ');
        return a.sub(b);
    };
    BinaryOps.pow = function (base, exp) {
        broadcast_util.assertAndGetBroadcastShape(base.shape, exp.shape);
        var grad = function (dy) {
            if (!util.arraysEqual(base.shape, exp.shape) &&
                !util.isScalarShape(exp.shape)) {
                throw new Error("Gradient of pow not yet supported for broadcasted shapes.");
            }
            var derBase = function () {
                var expFloat = exp.toFloat();
                var dx = expFloat.mul(base.toFloat().pow(expFloat.sub(ops_1.scalar(1))));
                return dy.mulStrict(dx);
            };
            return { base: derBase };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.pow(base, exp); }, { base: base }, grad);
    };
    BinaryOps.powStrict = function (base, exp) {
        util.assertShapesMatch(base.shape, exp.shape, 'Error in powStrict: ');
        return base.pow(exp);
    };
    BinaryOps.mul = function (a, b) {
        util.assertTypesMatch(a, b);
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.mul(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(b.shape);
                }
                return res;
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.multiply(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.mulStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in multiplyStrict: ');
        return a.mul(b);
    };
    BinaryOps.div = function (a, b) {
        var outShape = broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () {
                var res = dy.div(b.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(a.shape, outShape);
                if (reduceAxes.length > 0) {
                    return res.sum(reduceAxes).reshape(a.shape);
                }
                return res;
            };
            var derB = function () {
                var res = dy.mul(a.toFloat());
                var reduceAxes = broadcast_util.getReductionAxes(b.shape, outShape);
                if (reduceAxes.length > 0) {
                    res = res.sum(reduceAxes).reshape(b.shape);
                }
                var tmp = b.square();
                return res.div(tmp.toFloat()).neg();
            };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.divide(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.divStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in divideStrict: ');
        return a.div(b);
    };
    BinaryOps.minimum = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.lessEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.greater(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.minimum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.minimumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.minimum(b);
    };
    BinaryOps.maximum = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        var der = function (dy) {
            var derA = function () { return dy.mul(a.greaterEqual(b).toFloat()); };
            var derB = function () { return dy.mul(a.less(b).toFloat()); };
            return { a: derA, b: derB };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.maximum(a, b); }, { a: a, b: b }, der);
    };
    BinaryOps.maximumStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in minimumStrict: ');
        return a.maximum(b);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "add", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "addStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "sub", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "subStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "pow", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "powStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "mul", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "mulStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "div", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "divStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "minimum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "minimumStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Arithmetic' }),
        operation_1.operation
    ], BinaryOps, "maximum", null);
    __decorate([
        operation_1.operation
    ], BinaryOps, "maximumStrict", null);
    return BinaryOps;
}());
exports.BinaryOps = BinaryOps;

},{"../doc":25,"../environment":27,"../util":143,"./broadcast_util":101,"./operation":113,"./ops":114}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getBroadcastDims(inShape, outShape) {
    var inRank = inShape.length;
    var dims = [];
    for (var i = 0; i < inRank; i++) {
        var dim = inRank - 1 - i;
        var a = inShape[dim] || 1;
        var b = outShape[outShape.length - 1 - i] || 1;
        if (b > 1 && a === 1) {
            dims.unshift(dim);
        }
    }
    return dims;
}
exports.getBroadcastDims = getBroadcastDims;
function getReductionAxes(inShape, outShape) {
    var result = [];
    for (var i = 0; i < outShape.length; i++) {
        var inDim = inShape[inShape.length - i - 1];
        var outAxis = outShape.length - i - 1;
        var outDim = outShape[outAxis];
        if (inDim == null || (inDim === 1 && outDim > 1)) {
            result.unshift(outAxis);
        }
    }
    return result;
}
exports.getReductionAxes = getReductionAxes;
function broadcastDimsAreOuter(dims) {
    for (var i = 0; i < dims.length; i++) {
        if (dims[i] !== i) {
            return false;
        }
    }
    return true;
}
exports.broadcastDimsAreOuter = broadcastDimsAreOuter;
function assertAndGetBroadcastShape(shapeA, shapeB) {
    var result = [];
    var errMsg = "Operands could not be broadcast together with shapes " +
        (shapeA + " and " + shapeB + ".");
    var l = Math.max(shapeA.length, shapeB.length);
    for (var i = 0; i < l; i++) {
        var a = shapeA[shapeA.length - i - 1] || 1;
        var b = shapeB[shapeB.length - i - 1] || 1;
        if (a > 1 && b > 1 && a !== b) {
            throw Error(errMsg);
        }
        result.unshift(Math.max(a, b));
    }
    return result;
}
exports.assertAndGetBroadcastShape = assertAndGetBroadcastShape;

},{}],102:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var CompareOps = (function () {
    function CompareOps() {
    }
    CompareOps.notEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.notEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.notEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in notEqualStrict: ');
        return a.notEqual(b);
    };
    CompareOps.less = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.less(a, b); }, { a: a, b: b });
    };
    CompareOps.lessStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessStrict: ');
        return a.less(b);
    };
    CompareOps.equal = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.equal(a, b); }, { a: a, b: b });
    };
    CompareOps.equalStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in equalStrict: ');
        return a.equal(b);
    };
    CompareOps.lessEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.lessEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.lessEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in lessEqualStrict: ');
        return a.lessEqual(b);
    };
    CompareOps.greater = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greater(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterStrict: ');
        return a.greater(b);
    };
    CompareOps.greaterEqual = function (a, b) {
        util.assertTypesMatch(a, b);
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.greaterEqual(a, b); }, { a: a, b: b });
    };
    CompareOps.greaterEqualStrict = function (a, b) {
        util.assertShapesMatch(a.shape, b.shape, 'Error in greaterEqualStrict: ');
        return a.greaterEqual(b);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "notEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "notEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "less", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "equal", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "equalStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "lessEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "lessEqualStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greater", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterStrict", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], CompareOps, "greaterEqual", null);
    __decorate([
        operation_1.operation
    ], CompareOps, "greaterEqualStrict", null);
    return CompareOps;
}());
exports.CompareOps = CompareOps;

},{"../doc":25,"../environment":27,"../util":143,"./broadcast_util":101,"./operation":113}],103:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var concat_util = require("./concat_util");
var operation_1 = require("./operation");
var ConcatOps = (function () {
    function ConcatOps() {
    }
    ConcatOps.concat1d = function (tensors) {
        return ConcatOps.concat(tensors, 0);
    };
    ConcatOps.concat2d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat3d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat4d = function (tensors, axis) {
        return ConcatOps.concat(tensors, axis);
    };
    ConcatOps.concat = function (tensors, axis) {
        if (axis === void 0) { axis = 0; }
        util.assert(tensors.length >= 2, 'Pass at least two tensors to concat');
        var result = tensors[0];
        var axes = axis_util_1.parseAxisParam(axis, result.shape);
        for (var i = 1; i < tensors.length; ++i) {
            result = concat2Tensors(result, tensors[i], axes[0]);
        }
        return result;
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ConcatOps, "concat", null);
    return ConcatOps;
}());
exports.ConcatOps = ConcatOps;
function concat2Tensors(a, b, axis) {
    concat_util.assertParams(a.shape, b.shape, axis);
    var outShape = concat_util.computeOutShape(a.shape, b.shape, axis);
    var a2D = a.as2D(-1, util.sizeFromShape(a.shape.slice(axis)));
    var b2D = b.as2D(-1, util.sizeFromShape(b.shape.slice(axis)));
    var _a = concat_util.computeGradientSliceShapes(a2D.shape, b2D.shape), aBegin = _a.aBegin, aSize = _a.aSize, bBegin = _a.bBegin, bSize = _a.bSize;
    var der = function (dy) {
        return { a: function () { return dy.slice(aBegin, aSize); }, b: function () { return dy.slice(bBegin, bSize); } };
    };
    var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.concat(a2D, b2D); }, { a: a2D, b: b2D }, der);
    return res.reshape(outShape);
}

},{"../doc":25,"../environment":27,"../util":143,"./axis_util":98,"./concat_util":104,"./operation":113}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParams(aShape, bShape, axis) {
    var aRank = aShape.length;
    var bRank = bShape.length;
    util.assert(aShape.length === bShape.length, "Error in concat" + aRank + "D: rank of x1 (" + aRank + ") and x2 (" + bRank + ") " +
        "must be the same.");
    util.assert(axis >= 0 && axis < aRank, "Error in concat" + aRank + "D: axis must be " +
        ("between 0 and " + (aRank - 1) + "."));
    for (var i = 0; i < aRank; i++) {
        util.assert((i === axis) || (aShape[i] === bShape[i]), "Error in concat" + aRank + "D: Shape (" + aShape + ") does not match " +
            ("(" + bShape + ") along the non-concatenated axis " + i + "."));
    }
}
exports.assertParams = assertParams;
function computeOutShape1D(x1Shape, x2Shape) {
    util.assert(x1Shape.length === 1 && x2Shape.length === 1, 'x1 and x2 should be 1d array.');
    var outputShape = x1Shape.slice();
    outputShape[0] += x2Shape[0];
    return outputShape;
}
exports.computeOutShape1D = computeOutShape1D;
function computeOutShape(x1Shape, x2Shape, axis) {
    util.assert(x1Shape.length === x2Shape.length, 'x1 and x2 should have the same rank.');
    var outputShape = x1Shape.slice();
    outputShape[axis] += x2Shape[axis];
    return outputShape;
}
exports.computeOutShape = computeOutShape;
function computeGradientSliceShapes(aShape, bShape) {
    return {
        aBegin: [0, 0],
        aSize: aShape,
        bBegin: [0, aShape[1]],
        bSize: bShape
    };
}
exports.computeGradientSliceShapes = computeGradientSliceShapes;

},{"../util":143}],105:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var ConvOps = (function () {
    function ConvOps() {
    }
    ConvOps.conv1d = function (input, filter, stride, pad, dimRoundingMode) {
        var input3D = input;
        var reshapedTo3D = false;
        if (input.rank === 2) {
            reshapedTo3D = true;
            input3D = input.as3D(1, input.shape[0], input.shape[1]);
        }
        util.assert(input3D.rank === 3, "Error in conv1d: input must be rank 3, but got rank " + input3D.rank + ".");
        util.assert(filter.rank === 3, "Error in conv1d: filter must be rank 3, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv1d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(input3D.shape[2] === filter.shape[1], "Error in conv1d: depth of input (" + input3D.shape[2] + ") must match  " +
            ("input depth for filter " + filter.shape[1] + "."));
        var filter4D = filter.as4D(1, filter.shape[0], filter.shape[1], filter.shape[2]);
        var input4D = input3D.as4D(input3D.shape[0], 1, input3D.shape[1], input3D.shape[2]);
        var strides = [1, stride];
        var res = ConvOps.conv2d(input4D, filter4D, strides, pad, dimRoundingMode);
        if (reshapedTo3D) {
            return res.as2D(res.shape[2], res.shape[3]);
        }
        return res.as3D(res.shape[0], res.shape[2], res.shape[3]);
    };
    ConvOps.conv2d = function (x, filter, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2d: input must be rank 4, but got rank " + x4D.rank + ".");
        util.assert(filter.rank === 4, "Error in conv2d: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2d: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        util.assert(x4D.shape[3] === filter.shape[2], "Error in conv2d: depth of input (" + x4D.shape[3] + ") must match  " +
            ("input depth for filter " + filter.shape[2] + "."));
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode);
        var grad = function (dy) {
            return {
                x: function () { return ConvOps.conv2dDerInput(x4D.shape, dy, filter, strides, pad); },
                filter: function () {
                    return ConvOps.conv2dDerFilter(x4D, dy, filter.shape, strides, pad);
                }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2d(x4D, filter, convInfo); }, { x: x4D, filter: filter }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerInput = function (xShape, dy, filter, strides, pad, dimRoundingMode) {
        util.assert(xShape.length === dy.rank, "Length of inShape " +
            ("(" + xShape.length + ") and rank of dy (" + dy.rank + ") must match"));
        var xShape4D = xShape;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (dy.rank === 3) {
            reshapedTo4D = true;
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
            xShape4D = [1, xShape[0], xShape[1], xShape[2]];
        }
        var inDepth = xShape4D[3];
        var outDepth = dy4D.shape[3];
        util.assert(xShape4D.length === 4, "Error in conv2dDerInput: inShape must be length 4, but got length " +
            (xShape4D.length + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerInput: dy must be rank 4, but got " +
            ("rank " + dy4D.rank));
        util.assert(filter.rank === 4, "Error in conv2dDerInput: filter must be rank 4, but got " +
            ("rank " + filter.rank));
        util.assert(inDepth === filter.shape[2], "Error in conv2dDerInput: depth of input (" + inDepth + ") must " +
            ("match input depth for filter " + filter.shape[2] + "."));
        util.assert(outDepth === filter.shape[3], "Error in conv2dDerInput: depth of output (" + outDepth + ") must" +
            ("match output depth for filter " + filter.shape[3] + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerInput: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(xShape4D, filter.shape, strides, dilations, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerInput(dy4D, filter, convInfo); }, { dy4D: dy4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    ConvOps.conv2dDerFilter = function (x, dy, filterShape, strides, pad, dimRoundingMode) {
        var x4D = x;
        if (x.rank === 3) {
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var dy4D = dy;
        if (dy4D.rank === 3) {
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in conv2dDerFilter: input must be rank 4, but got shape " +
            (x4D.shape + "."));
        util.assert(dy4D.rank === 4, "Error in conv2dDerFilter: dy must be rank 4, but got shape " +
            (dy4D.shape + "."));
        util.assert(filterShape.length === 4, "Error in conv2dDerFilter: filterShape must be length 4, but got " +
            (filterShape + "."));
        util.assert(x4D.shape[3] === filterShape[2], "Error in conv2dDerFilter: depth of input " + x4D.shape[3] + ") must " +
            ("match input depth in filter (" + filterShape[2] + "."));
        util.assert(dy4D.shape[3] === filterShape[3], "Error in conv2dDerFilter: depth of dy (" + dy4D.shape[3] + ") must " +
            ("match output depth for filter (" + filterShape[3] + ")."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in conv2dDerFilter: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var dilations = 1;
        var convInfo = conv_util.computeConv2DInfo(x4D.shape, filterShape, strides, dilations, pad, dimRoundingMode);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.conv2dDerFilter(x4D, dy4D, convInfo); }, { x4D: x4D, dy4D: dy4D });
    };
    ConvOps.conv2dTranspose = function (x, filter, outputShape, strides, pad, dimRoundingMode) {
        return ConvOps.conv2dDerInput(outputShape, x, filter, strides, pad, dimRoundingMode);
    };
    ConvOps.depthwiseConv2d = function (input, filter, strides, pad, dilations, dimRoundingMode) {
        if (dilations === void 0) { dilations = [1, 1]; }
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in depthwiseConv2D: input must be rank 4, but got " +
            ("rank " + input4D.rank + "."));
        util.assert(filter.rank === 4, "Error in depthwiseConv2D: filter must be rank 4, but got rank " +
            (filter.rank + "."));
        util.assert(input4D.shape[3] === filter.shape[2], "Error in depthwiseConv2D: number of input channels " +
            ("(" + input4D.shape[3] + ") must match the inChannels dimension in ") +
            ("filter " + filter.shape[2] + "."));
        if (dilations == null) {
            dilations = [1, 1];
        }
        var _a = parseTupleParam(dilations), dilationHeight = _a[0], dilationWidth = _a[1];
        util.assert(dilationHeight === 1 && dilationWidth === 1, 'Error in depthwiseConv2D: dilation rates greater than 1 are not yet ' +
            ("supported. Got dilations '" + dilations + "'"));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in depthwiseConv2D: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computeConv2DInfo(input4D.shape, filter.shape, strides, dilations, pad, dimRoundingMode, true);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.depthwiseConv2D(input4D, filter, convInfo); }, { input4D: input4D, filter: filter });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv1d", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2d", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerInput", null);
    __decorate([
        operation_1.operation
    ], ConvOps, "conv2dDerFilter", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "conv2dTranspose", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], ConvOps, "depthwiseConv2d", null);
    return ConvOps;
}());
exports.ConvOps = ConvOps;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}

},{"../doc":25,"../environment":27,"../util":143,"./conv_util":106,"./operation":113}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function computePool2DInfo(inShape, filterSize, strides, pad, roundingMode, dataFormat) {
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = parseTupleParam(filterSize), filterHeight = _a[0], filterWidth = _a[1];
    var filterShape;
    if (dataFormat === 'channelsLast') {
        filterShape = [filterHeight, filterWidth, inShape[3], inShape[3]];
    }
    else if (dataFormat === 'channelsFirst') {
        filterShape = [filterHeight, filterWidth, inShape[1], inShape[1]];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var dilations = 1;
    return computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, false, dataFormat);
}
exports.computePool2DInfo = computePool2DInfo;
function computeConv2DInfo(inShape, filterShape, strides, dilations, pad, roundingMode, depthwise, dataFormat) {
    if (depthwise === void 0) { depthwise = false; }
    if (dataFormat === void 0) { dataFormat = 'channelsLast'; }
    var _a = [-1, -1, -1, -1], batchSize = _a[0], inHeight = _a[1], inWidth = _a[2], inChannels = _a[3];
    if (dataFormat === 'channelsLast') {
        batchSize = inShape[0], inHeight = inShape[1], inWidth = inShape[2], inChannels = inShape[3];
    }
    else if (dataFormat === 'channelsFirst') {
        batchSize = inShape[0], inChannels = inShape[1], inHeight = inShape[2], inWidth = inShape[3];
    }
    else {
        throw new Error("Unknown dataFormat " + dataFormat);
    }
    var filterHeight = filterShape[0], filterWidth = filterShape[1], filterChannels = filterShape[3];
    var _b = parseTupleParam(strides), strideHeight = _b[0], strideWidth = _b[1];
    var _c = parseTupleParam(dilations), dilationHeight = _c[0], dilationWidth = _c[1];
    var effectiveFilterHeight = getEffectiveFilterSize(filterHeight, dilationHeight);
    var effectiveFilterWidth = getEffectiveFilterSize(filterWidth, dilationWidth);
    var _d = getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, effectiveFilterHeight, effectiveFilterWidth, roundingMode), padInfo = _d.padInfo, outHeight = _d.outHeight, outWidth = _d.outWidth;
    var outChannels = depthwise ? filterChannels * inChannels : filterChannels;
    var outShape;
    if (dataFormat === 'channelsFirst') {
        outShape = [batchSize, outChannels, outHeight, outWidth];
    }
    else if (dataFormat === 'channelsLast') {
        outShape = [batchSize, outHeight, outWidth, outChannels];
    }
    return {
        batchSize: batchSize,
        dataFormat: dataFormat,
        inHeight: inHeight,
        inWidth: inWidth,
        inChannels: inChannels,
        outHeight: outHeight,
        outWidth: outWidth,
        outChannels: outChannels,
        padInfo: padInfo,
        strideHeight: strideHeight,
        strideWidth: strideWidth,
        filterHeight: filterHeight,
        filterWidth: filterWidth,
        inShape: inShape,
        outShape: outShape,
        filterShape: filterShape
    };
}
exports.computeConv2DInfo = computeConv2DInfo;
function computeOutputShape3D(inShape, fieldSize, outDepth, stride, zeroPad, roundingMode) {
    if (zeroPad == null) {
        zeroPad = computeDefaultPad(inShape, fieldSize, stride);
    }
    var inputRows = inShape[0];
    var inputCols = inShape[1];
    var outputRows = conditionalRound((inputRows - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputRows), "The output # of rows (" + outputRows + ") must be an integer. Change the " +
        "stride and/or zero pad parameters");
    var outputCols = conditionalRound((inputCols - fieldSize + 2 * zeroPad) / stride + 1, roundingMode);
    util.assert(util.isInt(outputCols), "The output # of columns (" + outputCols + ") must be an integer. Change " +
        "the stride and/or zero pad parameters");
    return [outputRows, outputCols, outDepth];
}
exports.computeOutputShape3D = computeOutputShape3D;
function computeDefaultPad(inputShape, fieldSize, stride) {
    return Math.floor((inputShape[0] * (stride - 1) - stride + fieldSize) / 2);
}
exports.computeDefaultPad = computeDefaultPad;
function computeWeightsShape4D(inputDepth, outputDepth, filterHeight, filterWidth) {
    return [filterHeight, filterWidth, inputDepth, outputDepth];
}
exports.computeWeightsShape4D = computeWeightsShape4D;
function computeDilatedRC(rc, origStride) {
    var rowsDilated = (rc[0] - 1) * origStride + 1;
    var colsDilated = (rc[1] - 1) * origStride + 1;
    return [rowsDilated, colsDilated];
}
exports.computeDilatedRC = computeDilatedRC;
function parseTupleParam(param) {
    return typeof param === 'number' ? [param, param] : param;
}
function getEffectiveFilterSize(filterSize, dilation) {
    if (dilation <= 1) {
        return filterSize;
    }
    return filterSize + (filterSize - 1) * (dilation - 1);
}
function getPadAndOutInfo(pad, inHeight, inWidth, strideHeight, strideWidth, filterHeight, filterWidth, roundingMode) {
    var padInfo;
    var outHeight;
    var outWidth;
    if (typeof pad === 'number') {
        padInfo = { top: pad, bottom: pad, left: pad, right: pad };
        var outShape = computeOutputShape3D([inHeight, inWidth, 1], filterHeight, 1, strideHeight, pad, roundingMode);
        outHeight = outShape[0];
        outWidth = outShape[1];
    }
    else if (pad === 'same') {
        outHeight = Math.ceil(inHeight / strideHeight);
        outWidth = Math.ceil(inWidth / strideWidth);
        var padAlongHeight = (outHeight - 1) * strideHeight + filterHeight - inHeight;
        var padAlongWidth = (outWidth - 1) * strideWidth + filterWidth - inWidth;
        var top_1 = Math.floor(padAlongHeight / 2);
        var bottom = padAlongHeight - top_1;
        var left = Math.floor(padAlongWidth / 2);
        var right = padAlongWidth - left;
        padInfo = { top: top_1, bottom: bottom, left: left, right: right };
    }
    else if (pad === 'valid') {
        padInfo = { top: 0, bottom: 0, left: 0, right: 0 };
        outHeight = Math.ceil((inHeight - filterHeight + 1) / strideHeight);
        outWidth = Math.ceil((inWidth - filterWidth + 1) / strideWidth);
    }
    else {
        throw Error("Unknown padding parameter: " + pad);
    }
    return { padInfo: padInfo, outHeight: outHeight, outWidth: outWidth };
}
function conditionalRound(value, roundingMode) {
    if (!roundingMode) {
        return value;
    }
    switch (roundingMode) {
        case 'round':
            return Math.round(value);
        case 'ceil':
            return Math.ceil(value);
        case 'floor':
            return Math.floor(value);
        default:
            throw new Error("Unknown roundingMode " + roundingMode);
    }
}

},{"../util":143}],107:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ImageOps = (function () {
    function ImageOps() {
    }
    ImageOps.resizeBilinear = function (images, size, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        util.assert(images.rank === 3 || images.rank === 4, "Error in resizeBilinear: x must be rank 3 or 4, but got " +
            ("rank " + images.rank + "."));
        util.assert(size.length === 2, "Error in resizeBilinear: new shape must 2D, but got shape " +
            (size + "."));
        var batchImages = images;
        var reshapedTo4D = false;
        if (images.rank === 3) {
            reshapedTo4D = true;
            batchImages =
                images.as4D(1, images.shape[0], images.shape[1], images.shape[2]);
        }
        var newHeight = size[0], newWidth = size[1];
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.resizeBilinear(batchImages, newHeight, newWidth, alignCorners); }, { batchImages: batchImages });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Images', namespace: 'image' }),
        operation_1.operation
    ], ImageOps, "resizeBilinear", null);
    return ImageOps;
}());
exports.ImageOps = ImageOps;

},{"../doc":25,"../environment":27,"../util":143,"./operation":113}],108:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var types = require("../types");
var util = require("../util");
var broadcast_util = require("./broadcast_util");
var operation_1 = require("./operation");
var LogicalOps = (function () {
    function LogicalOps() {
    }
    LogicalOps.logicalNot = function (x) {
        util.assert(x.dtype === 'bool', 'Error Array must be of type bool.');
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalNot(x); }, { x: x });
    };
    LogicalOps.logicalAnd = function (a, b) {
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalAnd(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalOr = function (a, b) {
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalOr(a, b); }, { a: a, b: b });
    };
    LogicalOps.logicalXor = function (a, b) {
        util.assert(a.dtype === 'bool' && b.dtype === 'bool', 'Error Array must be of type bool.');
        broadcast_util.assertAndGetBroadcastShape(a.shape, b.shape);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.logicalXor(a, b); }, { a: a, b: b });
    };
    LogicalOps.where = function (condition, a, b) {
        util.assert(condition.dtype === 'bool' || a.dtype === 'bool' || b.dtype === 'bool', 'Error Array must be of type bool.');
        util.assertShapesMatch(a.shape, b.shape, 'Error in where: ');
        if (condition.rank === 1) {
            util.assert(condition.shape[0] === a.shape[0], 'The first dimension of `a` must match the size of `condition`.');
        }
        else {
            util.assertShapesMatch(condition.shape, b.shape, 'Error in where: ');
        }
        var dtype = types.upcastType(a.dtype, b.dtype);
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.where(condition, a, b, dtype); }, { condition: condition, a: a, b: b });
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalNot", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalAnd", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalOr", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "logicalXor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Logical' }),
        operation_1.operation
    ], LogicalOps, "where", null);
    return LogicalOps;
}());
exports.LogicalOps = LogicalOps;

},{"../doc":25,"../environment":27,"../types":142,"../util":143,"./broadcast_util":101,"./operation":113}],109:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var LRNOps = (function () {
    function LRNOps() {
    }
    LRNOps.localResponseNormalization = function (x, radius, bias, alpha, beta, normRegion) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        if (normRegion === void 0) { normRegion = 'acrossChannels'; }
        util.assert(x.rank === 4 || x.rank === 3, "Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank " + x.rank + ".");
        util.assert(util.isInt(radius), "Error in localResponseNormalization3D: radius must be an integer\n                     but got radius " + radius + ".");
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.localResponseNormalization4D(x4D, radius, bias, alpha, beta, normRegion); }, { x4D: x4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        else {
            return res;
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], LRNOps, "localResponseNormalization", null);
    return LRNOps;
}());
exports.LRNOps = LRNOps;

},{"../doc":25,"../environment":27,"../util":143,"./operation":113}],110:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var operation_1 = require("./operation");
var LSTMOps = (function () {
    function LSTMOps() {
    }
    LSTMOps.multiRNNCell = function (lstmCells, data, c, h) {
        var input = data;
        var newStates = [];
        for (var i = 0; i < lstmCells.length; i++) {
            var output = lstmCells[i](input, c[i], h[i]);
            newStates.push(output[0]);
            newStates.push(output[1]);
            input = output[1];
        }
        var newC = [];
        var newH = [];
        for (var i = 0; i < newStates.length; i += 2) {
            newC.push(newStates[i]);
            newH.push(newStates[i + 1]);
        }
        return [newC, newH];
    };
    LSTMOps.basicLSTMCell = function (forgetBias, lstmKernel, lstmBias, data, c, h) {
        var combined = data.concat(h, 1);
        var weighted = combined.matMul(lstmKernel);
        var res = weighted.add(lstmBias);
        var batchSize = res.shape[0];
        var sliceCols = res.shape[1] / 4;
        var sliceSize = [batchSize, sliceCols];
        var i = res.slice([0, 0], sliceSize);
        var j = res.slice([0, sliceCols], sliceSize);
        var f = res.slice([0, sliceCols * 2], sliceSize);
        var o = res.slice([0, sliceCols * 3], sliceSize);
        var newC = i.sigmoid().mulStrict(j.tanh()).addStrict(c.mulStrict(forgetBias.add(f).sigmoid()));
        var newH = newC.tanh().mulStrict(o.sigmoid());
        return [newC, newH];
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "multiRNNCell", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'RNN' }),
        operation_1.operation
    ], LSTMOps, "basicLSTMCell", null);
    return LSTMOps;
}());
exports.LSTMOps = LSTMOps;

},{"../doc":25,"./operation":113}],111:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var MatrixOrientation;
(function (MatrixOrientation) {
    MatrixOrientation[MatrixOrientation["REGULAR"] = 0] = "REGULAR";
    MatrixOrientation[MatrixOrientation["TRANSPOSED"] = 1] = "TRANSPOSED";
})(MatrixOrientation = exports.MatrixOrientation || (exports.MatrixOrientation = {}));
var MatmulOps = (function () {
    function MatmulOps() {
    }
    MatmulOps.matMul = function (a, b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        _a = [enumToBool(transposeA), enumToBool(transposeB)], transposeA = _a[0], transposeB = _a[1];
        var innerShapeA = transposeA ? a.shape[0] : a.shape[1];
        var innerShapeB = transposeB ? b.shape[1] : b.shape[0];
        util.assert(a.rank === 2 && b.rank === 2, "Error in matMul: inputs must be rank 2, got ranks " + a.rank +
            (" and " + b.rank + "."));
        util.assert(innerShapeA === innerShapeB, "Error in matMul: inner shapes (" + innerShapeA + ") and (" +
            (innerShapeB + ") of Tensors with shapes " + a.shape + " and ") +
            (b.shape + " and transposeA=" + transposeA) +
            (" and transposeB=" + transposeB + " must match."));
        var grad = function (dy) {
            if (transposeA || transposeB) {
                throw new Error("Backprop for transposed MatMul not yet implemented.");
            }
            return {
                a: function () { return dy.matMul(b.toFloat(), false, true); },
                b: function () { return a.toFloat().matMul(dy, true, false); }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.matMul(a, b, transposeA, transposeB); }, { a: a, b: b }, grad);
        var _a;
    };
    MatmulOps.vectorTimesMatrix = function (v, matrix) {
        util.assert(v.rank === 1, "Error in vectorTimesMatrix: first input must be rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in vectorTimesMatrix: second input must be rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[0], "Error in vectorTimesMatrix: size of vector (" + v.size + ") " +
            ("must match first dimension of matrix (" + matrix.shape[0] + ")"));
        return v.as2D(1, -1).matMul(matrix).as1D();
    };
    MatmulOps.matrixTimesVector = function (matrix, v) {
        util.assert(v.rank === 1, "Error in matrixTimesVector: second input must rank 1, but got " +
            ("rank " + v.rank + "."));
        util.assert(matrix.rank === 2, "Error in matrixTimesVector: first input must be a rank 2, but got " +
            ("rank " + matrix.rank + "."));
        util.assert(v.size === matrix.shape[1], "Error in matrixTimesVector: size of first rank 1 input " + v.size + " " +
            "must match inner dimension of second rank 2 input, but got " +
            ("shape " + matrix.shape + "."));
        return matrix.matMul(v.as2D(-1, 1)).as1D();
    };
    MatmulOps.dotProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in dotProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        util.assert(v1.size === v2.size, "Error in dotProduct: size of inputs (" + v1.size + ") and (" +
            (v2.size + ") must match."));
        return v1.as2D(1, -1).matMul(v2.as2D(-1, 1)).asScalar();
    };
    MatmulOps.outerProduct = function (v1, v2) {
        util.assert(v1.rank === 1 && v2.rank === 1, "Error in outerProduct: inputs must be rank 1, but got ranks " +
            (v1.rank + " and " + v2.rank + "."));
        return v1.as2D(-1, 1).matMul(v2.as2D(1, -1));
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "matMul", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "vectorTimesMatrix", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "matrixTimesVector", null);
    __decorate([
        operation_1.operation
    ], MatmulOps, "dotProduct", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], MatmulOps, "outerProduct", null);
    return MatmulOps;
}());
exports.MatmulOps = MatmulOps;
function enumToBool(transpose) {
    if (transpose === MatrixOrientation.REGULAR) {
        return false;
    }
    if (transpose === MatrixOrientation.TRANSPOSED) {
        return true;
    }
    return transpose;
}

},{"../doc":25,"../environment":27,"../util":143,"./operation":113}],112:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var NormOps = (function () {
    function NormOps() {
    }
    NormOps.norm = function (x, ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var norm = normImpl(x, ord, axis);
        var keepDimsShape = norm.shape;
        if (keepDims) {
            var axes = axis_util.parseAxisParam(axis, x.shape);
            keepDimsShape = axis_util.expandShapeToKeepDim(norm.shape, axes);
        }
        return norm.reshape(keepDimsShape);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], NormOps, "norm", null);
    return NormOps;
}());
exports.NormOps = NormOps;
function normImpl(x, p, axis) {
    if (axis === void 0) { axis = null; }
    if (x.rank === 0) {
        return x.abs();
    }
    if (x.rank !== 1 && axis === null) {
        return normImpl(x.reshape([-1]), p, axis);
    }
    if (x.rank === 1 || typeof axis === 'number' ||
        axis instanceof Array && axis.length === 1) {
        if (p === 1) {
            return x.abs().sum(axis);
        }
        if (p === Infinity) {
            return x.abs().max(axis);
        }
        if (p === -Infinity) {
            return x.abs().min(axis);
        }
        if (p === 'euclidean' || p === 2) {
            return x.abs().pow(ops.scalar(2, 'int32')).sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    if (axis instanceof Array && axis.length === 2) {
        if (p === 1) {
            return x.abs().sum(axis[0]).max(axis[1] - 1);
        }
        if (p === Infinity) {
            return x.abs().sum(axis[1]).max(axis[0]);
        }
        if (p === -Infinity) {
            return x.abs().sum(axis[1]).min(axis[0]);
        }
        if (p === 'fro' || p === 'euclidean') {
            return x.square().sum(axis).sqrt();
        }
        throw new Error("Error in norm: invalid ord value: " + p);
    }
    throw new Error("Error in norm: invalid axis: " + axis);
}

},{"../doc":25,"./axis_util":98,"./operation":113,"./ops":114}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var globals_1 = require("../globals");
function operation(target, name, descriptor) {
    var fn = descriptor.value;
    descriptor.value = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        return globals_1.tidy(name, function () { return fn.apply(void 0, args); });
    };
    return descriptor;
}
exports.operation = operation;

},{"../globals":28}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var array_ops_1 = require("./array_ops");
var batchnorm_1 = require("./batchnorm");
var binary_ops_1 = require("./binary_ops");
var compare_1 = require("./compare");
var concat_1 = require("./concat");
var conv_1 = require("./conv");
var image_ops_1 = require("./image_ops");
var logical_ops_1 = require("./logical_ops");
var lrn_1 = require("./lrn");
var lstm_1 = require("./lstm");
var matmul_1 = require("./matmul");
var norm_1 = require("./norm");
var pool_1 = require("./pool");
var reduction_ops_1 = require("./reduction_ops");
var reverse_1 = require("./reverse");
var slice_1 = require("./slice");
var softmax_1 = require("./softmax");
var transpose_1 = require("./transpose");
var unary_ops_1 = require("./unary_ops");
exports.batchNormalization = batchnorm_1.BatchNormOps.batchNormalization;
exports.batchNormalization2d = batchnorm_1.BatchNormOps.batchNormalization2d;
exports.batchNormalization3d = batchnorm_1.BatchNormOps.batchNormalization3d;
exports.batchNormalization4d = batchnorm_1.BatchNormOps.batchNormalization4d;
exports.concat = concat_1.ConcatOps.concat;
exports.concat1d = concat_1.ConcatOps.concat1d;
exports.concat2d = concat_1.ConcatOps.concat2d;
exports.concat3d = concat_1.ConcatOps.concat3d;
exports.concat4d = concat_1.ConcatOps.concat4d;
exports.conv1d = conv_1.ConvOps.conv1d;
exports.conv2d = conv_1.ConvOps.conv2d;
exports.conv2dTranspose = conv_1.ConvOps.conv2dTranspose;
exports.depthwiseConv2d = conv_1.ConvOps.depthwiseConv2d;
exports.matMul = matmul_1.MatmulOps.matMul;
exports.matrixTimesVector = matmul_1.MatmulOps.matrixTimesVector;
exports.outerProduct = matmul_1.MatmulOps.outerProduct;
exports.vectorTimesMatrix = matmul_1.MatmulOps.vectorTimesMatrix;
exports.avgPool = pool_1.PoolOps.avgPool;
exports.maxPool = pool_1.PoolOps.maxPool;
exports.minPool = pool_1.PoolOps.minPool;
exports.transpose = transpose_1.TransposeOps.transpose;
exports.reverse = reverse_1.ReverseOps.reverse;
exports.reverse1d = reverse_1.ReverseOps.reverse1d;
exports.reverse2d = reverse_1.ReverseOps.reverse2d;
exports.reverse3d = reverse_1.ReverseOps.reverse3d;
exports.reverse4d = reverse_1.ReverseOps.reverse4d;
exports.slice = slice_1.SliceOps.slice;
exports.slice1d = slice_1.SliceOps.slice1d;
exports.slice2d = slice_1.SliceOps.slice2d;
exports.slice3d = slice_1.SliceOps.slice3d;
exports.slice4d = slice_1.SliceOps.slice4d;
exports.argMax = reduction_ops_1.ReductionOps.argMax;
exports.argMin = reduction_ops_1.ReductionOps.argMin;
exports.logSumExp = reduction_ops_1.ReductionOps.logSumExp;
exports.max = reduction_ops_1.ReductionOps.max;
exports.mean = reduction_ops_1.ReductionOps.mean;
exports.min = reduction_ops_1.ReductionOps.min;
exports.moments = reduction_ops_1.ReductionOps.moments;
exports.sum = reduction_ops_1.ReductionOps.sum;
exports.equal = compare_1.CompareOps.equal;
exports.equalStrict = compare_1.CompareOps.equalStrict;
exports.greater = compare_1.CompareOps.greater;
exports.greaterStrict = compare_1.CompareOps.greaterStrict;
exports.greaterEqual = compare_1.CompareOps.greaterEqual;
exports.greaterEqualStrict = compare_1.CompareOps.greaterEqualStrict;
exports.less = compare_1.CompareOps.less;
exports.lessStrict = compare_1.CompareOps.lessStrict;
exports.lessEqual = compare_1.CompareOps.lessEqual;
exports.lessEqualStrict = compare_1.CompareOps.lessEqualStrict;
exports.notEqual = compare_1.CompareOps.notEqual;
exports.notEqualStrict = compare_1.CompareOps.notEqualStrict;
exports.logicalNot = logical_ops_1.LogicalOps.logicalNot;
exports.logicalAnd = logical_ops_1.LogicalOps.logicalAnd;
exports.logicalOr = logical_ops_1.LogicalOps.logicalOr;
exports.logicalXor = logical_ops_1.LogicalOps.logicalXor;
exports.where = logical_ops_1.LogicalOps.where;
exports.abs = unary_ops_1.UnaryOps.abs;
exports.acos = unary_ops_1.UnaryOps.acos;
exports.asin = unary_ops_1.UnaryOps.asin;
exports.atan = unary_ops_1.UnaryOps.atan;
exports.ceil = unary_ops_1.UnaryOps.ceil;
exports.clipByValue = unary_ops_1.UnaryOps.clipByValue;
exports.cos = unary_ops_1.UnaryOps.cos;
exports.cosh = unary_ops_1.UnaryOps.cosh;
exports.elu = unary_ops_1.UnaryOps.elu;
exports.exp = unary_ops_1.UnaryOps.exp;
exports.floor = unary_ops_1.UnaryOps.floor;
exports.leakyRelu = unary_ops_1.UnaryOps.leakyRelu;
exports.log = unary_ops_1.UnaryOps.log;
exports.neg = unary_ops_1.UnaryOps.neg;
exports.prelu = unary_ops_1.UnaryOps.prelu;
exports.relu = unary_ops_1.UnaryOps.relu;
exports.selu = unary_ops_1.UnaryOps.selu;
exports.sigmoid = unary_ops_1.UnaryOps.sigmoid;
exports.sin = unary_ops_1.UnaryOps.sin;
exports.sinh = unary_ops_1.UnaryOps.sinh;
exports.sqrt = unary_ops_1.UnaryOps.sqrt;
exports.square = unary_ops_1.UnaryOps.square;
exports.step = unary_ops_1.UnaryOps.step;
exports.tan = unary_ops_1.UnaryOps.tan;
exports.tanh = unary_ops_1.UnaryOps.tanh;
exports.add = binary_ops_1.BinaryOps.add;
exports.addStrict = binary_ops_1.BinaryOps.addStrict;
exports.div = binary_ops_1.BinaryOps.div;
exports.divStrict = binary_ops_1.BinaryOps.divStrict;
exports.maximum = binary_ops_1.BinaryOps.maximum;
exports.maximumStrict = binary_ops_1.BinaryOps.maximumStrict;
exports.minimum = binary_ops_1.BinaryOps.minimum;
exports.minimumStrict = binary_ops_1.BinaryOps.minimumStrict;
exports.mul = binary_ops_1.BinaryOps.mul;
exports.mulStrict = binary_ops_1.BinaryOps.mulStrict;
exports.pow = binary_ops_1.BinaryOps.pow;
exports.powStrict = binary_ops_1.BinaryOps.powStrict;
exports.sub = binary_ops_1.BinaryOps.sub;
exports.subStrict = binary_ops_1.BinaryOps.subStrict;
exports.norm = norm_1.NormOps.norm;
exports.cast = array_ops_1.ArrayOps.cast;
exports.clone = array_ops_1.ArrayOps.clone;
exports.fromPixels = array_ops_1.ArrayOps.fromPixels;
exports.ones = array_ops_1.ArrayOps.ones;
exports.onesLike = array_ops_1.ArrayOps.onesLike;
exports.zeros = array_ops_1.ArrayOps.zeros;
exports.zerosLike = array_ops_1.ArrayOps.zerosLike;
exports.rand = array_ops_1.ArrayOps.rand;
exports.randomNormal = array_ops_1.ArrayOps.randomNormal;
exports.truncatedNormal = array_ops_1.ArrayOps.truncatedNormal;
exports.randomUniform = array_ops_1.ArrayOps.randomUniform;
exports.reshape = array_ops_1.ArrayOps.reshape;
exports.squeeze = array_ops_1.ArrayOps.squeeze;
exports.tile = array_ops_1.ArrayOps.tile;
exports.gather = array_ops_1.ArrayOps.gather;
exports.oneHot = array_ops_1.ArrayOps.oneHot;
exports.linspace = array_ops_1.ArrayOps.linspace;
exports.range = array_ops_1.ArrayOps.range;
exports.buffer = array_ops_1.ArrayOps.buffer;
exports.fill = array_ops_1.ArrayOps.fill;
exports.tensor = array_ops_1.ArrayOps.tensor;
exports.scalar = array_ops_1.ArrayOps.scalar;
exports.tensor1d = array_ops_1.ArrayOps.tensor1d;
exports.tensor2d = array_ops_1.ArrayOps.tensor2d;
exports.tensor3d = array_ops_1.ArrayOps.tensor3d;
exports.tensor4d = array_ops_1.ArrayOps.tensor4d;
exports.print = array_ops_1.ArrayOps.print;
exports.expandDims = array_ops_1.ArrayOps.expandDims;
exports.stack = array_ops_1.ArrayOps.stack;
exports.pad = array_ops_1.ArrayOps.pad;
exports.pad1d = array_ops_1.ArrayOps.pad1d;
exports.pad2d = array_ops_1.ArrayOps.pad2d;
exports.pad3d = array_ops_1.ArrayOps.pad3d;
exports.pad4d = array_ops_1.ArrayOps.pad4d;
exports.basicLSTMCell = lstm_1.LSTMOps.basicLSTMCell;
exports.multiRNNCell = lstm_1.LSTMOps.multiRNNCell;
exports.softmax = softmax_1.SoftmaxOps.softmax;
exports.localResponseNormalization = lrn_1.LRNOps.localResponseNormalization;
var tensor_1 = require("../tensor");
var types_1 = require("../types");
[tensor_1.Tensor, types_1.Rank, tensor_1.Tensor3D, tensor_1.Tensor4D];
exports.losses = {
    softmaxCrossEntropy: softmax_1.SoftmaxOps.softmaxCrossEntropy
};
exports.image = {
    resizeBilinear: image_ops_1.ImageOps.resizeBilinear
};

},{"../tensor":137,"../types":142,"./array_ops":97,"./batchnorm":99,"./binary_ops":100,"./compare":102,"./concat":103,"./conv":105,"./image_ops":107,"./logical_ops":108,"./lrn":109,"./lstm":110,"./matmul":111,"./norm":112,"./pool":115,"./reduction_ops":118,"./reverse":119,"./slice":121,"./softmax":123,"./transpose":124,"./unary_ops":125}],115:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var conv_util = require("./conv_util");
var operation_1 = require("./operation");
var PoolOps = (function () {
    function PoolOps() {
    }
    PoolOps.maxPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in maxPool: input must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad, dimRoundingMode);
        var grad = function (dy) {
            return {
                x: function () { return PoolOps.maxPoolBackprop(dy, x4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.maxPool(x4D, convInfo); }, { x: x4D }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.maxPoolBackprop = function (dy, input, filterSize, strides, pad, dimRoundingMode) {
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in maxPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in maxPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in maxPoolBackprop: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.maxPoolBackprop(dy4D, input4D, convInfo); }, { dy4D: dy4D, input4D: input4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.minPool = function (input, filterSize, strides, pad, dimRoundingMode) {
        var input4D = input;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
        }
        util.assert(input4D.rank === 4, "Error in minPool: x must be rank 4 but got rank " + input4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in minPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad, dimRoundingMode);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.minPool(input4D, convInfo); }, { input4D: input4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.avgPool = function (x, filterSize, strides, pad, dimRoundingMode) {
        var x4D = x;
        var reshapedTo4D = false;
        if (x.rank === 3) {
            reshapedTo4D = true;
            x4D = x.as4D(1, x.shape[0], x.shape[1], x.shape[2]);
        }
        util.assert(x4D.rank === 4, "Error in avgPool: x must be rank 4 but got rank " + x4D.rank + ".");
        if (dimRoundingMode != null) {
            util.assert(util.isInt(pad), "Error in avgPool: pad must be an integer when using, " +
                ("dimRoundingMode " + dimRoundingMode + " but got pad " + pad + "."));
        }
        var convInfo = conv_util.computePool2DInfo(x4D.shape, filterSize, strides, pad);
        var grad = function (dy) {
            return {
                x: function () { return PoolOps.avgPoolBackprop(dy, x4D, filterSize, strides, pad); }
            };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPool(x4D, convInfo); }, { x: x4D }, grad);
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    PoolOps.avgPoolBackprop = function (dy, input, filterSize, strides, pad) {
        util.assert(input.rank === dy.rank, "Rank of input (" + input.rank + ") does not match rank of dy (" + dy.rank + ")");
        var input4D = input;
        var dy4D = dy;
        var reshapedTo4D = false;
        if (input.rank === 3) {
            reshapedTo4D = true;
            input4D = input.as4D(1, input.shape[0], input.shape[1], input.shape[2]);
            dy4D = dy.as4D(1, dy.shape[0], dy.shape[1], dy.shape[2]);
        }
        util.assert(dy4D.rank === 4, "Error in avgPoolBackprop: dy must be rank 4 but got rank " +
            (dy4D.rank + "."));
        util.assert(input4D.rank === 4, "Error in avgPoolBackprop: input must be rank 4 but got rank " +
            (input4D.rank + "."));
        var convInfo = conv_util.computePool2DInfo(input4D.shape, filterSize, strides, pad);
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.avgPoolBackprop(dy4D, input4D, convInfo); }, { dy4D: dy4D, input4D: input4D });
        if (reshapedTo4D) {
            return res.as3D(res.shape[1], res.shape[2], res.shape[3]);
        }
        return res;
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "maxPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "maxPoolBackprop", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "minPool", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Convolution' }),
        operation_1.operation
    ], PoolOps, "avgPool", null);
    __decorate([
        operation_1.operation
    ], PoolOps, "avgPoolBackprop", null);
    return PoolOps;
}());
exports.PoolOps = PoolOps;

},{"../doc":25,"../environment":27,"../util":143,"./conv_util":106,"./operation":113}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var seedrandom = require("seedrandom");
var MPRandGauss = (function () {
    function MPRandGauss(mean, stdDeviation, dtype, truncated, seed) {
        this.mean = mean;
        this.stdDev = stdDeviation;
        this.dtype = dtype;
        this.nextVal = NaN;
        this.truncated = truncated;
        if (this.truncated) {
            this.upper = this.mean + this.stdDev * 2;
            this.lower = this.mean - this.stdDev * 2;
        }
        var seedValue = seed ? seed : Math.random();
        this.random = seedrandom.alea(seedValue.toString());
    }
    MPRandGauss.prototype.nextValue = function () {
        if (!isNaN(this.nextVal)) {
            var value = this.nextVal;
            this.nextVal = NaN;
            return value;
        }
        var resultX, resultY;
        var isValid = false;
        while (!isValid) {
            var v1 = void 0, v2 = void 0, s = void 0;
            do {
                v1 = 2 * this.random() - 1;
                v2 = 2 * this.random() - 1;
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s === 0);
            var mul = Math.sqrt(-2.0 * Math.log(s) / s);
            resultX = this.mean + this.stdDev * v1 * mul;
            resultY = this.mean + this.stdDev * v2 * mul;
            if (!this.truncated || this.isValidTruncated(resultX)) {
                isValid = true;
            }
        }
        if (!this.truncated || this.isValidTruncated(resultY)) {
            this.nextVal = this.convertValue(resultY);
        }
        return this.convertValue(resultX);
    };
    MPRandGauss.prototype.convertValue = function (value) {
        if (this.dtype == null || this.dtype === 'float32') {
            return value;
        }
        return Math.round(value);
    };
    MPRandGauss.prototype.isValidTruncated = function (value) {
        return value <= this.upper && value >= this.lower;
    };
    return MPRandGauss;
}());
exports.MPRandGauss = MPRandGauss;

},{"seedrandom":146}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PARALLELIZE_THRESHOLD = 30;
function computeOptimalWindowSize(inSize) {
    if (inSize <= exports.PARALLELIZE_THRESHOLD) {
        return inSize;
    }
    return nearestDivisor(inSize, Math.floor(Math.sqrt(inSize)));
}
exports.computeOptimalWindowSize = computeOptimalWindowSize;
function nearestDivisor(size, start) {
    for (var i = start; i < size; ++i) {
        if (size % i === 0) {
            return i;
        }
    }
    return size;
}

},{}],118:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_1 = require("../tensor");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ReductionOps = (function () {
    function ReductionOps() {
    }
    ReductionOps.logSumExp = function (input, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, input.shape);
        var xMax = input.max(axes, true);
        var a = input.sub(xMax);
        var b = a.exp();
        var c = b.sum(axes);
        var d = c.log();
        var res = xMax.reshape(d.shape).add(d);
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, axes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.sum = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var customOp = globals_1.customGrad(function (x) {
            var permutation = axis_util.getAxesPermutation(axes, x.rank);
            var reductionAxes = axes;
            var permutedX = x;
            if (permutation != null) {
                permutedX = x.transpose(permutation);
                reductionAxes =
                    axis_util.getInnerMostAxes(reductionAxes.length, x.rank);
            }
            var value = environment_1.ENV.engine.runKernel(function (backend) { return backend.sum(permutedX, reductionAxes); }, { permutedX: permutedX });
            if (keepDims) {
                var newShape = axis_util.expandShapeToKeepDim(value.shape, axes);
                value = value.reshape(newShape);
            }
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(tensor_1.Tensor.ones(x.shape, 'float32'));
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.mean = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var shapes = axis_util.computeOutAndReduceShapes(x.shape, axes);
        var reduceShape = shapes[1];
        var reduceSize = util.sizeFromShape(reduceShape);
        var customOp = globals_1.customGrad(function (x) {
            var reduceSizeScalar = ops.scalar(reduceSize);
            var res = x.div(reduceSizeScalar);
            var value = res.sum(axis, keepDims);
            var gradFunc = function (dy) {
                var expandedDyShape = x.shape.slice();
                axes.forEach(function (axis) {
                    expandedDyShape[axis] = 1;
                });
                var expandedDy = dy.reshape(expandedDyShape);
                var derX = expandedDy.mul(tensor_1.Tensor.ones(x.shape, 'float32'))
                    .div(reduceSizeScalar);
                return derX;
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(x);
    };
    ReductionOps.min = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.min(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.max = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var origAxes = axis_util.parseAxisParam(axis, x.shape);
        var axes = origAxes;
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.max(x, axes); }, { x: x });
        if (keepDims) {
            var newShape = axis_util.expandShapeToKeepDim(res.shape, origAxes);
            return res.reshape(newShape);
        }
        return res;
    };
    ReductionOps.argMin = function (x, axis) {
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMin(x, axes); }, { x: x });
    };
    ReductionOps.argMax = function (x, axis) {
        if (axis === void 0) { axis = null; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var permutedAxes = axis_util.getAxesPermutation(axes, x.rank);
        if (permutedAxes != null) {
            x = x.transpose(permutedAxes);
            axes = axis_util.getInnerMostAxes(axes.length, x.rank);
        }
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.argMax(x, axes); }, { x: x });
    };
    ReductionOps.moments = function (x, axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        var axes = axis_util.parseAxisParam(axis, x.shape);
        var mean = x.mean(axes, keepDims);
        var keepDimsShape = mean.shape;
        if (!keepDims) {
            keepDimsShape = axis_util.expandShapeToKeepDim(mean.shape, axes);
        }
        var devSquared = x.toFloat().sub(mean.reshape(keepDimsShape)).square();
        var variance = devSquared.mean(axes, keepDims);
        return { mean: mean, variance: variance };
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "logSumExp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "sum", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "mean", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "min", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "max", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Reduction' }),
        operation_1.operation
    ], ReductionOps, "argMax", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], ReductionOps, "moments", null);
    return ReductionOps;
}());
exports.ReductionOps = ReductionOps;

},{"../doc":25,"../environment":27,"../globals":28,"../tensor":137,"../util":143,"./axis_util":98,"./operation":113,"./ops":114}],119:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util_1 = require("./axis_util");
var operation_1 = require("./operation");
var ReverseOps = (function () {
    function ReverseOps() {
    }
    ReverseOps.reverse1d = function (x) {
        util.assert(x.rank === 1, "Error in reverse1D: x must be rank 1 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, 0);
    };
    ReverseOps.reverse2d = function (x, axis) {
        util.assert(x.rank === 2, "Error in reverse2D: x must be rank 2 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse3d = function (x, axis) {
        util.assert(x.rank === 3, "Error in reverse3D: x must be rank 3 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse4d = function (x, axis) {
        util.assert(x.rank === 4, "Error in reverse4D: x must be rank 4 but got\n             rank " + x.rank + ".");
        return ReverseOps.reverse(x, axis);
    };
    ReverseOps.reverse = function (x, axis) {
        if (x.rank === 0) {
            return x.clone();
        }
        var axes = axis_util_1.parseAxisParam(axis, x.shape);
        var grad = function (dy) {
            return { x: function () { return dy.reverse(axes); } };
        };
        var res = environment_1.ENV.engine.runKernel(function (backend) { return backend.reverse(x, axes); }, { x: x }, grad);
        return res.reshapeAs(x);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], ReverseOps, "reverse", null);
    return ReverseOps;
}());
exports.ReverseOps = ReverseOps;

},{"../doc":25,"../environment":27,"../util":143,"./axis_util":98,"./operation":113}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SELU_SCALEALPHA = 1.7580993408473768599402175208123;
exports.SELU_SCALE = 1.0507009873554804934193349852946;

},{}],121:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var slice_util = require("./slice_util");
var SliceOps = (function () {
    function SliceOps() {
    }
    SliceOps.slice1d = function (x, begin, size) {
        util.assert(x.rank === 1, "slice1d expects a rank-1 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, [begin], [size]);
    };
    SliceOps.slice2d = function (x, begin, size) {
        util.assert(x.rank === 2, "slice1d expects a rank-2 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice3d = function (x, begin, size) {
        util.assert(x.rank === 3, "slice1d expects a rank-3 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice4d = function (x, begin, size) {
        util.assert(x.rank === 4, "slice1d expects a rank-4 tensor, but got a rank-" + x.rank + " tensor");
        return SliceOps.slice(x, begin, size);
    };
    SliceOps.slice = function (x, begin, size) {
        slice_util.assertParamsValid(x, begin, size);
        if (x.rank === 0) {
            throw new Error('Slicing scalar is not possible');
        }
        var inputShape = x.shape;
        var grad = function (dy) {
            var paddings = [];
            for (var i = 0; i < dy.rank; i++) {
                paddings.push([begin[i], inputShape[i] - begin[i] - size[i]]);
            }
            return { x: function () { return dy.pad(paddings); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.slice(x, begin, size); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Slicing and Joining' }),
        operation_1.operation
    ], SliceOps, "slice", null);
    return SliceOps;
}());
exports.SliceOps = SliceOps;

},{"../doc":25,"../environment":27,"../util":143,"./operation":113,"./slice_util":122}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("../util");
function assertParamsValid(input, begin, size) {
    util.assert(input.rank === begin.length, "Error in slice" + input.rank + "D: Length of begin " + begin + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    util.assert(input.rank === size.length, "Error in slice" + input.rank + "D: Length of size " + size + " must " +
        ("match the rank of the array (" + input.rank + ")."));
    for (var i = 0; i < input.rank; ++i) {
        util.assert(begin[i] + size[i] <= input.shape[i], "Error in slice" + input.rank + "D: begin[" + i + "] + size[" + i + "] " +
            ("(" + (begin[i] + size[i]) + ") would overflow input.shape[" + i + "] (" + input.shape[i] + ")"));
    }
}
exports.assertParamsValid = assertParamsValid;

},{"../util":143}],123:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var ops = require("./ops");
var SoftmaxOps = (function () {
    function SoftmaxOps() {
    }
    SoftmaxOps.softmax = function (logits, dim) {
        if (dim === void 0) { dim = -1; }
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error('Softmax along a non-last dimension is not yet supported. ' +
                ("Logits was rank " + logits.rank + " and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (logits) {
            var keepDims = true;
            var lse = logits.logSumExp([dim], keepDims);
            var logResult = logits.toFloat().sub(lse);
            var y = logResult.exp();
            var gradFunc = function (dy) {
                var dyTimesY = dy.mul(y);
                var keepDims = true;
                return dyTimesY.sub(dyTimesY.sum([dim], keepDims).mul(y));
            };
            return { value: y, gradFunc: gradFunc };
        });
        return customOp(logits);
    };
    SoftmaxOps.softmaxCrossEntropy = function (labels, logits, dim) {
        if (dim === void 0) { dim = -1; }
        util.assertShapesMatch(labels.shape, logits.shape, 'Error in softmaxCrossEntropy: ');
        if (dim === -1) {
            dim = logits.rank - 1;
        }
        if (dim !== logits.rank - 1) {
            throw Error("Softmax cross entropy along a non-last dimension is not yet " +
                ("supported. Labels / logits was rank " + logits.rank + " ") +
                ("and dim was " + dim));
        }
        var customOp = globals_1.customGrad(function (labels, logits) {
            var predictedProbs = logits.softmax(dim);
            var costVector = ops.scalar(1e-5).add(predictedProbs).log().mul(labels).neg();
            var value = costVector.sum([dim]);
            var gradFunc = function (dy) {
                var dyShape = axis_util.expandShapeToKeepDim(dy.shape, [dim]);
                return [
                    dy.reshape(dyShape).mul(labels.toFloat().sub(predictedProbs)),
                    dy.reshape(dyShape).mul(predictedProbs.sub(labels.toFloat())),
                ];
            };
            return { value: value, gradFunc: gradFunc };
        });
        return customOp(labels, logits);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Normalization' }),
        operation_1.operation
    ], SoftmaxOps, "softmax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Losses', namespace: 'losses' }),
        operation_1.operation
    ], SoftmaxOps, "softmaxCrossEntropy", null);
    return SoftmaxOps;
}());
exports.SoftmaxOps = SoftmaxOps;

},{"../doc":25,"../globals":28,"../util":143,"./axis_util":98,"./operation":113,"./ops":114}],124:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var axis_util = require("./axis_util");
var operation_1 = require("./operation");
var TransposeOps = (function () {
    function TransposeOps() {
    }
    TransposeOps.transpose = function (x, perm) {
        if (perm == null) {
            perm = x.shape.map(function (s, i) { return i; }).reverse();
        }
        var der = function (dy) {
            var undoPerm = axis_util.getUndoAxesPermutation(perm);
            return { x: function () { return dy.transpose(undoPerm); } };
        };
        util.assert(x.rank === perm.length, "Error in transpose: rank of input " + x.rank + " " +
            ("must match length of perm " + perm + "."));
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.transpose(x, perm); }, { x: x }, der);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Matrices' }),
        operation_1.operation
    ], TransposeOps, "transpose", null);
    return TransposeOps;
}());
exports.TransposeOps = TransposeOps;

},{"../doc":25,"../environment":27,"../util":143,"./axis_util":98,"./operation":113}],125:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var environment_1 = require("../environment");
var util = require("../util");
var operation_1 = require("./operation");
var ops = require("./ops");
var ops_1 = require("./ops");
var selu_util = require("./selu_util");
var UnaryOps = (function () {
    function UnaryOps() {
    }
    UnaryOps.neg = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.neg(); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.neg(x); }, { x: x }, grad);
    };
    UnaryOps.ceil = function (x) {
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.ceil(x); }, { x: x }, grad);
    };
    UnaryOps.floor = function (x) {
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.floor(x); }, { x: x }, grad);
    };
    UnaryOps.exp = function (x) {
        var bck = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.exp(x)); }, { x: x }, bck);
    };
    UnaryOps.log = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.log(x); }, { x: x }, grad);
    };
    UnaryOps.sqrt = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.toFloat().sqrt().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sqrt(x); }, { x: x }, grad);
    };
    UnaryOps.square = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().mul(ops.scalar(2))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.square(x); }, { x: x }, grad);
    };
    UnaryOps.abs = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.toFloat().step(-1)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.abs(x); }, { x: x }, grad);
    };
    UnaryOps.clipByValue = function (x, clipValueMin, clipValueMax) {
        util.assert((clipValueMin <= clipValueMax), "Error in clip: min (" + clipValueMin + ") must be" +
            ("less than or equal to max (" + clipValueMax + ")."));
        var grad = function (dy) {
            return {
                x: function () { return dy.where(x.greater(ops.scalar(clipValueMin))
                    .logicalAnd(x.less(ops.scalar(clipValueMax))), ops_1.zerosLike(dy)); },
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.clip(x, clipValueMin, clipValueMax); }, { x: x }, grad);
    };
    UnaryOps.relu = function (x) {
        var grad = function (dy) {
            var stepRes = x.step();
            return { x: function () { return dy.mulStrict(stepRes.toFloat()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.relu(x); }, { x: x }, grad);
    };
    UnaryOps.elu = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(eluDer(x)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.elu(x); }, { x: x }, grad);
    };
    UnaryOps.selu = function (x) {
        var grad = function (dy) {
            return {
                x: function () {
                    var mask = x.greater(ops.scalar(0));
                    var scaleAlpha = ops.scalar(selu_util.SELU_SCALEALPHA);
                    var scale = ops.scalar(selu_util.SELU_SCALE);
                    var greaterThanZeroDer = dy.mul(scale);
                    var lessEqualZeroDer = dy.mul(scaleAlpha).mul(x.toFloat().exp());
                    return ops.where(mask, greaterThanZeroDer, lessEqualZeroDer);
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.selu(x); }, { x: x }, grad);
    };
    UnaryOps.leakyRelu = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(x.step(alpha)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.leakyRelu(x, alpha); }, { x: x }, grad);
    };
    UnaryOps.prelu = function (x, alpha) {
        var grad = function (dy) {
            return { x: function () { return dy.mulStrict(preluDer(x, alpha)); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.prelu(x, alpha); }, { x: x }, grad);
    };
    UnaryOps.sigmoid = function (x) {
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return dy.mulStrict(y.mul(ops.scalar(1).sub(y))); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.sigmoid(x)); }, { x: x }, grad);
    };
    UnaryOps.sin = function (x) {
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cos().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sin(x); }, { x: x }, grad);
    };
    UnaryOps.cos = function (x) {
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sin().neg().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cos(x); }, { x: x }, grad);
    };
    UnaryOps.tan = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(x.cos().square()); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.tan(x); }, { x: x }, grad);
    };
    UnaryOps.asin = function (x) {
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())));
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.asin(x); }, { x: x }, grad);
    };
    UnaryOps.acos = function (x) {
        var grad = function (dy) {
            return {
                x: function () {
                    return dy.divStrict(UnaryOps.sqrt(ops.scalar(1).sub(x.toFloat().square())))
                        .neg();
                }
            };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.acos(x); }, { x: x }, grad);
    };
    UnaryOps.atan = function (x) {
        var grad = function (dy) {
            return { x: function () { return dy.divStrict(ops.scalar(1).add(x.toFloat().square())); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.atan(x); }, { x: x }, grad);
    };
    UnaryOps.sinh = function (x) {
        var grad = function (dy) {
            return { x: function () { return x.toFloat().cosh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.sinh(x); }, { x: x }, grad);
    };
    UnaryOps.cosh = function (x) {
        var grad = function (dy) {
            return { x: function () { return x.toFloat().sinh().mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.cosh(x); }, { x: x }, grad);
    };
    UnaryOps.tanh = function (x) {
        var grad = function (dy, saved) {
            var y = saved[0];
            return { x: function () { return ops.scalar(1).sub(y.square()).mulStrict(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend, save) { return save(backend.tanh(x)); }, { x: x }, grad);
    };
    UnaryOps.step = function (x, alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        var grad = function (dy) {
            return { x: function () { return ops.zerosLike(dy); } };
        };
        return environment_1.ENV.engine.runKernel(function (backend) { return backend.step(x, alpha); }, { x: x }, grad);
    };
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "neg", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "ceil", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "floor", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "exp", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "log", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sqrt", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "square", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "abs", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "clipByValue", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "relu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "elu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "selu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "leakyRelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "prelu", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sigmoid", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "asin", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "acos", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "atan", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "sinh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "cosh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "tanh", null);
    __decorate([
        doc_1.doc({ heading: 'Operations', subheading: 'Basic math' }),
        operation_1.operation
    ], UnaryOps, "step", null);
    return UnaryOps;
}());
exports.UnaryOps = UnaryOps;
function preluDer(x, alpha) {
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.preluDer(x, alpha); }, { x: x, alpha: alpha });
}
function eluDer(x) {
    return environment_1.ENV.engine.runKernel(function (backend) { return backend.eluDer(x); }, { x: x });
}

},{"../doc":25,"../environment":27,"../util":143,"./operation":113,"./ops":114,"./selu_util":120}],126:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var optimizer_1 = require("./optimizer");
var AdadeltaOptimizer = (function (_super) {
    __extends(AdadeltaOptimizer, _super);
    function AdadeltaOptimizer(learningRate, rho, specifiedVariableList, epsilon) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.accumulatedGrads = {};
        _this.accumulatedUpdates = {};
        _this.accumulatedSquaredGradientsGraph = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedUpdatesGraph = new tensor_array_map_1.TensorArrayMap();
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(epsilon));
        _this.rho = globals_1.keep(ops_1.scalar(rho));
        _this.oneMinusRho = globals_1.keep(ops_1.scalar(1 - rho));
        return _this;
    }
    AdadeltaOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedUpdates[variableName] == null) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedUpdates[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            var accumulatedUpdate = this_1.accumulatedUpdates[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = _this.rho.mul(accumulatedGrad)
                    .add(_this.oneMinusRho.mul(gradient.square()));
                var updates = accumulatedUpdate.add(_this.epsilon)
                    .sqrt()
                    .div(accumulatedGrad.add(_this.epsilon).sqrt())
                    .mul(gradient);
                var newAccumulatedUpdate = _this.rho.mul(accumulatedUpdate)
                    .add(_this.oneMinusRho.mul(updates.square()));
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                _this.accumulatedUpdates[variableName].assign(newAccumulatedUpdate);
                var newValue = _this.c.mul(updates).add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdadeltaOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradientsGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradientsGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
                _this.accumulatedUpdatesGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    AdadeltaOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        if (this.one == null) {
            this.one = globals_1.keep(ops_1.scalar(1));
        }
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradientsGraph.get(node.output);
                var oldUpdates = _this.accumulatedUpdatesGraph.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.scaledArrayAdd(_this.rho, oldCache, math.subtract(_this.one, _this.rho), gradientSquare);
                var updates = math.multiply(math.divide(math.sqrt(math.add(oldUpdates, _this.epsilon)), math.sqrt(math.add(oldCache, _this.epsilon))), gradient);
                var variable = math.scaledArrayAdd(_this.cGraph, updates, _this.one, oldVariable);
                var updateSquare = math.multiply(updates, updates);
                var newUpdates = math.scaledArrayAdd(_this.rho, oldUpdates, math.subtract(_this.one, _this.rho), updateSquare);
                _this.accumulatedSquaredGradientsGraph.set(node.output, globals_1.keep(cache));
                _this.accumulatedUpdatesGraph.set(node.output, globals_1.keep(newUpdates));
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
                oldUpdates.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdadeltaOptimizer.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.c.dispose();
        this.epsilon.dispose();
        this.rho.dispose();
        this.oneMinusRho.dispose();
        if (this.one != null) {
            this.one.dispose();
        }
        if (this.accumulatedSquaredGradientsGraph != null) {
            this.accumulatedSquaredGradientsGraph.dispose();
        }
        if (this.accumulatedUpdatesGraph != null) {
            this.accumulatedUpdatesGraph.dispose();
        }
        if (this.accumulatedUpdates != null) {
            Object.keys(this.accumulatedUpdates)
                .forEach(function (name) { return _this.accumulatedUpdates[name].dispose(); });
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    return AdadeltaOptimizer;
}(optimizer_1.Optimizer));
exports.AdadeltaOptimizer = AdadeltaOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./optimizer":131}],127:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var optimizer_1 = require("./optimizer");
var AdagradOptimizer = (function (_super) {
    __extends(AdagradOptimizer, _super);
    function AdagradOptimizer(learningRate, specifiedVariableList, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.initialAccumulatorValue = initialAccumulatorValue;
        _this.accumulatedGrads = {};
        _this.accumulatedSquaredGradients = new tensor_array_map_1.TensorArrayMap();
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(1e-8));
        return _this;
    }
    AdagradOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedGrads[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedGrads[variableName] =
                        ops_1.fill(value.shape, _this.initialAccumulatorValue)
                            .variable(trainable_1);
                });
            }
            var gradient = variableGradients[variableName];
            var accumulatedGrad = this_1.accumulatedGrads[variableName];
            globals_1.tidy(function () {
                var newAccumulatedGrad = accumulatedGrad.add(gradient.square());
                _this.accumulatedGrads[variableName].assign(newAccumulatedGrad);
                var newValue = _this.c
                    .mul(gradient.div(newAccumulatedGrad.add(_this.epsilon).sqrt()))
                    .add(value);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    AdagradOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.accumulatedSquaredGradients.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedSquaredGradients.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    AdagradOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        if (this.one == null) {
            this.one = globals_1.keep(ops_1.scalar(1));
        }
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldCache = _this.accumulatedSquaredGradients.get(node.output);
                var gradientSquare = math.multiply(gradient, gradient);
                var cache = math.add(oldCache, gradientSquare);
                var variable = math.scaledArrayAdd(_this.cGraph, math.divide(gradient, math.add(math.sqrt(cache), _this.epsilon)), _this.one, oldVariable);
                _this.accumulatedSquaredGradients.set(node.output, globals_1.keep(cache));
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldCache.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdagradOptimizer.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.epsilon.dispose();
        this.c.dispose();
        if (this.one != null) {
            this.one.dispose();
        }
        if (this.accumulatedSquaredGradients != null) {
            this.accumulatedSquaredGradients.dispose();
        }
        if (this.accumulatedGrads != null) {
            Object.keys(this.accumulatedGrads)
                .forEach(function (name) { return _this.accumulatedGrads[name].dispose(); });
        }
    };
    return AdagradOptimizer;
}(optimizer_1.Optimizer));
exports.AdagradOptimizer = AdagradOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./optimizer":131}],128:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var optimizer_1 = require("./optimizer");
var AdamOptimizer = (function (_super) {
    __extends(AdamOptimizer, _super);
    function AdamOptimizer(learningRate, beta1, beta2, epsilon, specifiedVariableList) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedSecondMoment = {};
        _this.firstMomentGraph = new tensor_array_map_1.TensorArrayMap();
        _this.secondMomentGraph = new tensor_array_map_1.TensorArrayMap();
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.eps = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1 = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2 = globals_1.keep(ops_1.scalar(beta2));
        globals_1.tidy(function () {
            _this.accBeta1 = ops_1.scalar(beta1).variable();
            _this.accBeta2 = ops_1.scalar(beta2).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.oneMinusBeta2 = globals_1.keep(ops_1.scalar(1 - beta2));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedSecondMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedSecondMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var secondMoment = _this.accumulatedSecondMoment[variableName];
                var newFirstMoment = _this.beta1.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));
                var newSecondMoment = _this.beta2.mul(secondMoment)
                    .add(_this.oneMinusBeta2.mul(gradient.square()));
                var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedSecondMoment[variableName].assign(newSecondMoment);
                var newValue = _this.c
                    .mul(biasCorrectedFirstMoment.div(_this.eps.add(biasCorrectedSecondMoment.sqrt())))
                    .add(value);
                value.assign(newValue);
            }
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1));
            _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2));
        });
    };
    AdamOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMomentGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMomentGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
        if (this.secondMomentGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.secondMomentGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    AdamOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var oneMinusAccBeta2 = _this.one.sub(_this.accBeta2);
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMomentGraph.get(node.output);
                var oldSecondMoment = _this.secondMomentGraph.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.beta1, oldFirstMoment, _this.oneMinusBeta1, gradient);
                var newSecondMoment = math.scaledArrayAdd(_this.beta2, oldSecondMoment, _this.oneMinusBeta2, gradient.square());
                var biasCorrectedFirstMoment = newFirstMoment.div(oneMinusAccBeta1);
                var biasCorrectedSecondMoment = newSecondMoment.div(oneMinusAccBeta2);
                var variable = math.scaledArrayAdd(_this.cGraph, biasCorrectedFirstMoment.div(_this.eps.add(biasCorrectedSecondMoment.sqrt())), _this.one, oldVariable);
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                _this.firstMomentGraph.set(node.output, globals_1.keep(newFirstMoment));
                _this.secondMomentGraph.set(node.output, globals_1.keep(newSecondMoment));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldSecondMoment.dispose();
            });
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1));
            _this.accBeta2.assign(_this.accBeta2.mul(_this.beta2));
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamOptimizer.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.c.dispose();
        this.eps.dispose();
        this.beta1.dispose();
        this.beta2.dispose();
        this.accBeta1.dispose();
        this.accBeta2.dispose();
        this.oneMinusBeta1.dispose();
        this.oneMinusBeta2.dispose();
        this.one.dispose();
        if (this.firstMomentGraph != null) {
            this.firstMomentGraph.dispose();
        }
        if (this.secondMomentGraph != null) {
            this.secondMomentGraph.dispose();
        }
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedSecondMoment != null) {
            Object.keys(this.accumulatedSecondMoment)
                .forEach(function (name) { return _this.accumulatedSecondMoment[name].dispose(); });
        }
    };
    return AdamOptimizer;
}(optimizer_1.Optimizer));
exports.AdamOptimizer = AdamOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./optimizer":131}],129:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var optimizer_1 = require("./optimizer");
var AdamaxOptimizer = (function (_super) {
    __extends(AdamaxOptimizer, _super);
    function AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay, specifiedVariableList) {
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedFirstMoment = {};
        _this.accumulatedWeightedInfNorm = {};
        _this.firstMomentGraph = new tensor_array_map_1.TensorArrayMap();
        _this.weightedInfNormGraph = new tensor_array_map_1.TensorArrayMap();
        _this.c = globals_1.keep(ops_1.scalar(-learningRate));
        _this.eps = globals_1.keep(ops_1.scalar(epsilon));
        _this.beta1 = globals_1.keep(ops_1.scalar(beta1));
        _this.beta2 = globals_1.keep(ops_1.scalar(beta2));
        _this.decay = globals_1.keep(ops_1.scalar(decay));
        globals_1.tidy(function () {
            _this.iteration = ops_1.scalar(0).variable();
            _this.accBeta1 = ops_1.scalar(beta1).variable();
        });
        _this.oneMinusBeta1 = globals_1.keep(ops_1.scalar(1 - beta1));
        _this.one = globals_1.keep(ops_1.scalar(1));
        return _this;
    }
    AdamaxOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        globals_1.tidy(function () {
            var oneMinusAccBeta1 = _this.one.sub(_this.accBeta1);
            var lr = _this.c.div(_this.one.add(_this.decay.mul(_this.iteration)));
            for (var variableName in variableGradients) {
                var value = environment_1.ENV.engine.registeredVariables[variableName];
                if (_this.accumulatedFirstMoment[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedFirstMoment[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                if (_this.accumulatedWeightedInfNorm[variableName] == null) {
                    var trainable = false;
                    _this.accumulatedWeightedInfNorm[variableName] =
                        ops_1.zerosLike(value).variable(trainable);
                }
                var gradient = variableGradients[variableName];
                var firstMoment = _this.accumulatedFirstMoment[variableName];
                var weightedInfNorm = _this.accumulatedWeightedInfNorm[variableName];
                var newFirstMoment = _this.beta1.mul(firstMoment).add(_this.oneMinusBeta1.mul(gradient));
                var ut0 = _this.beta2.mul(weightedInfNorm);
                var ut1 = gradient.abs();
                var newWeightedInfNorm = ut0.maximum(ut1);
                _this.accumulatedFirstMoment[variableName].assign(newFirstMoment);
                _this.accumulatedWeightedInfNorm[variableName].assign(newWeightedInfNorm);
                var newValue = lr.div(oneMinusAccBeta1)
                    .mul(newFirstMoment.div(_this.eps.add(newWeightedInfNorm)))
                    .add(value);
                value.assign(newValue);
            }
            _this.iteration.assign(_this.iteration.add(_this.one));
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1));
        });
    };
    AdamaxOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.firstMomentGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.firstMomentGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
        if (this.weightedInfNormGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.weightedInfNormGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    AdamaxOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        globals_1.tidy(function () {
            var lr = _this.cGraph.div(_this.one.add(_this.decay.mul(_this.iteration)));
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldFirstMoment = _this.firstMomentGraph.get(node.output);
                var oldWeightedInfNorm = _this.weightedInfNormGraph.get(node.output);
                var newFirstMoment = math.scaledArrayAdd(_this.beta1, oldFirstMoment, _this.oneMinusBeta1, gradient);
                var ut0 = _this.beta2.mul(oldWeightedInfNorm);
                var ut1 = gradient.abs();
                var newWeightedInfNorm = ut0.maximum(ut1);
                var variable = math.scaledArrayAdd(_this.one, oldVariable, lr.div(_this.one.sub(_this.accBeta1)), newFirstMoment.div(_this.eps.add(newWeightedInfNorm)));
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                _this.firstMomentGraph.set(node.output, globals_1.keep(newFirstMoment));
                _this.weightedInfNormGraph.set(node.output, globals_1.keep(newWeightedInfNorm));
                oldVariable.dispose();
                gradient.dispose();
                oldFirstMoment.dispose();
                oldWeightedInfNorm.dispose();
            });
            _this.iteration.assign(_this.iteration.add(_this.one));
            _this.accBeta1.assign(_this.accBeta1.mul(_this.beta1));
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    AdamaxOptimizer.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.c.dispose();
        this.eps.dispose();
        this.accBeta1.dispose();
        this.beta1.dispose();
        this.beta2.dispose();
        this.oneMinusBeta1.dispose();
        this.decay.dispose();
        this.iteration.dispose();
        this.one.dispose();
        if (this.firstMomentGraph != null) {
            this.firstMomentGraph.dispose();
        }
        if (this.weightedInfNormGraph != null) {
            this.weightedInfNormGraph.dispose();
        }
        if (this.accumulatedFirstMoment != null) {
            Object.keys(this.accumulatedFirstMoment)
                .forEach(function (name) { return _this.accumulatedFirstMoment[name].dispose(); });
        }
        if (this.accumulatedWeightedInfNorm != null) {
            Object.keys(this.accumulatedWeightedInfNorm)
                .forEach(function (name) { return _this.accumulatedWeightedInfNorm[name].dispose(); });
        }
    };
    return AdamaxOptimizer;
}(optimizer_1.Optimizer));
exports.AdamaxOptimizer = AdamaxOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./optimizer":131}],130:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var sgd_optimizer_1 = require("./sgd_optimizer");
var MomentumOptimizer = (function (_super) {
    __extends(MomentumOptimizer, _super);
    function MomentumOptimizer(learningRate, momentum, specifiedVariableList, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.momentum = momentum;
        _this.useNesterov = useNesterov;
        _this.m = ops_1.scalar(_this.momentum);
        _this.accumulations = {};
        return _this;
    }
    MomentumOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulations[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulations[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            var accumulation = this_1.accumulations[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newValue;
                var newAccumulation = _this.m.mul(accumulation).add(gradient);
                if (_this.useNesterov) {
                    newValue =
                        _this.c.mul(gradient.add(newAccumulation.mul(_this.m))).add(value);
                }
                else {
                    newValue = _this.c.mul(newAccumulation).add(value);
                }
                _this.accumulations[variableName].assign(newAccumulation);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    MomentumOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        if (this.variableVelocitiesGraph == null) {
            this.variableVelocitiesGraph = new tensor_array_map_1.TensorArrayMap();
        }
        _super.prototype.beforeBatch.call(this, math, batchSize, runtime, activationArrayMap, gradientArrayMap);
        if (this.variableVelocitiesGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.variableVelocitiesGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    MomentumOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldVelocity = _this.variableVelocitiesGraph.get(node.output);
                var variable;
                var velocity = _this.m.mul(oldVelocity).add(gradient);
                if (_this.useNesterov) {
                    variable = _this.cGraph.mul(gradient.add(velocity.mul(_this.m)))
                        .add(oldVariable);
                }
                else {
                    variable = _this.cGraph.mul(velocity).add(oldVariable);
                }
                _this.variableVelocitiesGraph.set(node.output, globals_1.keep(velocity));
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldVelocity.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    MomentumOptimizer.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.m.dispose();
        if (this.variableVelocitiesGraph != null) {
            this.variableVelocitiesGraph.dispose();
        }
        if (this.accumulations != null) {
            for (var variableName in this.accumulations) {
                this.accumulations[variableName].dispose();
            }
        }
    };
    MomentumOptimizer.prototype.setMomentum = function (momentum) {
        this.momentum = momentum;
    };
    return MomentumOptimizer;
}(sgd_optimizer_1.SGDOptimizer));
exports.MomentumOptimizer = MomentumOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./sgd_optimizer":134}],131:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var globals_1 = require("../globals");
var session_util = require("../graph/session_util");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops = require("../ops/ops");
var tensor_1 = require("../tensor");
var Optimizer = (function () {
    function Optimizer(learningRate, specifiedVariableList) {
        this.learningRate = learningRate;
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
        if (specifiedVariableList != null) {
            this.specifiedVariableNodes = specifiedVariableList;
        }
    }
    Optimizer.prototype.minimize = function (f, returnCost, varList) {
        if (returnCost === void 0) { returnCost = false; }
        var _a = this.computeGradients(f, varList), value = _a.value, grads = _a.grads;
        this.applyGradients(grads);
        var varNames = Object.keys(grads);
        varNames.forEach(function (varName) { return grads[varName].dispose(); });
        if (returnCost) {
            return value;
        }
        else {
            value.dispose();
            return null;
        }
    };
    Optimizer.prototype.computeGradients = function (f, varList) {
        return globals_1.variableGrads(f, varList);
    };
    Optimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.cGraph != null) {
                this.cGraph.dispose();
            }
            this.prevBatchSize = batchSize;
            this.cGraph = math.keep(ops.scalar(-this.learningRate / batchSize));
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, math.keep(tensor_1.Tensor.zeros(node.output.shape))); });
    };
    Optimizer.prototype.afterExample = function (math, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var gradient = gradientArrayMap.get(node.output);
                var accumulatedGradient = _this.variableGradients.get(node.output);
                _this.variableGradients.set(node.output, globals_1.keep(math.add(gradient, accumulatedGradient)));
                accumulatedGradient.dispose();
            });
        });
    };
    Optimizer.prototype.dispose = function () {
        if (this.cGraph != null) {
            this.cGraph.dispose();
        }
        if (this.variableNodes != null) {
            this.variableNodes.forEach(function (node) {
                node.data.dispose();
            });
        }
        if (this.specifiedVariableNodes != null) {
            this.specifiedVariableNodes.forEach(function (node) {
                node.data.dispose();
            });
        }
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers' })
    ], Optimizer.prototype, "minimize", null);
    Optimizer = __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Classes', namespace: 'train' })
    ], Optimizer);
    return Optimizer;
}());
exports.Optimizer = Optimizer;

},{"../doc":25,"../globals":28,"../graph/session_util":58,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137}],132:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("../doc");
var adadelta_optimizer_1 = require("./adadelta_optimizer");
var adagrad_optimizer_1 = require("./adagrad_optimizer");
var adam_optimizer_1 = require("./adam_optimizer");
var adamax_optimizer_1 = require("./adamax_optimizer");
var momentum_optimizer_1 = require("./momentum_optimizer");
var rmsprop_optimizer_1 = require("./rmsprop_optimizer");
var sgd_optimizer_1 = require("./sgd_optimizer");
var OptimizerConstructors = (function () {
    function OptimizerConstructors() {
    }
    OptimizerConstructors.sgd = function (learningRate) {
        return new sgd_optimizer_1.SGDOptimizer(learningRate);
    };
    OptimizerConstructors.momentum = function (learningRate, momentum, useNesterov) {
        if (useNesterov === void 0) { useNesterov = false; }
        return new momentum_optimizer_1.MomentumOptimizer(learningRate, momentum, undefined, useNesterov);
    };
    OptimizerConstructors.rmsprop = function (learningRate, decay, momentum, epsilon) {
        if (decay === void 0) { decay = .9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new rmsprop_optimizer_1.RMSPropOptimizer(learningRate, decay, momentum, undefined, epsilon);
    };
    OptimizerConstructors.adam = function (learningRate, beta1, beta2, epsilon) {
        if (learningRate === void 0) { learningRate = 0.001; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adam_optimizer_1.AdamOptimizer(learningRate, beta1, beta2, epsilon, undefined);
    };
    OptimizerConstructors.adadelta = function (learningRate, rho, epsilon) {
        if (learningRate === void 0) { learningRate = .001; }
        if (rho === void 0) { rho = .95; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        return new adadelta_optimizer_1.AdadeltaOptimizer(learningRate, rho, undefined, epsilon);
    };
    OptimizerConstructors.adamax = function (learningRate, beta1, beta2, epsilon, decay) {
        if (learningRate === void 0) { learningRate = 0.002; }
        if (beta1 === void 0) { beta1 = 0.9; }
        if (beta2 === void 0) { beta2 = 0.999; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        if (decay === void 0) { decay = 0.0; }
        return new adamax_optimizer_1.AdamaxOptimizer(learningRate, beta1, beta2, epsilon, decay, undefined);
    };
    OptimizerConstructors.adagrad = function (learningRate, initialAccumulatorValue) {
        if (initialAccumulatorValue === void 0) { initialAccumulatorValue = 0.1; }
        return new adagrad_optimizer_1.AdagradOptimizer(learningRate, undefined, initialAccumulatorValue);
    };
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "sgd", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "momentum", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "rmsprop", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adam", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adadelta", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adamax", null);
    __decorate([
        doc_1.doc({ heading: 'Training', subheading: 'Optimizers', namespace: 'train' })
    ], OptimizerConstructors, "adagrad", null);
    return OptimizerConstructors;
}());
exports.OptimizerConstructors = OptimizerConstructors;

},{"../doc":25,"./adadelta_optimizer":126,"./adagrad_optimizer":127,"./adam_optimizer":128,"./adamax_optimizer":129,"./momentum_optimizer":130,"./rmsprop_optimizer":133,"./sgd_optimizer":134}],133:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var session_util = require("../graph/session_util");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var tensor_1 = require("../tensor");
var optimizer_1 = require("./optimizer");
var RMSPropOptimizer = (function (_super) {
    __extends(RMSPropOptimizer, _super);
    function RMSPropOptimizer(learningRate, decay, momentum, specifiedVariableList, epsilon) {
        if (decay === void 0) { decay = 0.9; }
        if (momentum === void 0) { momentum = 0.0; }
        if (epsilon === void 0) { epsilon = 1e-8; }
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.accumulatedMeanSquares = {};
        _this.accumulatedMoments = {};
        _this.accumulatedMeanSquaredGraph = new tensor_array_map_1.TensorArrayMap();
        _this.accumulatedMomentGraph = new tensor_array_map_1.TensorArrayMap();
        _this.c = globals_1.keep(ops_1.scalar(learningRate));
        _this.epsilon = globals_1.keep(ops_1.scalar(epsilon));
        _this.decay = globals_1.keep(ops_1.scalar(decay));
        _this.momentum = globals_1.keep(ops_1.scalar(momentum));
        _this.oneMinusDecay = globals_1.keep(ops_1.scalar(1 - decay));
        return _this;
    }
    RMSPropOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var _loop_1 = function (variableName) {
            var value = environment_1.ENV.engine.registeredVariables[variableName];
            if (this_1.accumulatedMeanSquares[variableName] == null) {
                var trainable_1 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMeanSquares[variableName] =
                        ops_1.zerosLike(value).variable(trainable_1);
                });
            }
            if (this_1.accumulatedMoments[variableName] == null) {
                var trainable_2 = false;
                globals_1.tidy(function () {
                    _this.accumulatedMoments[variableName] =
                        ops_1.zerosLike(value).variable(trainable_2);
                });
            }
            var accumulatedMeanSquare = this_1.accumulatedMeanSquares[variableName];
            var accumulatedMoments = this_1.accumulatedMoments[variableName];
            var gradient = variableGradients[variableName];
            globals_1.tidy(function () {
                var newAccumulatedMeanSquare = _this.decay.mul(accumulatedMeanSquare)
                    .add(_this.oneMinusDecay.mul(gradient.square()));
                var newAccumulatedMoments = _this.momentum.mul(accumulatedMoments)
                    .add(_this.c.mul(gradient).div(newAccumulatedMeanSquare.add(_this.epsilon).sqrt()));
                _this.accumulatedMeanSquares[variableName].assign(newAccumulatedMeanSquare);
                _this.accumulatedMoments[variableName].assign(newAccumulatedMoments);
                var newValue = value.sub(newAccumulatedMoments);
                value.assign(newValue);
            });
        };
        var this_1 = this;
        for (var variableName in variableGradients) {
            _loop_1(variableName);
        }
    };
    RMSPropOptimizer.prototype.beforeBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        this.variableNodes = this.specifiedVariableNodes == null ?
            session_util.getVariableNodesFromEvaluationSet(runtime.nodes) :
            this.specifiedVariableNodes;
        if (batchSize !== this.prevBatchSize) {
            if (this.cGraph != null) {
                this.cGraph.dispose();
            }
            this.prevBatchSize = batchSize;
            this.cGraph = math.keep(ops_1.scalar(this.learningRate / batchSize));
        }
        this.variableNodes.forEach(function (node) { return _this.variableGradients.set(node.output, math.keep(tensor_1.Tensor.zeros(node.output.shape))); });
        if (this.accumulatedMeanSquaredGraph.size() === 0) {
            this.variableNodes.forEach(function (node) {
                _this.accumulatedMeanSquaredGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
                _this.accumulatedMomentGraph.set(node.output, tensor_1.Tensor.zeros(node.output.shape));
            });
        }
    };
    RMSPropOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var oldMeanSquare = _this.accumulatedMeanSquaredGraph.get(node.output);
                var oldMoment = _this.accumulatedMomentGraph.get(node.output);
                var meanSquare = math.scaledArrayAdd(_this.decay, oldMeanSquare, _this.oneMinusDecay, gradient.square());
                var moment = math.scaledArrayAdd(_this.momentum, oldMoment, _this.cGraph, gradient.div(meanSquare.add(_this.epsilon).sqrt()));
                var variable = oldVariable.sub(moment);
                _this.accumulatedMeanSquaredGraph.set(node.output, globals_1.keep(meanSquare));
                _this.accumulatedMomentGraph.set(node.output, globals_1.keep(moment));
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                oldVariable.dispose();
                oldMeanSquare.dispose();
                oldMoment.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    RMSPropOptimizer.prototype.dispose = function () {
        var _this = this;
        _super.prototype.dispose.call(this);
        this.c.dispose();
        this.epsilon.dispose();
        this.decay.dispose();
        this.momentum.dispose();
        this.oneMinusDecay.dispose();
        if (this.accumulatedMeanSquaredGraph != null) {
            this.accumulatedMeanSquaredGraph.dispose();
        }
        if (this.accumulatedMomentGraph != null) {
            this.accumulatedMomentGraph.dispose();
        }
        if (this.accumulatedMeanSquares != null) {
            Object.keys(this.accumulatedMeanSquares)
                .forEach(function (name) { return _this.accumulatedMeanSquares[name].dispose(); });
        }
        if (this.accumulatedMoments != null) {
            Object.keys(this.accumulatedMoments)
                .forEach(function (name) { return _this.accumulatedMoments[name].dispose(); });
        }
    };
    return RMSPropOptimizer;
}(optimizer_1.Optimizer));
exports.RMSPropOptimizer = RMSPropOptimizer;

},{"../environment":27,"../globals":28,"../graph/session_util":58,"../graph/tensor_array_map":59,"../ops/ops":114,"../tensor":137,"./optimizer":131}],134:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("../environment");
var globals_1 = require("../globals");
var tensor_array_map_1 = require("../graph/tensor_array_map");
var ops_1 = require("../ops/ops");
var optimizer_1 = require("./optimizer");
var SGDOptimizer = (function (_super) {
    __extends(SGDOptimizer, _super);
    function SGDOptimizer(learningRate, specifiedVariableList) {
        var _this = _super.call(this, learningRate, specifiedVariableList) || this;
        _this.learningRate = learningRate;
        _this.setLearningRate(learningRate);
        return _this;
    }
    SGDOptimizer.prototype.applyGradients = function (variableGradients) {
        var _this = this;
        var varNames = Object.keys(variableGradients);
        varNames.forEach(function (varName) {
            var gradient = variableGradients[varName];
            var value = environment_1.ENV.engine.registeredVariables[varName];
            globals_1.tidy(function () {
                var newValue = _this.c.mul(gradient).add(value);
                value.assign(newValue);
            });
        });
    };
    SGDOptimizer.prototype.setLearningRate = function (learningRate) {
        this.learningRate = learningRate;
        if (this.c != null) {
            this.c.dispose();
        }
        this.c = environment_1.ENV.math.keep(ops_1.scalar(-learningRate));
    };
    SGDOptimizer.prototype.dispose = function () {
        this.c.dispose();
        if (this.one != null) {
            this.one.dispose();
        }
        _super.prototype.dispose.call(this);
    };
    SGDOptimizer.prototype.afterBatch = function (math, batchSize, runtime, activationArrayMap, gradientArrayMap) {
        var _this = this;
        if (this.one == null) {
            this.one = globals_1.keep(ops_1.scalar(1));
        }
        globals_1.tidy(function () {
            _this.variableNodes.forEach(function (node) {
                var oldVariable = activationArrayMap.get(node.output);
                var gradient = _this.variableGradients.get(node.output);
                var variable = math.scaledArrayAdd(_this.cGraph, gradient, _this.one, oldVariable);
                activationArrayMap.set(node.output, globals_1.keep(variable));
                node.data = variable;
                oldVariable.dispose();
            });
        });
        this.variableGradients.dispose();
        this.variableGradients = new tensor_array_map_1.TensorArrayMap();
    };
    return SGDOptimizer;
}(optimizer_1.Optimizer));
exports.SGDOptimizer = SGDOptimizer;

},{"../environment":27,"../globals":28,"../graph/tensor_array_map":59,"../ops/ops":114,"./optimizer":131}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var Profiler = (function () {
    function Profiler(backendTimer, logger) {
        this.backendTimer = backendTimer;
        this.logger = logger;
        if (logger == null) {
            this.logger = new Logger();
        }
    }
    Profiler.prototype.profileKernel = function (name, f) {
        var _this = this;
        var result;
        var holdResultWrapperFn = function () {
            result = f();
        };
        var timer = this.backendTimer.time(holdResultWrapperFn);
        var vals = result.dataSync();
        util.checkForNaN(vals, result.dtype, name);
        timer.then(function (timing) {
            _this.logger.logKernelProfile(name, result, vals, timing.kernelMs);
        });
        return result;
    };
    return Profiler;
}());
exports.Profiler = Profiler;
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.logKernelProfile = function (name, result, vals, timeMs) {
        var time = util.rightPad(timeMs + "ms", 9);
        var paddedName = util.rightPad(name, 25);
        var rank = result.rank;
        var size = result.size;
        var shape = util.rightPad(result.shape.toString(), 14);
        console.log("%c" + paddedName + "\t%c" + time + "\t%c" + rank + "D " + shape + "\t%c" + size, 'font-weight:bold', 'color:red', 'color:blue', 'color: orange');
    };
    return Logger;
}());
exports.Logger = Logger;

},{"./util":143}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
function getFilteredNodesXToY(tape, xs, y) {
    var tensorsFromX = {};
    var nodesFromX = {};
    for (var i = 0; i < xs.length; i++) {
        tensorsFromX[xs[i].id] = true;
    }
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        for (var inputName in nodeInputs) {
            var input = nodeInputs[inputName];
            var anyInputFromX = false;
            for (var j = 0; j < xs.length; j++) {
                if (tensorsFromX[input.id]) {
                    tensorsFromX[node.output.id] = true;
                    anyInputFromX = true;
                    nodesFromX[node.id] = true;
                    break;
                }
            }
            if (anyInputFromX) {
                break;
            }
        }
    }
    var tensorsLeadToY = {};
    tensorsLeadToY[y.id] = true;
    var nodesToY = {};
    for (var i = tape.length - 1; i >= 0; i--) {
        var node = tape[i];
        var nodeInputs = node.inputs;
        var outputs = [];
        outputs.push(node.output);
        for (var j = 0; j < outputs.length; j++) {
            if (tensorsLeadToY[outputs[j].id]) {
                for (var inputName in nodeInputs) {
                    tensorsLeadToY[nodeInputs[inputName].id] = true;
                    nodesToY[node.id] = true;
                }
                break;
            }
        }
    }
    var filteredTape = [];
    for (var i = 0; i < tape.length; i++) {
        var node = tape[i];
        if (nodesFromX[node.id] && nodesToY[node.id]) {
            var prunedInputs = {};
            for (var inputName in node.inputs) {
                var nodeInput = node.inputs[inputName];
                if (tensorsFromX[nodeInput.id]) {
                    prunedInputs[inputName] = nodeInput;
                }
            }
            var prunedNode = Object.assign({}, node);
            prunedNode.inputs = prunedInputs;
            prunedNode.output = node.output;
            filteredTape.push(prunedNode);
        }
    }
    return filteredTape;
}
exports.getFilteredNodesXToY = getFilteredNodesXToY;
function backpropagateGradients(tensorAccumulatedGradientMap, filteredTape) {
    for (var i = filteredTape.length - 1; i >= 0; i--) {
        var node = filteredTape[i];
        var dy = tensorAccumulatedGradientMap[node.output.id];
        if (node.gradient == null) {
            throw new Error("Cannot compute gradient: gradient function not found " +
                ("for " + node.name + "."));
        }
        var inputGradients = node.gradient(dy);
        for (var inputName in node.inputs) {
            if (!(inputName in inputGradients)) {
                throw new Error("Cannot backprop through input " + inputName + ". " +
                    ("Available gradients found: " + Object.keys(inputGradients) + "."));
            }
            var dx = inputGradients[inputName]();
            var x = node.inputs[inputName];
            if (!util.arraysEqual(dx.shape, x.shape)) {
                throw new Error("Error in gradient for op " + node.name + ". The gradient of input " +
                    ("'" + inputName + "' has shape '" + dx.shape + "', which does not match ") +
                    ("the shape of the input '" + x.shape + "'"));
            }
            if (tensorAccumulatedGradientMap[x.id] == null) {
                tensorAccumulatedGradientMap[x.id] = dx;
            }
            else {
                var curGradient = tensorAccumulatedGradientMap[x.id];
                tensorAccumulatedGradientMap[x.id] = curGradient.add(dx);
                curGradient.dispose();
            }
        }
    }
}
exports.backpropagateGradients = backpropagateGradients;

},{"./util":143}],137:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var ops = require("./ops/ops");
var tensor_util = require("./tensor_util");
var util = require("./util");
var TensorBuffer = (function () {
    function TensorBuffer(shape, dtype, values) {
        this.shape = shape;
        this.dtype = dtype;
        this.values = values;
        if (values != null) {
            var n = values.length;
            var size = util.sizeFromShape(shape);
            util.assert(n === size, "Length of values '" + n + "' does not match the size " +
                ("inferred by the shape '" + size + "'"));
        }
        this.values =
            values || util.getTypedArrayFromDType(dtype, util.sizeFromShape(shape));
        this.strides = computeStrides(shape);
        this.size = util.sizeFromShape(shape);
    }
    TensorBuffer.prototype.set = function (value) {
        var locs = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            locs[_i - 1] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        util.assert(locs.length === this.rank, "The number of provided coordinates (" + locs.length + ") must " +
            ("match the rank (" + this.rank + ")"));
        var index = this.locToIndex(locs);
        this.values[index] = value;
    };
    TensorBuffer.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.values[index];
    };
    TensorBuffer.prototype.locToIndex = function (locs) {
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    TensorBuffer.prototype.indexToLoc = function (index) {
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    Object.defineProperty(TensorBuffer.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    TensorBuffer.prototype.toTensor = function () {
        return Tensor.make(this.shape, { values: this.values }, this.dtype);
    };
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "set", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "get", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], TensorBuffer.prototype, "toTensor", null);
    TensorBuffer = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], TensorBuffer);
    return TensorBuffer;
}());
exports.TensorBuffer = TensorBuffer;
var Tensor = (function () {
    function Tensor(shape, dtype, values, dataId) {
        this.isDisposed = false;
        this.size = util.sizeFromShape(shape);
        if (values != null) {
            util.assert(this.size === values.length, "Constructing tensor of shape (" + this.size + ") should match the " +
                ("length of values (" + values.length + ")"));
        }
        this.shape = shape;
        this.dtype = dtype || 'float32';
        this.strides = computeStrides(shape);
        this.dataId = dataId != null ? dataId : {};
        this.id = Tensor_1.nextId++;
        this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
        environment_1.ENV.engine.registerTensor(this);
        if (values != null) {
            environment_1.ENV.engine.write(this.dataId, values);
        }
    }
    Tensor_1 = Tensor;
    Tensor.ones = function (shape, dtype) {
        return ops.ones(shape, dtype);
    };
    Tensor.zeros = function (shape, dtype) {
        return ops.zeros(shape, dtype);
    };
    Tensor.onesLike = function (x) {
        return ops.onesLike(x);
    };
    Tensor.zerosLike = function (x) {
        return ops.zerosLike(x);
    };
    Tensor.like = function (x) {
        return ops.clone(x);
    };
    Tensor.make = function (shape, data, dtype) {
        return new Tensor_1(shape, dtype, data.values, data.dataId);
    };
    Tensor.fromPixels = function (pixels, numChannels) {
        if (numChannels === void 0) { numChannels = 3; }
        return ops.fromPixels(pixels, numChannels);
    };
    Tensor.rand = function (shape, randFunction, dtype) {
        return ops.rand(shape, randFunction, dtype);
    };
    Tensor.randNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return ops.randomNormal(shape, mean, stdDev, dtype, seed);
    };
    Tensor.randTruncatedNormal = function (shape, mean, stdDev, dtype, seed) {
        if (mean === void 0) { mean = 0; }
        if (stdDev === void 0) { stdDev = 1; }
        return ops.truncatedNormal(shape, mean, stdDev, dtype, seed);
    };
    Tensor.randUniform = function (shape, a, b, dtype) {
        return ops.randomUniform(shape, a, b, dtype);
    };
    Tensor.prototype.flatten = function () {
        this.throwIfDisposed();
        return this.as1D();
    };
    Tensor.prototype.asScalar = function () {
        this.throwIfDisposed();
        util.assert(this.size === 1, 'The array must have only 1 element.');
        return this.reshape([]);
    };
    Tensor.prototype.as1D = function () {
        this.throwIfDisposed();
        return this.reshape([this.size]);
    };
    Tensor.prototype.as2D = function (rows, columns) {
        this.throwIfDisposed();
        return this.reshape([rows, columns]);
    };
    Tensor.prototype.as3D = function (rows, columns, depth) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth]);
    };
    Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
        this.throwIfDisposed();
        return this.reshape([rows, columns, depth, depth2]);
    };
    Tensor.prototype.asType = function (dtype) {
        this.throwIfDisposed();
        return ops.cast(this, dtype);
    };
    Object.defineProperty(Tensor.prototype, "rank", {
        get: function () {
            return this.shape.length;
        },
        enumerable: true,
        configurable: true
    });
    Tensor.prototype.get = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        this.throwIfDisposed();
        if (locs.length === 0) {
            locs = [0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return this.dataSync()[index];
    };
    Tensor.prototype.val = function () {
        var locs = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            locs[_i] = arguments[_i];
        }
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (locs.length === 0) {
                            locs = [0];
                        }
                        this.throwIfDisposed();
                        return [4, this.data()];
                    case 1:
                        _a.sent();
                        return [2, this.get.apply(this, locs)];
                }
            });
        });
    };
    Tensor.prototype.locToIndex = function (locs) {
        this.throwIfDisposed();
        if (this.rank === 0) {
            return 0;
        }
        else if (this.rank === 1) {
            return locs[0];
        }
        var index = locs[locs.length - 1];
        for (var i = 0; i < locs.length - 1; ++i) {
            index += this.strides[i] * locs[i];
        }
        return index;
    };
    Tensor.prototype.indexToLoc = function (index) {
        this.throwIfDisposed();
        if (this.rank === 0) {
            return [];
        }
        else if (this.rank === 1) {
            return [index];
        }
        var locs = new Array(this.shape.length);
        for (var i = 0; i < locs.length - 1; ++i) {
            locs[i] = Math.floor(index / this.strides[i]);
            index -= locs[i] * this.strides[i];
        }
        locs[locs.length - 1] = index;
        return locs;
    };
    Tensor.prototype.getValues = function () {
        return this.dataSync();
    };
    Tensor.prototype.getValuesAsync = function () {
        return this.data();
    };
    Tensor.prototype.buffer = function () {
        return ops.buffer(this.shape, this.dtype, this.dataSync());
    };
    Tensor.prototype.data = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                this.throwIfDisposed();
                return [2, environment_1.ENV.engine.read(this.dataId)];
            });
        });
    };
    Tensor.prototype.dataSync = function () {
        this.throwIfDisposed();
        return environment_1.ENV.engine.readSync(this.dataId);
    };
    Tensor.prototype.dispose = function () {
        if (this.isDisposed) {
            return;
        }
        this.isDisposed = true;
        environment_1.ENV.engine.disposeTensor(this);
    };
    Tensor.prototype.throwIfDisposed = function () {
        if (this.isDisposed) {
            throw new Error("Tensor is disposed.");
        }
    };
    Tensor.prototype.toFloat = function () {
        return this.asType('float32');
    };
    Tensor.prototype.toInt = function () {
        return this.asType('int32');
    };
    Tensor.prototype.toBool = function () {
        return this.asType('bool');
    };
    Tensor.prototype.print = function (verbose) {
        if (verbose === void 0) { verbose = false; }
        return ops.print(this, verbose);
    };
    Tensor.prototype.reshape = function (newShape) {
        this.throwIfDisposed();
        return ops.reshape(this, newShape);
    };
    Tensor.prototype.reshapeAs = function (x) {
        this.throwIfDisposed();
        return this.reshape(x.shape);
    };
    Tensor.prototype.expandDims = function (axis) {
        if (axis === void 0) { axis = 0; }
        return ops.expandDims(this, axis);
    };
    Tensor.prototype.squeeze = function (axis) {
        this.throwIfDisposed();
        return ops.squeeze(this, axis);
    };
    Tensor.prototype.clone = function () {
        this.throwIfDisposed();
        return ops.clone(this);
    };
    Tensor.prototype.toString = function () {
        return tensor_util.tensorToString(this, true);
    };
    Tensor.prototype.tile = function (reps) {
        this.throwIfDisposed();
        return ops.tile(this, reps);
    };
    Tensor.prototype.gather = function (indices, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.gather(this, indices);
    };
    Tensor.prototype.matMul = function (b, transposeA, transposeB) {
        if (transposeA === void 0) { transposeA = false; }
        if (transposeB === void 0) { transposeB = false; }
        this.throwIfDisposed();
        return ops.matMul(this, b, transposeA, transposeB);
    };
    Tensor.prototype.norm = function (ord, axis, keepDims) {
        if (ord === void 0) { ord = 'euclidean'; }
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.norm(this, ord, axis, keepDims);
    };
    Tensor.prototype.slice = function (begin, size) {
        this.throwIfDisposed();
        return ops.slice(this, begin, size);
    };
    Tensor.prototype.reverse = function (axis) {
        this.throwIfDisposed();
        return ops.reverse(this, axis);
    };
    Tensor.prototype.concat = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        this.throwIfDisposed();
        return ops.concat([this, x], axis);
    };
    Tensor.prototype.stack = function (x, axis) {
        if (axis === void 0) { axis = 0; }
        return ops.stack([this, x], axis);
    };
    Tensor.prototype.pad = function (paddings, constantValue) {
        if (constantValue === void 0) { constantValue = 0; }
        return ops.pad(this, paddings, constantValue);
    };
    Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
        if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
        this.throwIfDisposed();
        return ops.batchNormalization(this, mean, variance, varianceEpsilon, scale, offset);
    };
    Tensor.prototype.logSumExp = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.logSumExp(this, axis, keepDims);
    };
    Tensor.prototype.sum = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.sum(this, axis, keepDims);
    };
    Tensor.prototype.mean = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.mean(this, axis, keepDims);
    };
    Tensor.prototype.min = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.min(this, axis, keepDims);
    };
    Tensor.prototype.max = function (axis, keepDims) {
        if (axis === void 0) { axis = null; }
        if (keepDims === void 0) { keepDims = false; }
        this.throwIfDisposed();
        return ops.max(this, axis, keepDims);
    };
    Tensor.prototype.argMin = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMin(this, axis);
    };
    Tensor.prototype.argMax = function (axis) {
        if (axis === void 0) { axis = null; }
        this.throwIfDisposed();
        return ops.argMax(this, axis);
    };
    Tensor.prototype.add = function (x) {
        this.throwIfDisposed();
        return ops.add(this, x);
    };
    Tensor.prototype.addStrict = function (x) {
        this.throwIfDisposed();
        return ops.addStrict(this, x);
    };
    Tensor.prototype.sub = function (x) {
        this.throwIfDisposed();
        return ops.sub(this, x);
    };
    Tensor.prototype.subStrict = function (x) {
        this.throwIfDisposed();
        return ops.subStrict(this, x);
    };
    Tensor.prototype.pow = function (exp) {
        this.throwIfDisposed();
        return ops.pow(this, exp);
    };
    Tensor.prototype.powStrict = function (exp) {
        this.throwIfDisposed();
        return ops.powStrict(this, exp);
    };
    Tensor.prototype.mul = function (x) {
        this.throwIfDisposed();
        return ops.mul(this, x);
    };
    Tensor.prototype.mulStrict = function (x) {
        this.throwIfDisposed();
        return ops.mulStrict(this, x);
    };
    Tensor.prototype.div = function (x) {
        this.throwIfDisposed();
        return ops.div(this, x);
    };
    Tensor.prototype.divStrict = function (x) {
        this.throwIfDisposed();
        return ops.divStrict(this, x);
    };
    Tensor.prototype.minimum = function (x) {
        this.throwIfDisposed();
        return ops.minimum(this, x);
    };
    Tensor.prototype.minimumStrict = function (x) {
        this.throwIfDisposed();
        return ops.minimumStrict(this, x);
    };
    Tensor.prototype.maximum = function (x) {
        this.throwIfDisposed();
        return ops.maximum(this, x);
    };
    Tensor.prototype.maximumStrict = function (x) {
        this.throwIfDisposed();
        return ops.maximumStrict(this, x);
    };
    Tensor.prototype.transpose = function (perm) {
        this.throwIfDisposed();
        return ops.transpose(this, perm);
    };
    Tensor.prototype.notEqual = function (x) {
        this.throwIfDisposed();
        return ops.notEqual(this, x);
    };
    Tensor.prototype.notEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.notEqualStrict(this, x);
    };
    Tensor.prototype.less = function (x) {
        this.throwIfDisposed();
        return ops.less(this, x);
    };
    Tensor.prototype.lessStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessStrict(this, x);
    };
    Tensor.prototype.equal = function (x) {
        this.throwIfDisposed();
        return ops.equal(this, x);
    };
    Tensor.prototype.equalStrict = function (x) {
        this.throwIfDisposed();
        return ops.equalStrict(this, x);
    };
    Tensor.prototype.lessEqual = function (x) {
        this.throwIfDisposed();
        return ops.lessEqual(this, x);
    };
    Tensor.prototype.lessEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.lessEqualStrict(this, x);
    };
    Tensor.prototype.greater = function (x) {
        this.throwIfDisposed();
        return ops.greater(this, x);
    };
    Tensor.prototype.greaterStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterStrict(this, x);
    };
    Tensor.prototype.greaterEqual = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqual(this, x);
    };
    Tensor.prototype.greaterEqualStrict = function (x) {
        this.throwIfDisposed();
        return ops.greaterEqualStrict(this, x);
    };
    Tensor.prototype.logicalAnd = function (x) {
        this.throwIfDisposed();
        return ops.logicalAnd(this, x);
    };
    Tensor.prototype.logicalOr = function (x) {
        this.throwIfDisposed();
        return ops.logicalOr(this, x);
    };
    Tensor.prototype.logicalXor = function (x) {
        this.throwIfDisposed();
        return ops.logicalXor(this, x);
    };
    Tensor.prototype.where = function (condition, x) {
        this.throwIfDisposed();
        return ops.where(condition, this, x);
    };
    Tensor.prototype.neg = function () {
        this.throwIfDisposed();
        return ops.neg(this);
    };
    Tensor.prototype.ceil = function () {
        this.throwIfDisposed();
        return ops.ceil(this);
    };
    Tensor.prototype.floor = function () {
        this.throwIfDisposed();
        return ops.floor(this);
    };
    Tensor.prototype.exp = function () {
        this.throwIfDisposed();
        return ops.exp(this);
    };
    Tensor.prototype.log = function () {
        this.throwIfDisposed();
        return ops.log(this);
    };
    Tensor.prototype.sqrt = function () {
        this.throwIfDisposed();
        return ops.sqrt(this);
    };
    Tensor.prototype.square = function () {
        this.throwIfDisposed();
        return ops.square(this);
    };
    Tensor.prototype.abs = function () {
        this.throwIfDisposed();
        return ops.abs(this);
    };
    Tensor.prototype.clipByValue = function (min, max) {
        this.throwIfDisposed();
        return ops.clipByValue(this, min, max);
    };
    Tensor.prototype.relu = function () {
        this.throwIfDisposed();
        return ops.relu(this);
    };
    Tensor.prototype.elu = function () {
        this.throwIfDisposed();
        return ops.elu(this);
    };
    Tensor.prototype.selu = function () {
        this.throwIfDisposed();
        return ops.selu(this);
    };
    Tensor.prototype.leakyRelu = function (alpha) {
        if (alpha === void 0) { alpha = 0.2; }
        this.throwIfDisposed();
        return ops.leakyRelu(this, alpha);
    };
    Tensor.prototype.prelu = function (alpha) {
        this.throwIfDisposed();
        return ops.prelu(this, alpha);
    };
    Tensor.prototype.sigmoid = function () {
        this.throwIfDisposed();
        return ops.sigmoid(this);
    };
    Tensor.prototype.sin = function () {
        this.throwIfDisposed();
        return ops.sin(this);
    };
    Tensor.prototype.cos = function () {
        this.throwIfDisposed();
        return ops.cos(this);
    };
    Tensor.prototype.tan = function () {
        this.throwIfDisposed();
        return ops.tan(this);
    };
    Tensor.prototype.asin = function () {
        this.throwIfDisposed();
        return ops.asin(this);
    };
    Tensor.prototype.acos = function () {
        this.throwIfDisposed();
        return ops.acos(this);
    };
    Tensor.prototype.atan = function () {
        this.throwIfDisposed();
        return ops.atan(this);
    };
    Tensor.prototype.sinh = function () {
        this.throwIfDisposed();
        return ops.sinh(this);
    };
    Tensor.prototype.cosh = function () {
        this.throwIfDisposed();
        return ops.cosh(this);
    };
    Tensor.prototype.tanh = function () {
        this.throwIfDisposed();
        return ops.tanh(this);
    };
    Tensor.prototype.step = function (alpha) {
        if (alpha === void 0) { alpha = 0.0; }
        this.throwIfDisposed();
        return ops.step(this, alpha);
    };
    Tensor.prototype.softmax = function (dim) {
        if (dim === void 0) { dim = -1; }
        this.throwIfDisposed();
        return ops.softmax(this, dim);
    };
    Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
        if (alignCorners === void 0) { alignCorners = false; }
        this.throwIfDisposed();
        return ops.image.resizeBilinear(this, newShape2D, alignCorners);
    };
    Tensor.prototype.conv1d = function (filter, stride, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv1d(this, filter, stride, pad, dimRoundingMode);
    };
    Tensor.prototype.conv2d = function (filter, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2d(this, filter, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dilations, dimRoundingMode) {
        if (dilations === void 0) { dilations = [1, 1]; }
        this.throwIfDisposed();
        return ops.depthwiseConv2d(this, filter, strides, pad, dilations, dimRoundingMode);
    };
    Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.avgPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.maxPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.minPool = function (filterSize, strides, pad, dimRoundingMode) {
        this.throwIfDisposed();
        return ops.minPool(this, filterSize, strides, pad, dimRoundingMode);
    };
    Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta, normRegion) {
        if (radius === void 0) { radius = 5; }
        if (bias === void 0) { bias = 1; }
        if (alpha === void 0) { alpha = 1; }
        if (beta === void 0) { beta = 0.5; }
        if (normRegion === void 0) { normRegion = 'acrossChannels'; }
        return ops.localResponseNormalization(this, radius, bias, alpha, beta, normRegion);
    };
    Tensor.prototype.variable = function (trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        this.throwIfDisposed();
        return Variable.variable(this, trainable, name, dtype);
    };
    Tensor.nextId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "flatten", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asScalar", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as1D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as2D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as3D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "as4D", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "asType", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "buffer", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "data", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dataSync", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "dispose", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toFloat", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toInt", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toBool", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "print", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshape", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "reshapeAs", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "expandDims", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "squeeze", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "clone", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor.prototype, "toString", null);
    Tensor = Tensor_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Tensor);
    return Tensor;
    var Tensor_1;
}());
exports.Tensor = Tensor;
exports.NDArray = Tensor;
var Scalar = (function (_super) {
    __extends(Scalar, _super);
    function Scalar() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Scalar.new = function (value, dtype) {
        return ops.scalar(value, dtype);
    };
    return Scalar;
}(Tensor));
exports.Scalar = Scalar;
var Tensor1D = (function (_super) {
    __extends(Tensor1D, _super);
    function Tensor1D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tensor1D.new = function (values, dtype) {
        return ops.tensor1d(values, dtype);
    };
    return Tensor1D;
}(Tensor));
exports.Tensor1D = Tensor1D;
exports.Array1D = Tensor1D;
var Tensor2D = (function (_super) {
    __extends(Tensor2D, _super);
    function Tensor2D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tensor2D.new = function (shape, values, dtype) {
        return ops.tensor2d(values, shape, dtype);
    };
    return Tensor2D;
}(Tensor));
exports.Tensor2D = Tensor2D;
exports.Array2D = Tensor2D;
var Tensor3D = (function (_super) {
    __extends(Tensor3D, _super);
    function Tensor3D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tensor3D.new = function (shape, values, dtype) {
        return ops.tensor3d(values, shape, dtype);
    };
    return Tensor3D;
}(Tensor));
exports.Tensor3D = Tensor3D;
exports.Array3D = Tensor3D;
var Tensor4D = (function (_super) {
    __extends(Tensor4D, _super);
    function Tensor4D() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Tensor4D.new = function (shape, values, dtype) {
        return ops.tensor4d(values, shape, dtype);
    };
    return Tensor4D;
}(Tensor));
exports.Tensor4D = Tensor4D;
exports.Array4D = Tensor4D;
var Variable = (function (_super) {
    __extends(Variable, _super);
    function Variable(initialValue, trainable, name) {
        if (trainable === void 0) { trainable = true; }
        var _this = _super.call(this, initialValue.shape, initialValue.dtype, null, initialValue.dataId) || this;
        _this.trainable = trainable;
        _this.name = name;
        if (_this.name == null) {
            _this.name = Variable_1.nextVarId.toString();
            Variable_1.nextVarId++;
        }
        environment_1.ENV.engine.registerVariable(_this);
        return _this;
    }
    Variable_1 = Variable;
    Variable.variable = function (initialValue, trainable, name, dtype) {
        if (trainable === void 0) { trainable = true; }
        if (dtype != null && dtype !== initialValue.dtype) {
            initialValue = initialValue.asType(dtype);
        }
        return new Variable_1(initialValue, trainable, name);
    };
    Variable.prototype.assign = function (newValue) {
        if (newValue.dtype !== this.dtype) {
            throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                ("previous value (" + this.dtype + ") must match"));
        }
        if (!util.arraysEqual(newValue.shape, this.shape)) {
            throw new Error("shape of the new value (" + newValue.shape + ") and " +
                ("previous value (" + this.shape + ") must match"));
        }
        environment_1.ENV.engine.disposeTensor(this);
        this.dataId = newValue.dataId;
        environment_1.ENV.engine.registerTensor(this);
    };
    Variable.nextVarId = 0;
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable.prototype, "assign", null);
    __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Creation' })
    ], Variable, "variable", null);
    Variable = Variable_1 = __decorate([
        doc_1.doc({ heading: 'Tensors', subheading: 'Classes' })
    ], Variable);
    return Variable;
    var Variable_1;
}(Tensor));
exports.Variable = Variable;
var variable = Variable.variable;
exports.variable = variable;
function computeStrides(shape) {
    var rank = shape.length;
    if (rank < 2) {
        return [];
    }
    var strides = new Array(rank - 1);
    strides[rank - 2] = shape[rank - 1];
    for (var i = rank - 3; i >= 0; --i) {
        strides[i] = strides[i + 1] * shape[i + 1];
    }
    return strides;
}

},{"./doc":25,"./environment":27,"./ops/ops":114,"./tensor_util":138,"./util":143}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util = require("./util");
var FORMAT_LIMIT_NUM_VALS = 20;
var FORMAT_NUM_FIRST_LAST_VALS = 3;
var FORMAT_NUM_SIG_DIGITS = 7;
function tensorToString(t, verbose) {
    var vals = t.dataSync();
    var padPerCol = computeMaxSizePerColumn(t);
    var valsLines = subTensorToString(vals, t.shape, t.strides, padPerCol);
    var lines = ['Tensor'];
    if (verbose) {
        lines.push("  dtype: " + t.dtype);
        lines.push("  rank: " + t.rank);
        lines.push("  shape: [" + t.shape + "]");
        lines.push("  values:");
    }
    lines.push(valsLines.map(function (l) { return '    ' + l; }).join('\n'));
    return lines.join('\n');
}
exports.tensorToString = tensorToString;
function computeMaxSizePerColumn(t) {
    var vals = t.dataSync();
    var n = t.size;
    var numCols = t.strides[t.strides.length - 1];
    var padPerCol = new Array(numCols).fill(0);
    if (t.rank > 1) {
        for (var row = 0; row < n / numCols; row++) {
            var offset = row * numCols;
            for (var j = 0; j < numCols; j++) {
                padPerCol[j] =
                    Math.max(padPerCol[j], valToString(vals[offset + j], 0).length);
            }
        }
    }
    return padPerCol;
}
function valToString(val, pad) {
    return util.rightPad(parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString(), pad);
}
function subTensorToString(vals, shape, strides, padPerCol, isLast) {
    if (isLast === void 0) { isLast = true; }
    var size = shape[0];
    var rank = shape.length;
    if (rank === 0) {
        return [vals[0].toString()];
    }
    if (rank === 1) {
        if (size > FORMAT_LIMIT_NUM_VALS) {
            var firstVals = Array.from(vals.subarray(0, FORMAT_NUM_FIRST_LAST_VALS));
            var lastVals = Array.from(vals.subarray(size - FORMAT_NUM_FIRST_LAST_VALS, size));
            return [
                '[' + firstVals.map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                    ', ..., ' +
                    lastVals
                        .map(function (x, i) { return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i]); })
                        .join(', ') +
                    ']'
            ];
        }
        return [
            '[' +
                Array.from(vals).map(function (x, i) { return valToString(x, padPerCol[i]); }).join(', ') +
                ']'
        ];
    }
    var subshape = shape.slice(1);
    var substrides = strides.slice(1);
    var stride = strides[0];
    var lines = [];
    if (size > FORMAT_LIMIT_NUM_VALS) {
        for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, false));
        }
        lines.push('...');
        for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    else {
        for (var i = 0; i < size; i++) {
            var start = i * stride;
            var end = start + stride;
            lines.push.apply(lines, subTensorToString(vals.subarray(start, end), subshape, substrides, padPerCol, i === size - 1));
        }
    }
    var sep = rank === 2 ? ',' : '';
    lines[0] = '[' + lines[0] + sep;
    for (var i = 1; i < lines.length - 1; i++) {
        lines[i] = ' ' + lines[i] + sep;
    }
    var newLineSep = ',\n';
    for (var i = 2; i < rank; i++) {
        newLineSep += '\n';
    }
    lines[lines.length - 1] =
        ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
    return lines;
}

},{"./util":143}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var environment_1 = require("./environment");
var backend_cpu_1 = require("./kernels/backend_cpu");
var backend_webgl_1 = require("./kernels/backend_webgl");
var tensor_1 = require("./tensor");
var util = require("./util");
exports.WEBGL_ENVS = [
    { 'BACKEND': 'webgl', 'WEBGL_FLOAT_TEXTURE_ENABLED': true, 'WEBGL_VERSION': 1 },
    { 'BACKEND': 'webgl', 'WEBGL_FLOAT_TEXTURE_ENABLED': true, 'WEBGL_VERSION': 2 },
];
exports.CPU_ENVS = [{ 'BACKEND': 'cpu' }];
exports.ALL_ENVS = exports.WEBGL_ENVS.concat(exports.CPU_ENVS);
exports.TEST_EPSILON = 1e-3;
function expectArraysClose(actual, expected, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!(actual instanceof tensor_1.Tensor) && !(expected instanceof tensor_1.Tensor)) {
        var aType = actual.constructor.name;
        var bType = expected.constructor.name;
        if (aType !== bType) {
            throw new Error("Arrays are of different type actual: " + aType + " " +
                ("vs expected: " + bType));
        }
    }
    else if (actual instanceof tensor_1.Tensor && expected instanceof tensor_1.Tensor) {
        if (actual.dtype !== expected.dtype) {
            throw new Error("Arrays are of different type actual: " + actual.dtype + " " +
                ("vs expected: " + expected.dtype + "."));
        }
        if (!util.arraysEqual(actual.shape, expected.shape)) {
            throw new Error("Arrays are of different shape actual: " + actual.shape + " " +
                ("vs expected: " + expected.shape + "."));
        }
    }
    var actualValues;
    var expectedValues;
    if (actual instanceof tensor_1.Tensor) {
        actualValues = actual.dataSync();
    }
    else {
        actualValues = actual;
    }
    if (expected instanceof tensor_1.Tensor) {
        expectedValues = expected.dataSync();
    }
    else {
        expectedValues = expected;
    }
    if (actualValues.length !== expectedValues.length) {
        throw new Error("Arrays have different lengths actual: " + actualValues.length + " vs " +
            ("expected: " + expectedValues.length + ".\n") +
            ("Actual:   " + actualValues + ".\n") +
            ("Expected: " + expectedValues + "."));
    }
    for (var i = 0; i < expectedValues.length; ++i) {
        var a = actualValues[i];
        var e = expectedValues[i];
        if (!areClose(a, Number(e), epsilon)) {
            throw new Error("Arrays differ: actual[" + i + "] = " + a + ", expected[" + i + "] = " + e + ".\n" +
                ("Actual:   " + actualValues + ".\n") +
                ("Expected: " + expectedValues + "."));
        }
    }
}
exports.expectArraysClose = expectArraysClose;
function expectArraysEqual(actual, expected) {
    return expectArraysClose(actual, expected, 0);
}
exports.expectArraysEqual = expectArraysEqual;
function expectNumbersClose(a, e, epsilon) {
    if (epsilon === void 0) { epsilon = exports.TEST_EPSILON; }
    if (!areClose(a, e, epsilon)) {
        throw new Error("Numbers differ: actual === " + a + ", expected === " + e);
    }
}
exports.expectNumbersClose = expectNumbersClose;
function areClose(a, e, epsilon) {
    if (isNaN(a) && isNaN(e)) {
        return true;
    }
    if (isNaN(a) || isNaN(e) || Math.abs(a - e) > epsilon) {
        return false;
    }
    return true;
}
function expectValuesInRange(actual, low, high) {
    var actualVals;
    if (actual instanceof tensor_1.Tensor) {
        actualVals = actual.dataSync();
    }
    else {
        actualVals = actual;
    }
    for (var i = 0; i < actualVals.length; i++) {
        if (actualVals[i] < low || actualVals[i] > high) {
            throw new Error("Value out of range:" + actualVals[i] + " low: " + low + ", high: " + high);
        }
    }
}
exports.expectValuesInRange = expectValuesInRange;
function describeWithFlags(name, featuresList, tests) {
    featuresList.forEach(function (features) {
        var testName = name + ' ' + JSON.stringify(features);
        executeTests(testName, tests, features);
    });
}
exports.describeWithFlags = describeWithFlags;
function executeTests(testName, tests, features) {
    describe(testName, function () {
        beforeEach(function () {
            environment_1.ENV.setFeatures(features || {});
            environment_1.ENV.addCustomBackend('webgl', function () { return new backend_webgl_1.MathBackendWebGL(); });
            environment_1.ENV.addCustomBackend('cpu', function () { return new backend_cpu_1.MathBackendCPU(); });
            if (features && features.BACKEND != null) {
                environment_1.Environment.setBackend(features.BACKEND);
            }
            environment_1.ENV.engine.startScope();
        });
        afterEach(function () {
            environment_1.ENV.engine.endScope(null);
            environment_1.ENV.reset();
        });
        tests();
    });
}
function assertIsNan(val, dtype) {
    if (!util.isValNaN(val, dtype)) {
        throw new Error("Value " + val + " does not represent NaN for dtype " + dtype);
    }
}
exports.assertIsNan = assertIsNan;

},{"./environment":27,"./kernels/backend_cpu":61,"./kernels/backend_webgl":62,"./tensor":137,"./util":143}],140:[function(require,module,exports){
"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
var doc_1 = require("./doc");
var environment_1 = require("./environment");
var util_1 = require("./util");
var Tracking = (function () {
    function Tracking() {
    }
    Tracking.tidy = function (nameOrFn, fn, gradMode) {
        if (gradMode === void 0) { gradMode = false; }
        var name = null;
        if (fn == null) {
            if (typeof nameOrFn !== 'function') {
                throw new Error('Please provide a function to dl.tidy()');
            }
            fn = nameOrFn;
        }
        else {
            if (typeof nameOrFn !== 'string' && !(nameOrFn instanceof String)) {
                throw new Error('When calling with two arguments, the first argument ' +
                    'to dl.tidy() must be a string');
            }
            if (typeof fn !== 'function') {
                throw new Error('When calling with two arguments, the 2nd argument ' +
                    'to dl.tidy() must be a function');
            }
            name = nameOrFn;
        }
        environment_1.ENV.engine.startScope(name, gradMode);
        var result = fn();
        if (result instanceof Promise) {
            console.warn('Returning a promise inside of tidy is dangerous. ' +
                'This will be a run-time error in 0.6.0');
        }
        environment_1.ENV.engine.endScope(result, gradMode);
        return result;
    };
    Tracking.dispose = function (container) {
        var tensors = util_1.extractTensorsFromAny(container);
        tensors.forEach(function (tensor) { return tensor.dispose(); });
    };
    Tracking.keep = function (result) {
        return environment_1.ENV.engine.keep(result);
    };
    Tracking.time = function (f) {
        return environment_1.ENV.engine.time(f);
    };
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "tidy", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Memory' })
    ], Tracking, "keep", null);
    __decorate([
        doc_1.doc({ heading: 'Performance', subheading: 'Timing' })
    ], Tracking, "time", null);
    return Tracking;
}());
exports.Tracking = Tracking;

},{"./doc":25,"./environment":27,"./util":143}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var adadelta_optimizer_1 = require("./optimizers/adadelta_optimizer");
var adagrad_optimizer_1 = require("./optimizers/adagrad_optimizer");
var adam_optimizer_1 = require("./optimizers/adam_optimizer");
var adamax_optimizer_1 = require("./optimizers/adamax_optimizer");
var momentum_optimizer_1 = require("./optimizers/momentum_optimizer");
var optimizer_constructors_1 = require("./optimizers/optimizer_constructors");
var rmsprop_optimizer_1 = require("./optimizers/rmsprop_optimizer");
var sgd_optimizer_1 = require("./optimizers/sgd_optimizer");
[momentum_optimizer_1.MomentumOptimizer, sgd_optimizer_1.SGDOptimizer, adadelta_optimizer_1.AdadeltaOptimizer, adagrad_optimizer_1.AdagradOptimizer,
    rmsprop_optimizer_1.RMSPropOptimizer, adamax_optimizer_1.AdamaxOptimizer, adam_optimizer_1.AdamOptimizer];
exports.train = {
    sgd: optimizer_constructors_1.OptimizerConstructors.sgd,
    momentum: optimizer_constructors_1.OptimizerConstructors.momentum,
    adadelta: optimizer_constructors_1.OptimizerConstructors.adadelta,
    adagrad: optimizer_constructors_1.OptimizerConstructors.adagrad,
    rmsprop: optimizer_constructors_1.OptimizerConstructors.rmsprop,
    adamax: optimizer_constructors_1.OptimizerConstructors.adamax,
    adam: optimizer_constructors_1.OptimizerConstructors.adam
};

},{"./optimizers/adadelta_optimizer":126,"./optimizers/adagrad_optimizer":127,"./optimizers/adam_optimizer":128,"./optimizers/adamax_optimizer":129,"./optimizers/momentum_optimizer":130,"./optimizers/optimizer_constructors":132,"./optimizers/rmsprop_optimizer":133,"./optimizers/sgd_optimizer":134}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DType;
(function (DType) {
    DType["float32"] = "float32";
    DType["int32"] = "int32";
    DType["bool"] = "bool";
})(DType = exports.DType || (exports.DType = {}));
var Rank;
(function (Rank) {
    Rank["R0"] = "R0";
    Rank["R1"] = "R1";
    Rank["R2"] = "R2";
    Rank["R3"] = "R3";
    Rank["R4"] = "R4";
})(Rank = exports.Rank || (exports.Rank = {}));
var UpcastInt32AndMap;
(function (UpcastInt32AndMap) {
    UpcastInt32AndMap["float32"] = "float32";
    UpcastInt32AndMap["int32"] = "int32";
    UpcastInt32AndMap["bool"] = "int32";
})(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
var UpcastBoolAndMap;
(function (UpcastBoolAndMap) {
    UpcastBoolAndMap["float32"] = "float32";
    UpcastBoolAndMap["int32"] = "int32";
    UpcastBoolAndMap["bool"] = "bool";
})(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
var UpcastFloat32AndMap;
(function (UpcastFloat32AndMap) {
    UpcastFloat32AndMap["float32"] = "float32";
    UpcastFloat32AndMap["int32"] = "float32";
    UpcastFloat32AndMap["bool"] = "float32";
})(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
var upcastTypeMap = {
    float32: UpcastFloat32AndMap,
    int32: UpcastInt32AndMap,
    bool: UpcastBoolAndMap
};
function upcastType(typeA, typeB) {
    return upcastTypeMap[typeA][typeB];
}
exports.upcastType = upcastType;
function sumOutType(type) {
    return upcastType(type, 'int32');
}
exports.sumOutType = sumOutType;

},{}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tensor_1 = require("./tensor");
function shuffle(array) {
    var counter = array.length;
    var temp = 0;
    var index = 0;
    while (counter > 0) {
        index = (Math.random() * counter) | 0;
        counter--;
        temp = array[counter];
        array[counter] = array[index];
        array[index] = temp;
    }
}
exports.shuffle = shuffle;
function clamp(min, x, max) {
    return Math.max(min, Math.min(x, max));
}
exports.clamp = clamp;
function randUniform(a, b) {
    return Math.random() * (b - a) + a;
}
exports.randUniform = randUniform;
function distSquared(a, b) {
    var result = 0;
    for (var i = 0; i < a.length; i++) {
        var diff = Number(a[i]) - Number(b[i]);
        result += diff * diff;
    }
    return result;
}
exports.distSquared = distSquared;
function assert(expr, msg) {
    if (!expr) {
        throw new Error(msg);
    }
}
exports.assert = assert;
function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
    if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
    assert(arraysEqual(shapeA, shapeB), errorMessagePrefix + ("Shapes " + shapeA + " and " + shapeB + " must match"));
}
exports.assertShapesMatch = assertShapesMatch;
function assertTypesMatch(a, b) {
    assert(a.dtype === b.dtype, "The dtypes of the first (" + a.dtype + ") and " +
        ("second (" + b.dtype + ") input must match"));
}
exports.assertTypesMatch = assertTypesMatch;
function flatten(arr, ret) {
    if (ret === void 0) { ret = []; }
    if (Array.isArray(arr)) {
        for (var i = 0; i < arr.length; ++i) {
            flatten(arr[i], ret);
        }
    }
    else {
        ret.push(arr);
    }
    return ret;
}
exports.flatten = flatten;
function inferShape(val) {
    if (isTypedArray(val)) {
        return [val.length];
    }
    if (!Array.isArray(val)) {
        return [];
    }
    var shape = [];
    while (val instanceof Array) {
        shape.push(val.length);
        val = val[0];
    }
    return shape;
}
exports.inferShape = inferShape;
function sizeFromShape(shape) {
    if (shape.length === 0) {
        return 1;
    }
    var size = shape[0];
    for (var i = 1; i < shape.length; i++) {
        size *= shape[i];
    }
    return size;
}
exports.sizeFromShape = sizeFromShape;
function isScalarShape(shape) {
    return shape.length === 0;
}
exports.isScalarShape = isScalarShape;
function arraysEqual(n1, n2) {
    if (n1.length !== n2.length) {
        return false;
    }
    for (var i = 0; i < n1.length; i++) {
        if (n1[i] !== n2[i]) {
            return false;
        }
    }
    return true;
}
exports.arraysEqual = arraysEqual;
function isInt(a) {
    return a % 1 === 0;
}
exports.isInt = isInt;
function tanh(x) {
    if (Math.tanh != null) {
        return Math.tanh(x);
    }
    if (x === Infinity) {
        return 1;
    }
    else if (x === -Infinity) {
        return -1;
    }
    else {
        var e2x = Math.exp(2 * x);
        return (e2x - 1) / (e2x + 1);
    }
}
exports.tanh = tanh;
function sizeToSquarishShape(size) {
    for (var a = Math.floor(Math.sqrt(size)); a > 1; --a) {
        if (size % a === 0) {
            return [a, size / a];
        }
    }
    return [1, size];
}
exports.sizeToSquarishShape = sizeToSquarishShape;
function createShuffledIndices(n) {
    var shuffledIndices = new Uint32Array(n);
    for (var i = 0; i < n; ++i) {
        shuffledIndices[i] = i;
    }
    shuffle(shuffledIndices);
    return shuffledIndices;
}
exports.createShuffledIndices = createShuffledIndices;
function rightPad(a, size) {
    if (size <= a.length) {
        return a;
    }
    return a + ' '.repeat(size - a.length);
}
exports.rightPad = rightPad;
function repeatedTry(checkFn, delayFn, maxCounter) {
    if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
    return new Promise(function (resolve, reject) {
        var tryCount = 0;
        var tryFn = function () {
            if (checkFn()) {
                resolve();
                return;
            }
            tryCount++;
            var nextBackoff = delayFn(tryCount);
            if (maxCounter != null && tryCount >= maxCounter) {
                reject();
                return;
            }
            setTimeout(tryFn, nextBackoff);
        };
        setTimeout(tryFn, 0);
    });
}
exports.repeatedTry = repeatedTry;
function getQueryParams(queryString) {
    var params = {};
    queryString.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g, function (s) {
        var t = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            t[_i - 1] = arguments[_i];
        }
        decodeParam(params, t[0], t[1]);
        return t.join('=');
    });
    return params;
}
exports.getQueryParams = getQueryParams;
function decodeParam(params, name, value) {
    params[decodeURIComponent(name)] = decodeURIComponent(value || '');
}
function inferFromImplicitShape(shape, size) {
    var shapeProd = 1;
    var implicitIdx = -1;
    for (var i = 0; i < shape.length; ++i) {
        if (shape[i] > 0) {
            shapeProd *= shape[i];
        }
        else if (shape[i] === -1) {
            if (implicitIdx !== -1) {
                throw Error("Shapes can only have 1 implicit size. " +
                    ("Found -1 at dim " + implicitIdx + " and dim " + i));
            }
            implicitIdx = i;
        }
        else if (shape[i] <= 0) {
            throw Error("Shapes can not be <= 0. Found " + shape[i] + " at dim " + i);
        }
    }
    if (implicitIdx === -1) {
        if (size > 0 && size !== shapeProd) {
            throw Error("Size (" + size + ") must match the product of shape " + shape);
        }
        return shape;
    }
    if (size % shapeProd !== 0) {
        throw Error("The implicit shape can't be a fractional number. " +
            ("Got " + size + " / " + shapeProd));
    }
    var newShape = shape.slice();
    newShape[implicitIdx] = size / shapeProd;
    return newShape;
}
exports.inferFromImplicitShape = inferFromImplicitShape;
exports.NAN_INT32 = 1 << 31;
exports.NAN_BOOL = 255;
exports.NAN_FLOAT32 = NaN;
function getNaN(dtype) {
    if (dtype === 'float32') {
        return exports.NAN_FLOAT32;
    }
    else if (dtype === 'int32') {
        return exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.getNaN = getNaN;
function isValNaN(val, dtype) {
    if (isNaN(val)) {
        return true;
    }
    if (dtype === 'float32') {
        return false;
    }
    else if (dtype === 'int32') {
        return val === exports.NAN_INT32;
    }
    else if (dtype === 'bool') {
        return val === exports.NAN_BOOL;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.isValNaN = isValNaN;
function squeezeShape(shape, axis) {
    var newShape = [];
    var keptDims = [];
    var j = 0;
    for (var i = 0; i < shape.length; ++i) {
        if (axis != null) {
            if (axis[j] === i && shape[i] > 1) {
                throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
            }
            if ((axis[j] == null || axis[j] > i) && shape[i] === 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
            if (axis[j] <= i) {
                j++;
            }
        }
        if (shape[i] > 1) {
            newShape.push(shape[i]);
            keptDims.push(i);
        }
    }
    return { newShape: newShape, keptDims: keptDims };
}
exports.squeezeShape = squeezeShape;
function getTypedArrayFromDType(dtype, size) {
    var values = null;
    if (dtype == null || dtype === 'float32') {
        values = new Float32Array(size);
    }
    else if (dtype === 'int32') {
        values = new Int32Array(size);
    }
    else if (dtype === 'bool') {
        values = new Uint8Array(size);
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
    return values;
}
exports.getTypedArrayFromDType = getTypedArrayFromDType;
function isTensorInList(tensor, tensorList) {
    for (var i = 0; i < tensorList.length; i++) {
        if (tensorList[i].id === tensor.id) {
            return true;
        }
    }
    return false;
}
exports.isTensorInList = isTensorInList;
function checkForNaN(vals, dtype, name) {
    for (var i = 0; i < vals.length; i++) {
        if (isValNaN(vals[i], dtype)) {
            throw Error("The result of the '" + name + "' has NaNs.");
        }
    }
}
exports.checkForNaN = checkForNaN;
function flattenNameArrayMap(nameArrayMap, keys) {
    var xs = [];
    if (nameArrayMap instanceof tensor_1.Tensor) {
        xs.push(nameArrayMap);
    }
    else {
        var xMap = nameArrayMap;
        for (var i = 0; i < keys.length; i++) {
            xs.push(xMap[keys[i]]);
        }
    }
    return xs;
}
exports.flattenNameArrayMap = flattenNameArrayMap;
function unflattenToNameArrayMap(keys, flatArrays) {
    if (keys.length !== flatArrays.length) {
        throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");
    }
    var result = {};
    for (var i = 0; i < keys.length; i++) {
        result[keys[i]] = flatArrays[i];
    }
    return result;
}
exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
function hasEncodingLoss(oldType, newType) {
    if (newType === 'float32') {
        return false;
    }
    if (newType === 'int32' && oldType !== 'float32') {
        return false;
    }
    if (newType === 'bool' && oldType === 'bool') {
        return false;
    }
    return true;
}
exports.hasEncodingLoss = hasEncodingLoss;
function copyTypedArray(array, dtype) {
    if (dtype == null || dtype === 'float32') {
        return new Float32Array(array);
    }
    else if (dtype === 'int32') {
        var vals = new Int32Array(array.length);
        for (var i = 0; i < vals.length; ++i) {
            var val = array[i];
            if (isValNaN(val, 'int32')) {
                vals[i] = getNaN('int32');
            }
            else {
                vals[i] = val;
            }
        }
        return vals;
    }
    else if (dtype === 'bool') {
        var bool = new Uint8Array(array.length);
        for (var i = 0; i < bool.length; ++i) {
            var val = array[i];
            if (isValNaN(val, 'bool')) {
                bool[i] = getNaN('bool');
            }
            else if (Math.round(val) !== 0) {
                bool[i] = 1;
            }
        }
        return bool;
    }
    else {
        throw new Error("Unknown data type " + dtype);
    }
}
exports.copyTypedArray = copyTypedArray;
function isTypedArray(a) {
    return a instanceof Float32Array || a instanceof Int32Array ||
        a instanceof Uint8Array;
}
exports.isTypedArray = isTypedArray;
function bytesPerElement(dtype) {
    if (dtype === 'float32' || dtype === 'int32') {
        return 4;
    }
    else if (dtype === 'bool') {
        return 1;
    }
    else {
        throw new Error("Unknown dtype " + dtype);
    }
}
exports.bytesPerElement = bytesPerElement;
function isFunction(f) {
    return !!(f && f.constructor && f.call && f.apply);
}
exports.isFunction = isFunction;
function extractTensorsFromContainer(result) {
    return extractTensorsFromAny(result);
}
exports.extractTensorsFromContainer = extractTensorsFromContainer;
function extractTensorsFromAny(result) {
    if (result == null) {
        return [];
    }
    if (result instanceof tensor_1.Tensor) {
        return [result];
    }
    var list = [];
    var resultObj = result;
    if (!isIterable(resultObj)) {
        return [];
    }
    for (var k in resultObj) {
        var sublist = flatten(resultObj[k]).filter(function (x) { return x instanceof tensor_1.Tensor; });
        list.push.apply(list, sublist);
    }
    return list;
}
exports.extractTensorsFromAny = extractTensorsFromAny;
function isIterable(obj) {
    return Array.isArray(obj) || typeof obj === 'object';
}

},{"./tensor":137}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var version = '0.5.1';
exports.version = version;

},{}],145:[function(require,module,exports){
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var ops_1 = require("./ops/ops");
var util = require("./util");
var DTYPE_VALUE_SIZE_MAP = {
    'float32': 4,
    'int32': 4
};
function loadWeights(manifest, filePathPrefix, weightNames) {
    if (filePathPrefix === void 0) { filePathPrefix = ''; }
    return __awaiter(this, void 0, void 0, function () {
        var groupIndicesToFetchMap, groupWeightsToFetch, weightsFound, allManifestWeightNames, weightsNotFound, groupIndicesToFetch, requests, responses, buffers, weightsTensorMap, bufferIndexOffset;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    groupIndicesToFetchMap = manifest.map(function () { return false; });
                    groupWeightsToFetch = {};
                    weightsFound = weightNames != null ? weightNames.map(function () { return false; }) : [];
                    allManifestWeightNames = [];
                    manifest.forEach(function (manifestGroupConfig, groupIndex) {
                        var groupOffset = 0;
                        manifestGroupConfig.weights.forEach(function (weightsEntry) {
                            var weightsBytes = DTYPE_VALUE_SIZE_MAP[weightsEntry.dtype] *
                                util.sizeFromShape(weightsEntry.shape);
                            var enqueueWeightsForFetchingFn = function () {
                                groupIndicesToFetchMap[groupIndex] = true;
                                if (groupWeightsToFetch[groupIndex] == null) {
                                    groupWeightsToFetch[groupIndex] = [];
                                }
                                groupWeightsToFetch[groupIndex].push({
                                    manifestEntry: weightsEntry,
                                    groupOffset: groupOffset,
                                    sizeBytes: weightsBytes
                                });
                            };
                            if (weightNames != null) {
                                weightNames.forEach(function (weightName, weightIndex) {
                                    if (weightName === weightsEntry.name) {
                                        enqueueWeightsForFetchingFn();
                                        weightsFound[weightIndex] = true;
                                    }
                                });
                            }
                            else {
                                enqueueWeightsForFetchingFn();
                            }
                            allManifestWeightNames.push(weightsEntry.name);
                            groupOffset += weightsBytes;
                        });
                    });
                    if (!weightsFound.every(function (found) { return found; })) {
                        weightsNotFound = weightNames.filter(function (weight, i) { return !weightsFound[i]; });
                        throw new Error("Could not find weights in manifest with names: " +
                            (weightsNotFound.join(', ') + ". \n") +
                            "Manifest JSON has weights with names: " +
                            (allManifestWeightNames.join(', ') + "."));
                    }
                    groupIndicesToFetch = groupIndicesToFetchMap.reduce(function (accumulator, shouldFetch, i) {
                        if (shouldFetch) {
                            accumulator.push(i);
                        }
                        return accumulator;
                    }, []);
                    requests = [];
                    groupIndicesToFetch.forEach(function (i) {
                        manifest[i].paths.forEach(function (filepath) {
                            var fetchUrl = filePathPrefix +
                                (!filePathPrefix.endsWith('/') ? '/' : '') + filepath;
                            requests.push(fetch(fetchUrl));
                        });
                    });
                    return [4, Promise.all(requests)];
                case 1:
                    responses = _a.sent();
                    return [4, Promise.all(responses.map(function (response) { return response.arrayBuffer(); }))];
                case 2:
                    buffers = _a.sent();
                    weightsTensorMap = {};
                    bufferIndexOffset = 0;
                    groupIndicesToFetch.forEach(function (i) {
                        var numBuffers = manifest[i].paths.length;
                        var groupBytes = 0;
                        for (var i_1 = 0; i_1 < numBuffers; i_1++) {
                            groupBytes += buffers[bufferIndexOffset + i_1].byteLength;
                        }
                        var groupBuffer = new ArrayBuffer(groupBytes);
                        var groupByteBuffer = new Uint8Array(groupBuffer);
                        var groupBufferOffset = 0;
                        for (var i_2 = 0; i_2 < numBuffers; i_2++) {
                            var buffer = new Uint8Array(buffers[bufferIndexOffset + i_2]);
                            groupByteBuffer.set(buffer, groupBufferOffset);
                            groupBufferOffset += buffer.byteLength;
                        }
                        var weightsEntries = groupWeightsToFetch[i];
                        weightsEntries.forEach(function (weightsEntry) {
                            var byteBuffer = groupBuffer.slice(weightsEntry.groupOffset, weightsEntry.groupOffset + weightsEntry.sizeBytes);
                            var typedArray;
                            if (weightsEntry.manifestEntry.dtype === 'float32') {
                                typedArray = new Float32Array(byteBuffer);
                            }
                            else if (weightsEntry.manifestEntry.dtype === 'int32') {
                                typedArray = new Int32Array(byteBuffer);
                            }
                            else {
                                throw new Error("Weight " + weightsEntry.manifestEntry.name + " has unknown dtype " +
                                    (weightsEntry.manifestEntry.dtype + "."));
                            }
                            var weightName = weightsEntry.manifestEntry.name;
                            if (weightsTensorMap[weightName] != null) {
                                throw new Error("Duplicate weight with name " + weightName + ". " +
                                    "Please make sure weights names are unique in the manifest JSON.");
                            }
                            weightsTensorMap[weightName] = ops_1.tensor(typedArray, weightsEntry.manifestEntry.shape, weightsEntry.manifestEntry.dtype);
                        });
                        bufferIndexOffset += numBuffers;
                    });
                    return [2, weightsTensorMap];
            }
        });
    });
}
exports.loadWeights = loadWeights;

},{"./ops/ops":114,"./util":143}],146:[function(require,module,exports){
// A library of seedable RNGs implemented in Javascript.
//
// Usage:
//
// var seedrandom = require('seedrandom');
// var random = seedrandom(1); // or any seed.
// var x = random();       // 0 <= x < 1.  Every bit is random.
// var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

// alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
// Period: ~2^116
// Reported to pass all BigCrush tests.
var alea = require('./lib/alea');

// xor128, a pure xor-shift generator by George Marsaglia.
// Period: 2^128-1.
// Reported to fail: MatrixRank and LinearComp.
var xor128 = require('./lib/xor128');

// xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
// Period: 2^192-2^32
// Reported to fail: CollisionOver, SimpPoker, and LinearComp.
var xorwow = require('./lib/xorwow');

// xorshift7, by François Panneton and Pierre L'ecuyer, takes
// a different approach: it adds robustness by allowing more shifts
// than Marsaglia's original three.  It is a 7-shift generator
// with 256 bits, that passes BigCrush with no systmatic failures.
// Period 2^256-1.
// No systematic BigCrush failures reported.
var xorshift7 = require('./lib/xorshift7');

// xor4096, by Richard Brent, is a 4096-bit xor-shift with a
// very long period that also adds a Weyl generator. It also passes
// BigCrush with no systematic failures.  Its long period may
// be useful if you have many generators and need to avoid
// collisions.
// Period: 2^4128-2^32.
// No systematic BigCrush failures reported.
var xor4096 = require('./lib/xor4096');

// Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
// number generator derived from ChaCha, a modern stream cipher.
// https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
// Period: ~2^127
// No systematic BigCrush failures reported.
var tychei = require('./lib/tychei');

// The original ARC4-based prng included in this library.
// Period: ~2^1600
var sr = require('./seedrandom');

sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;

module.exports = sr;

},{"./lib/alea":147,"./lib/tychei":148,"./lib/xor128":149,"./lib/xor4096":150,"./lib/xorshift7":151,"./lib/xorwow":152,"./seedrandom":153}],147:[function(require,module,exports){
// A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
// http://baagoe.com/en/RandomMusings/javascript/
// https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
// Original work is under MIT license -

// Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



(function(global, module, define) {

function Alea(seed) {
  var me = this, mash = Mash();

  me.next = function() {
    var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
    me.s0 = me.s1;
    me.s1 = me.s2;
    return me.s2 = t - (me.c = t | 0);
  };

  // Apply the seeding algorithm from Baagoe.
  me.c = 1;
  me.s0 = mash(' ');
  me.s1 = mash(' ');
  me.s2 = mash(' ');
  me.s0 -= mash(seed);
  if (me.s0 < 0) { me.s0 += 1; }
  me.s1 -= mash(seed);
  if (me.s1 < 0) { me.s1 += 1; }
  me.s2 -= mash(seed);
  if (me.s2 < 0) { me.s2 += 1; }
  mash = null;
}

function copy(f, t) {
  t.c = f.c;
  t.s0 = f.s0;
  t.s1 = f.s1;
  t.s2 = f.s2;
  return t;
}

function impl(seed, opts) {
  var xg = new Alea(seed),
      state = opts && opts.state,
      prng = xg.next;
  prng.int32 = function() { return (xg.next() * 0x100000000) | 0; }
  prng.double = function() {
    return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
  };
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

function Mash() {
  var n = 0xefc8249d;

  var mash = function(data) {
    data = data.toString();
    for (var i = 0; i < data.length; i++) {
      n += data.charCodeAt(i);
      var h = 0.02519603282416938 * n;
      n = h >>> 0;
      h -= n;
      h *= n;
      n = h >>> 0;
      h -= n;
      n += h * 0x100000000; // 2^32
    }
    return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
  };

  return mash;
}


if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.alea = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],148:[function(require,module,exports){
// A Javascript implementaion of the "Tyche-i" prng algorithm by
// Samuel Neves and Filipe Araujo.
// See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var b = me.b, c = me.c, d = me.d, a = me.a;
    b = (b << 25) ^ (b >>> 7) ^ c;
    c = (c - d) | 0;
    d = (d << 24) ^ (d >>> 8) ^ a;
    a = (a - b) | 0;
    me.b = b = (b << 20) ^ (b >>> 12) ^ c;
    me.c = c = (c - d) | 0;
    me.d = (d << 16) ^ (c >>> 16) ^ a;
    return me.a = (a - b) | 0;
  };

  /* The following is non-inverted tyche, which has better internal
   * bit diffusion, but which is about 25% slower than tyche-i in JS.
  me.next = function() {
    var a = me.a, b = me.b, c = me.c, d = me.d;
    a = (me.a + me.b | 0) >>> 0;
    d = me.d ^ a; d = d << 16 ^ d >>> 16;
    c = me.c + d | 0;
    b = me.b ^ c; b = b << 12 ^ d >>> 20;
    me.a = a = a + b | 0;
    d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
    me.c = c = c + d | 0;
    b = b ^ c;
    return me.b = (b << 7 ^ b >>> 25);
  }
  */

  me.a = 0;
  me.b = 0;
  me.c = 2654435769 | 0;
  me.d = 1367130551;

  if (seed === Math.floor(seed)) {
    // Integer seed.
    me.a = (seed / 0x100000000) | 0;
    me.b = seed | 0;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 20; k++) {
    me.b ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.a = f.a;
  t.b = f.b;
  t.c = f.c;
  t.d = f.d;
  return t;
};

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.tychei = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],149:[function(require,module,exports){
// A Javascript implementaion of the "xor128" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;

  // Set up generator function.
  me.next = function() {
    var t = me.x ^ (me.x << 11);
    me.x = me.y;
    me.y = me.z;
    me.z = me.w;
    return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
  };

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor128 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],150:[function(require,module,exports){
// A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
//
// This fast non-cryptographic random number generator is designed for
// use in Monte-Carlo algorithms. It combines a long-period xorshift
// generator with a Weyl generator, and it passes all common batteries
// of stasticial tests for randomness while consuming only a few nanoseconds
// for each prng generated.  For background on the generator, see Brent's
// paper: "Some long-period random number generators using shifts and xors."
// http://arxiv.org/pdf/1004.3115v1.pdf
//
// Usage:
//
// var xor4096 = require('xor4096');
// random = xor4096(1);                        // Seed with int32 or string.
// assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
// assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
//
// For nonzero numeric keys, this impelementation provides a sequence
// identical to that by Brent's xorgens 3 implementaion in C.  This
// implementation also provides for initalizing the generator with
// string seeds, or for saving and restoring the state of the generator.
//
// On Chrome, this prng benchmarks about 2.1 times slower than
// Javascript's built-in Math.random().

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    var w = me.w,
        X = me.X, i = me.i, t, v;
    // Update Weyl generator.
    me.w = w = (w + 0x61c88647) | 0;
    // Update xor generator.
    v = X[(i + 34) & 127];
    t = X[i = ((i + 1) & 127)];
    v ^= v << 13;
    t ^= t << 17;
    v ^= v >>> 15;
    t ^= t >>> 12;
    // Update Xor generator array state.
    v = X[i] = v ^ t;
    me.i = i;
    // Result is the combination.
    return (v + (w ^ (w >>> 16))) | 0;
  };

  function init(me, seed) {
    var t, v, i, j, w, X = [], limit = 128;
    if (seed === (seed | 0)) {
      // Numeric seeds initialize v, which is used to generates X.
      v = seed;
      seed = null;
    } else {
      // String seeds are mixed into v and X one character at a time.
      seed = seed + '\0';
      v = 0;
      limit = Math.max(limit, seed.length);
    }
    // Initialize circular array and weyl value.
    for (i = 0, j = -32; j < limit; ++j) {
      // Put the unicode characters into the array, and shuffle them.
      if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
      // After 32 shuffles, take v as the starting w value.
      if (j === 0) w = v;
      v ^= v << 10;
      v ^= v >>> 15;
      v ^= v << 4;
      v ^= v >>> 13;
      if (j >= 0) {
        w = (w + 0x61c88647) | 0;     // Weyl.
        t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
        i = (0 == t) ? i + 1 : 0;     // Count zeroes.
      }
    }
    // We have detected all zeroes; make the key nonzero.
    if (i >= 128) {
      X[(seed && seed.length || 0) & 127] = -1;
    }
    // Run the generator 512 times to further mix the state before using it.
    // Factoring this as a function slows the main generator, so it is just
    // unrolled here.  The weyl generator is not advanced while warming up.
    i = 127;
    for (j = 4 * 128; j > 0; --j) {
      v = X[(i + 34) & 127];
      t = X[i = ((i + 1) & 127)];
      v ^= v << 13;
      t ^= t << 17;
      v ^= v >>> 15;
      t ^= t >>> 12;
      X[i] = v ^ t;
    }
    // Storing state as object members is faster than using closure variables.
    me.w = w;
    me.X = X;
    me.i = i;
  }

  init(me, seed);
}

function copy(f, t) {
  t.i = f.i;
  t.w = f.w;
  t.X = f.X.slice();
  return t;
};

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.X) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xor4096 = impl;
}

})(
  this,                                     // window object or global
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);

},{}],151:[function(require,module,exports){
// A Javascript implementaion of the "xorshift7" algorithm by
// François Panneton and Pierre L'ecuyer:
// "On the Xorgshift Random Number Generators"
// http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

(function(global, module, define) {

function XorGen(seed) {
  var me = this;

  // Set up generator function.
  me.next = function() {
    // Update xor generator.
    var X = me.x, i = me.i, t, v, w;
    t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
    t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
    t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
    t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
    t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
    X[i] = v;
    me.i = (i + 1) & 7;
    return v;
  };

  function init(me, seed) {
    var j, w, X = [];

    if (seed === (seed | 0)) {
      // Seed state array using a 32-bit integer.
      w = X[0] = seed;
    } else {
      // Seed state using a string.
      seed = '' + seed;
      for (j = 0; j < seed.length; ++j) {
        X[j & 7] = (X[j & 7] << 15) ^
            (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
      }
    }
    // Enforce an array length of 8, not all zeroes.
    while (X.length < 8) X.push(0);
    for (j = 0; j < 8 && X[j] === 0; ++j);
    if (j == 8) w = X[7] = -1; else w = X[j];

    me.x = X;
    me.i = 0;

    // Discard an initial 256 values.
    for (j = 256; j > 0; --j) {
      me.next();
    }
  }

  init(me, seed);
}

function copy(f, t) {
  t.x = f.x.slice();
  t.i = f.i;
  return t;
}

function impl(seed, opts) {
  if (seed == null) seed = +(new Date);
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (state.x) copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorshift7 = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);


},{}],152:[function(require,module,exports){
// A Javascript implementaion of the "xorwow" prng algorithm by
// George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

(function(global, module, define) {

function XorGen(seed) {
  var me = this, strseed = '';

  // Set up generator function.
  me.next = function() {
    var t = (me.x ^ (me.x >>> 2));
    me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
    return (me.d = (me.d + 362437 | 0)) +
       (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
  };

  me.x = 0;
  me.y = 0;
  me.z = 0;
  me.w = 0;
  me.v = 0;

  if (seed === (seed | 0)) {
    // Integer seed.
    me.x = seed;
  } else {
    // String seed.
    strseed += seed;
  }

  // Mix in string seed, then discard an initial batch of 64 values.
  for (var k = 0; k < strseed.length + 64; k++) {
    me.x ^= strseed.charCodeAt(k) | 0;
    if (k == strseed.length) {
      me.d = me.x << 10 ^ me.x >>> 4;
    }
    me.next();
  }
}

function copy(f, t) {
  t.x = f.x;
  t.y = f.y;
  t.z = f.z;
  t.w = f.w;
  t.v = f.v;
  t.d = f.d;
  return t;
}

function impl(seed, opts) {
  var xg = new XorGen(seed),
      state = opts && opts.state,
      prng = function() { return (xg.next() >>> 0) / 0x100000000; };
  prng.double = function() {
    do {
      var top = xg.next() >>> 11,
          bot = (xg.next() >>> 0) / 0x100000000,
          result = (top + bot) / (1 << 21);
    } while (result === 0);
    return result;
  };
  prng.int32 = xg.next;
  prng.quick = prng;
  if (state) {
    if (typeof(state) == 'object') copy(state, xg);
    prng.state = function() { return copy(xg, {}); }
  }
  return prng;
}

if (module && module.exports) {
  module.exports = impl;
} else if (define && define.amd) {
  define(function() { return impl; });
} else {
  this.xorwow = impl;
}

})(
  this,
  (typeof module) == 'object' && module,    // present in node.js
  (typeof define) == 'function' && define   // present with an AMD loader
);



},{}],153:[function(require,module,exports){
/*
Copyright 2014 David Bau.

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

*/

(function (pool, math) {
//
// The following constants are related to IEEE 754 limits.
//
var global = this,
    width = 256,        // each RC4 output is 0 <= x < 256
    chunks = 6,         // at least six RC4 outputs for each double
    digits = 52,        // there are 52 significant digits in a double
    rngname = 'random', // rngname: name for Math.random and Math.seedrandom
    startdenom = math.pow(width, chunks),
    significance = math.pow(2, digits),
    overflow = significance * 2,
    mask = width - 1,
    nodecrypto;         // node.js crypto module, initialized at the bottom.

//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed, options, callback) {
  var key = [];
  options = (options == true) ? { entropy: true } : (options || {});

  // Flatten the seed string or build one from local entropy if needed.
  var shortseed = mixkey(flatten(
    options.entropy ? [seed, tostring(pool)] :
    (seed == null) ? autoseed() : seed, 3), key);

  // Use the seed to initialize an ARC4 generator.
  var arc4 = new ARC4(key);

  // This function returns a random double in [0, 1) that contains
  // randomness in every bit of the mantissa of the IEEE 754 value.
  var prng = function() {
    var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
        d = startdenom,                 //   and denominator d = 2 ^ 48.
        x = 0;                          //   and no 'extra last byte'.
    while (n < significance) {          // Fill up all significant digits by
      n = (n + x) * width;              //   shifting numerator and
      d *= width;                       //   denominator and generating a
      x = arc4.g(1);                    //   new least-significant-byte.
    }
    while (n >= overflow) {             // To avoid rounding up, before adding
      n /= 2;                           //   last byte, shift everything
      d /= 2;                           //   right using integer math until
      x >>>= 1;                         //   we have exactly the desired bits.
    }
    return (n + x) / d;                 // Form the number within [0, 1).
  };

  prng.int32 = function() { return arc4.g(4) | 0; }
  prng.quick = function() { return arc4.g(4) / 0x100000000; }
  prng.double = prng;

  // Mix the randomness into accumulated entropy.
  mixkey(tostring(arc4.S), pool);

  // Calling convention: what to return as a function of prng, seed, is_math.
  return (options.pass || callback ||
      function(prng, seed, is_math_call, state) {
        if (state) {
          // Load the arc4 state from the given state if it has an S array.
          if (state.S) { copy(state, arc4); }
          // Only provide the .state method if requested via options.state.
          prng.state = function() { return copy(arc4, {}); }
        }

        // If called as a method of Math (Math.seedrandom()), mutate
        // Math.random because that is how seedrandom.js has worked since v1.0.
        if (is_math_call) { math[rngname] = prng; return seed; }

        // Otherwise, it is a newer calling convention, so return the
        // prng directly.
        else return prng;
      })(
  prng,
  shortseed,
  'global' in options ? options.global : (this == math),
  options.state);
}
math['seed' + rngname] = seedrandom;

//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key) {
  var t, keylen = key.length,
      me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

  // The empty key [] is treated as [0].
  if (!keylen) { key = [keylen++]; }

  // Set up S using the standard key scheduling algorithm.
  while (i < width) {
    s[i] = i++;
  }
  for (i = 0; i < width; i++) {
    s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
    s[j] = t;
  }

  // The "g" method returns the next (count) outputs as one number.
  (me.g = function(count) {
    // Using instance members instead of closure state nearly doubles speed.
    var t, r = 0,
        i = me.i, j = me.j, s = me.S;
    while (count--) {
      t = s[i = mask & (i + 1)];
      r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
    }
    me.i = i; me.j = j;
    return r;
    // For robust unpredictability, the function call below automatically
    // discards an initial batch of values.  This is called RC4-drop[256].
    // See http://google.com/search?q=rsa+fluhrer+response&btnI
  })(width);
}

//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f, t) {
  t.i = f.i;
  t.j = f.j;
  t.S = f.S.slice();
  return t;
};

//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj, depth) {
  var result = [], typ = (typeof obj), prop;
  if (depth && typ == 'object') {
    for (prop in obj) {
      try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
    }
  }
  return (result.length ? result : typ == 'string' ? obj : obj + '\0');
}

//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed, key) {
  var stringseed = seed + '', smear, j = 0;
  while (j < stringseed.length) {
    key[mask & j] =
      mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
  }
  return tostring(key);
}

//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed() {
  try {
    var out;
    if (nodecrypto && (out = nodecrypto.randomBytes)) {
      // The use of 'out' to remember randomBytes makes tight minified code.
      out = out(width);
    } else {
      out = new Uint8Array(width);
      (global.crypto || global.msCrypto).getRandomValues(out);
    }
    return tostring(out);
  } catch (e) {
    var browser = global.navigator,
        plugins = browser && browser.plugins;
    return [+new Date, global, plugins, global.screen, tostring(pool)];
  }
}

//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a) {
  return String.fromCharCode.apply(0, a);
}

//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(), pool);

//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
if ((typeof module) == 'object' && module.exports) {
  module.exports = seedrandom;
  // When in node.js, try using crypto package for autoseeding.
  try {
    nodecrypto = require('crypto');
  } catch (ex) {}
} else if ((typeof define) == 'function' && define.amd) {
  define(function() { return seedrandom; });
}

// End anonymous scope, and pass initial values.
})(
  [],     // pool: entropy pool starts empty
  Math    // math: package containing random, pow, and seedrandom
);

},{"crypto":2}],154:[function(require,module,exports){
(function (global){
/*! https://mths.be/utf8js v2.1.2 by @mathias */
;(function(root) {

	// Detect free variables `exports`
	var freeExports = typeof exports == 'object' && exports;

	// Detect free variable `module`
	var freeModule = typeof module == 'object' && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	// Taken from https://mths.be/punycode
	function ucs2decode(string) {
		var output = [];
		var counter = 0;
		var length = string.length;
		var value;
		var extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	// Taken from https://mths.be/punycode
	function ucs2encode(array) {
		var length = array.length;
		var index = -1;
		var value;
		var output = '';
		while (++index < length) {
			value = array[index];
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
		}
		return output;
	}

	function checkScalarValue(codePoint) {
		if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
			throw Error(
				'Lone surrogate U+' + codePoint.toString(16).toUpperCase() +
				' is not a scalar value'
			);
		}
	}
	/*--------------------------------------------------------------------------*/

	function createByte(codePoint, shift) {
		return stringFromCharCode(((codePoint >> shift) & 0x3F) | 0x80);
	}

	function encodeCodePoint(codePoint) {
		if ((codePoint & 0xFFFFFF80) == 0) { // 1-byte sequence
			return stringFromCharCode(codePoint);
		}
		var symbol = '';
		if ((codePoint & 0xFFFFF800) == 0) { // 2-byte sequence
			symbol = stringFromCharCode(((codePoint >> 6) & 0x1F) | 0xC0);
		}
		else if ((codePoint & 0xFFFF0000) == 0) { // 3-byte sequence
			checkScalarValue(codePoint);
			symbol = stringFromCharCode(((codePoint >> 12) & 0x0F) | 0xE0);
			symbol += createByte(codePoint, 6);
		}
		else if ((codePoint & 0xFFE00000) == 0) { // 4-byte sequence
			symbol = stringFromCharCode(((codePoint >> 18) & 0x07) | 0xF0);
			symbol += createByte(codePoint, 12);
			symbol += createByte(codePoint, 6);
		}
		symbol += stringFromCharCode((codePoint & 0x3F) | 0x80);
		return symbol;
	}

	function utf8encode(string) {
		var codePoints = ucs2decode(string);
		var length = codePoints.length;
		var index = -1;
		var codePoint;
		var byteString = '';
		while (++index < length) {
			codePoint = codePoints[index];
			byteString += encodeCodePoint(codePoint);
		}
		return byteString;
	}

	/*--------------------------------------------------------------------------*/

	function readContinuationByte() {
		if (byteIndex >= byteCount) {
			throw Error('Invalid byte index');
		}

		var continuationByte = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		if ((continuationByte & 0xC0) == 0x80) {
			return continuationByte & 0x3F;
		}

		// If we end up here, it’s not a continuation byte
		throw Error('Invalid continuation byte');
	}

	function decodeSymbol() {
		var byte1;
		var byte2;
		var byte3;
		var byte4;
		var codePoint;

		if (byteIndex > byteCount) {
			throw Error('Invalid byte index');
		}

		if (byteIndex == byteCount) {
			return false;
		}

		// Read first byte
		byte1 = byteArray[byteIndex] & 0xFF;
		byteIndex++;

		// 1-byte sequence (no continuation bytes)
		if ((byte1 & 0x80) == 0) {
			return byte1;
		}

		// 2-byte sequence
		if ((byte1 & 0xE0) == 0xC0) {
			byte2 = readContinuationByte();
			codePoint = ((byte1 & 0x1F) << 6) | byte2;
			if (codePoint >= 0x80) {
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 3-byte sequence (may include unpaired surrogates)
		if ((byte1 & 0xF0) == 0xE0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			codePoint = ((byte1 & 0x0F) << 12) | (byte2 << 6) | byte3;
			if (codePoint >= 0x0800) {
				checkScalarValue(codePoint);
				return codePoint;
			} else {
				throw Error('Invalid continuation byte');
			}
		}

		// 4-byte sequence
		if ((byte1 & 0xF8) == 0xF0) {
			byte2 = readContinuationByte();
			byte3 = readContinuationByte();
			byte4 = readContinuationByte();
			codePoint = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0C) |
				(byte3 << 0x06) | byte4;
			if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
				return codePoint;
			}
		}

		throw Error('Invalid UTF-8 detected');
	}

	var byteArray;
	var byteCount;
	var byteIndex;
	function utf8decode(byteString) {
		byteArray = ucs2decode(byteString);
		byteCount = byteArray.length;
		byteIndex = 0;
		var codePoints = [];
		var tmp;
		while ((tmp = decodeSymbol()) !== false) {
			codePoints.push(tmp);
		}
		return ucs2encode(codePoints);
	}

	/*--------------------------------------------------------------------------*/

	var utf8 = {
		'version': '2.1.2',
		'encode': utf8encode,
		'decode': utf8decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define(function() {
			return utf8;
		});
	}	else if (freeExports && !freeExports.nodeType) {
		if (freeModule) { // in Node.js or RingoJS v0.8.0+
			freeModule.exports = utf8;
		} else { // in Narwhal or RingoJS v0.7.0-
			var object = {};
			var hasOwnProperty = object.hasOwnProperty;
			for (var key in utf8) {
				hasOwnProperty.call(utf8, key) && (freeExports[key] = utf8[key]);
			}
		}
	} else { // in Rhino or a web browser
		root.utf8 = utf8;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJtYWluLnRzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9icm93c2VyX3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvY29udHJpYi9kYXRhL2JhdGNoX2RhdGFzZXQuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvY29udHJpYi9kYXRhL2RhdGFzZXQuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvY29udHJpYi9kYXRhL2RhdGFzZXRzL2Nzdl9kYXRhc2V0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2NvbnRyaWIvZGF0YS9kYXRhc2V0cy90ZXh0X2xpbmVfZGF0YXNldC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvZGF0YXNvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc291cmNlcy9maWxlX2RhdGFfc291cmNlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2NvbnRyaWIvZGF0YS9zb3VyY2VzL3VybF9kYXRhX3NvdXJjZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc3RhdGlzdGljcy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc3RyZWFtcy9ieXRlX3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc3RyZWFtcy9kYXRhX3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc3RyZWFtcy9maWxlcmVhZGVyX3N0cmVhbS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvc3RyZWFtcy9zdHJpbmdfc3RyZWFtLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2NvbnRyaWIvZGF0YS9zdHJlYW1zL3VybF9zdHJlYW0uanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvY29udHJpYi9kYXRhL3V0aWwvZ3Jvd2luZ19yaW5nX2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2RhdGEvdXRpbC9yaW5nX2J1ZmZlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9jb250cmliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2RhdGEvY2hlY2twb2ludF9sb2FkZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZGF0YS9kYXRhc2V0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2RhdGEvaW5wdXRfcHJvdmlkZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZGF0YS94aHItZGF0YXNldC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9kZXZpY2VfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9kb2MuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZW5naW5lLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2Vudmlyb25tZW50LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dsb2JhbHMuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhZGllbnRzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL2FjdGl2YXRpb25fZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL2Nvc3RfZnVuY3Rpb25zLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL2dyYXBoLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL2dyYXBoX3J1bm5lci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9ncmFwaF91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL2luaXRpYWxpemVycy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcGVyYXRpb25fZW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL29wcy9hcmdtYXguanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvb3BzL2FyZ21heGVxdWFscy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvY29uY2F0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL29wcy9jb252b2x1dGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvZGl2aWRlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvZWxlbWVudF93aXNlX2Nvc3QuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvb3BzL2V4cC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvbGluZWFyX2NvbWJpbmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL29wcy9sb2cuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvb3BzL21hdG11bC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvbWF4X3Bvb2wuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvb3BzL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2dyYXBoL29wcy9vcC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvcmVkdWNlX3N1bS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvcmVzaGFwZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvc29mdG1heC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9vcHMvc3VidHJhY3QuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvcHJpb3JpdHlfcXVldWUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvc2Vzc2lvbi5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9ncmFwaC9zZXNzaW9uX3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvZ3JhcGgvdGVuc29yX2FycmF5X21hcC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL2JhY2tlbmRfY3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvYmFja2VuZF93ZWJnbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2FyZ21pbm1heF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9hdmdfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9iYXRjaG5vcm1fZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvYmluYXJ5b3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvY2xpcF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9jb25jYXRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvY29udl9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9jb252X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2NvbnZfZ3B1X2RlcHRod2lzZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2Zyb21fcGl4ZWxzX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2dhdGhlcl9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9ncGdwdV9jb250ZXh0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvZ3BncHVfbWF0aC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2dwZ3B1X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9sb2dpY2FsX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL2xybl9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9tYXhfcG9vbF9iYWNrcHJvcF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9tdWxtYXRfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvbXVsdGlub21pYWxfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvb25laG90X2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL3BhZF9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9wb29sX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL3JlZHVjZV9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9yZXNpemVfYmlsaW5lYXJfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvcmV2ZXJzZV9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9zaGFkZXJfY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC9zbGljZV9ncHUuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qva2VybmVscy93ZWJnbC90ZXhfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL3RleHR1cmVfbWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL3RpbGVfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvdHJhbnNwb3NlX2dwdS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9rZXJuZWxzL3dlYmdsL3VuYXJ5b3BfZ3B1LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L2tlcm5lbHMvd2ViZ2wvd2ViZ2xfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9tYXRoLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9hcnJheV9vcHMuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL2F4aXNfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvYmF0Y2hub3JtLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9iaW5hcnlfb3BzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9icm9hZGNhc3RfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvY29tcGFyZS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvY29uY2F0LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9jb25jYXRfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvY29udi5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvY29udl91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9pbWFnZV9vcHMuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL2xvZ2ljYWxfb3BzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9scm4uanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL2xzdG0uanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL21hdG11bC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvbm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHMvb3BlcmF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9vcHMuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL3Bvb2wuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL3JhbmQuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL3JlZHVjZV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9yZWR1Y3Rpb25fb3BzLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9yZXZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9zZWx1X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL3NsaWNlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9zbGljZV91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy9zb2Z0bWF4LmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wcy90cmFuc3Bvc2UuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3BzL3VuYXJ5X29wcy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHRpbWl6ZXJzL2FkYWdyYWRfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wdGltaXplcnMvYWRhbV9vcHRpbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3Qvb3B0aW1pemVycy9hZGFtYXhfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wdGltaXplcnMvbW9tZW50dW1fb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wdGltaXplcnMvb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wdGltaXplcnMvb3B0aW1pemVyX2NvbnN0cnVjdG9ycy5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9vcHRpbWl6ZXJzL3Jtc3Byb3Bfb3B0aW1pemVyLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L29wdGltaXplcnMvc2dkX29wdGltaXplci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC9wcm9maWxlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC90YXBlLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3RlbnNvci5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC90ZW5zb3JfdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC90ZXN0X3V0aWwuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvdHJhY2tpbmcuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvdHJhaW4uanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvdHlwZXMuanMiLCJub2RlX21vZHVsZXMvZGVlcGxlYXJuL2Rpc3QvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy9kZWVwbGVhcm4vZGlzdC92ZXJzaW9uLmpzIiwibm9kZV9tb2R1bGVzL2RlZXBsZWFybi9kaXN0L3dlaWdodHNfbG9hZGVyLmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vaW5kZXguanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIvYWxlYS5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL2xpYi90eWNoZWkuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yMTI4LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcjQwOTYuanMiLCJub2RlX21vZHVsZXMvc2VlZHJhbmRvbS9saWIveG9yc2hpZnQ3LmpzIiwibm9kZV9tb2R1bGVzL3NlZWRyYW5kb20vbGliL3hvcndvdy5qcyIsIm5vZGVfbW9kdWxlcy9zZWVkcmFuZG9tL3NlZWRyYW5kb20uanMiLCJub2RlX21vZHVsZXMvdXRmOC91dGY4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQ0EsaUJBNElBOztBQTVJQSw4QkFBZ0M7QUFLaEMsMERBQTBEO0FBQzFELCtFQUErRTtBQUMvRSwyQkFBMkI7QUFDM0IsT0FBTztBQUVQLCtEQUErRDtBQUMvRCxJQUFNLGFBQWEsR0FBRyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsTUFBTSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsQ0FBQTtBQUU3RixJQUFNLE1BQU0sR0FBRyxJQUFJLEVBQUUsQ0FBQyxnQkFBZ0IsQ0FBQyxhQUFhLENBQUMsQ0FBQztBQUN0RCxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQUEsSUFBSTtJQUNoQyxtQkFBbUI7SUFDbkIsSUFBTSxHQUFHLEdBQUcsSUFBSSxjQUFjLEVBQUUsQ0FBQztJQUNqQyxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxzQkFBc0IsQ0FBQyxDQUFDO0lBQ3hDLEdBQUcsQ0FBQyxNQUFNLEdBQUc7Ozs7O29CQUNMLElBQUksR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxZQUFZLENBQWUsQ0FBQztvQkFFeEQsT0FBTyxDQUFDLEdBQUcsQ0FBQyx1QkFBcUIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLE1BQUcsQ0FBQyxDQUFDO29CQUVwRCxVQUFVLEdBQUcsQ0FBQyxDQUFDO3dDQUNWLENBQUM7Ozs7O29DQUNGLFFBQVEsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDO3dDQUN2QixJQUFNLENBQUMsR0FBRyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQzt3Q0FDdEMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7d0NBQ3RCLCtDQUErQztvQ0FDakQsQ0FBQyxDQUFDLENBQUM7b0NBQ29CLEtBQUEsQ0FBQSxLQUFBLElBQUksQ0FBQSxDQUFDLEtBQUssQ0FBQTtvQ0FBQyxxQkFBTSxRQUFRLENBQUMsR0FBRyxFQUFFLEVBQUE7O29DQUFoRCxjQUFjLEdBQUcsY0FBVyxTQUFvQixFQUFDO29DQUN2RCxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUM7b0NBQ25CLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBUSxDQUFDLDBCQUFxQixjQUFjLE1BQUcsQ0FBQyxDQUFDO29DQUd2RCxLQUFLLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztvQ0FDN0IsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLGNBQWMsQ0FBQyxDQUFDLENBQUM7d0NBQzdCLFVBQVUsRUFBRSxDQUFDO29DQUNmLENBQUM7b0NBRUQsa0JBQWtCO29DQUNsQixFQUFFLENBQUMsSUFBSSxDQUFDO3dDQUNOLElBQU0sTUFBTSxHQUNSLGFBQWEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRSxhQUFhLENBQUMsS0FBSyxDQUFDLEVBQUUsYUFBYSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUM7d0NBQ3BHLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO29DQUNwQyxDQUFDLENBQUMsQ0FBQzs7Ozs7b0JBckJJLENBQUMsR0FBRyxDQUFDOzs7eUJBQUUsQ0FBQSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUE7a0RBQTdCLENBQUM7Ozs7O29CQUE4QixDQUFDLEVBQUUsQ0FBQTs7O29CQXlCckMsUUFBUSxHQUFHLFVBQVUsR0FBRyxHQUFHLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUM7b0JBQ3ZELFFBQVEsQ0FBQyxjQUFjLENBQUMsVUFBVSxDQUFDLENBQUMsU0FBUyxHQUFNLFFBQVEsTUFBRyxDQUFDOzs7O1NBQ2hFLENBQUM7SUFDRixHQUFHLENBQUMsT0FBTyxHQUFHLFVBQUMsR0FBRyxJQUFLLE9BQUEsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsRUFBbEIsQ0FBa0IsQ0FBQztJQUMxQyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7SUFFWCxPQUFPLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFBO0FBQ3ZCLENBQUMsQ0FBQyxDQUFDO0FBT0g7Ozs7R0FJRztBQUNILGVBQ0ksQ0FBYyxFQUFFLElBQW9DO0lBQ3RELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBZ0IsQ0FBQztJQUMxRCxJQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsdUJBQXVCLENBQWdCLENBQUM7SUFDNUQsSUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLHVCQUF1QixDQUFnQixDQUFDO0lBQzVELElBQU0sTUFBTSxHQUFHLElBQUksQ0FBQyx5QkFBeUIsQ0FBZ0IsQ0FBQztJQUU5RCxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQWdCLENBQUM7SUFDM0QsSUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDLHNCQUFzQixDQUFnQixDQUFDO0lBQzdELElBQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxzQkFBc0IsQ0FBZ0IsQ0FBQztJQUM3RCxJQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsd0JBQXdCLENBQWdCLENBQUM7SUFDL0Qsa0VBQWtFO0lBQ2xFLGlFQUFpRTtJQUNqRSxJQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUMsRUFBRSxFQUFDLEVBQUUsRUFBQyxDQUFDLENBQUMsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFDLE9BQU8sQ0FBZ0IsQ0FBQztJQUM5RSxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBaUIsQ0FBQztJQUN4RCxJQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBZ0IsQ0FBQztJQUVyRSxJQUFNLEtBQUssR0FBRyxFQUFFLENBQUMsTUFBTSxDQUFDLFVBQVUsRUFBRSxNQUFNLEVBQUUsQ0FBQyxFQUFDLE9BQU8sQ0FBZ0IsQ0FBQztJQUN0RSxJQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLElBQUksRUFBaUIsQ0FBQztJQUN4RCxJQUFNLFVBQVUsR0FBRyxFQUFFLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLE9BQU8sQ0FBZ0IsQ0FBQztJQUdyRSxJQUFNLE9BQU8sR0FBRyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBZ0IsQ0FBQztJQUVyRyxJQUFNLE9BQU8sR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBZ0IsQ0FBQztJQUNsRyxJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsT0FBTyxFQUFpQixDQUFDO0lBQ2hELE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFBO0lBRXpCLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLENBQUM7QUFDekIsQ0FBQztBQTdCRCxzQkE2QkM7QUFFRCxxQkFBcUIsS0FBa0I7SUFDckMsSUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLElBQU0sTUFBTSxHQUFHLEVBQUUsQ0FBQztJQUNsQixJQUFNLE1BQU0sR0FBRyxRQUFRLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ2hELE1BQU0sQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO0lBQ3JCLE1BQU0sQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLElBQU0sR0FBRyxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDcEMsSUFBTSxZQUFZLEdBQUcsS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQ3RDLElBQU0sU0FBUyxHQUFHLEdBQUcsQ0FBQyxlQUFlLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBRSxDQUFDLEVBQUUsQ0FBQyxJQUFFLENBQUMsRUFBRSxDQUFDO1FBQzNELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO1FBQ2xELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLENBQUMsR0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLENBQUMsQ0FBQztRQUNwRCxJQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxDQUFDLEdBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7UUFFcEQsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsT0FBTyxDQUFDO1FBQ2hDLFNBQVMsQ0FBQyxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLE9BQU8sQ0FBQztRQUNoQyxTQUFTLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxPQUFPLENBQUM7UUFDaEMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDO0lBQzlCLENBQUM7SUFDRCxHQUFHLENBQUMsWUFBWSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDbEMsTUFBTSxDQUFDLE1BQU0sQ0FBQztBQUNoQixDQUFDO0FBRUQsdUJBQ0ksS0FBa0IsRUFBRSxLQUFhLEVBQUUsY0FBc0I7SUFDM0QsSUFBTSxJQUFJLEdBQUcsUUFBUSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUMzQyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3JDLElBQU0sTUFBTSxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDN0MsTUFBTSxDQUFDLFNBQVMsR0FBRyxhQUFXLEtBQU8sQ0FBQztJQUN0QyxJQUFJLENBQUMsV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3pCLElBQU0sU0FBUyxHQUFHLFFBQVEsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDaEQsU0FBUyxDQUFDLFNBQVMsR0FBRyxnQkFBYyxjQUFnQixDQUFDO0lBQ3JELElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLENBQUM7SUFFNUIsRUFBRSxDQUFDLENBQUMsS0FBSyxLQUFLLGNBQWMsQ0FBQyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsQ0FBQztJQUVELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdCLE1BQU0sQ0FBQyxJQUFJLENBQUM7QUFDZCxDQUFDOzs7QUM1SUQ7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25LQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwV0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbElBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdDBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN09BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDck9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc31yZXR1cm4gZX0pKCkiLCJcbmltcG9ydCAqIGFzIGRsIGZyb20gJ2RlZXBsZWFybic7XG5cbmltcG9ydCB7TkRBcnJheX0gZnJvbSAnZGVlcGxlYXJuJztcbmltcG9ydCB7VGVuc29yZmxvd0xvYWRlcn0gZnJvbSAnZGVlcGxlYXJuLXRlbnNvcmZsb3cnO1xuXG4vLyBjb25zdCB0ZW5zb3JmbG93UmVhZGVyID0gbmV3IFRlbnNvcmZsb3dMb2FkZXIoTkRBcnJheSk7XG4vLyB0ZW5zb3JmbG93UmVhZGVyLmxvYWRSZW1vdGVGaWxlcygndGZfbW9kZWwvbW9kZWwuY2twdC0yMDAnKS50aGVuKCh2YXJzKSA9PiB7XG4vLyAgICAgY29uc29sZS5sb2coJ0RvbmUnKTtcbi8vIH0pOyBcblxuLy8gbWFuaWZlc3QuanNvbiBsaXZlcyBpbiB0aGUgc2FtZSBkaXJlY3RvcnkgYXMgdGhlIG1uaXN0IGRlbW8uXG5jb25zdCBsYWJlbF9zdHJpbmdzID0gWydiZWQnLCAnY2hhaXInLCAnbGFtcCcsICdzaGVsZicsICdzb2ZhJywgJ3N0b29sJywgJ3RhYmxlJywgJ3dhcmRyb2JlJ11cblxuY29uc3QgcmVhZGVyID0gbmV3IGRsLkNoZWNrcG9pbnRMb2FkZXIoJ2NvbG9yX21vZGVsJyk7XG5yZWFkZXIuZ2V0QWxsVmFyaWFibGVzKCkudGhlbih2YXJzID0+IHtcbiAgLy8gR2V0IHNhbXBsZSBkYXRhLlxuICBjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgeGhyLm9wZW4oJ0dFVCcsICd0ZXN0X2NvbG9yX2RhdGEuanNvbicpO1xuICB4aHIub25sb2FkID0gYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpIGFzIFNhbXBsZURhdGE7XG5cbiAgICBjb25zb2xlLmxvZyhgRXZhbHVhdGlvbiBzZXQ6IG49JHtkYXRhLmltYWdlcy5sZW5ndGh9LmApO1xuXG4gICAgbGV0IG51bUNvcnJlY3QgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5pbWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZmVycmVkID0gZGwudGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHggPSBkbC50ZW5zb3IzZChkYXRhLmltYWdlc1tpXSk7XG4gICAgICAgIHJldHVybiBpbmZlcih4LCB2YXJzKTtcbiAgICAgICAgLy8gSW5mZXIgdGhyb3VnaCB0aGUgbW9kZWwgdG8gZ2V0IGEgcHJlZGljdGlvbi5cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJlZGljdGVkTGFiZWwgPSBNYXRoLnJvdW5kKGF3YWl0IGluZmVycmVkLnZhbCgpKTtcbiAgICAgIGluZmVycmVkLmRpc3Bvc2UoKTtcbiAgICAgIGNvbnNvbGUubG9nKGBJdGVtICR7aX0sIHByZWRpY3RlZCBsYWJlbCAke3ByZWRpY3RlZExhYmVsfS5gKTtcblxuICAgICAgLy8gQWdncmVnYXRlIGNvcnJlY3RuZXNzIHRvIHNob3cgYWNjdXJhY3kuXG4gICAgICBjb25zdCBsYWJlbCA9IGRhdGEubGFiZWxzW2ldO1xuICAgICAgaWYgKGxhYmVsID09PSBwcmVkaWN0ZWRMYWJlbCkge1xuICAgICAgICBudW1Db3JyZWN0Kys7XG4gICAgICB9XG5cbiAgICAgIC8vIFNob3cgdGhlIGltYWdlLlxuICAgICAgZGwudGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9XG4gICAgICAgICAgICByZW5kZXJSZXN1bHRzKGRsLnRlbnNvcjFkKGRhdGEuaW1hZ2VzW2ldKSwgbGFiZWxfc3RyaW5nc1tsYWJlbF0sIGxhYmVsX3N0cmluZ3NbcHJlZGljdGVkTGFiZWxdKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChyZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSBmaW5hbCBhY2N1cmFjeS5cbiAgICBjb25zdCBhY2N1cmFjeSA9IG51bUNvcnJlY3QgKiAxMDAgLyBkYXRhLmltYWdlcy5sZW5ndGg7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FjY3VyYWN5JykuaW5uZXJIVE1MID0gYCR7YWNjdXJhY3l9JWA7XG4gIH07XG4gIHhoci5vbmVycm9yID0gKGVycikgPT4gY29uc29sZS5lcnJvcihlcnIpO1xuICB4aHIuc2VuZCgpO1xuXG4gIGNvbnNvbGUubG9nKFwiTG9hZGVkXCIpXG59KTtcblxuZXhwb3J0IGludGVyZmFjZSBTYW1wbGVEYXRhIHtcbiAgaW1hZ2VzOiBudW1iZXJbXVtdO1xuICBsYWJlbHM6IG51bWJlcltdO1xufVxuXG4vKipcbiAqIEluZmVycyB0aHJvdWdoIGEgMy1sYXllciBmdWxseSBjb25uZWN0ZWQgTU5JU1QgbW9kZWwgdXNpbmcgdGhlIE1hdGggQVBJLlxuICogVGhpcyBpcyB0aGUgbG93ZXN0IGxldmVsIHVzZXItZmFjaW5nIEFQSSBpbiBkZWVwbGVhcm4uanMgZ2l2aW5nIHRoZSBtb3N0XG4gKiBjb250cm9sIHRvIHRoZSB1c2VyLiBNYXRoIGNvbW1hbmRzIGV4ZWN1dGUgaW1tZWRpYXRlbHksIGxpa2UgbnVtcHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZlcihcbiAgICB4OiBkbC5UZW5zb3IzRCwgdmFyczoge1t2YXJOYW1lOiBzdHJpbmddOiBkbC5UZW5zb3J9KTogZGwuU2NhbGFyIHtcbiAgY29uc3QgY29udjFCID0gdmFyc1snQ29udk5ldC9jb252MmQvYmlhcyddIGFzIGRsLlRlbnNvcjFEO1xuICBjb25zdCBjb252MVcgPSB2YXJzWydDb252TmV0L2NvbnYyZC9rZXJuZWwnXSBhcyBkbC5UZW5zb3I0RDtcbiAgY29uc3QgY29udjJCID0gdmFyc1snQ29udk5ldC9jb252MmRfMS9iaWFzJ10gYXMgZGwuVGVuc29yMUQ7XG4gIGNvbnN0IGNvbnYyVyA9IHZhcnNbJ0NvbnZOZXQvY29udjJkXzEva2VybmVsJ10gYXMgZGwuVGVuc29yNEQ7XG5cbiAgY29uc3QgaGlkZGVuMUIgPSB2YXJzWydDb252TmV0L2RlbnNlL2JpYXMnXSBhcyBkbC5UZW5zb3IxRDtcbiAgY29uc3QgaGlkZGVuMVcgPSB2YXJzWydDb252TmV0L2RlbnNlL2tlcm5lbCddIGFzIGRsLlRlbnNvcjJEO1xuICBjb25zdCBoaWRkZW4yQiA9IHZhcnNbJ0NvbnZOZXQvZGVuc2VfMS9iaWFzJ10gYXMgZGwuVGVuc29yMUQ7XG4gIGNvbnN0IGhpZGRlbjJXID0gdmFyc1snQ29udk5ldC9kZW5zZV8xL2tlcm5lbCddIGFzIGRsLlRlbnNvcjJEO1xuICAvLyBjb25zdCBzb2Z0bWF4VyA9IHZhcnNbJ3NvZnRtYXhfbGluZWFyL3dlaWdodHMnXSBhcyBkbC5UZW5zb3IyRDtcbiAgLy8gY29uc3Qgc29mdG1heEIgPSB2YXJzWydzb2Z0bWF4X2xpbmVhci9iaWFzZXMnXSBhcyBkbC5UZW5zb3IxRDtcbiAgY29uc3QgY29udjEgPSBkbC5jb252MmQoeC5hczREKC0xLDY0LDY0LDMpLCBjb252MVcsIDEsJ3ZhbGlkJykgYXMgZGwuVGVuc29yNEQ7XG4gIGNvbnN0IGNvbnYxX2IgPSBjb252MS5hZGQoY29udjFCKS5yZWx1KCkgYXMgZGwuVGVuc29yNEQ7XG4gIGNvbnN0IGNvbnYxX3Bvb2wgPSBkbC5tYXhQb29sKGNvbnYxX2IsIDIsIDIsICd2YWxpZCcpIGFzIGRsLlRlbnNvcjREO1xuXG4gIGNvbnN0IGNvbnYyID0gZGwuY29udjJkKGNvbnYxX3Bvb2wsIGNvbnYyVywgMSwndmFsaWQnKSBhcyBkbC5UZW5zb3I0RDtcbiAgY29uc3QgY29udjJfYiA9IGNvbnYyLmFkZChjb252MkIpLnJlbHUoKSBhcyBkbC5UZW5zb3I0RDtcbiAgY29uc3QgY29udjJfcG9vbCA9IGRsLm1heFBvb2woY29udjJfYiwgMiwgMiwgJ3ZhbGlkJykgYXMgZGwuVGVuc29yNEQ7XG5cblxuICBjb25zdCBoaWRkZW4xID0gY29udjJfcG9vbC5hczJEKC0xLCBoaWRkZW4xVy5zaGFwZVswXSkubWF0TXVsKGhpZGRlbjFXKS5hZGQoaGlkZGVuMUIpIGFzIGRsLlRlbnNvcjFEO1xuXG4gIGNvbnN0IGhpZGRlbjIgPSBoaWRkZW4xLmFzMkQoLTEsIGhpZGRlbjJXLnNoYXBlWzBdKS5tYXRNdWwoaGlkZGVuMlcpLmFkZChoaWRkZW4yQikgYXMgZGwuVGVuc29yMUQ7XG4gIGNvbnN0IGxvZ2l0cyA9IGhpZGRlbjIuc29mdG1heCgpIGFzIGRsLlRlbnNvcjFEO1xuICBjb25zb2xlLmxvZyhsb2dpdHMuc2hhcGUpXG5cbiAgcmV0dXJuIGxvZ2l0cy5hcmdNYXgoKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVySW1hZ2UoYXJyYXk6IGRsLlRlbnNvcjFEKSB7XG4gIGNvbnN0IHdpZHRoID0gNjQ7XG4gIGNvbnN0IGhlaWdodCA9IDY0O1xuICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG4gIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICBjb25zdCBmbG9hdDMyQXJyYXkgPSBhcnJheS5kYXRhU3luYygpO1xuICBjb25zdCBpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHdpZHRoLCBoZWlnaHQpO1xuICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBmbG9hdDMyQXJyYXkubGVuZ3RoOyBpKz0zLCBqKz00KSB7XG4gICAgY29uc3Qgcl92YWx1ZSA9IE1hdGgucm91bmQoZmxvYXQzMkFycmF5W2ldICogMjU1KTtcbiAgICBjb25zdCBnX3ZhbHVlID0gTWF0aC5yb3VuZChmbG9hdDMyQXJyYXlbaSsxXSAqIDI1NSk7XG4gICAgY29uc3QgYl92YWx1ZSA9IE1hdGgucm91bmQoZmxvYXQzMkFycmF5W2krMl0gKiAyNTUpO1xuXG4gICAgaW1hZ2VEYXRhLmRhdGFbaiArIDBdID0gcl92YWx1ZTtcbiAgICBpbWFnZURhdGEuZGF0YVtqICsgMV0gPSBnX3ZhbHVlO1xuICAgIGltYWdlRGF0YS5kYXRhW2ogKyAyXSA9IGJfdmFsdWU7XG4gICAgaW1hZ2VEYXRhLmRhdGFbaiArIDNdID0gMjU1O1xuICB9XG4gIGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuZnVuY3Rpb24gcmVuZGVyUmVzdWx0cyhcbiAgICBhcnJheTogZGwuVGVuc29yMUQsIGxhYmVsOiBzdHJpbmcsIHByZWRpY3RlZExhYmVsOiBzdHJpbmcpIHtcbiAgY29uc3Qgcm9vdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICByb290LmFwcGVuZENoaWxkKHJlbmRlckltYWdlKGFycmF5KSk7XG4gIGNvbnN0IGFjdHVhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBhY3R1YWwuaW5uZXJIVE1MID0gYEFjdHVhbDogJHtsYWJlbH1gO1xuICByb290LmFwcGVuZENoaWxkKGFjdHVhbCk7XG4gIGNvbnN0IHByZWRpY3RlZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwcmVkaWN0ZWQuaW5uZXJIVE1MID0gYFByZWRpY3RlZDogJHtwcmVkaWN0ZWRMYWJlbH1gO1xuICByb290LmFwcGVuZENoaWxkKHByZWRpY3RlZCk7XG5cbiAgaWYgKGxhYmVsICE9PSBwcmVkaWN0ZWRMYWJlbCkge1xuICAgIHJvb3QuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgfVxuXG4gIHJvb3QuY2xhc3NMaXN0LmFkZCgncmVzdWx0Jyk7XG4gIHJldHVybiByb290O1xufVxuIiwiIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG52YXIgQnJvd3NlclV0aWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJyb3dzZXJVdGlsKCkge1xuICAgIH1cbiAgICBCcm93c2VyVXRpbC5uZXh0RnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJlc29sdmUoKTsgfSk7IH0pO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdQZXJmb3JtYW5jZScsIHN1YmhlYWRpbmc6ICdUaW1pbmcnIH0pXG4gICAgXSwgQnJvd3NlclV0aWwsIFwibmV4dEZyYW1lXCIsIG51bGwpO1xuICAgIHJldHVybiBCcm93c2VyVXRpbDtcbn0oKSk7XG5leHBvcnRzLkJyb3dzZXJVdGlsID0gQnJvd3NlclV0aWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uLy4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgQmF0Y2hEYXRhc2V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaERhdGFzZXQoYmFzZSwgYmF0Y2hTaXplLCBzbWFsbExhc3RCYXRjaCkge1xuICAgICAgICBpZiAoc21hbGxMYXN0QmF0Y2ggPT09IHZvaWQgMCkgeyBzbWFsbExhc3RCYXRjaCA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIHRoaXMuc21hbGxMYXN0QmF0Y2ggPSBzbWFsbExhc3RCYXRjaDtcbiAgICB9XG4gICAgQmF0Y2hEYXRhc2V0LnByb3RvdHlwZS5nZXRTdHJlYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBiYXRjaGVzQXNBcnJheXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgYmF0Y2hlc0FzQXJyYXlzID0gdGhpcy5iYXNlLmdldFN0cmVhbSgpLmJhdGNoKHRoaXMuYmF0Y2hTaXplLCB0aGlzLnNtYWxsTGFzdEJhdGNoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGJhdGNoZXNBc0FycmF5cy5tYXAobWFrZURhdGFzZXRCYXRjaCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJhdGNoRGF0YXNldDtcbn0oKSk7XG5leHBvcnRzLkJhdGNoRGF0YXNldCA9IEJhdGNoRGF0YXNldDtcbmZ1bmN0aW9uIG1ha2VEYXRhc2V0QmF0Y2goZWxlbWVudHMpIHtcbiAgICB2YXIgcm90YXRlZCA9IHt9O1xuICAgIHZhciBmaXJzdEVsZW1lbnQgPSBlbGVtZW50c1swXTtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZpcnN0RWxlbWVudCk7XG4gICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgcm90YXRlZFtrZXldID0gW107XG4gICAgfSk7XG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZVtrZXldO1xuICAgICAgICAgICAgcm90YXRlZFtrZXldLnB1c2godmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAodmFyIF9pID0gMCwgZWxlbWVudHNfMSA9IGVsZW1lbnRzOyBfaSA8IGVsZW1lbnRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBlID0gZWxlbWVudHNfMVtfaV07XG4gICAgICAgIF9sb29wXzEoZSk7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBpZiAocm90YXRlZFtrZXldLmxlbmd0aCAhPT0gZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXRjaGluZyBmYWlsZWQgdG8gZ2V0IGEgJ1wiICsga2V5ICsgXCInIHZhbHVlIGZvciBlYWNoIGVsZW1lbnQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm90YXRlZFtrZXldWzBdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByb3RhdGVkW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGJhdGNoQ29uY2F0KHJvdGF0ZWRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKGdsb2JhbHNfMS5kaXNwb3NlKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gYmF0Y2hDb25jYXQoYXJyYXlzKSB7XG4gICAgdmFyIGVsZW1lbnRTaGFwZSA9IHNoYXBlQW5kVmFsdWVzKGFycmF5c1swXSlbMF07XG4gICAgdmFyIGJhdGNoU2hhcGUgPSBbYXJyYXlzLmxlbmd0aF0uY29uY2F0KGVsZW1lbnRTaGFwZSk7XG4gICAgdmFyIHJlc3VsdFZhbHMgPSBuZXcgRmxvYXQzMkFycmF5KGJhdGNoU2hhcGUucmVkdWNlKGZ1bmN0aW9uICh4LCB5KSB7IHJldHVybiB4ICogeTsgfSkpO1xuICAgIHZhciBvZmZzZXQgPSAwO1xuICAgIGZvciAodmFyIF9pID0gMCwgYXJyYXlzXzEgPSBhcnJheXM7IF9pIDwgYXJyYXlzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBhID0gYXJyYXlzXzFbX2ldO1xuICAgICAgICB2YXIgX2EgPSBzaGFwZUFuZFZhbHVlcyhhKSwgYVNoYXBlID0gX2FbMF0sIGFWYWxzID0gX2FbMV07XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhU2hhcGUsIGVsZW1lbnRTaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudHMgbXVzdCBoYXZlIHRoZSBzYW1lIHNoYXBlIHRvIGJlIGJhdGNoZWQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRWYWxzLnNldChhVmFscywgb2Zmc2V0KTtcbiAgICAgICAgb2Zmc2V0ICs9IGFWYWxzLmxlbmd0aDtcbiAgICB9XG4gICAgdmFyIHJlc3VsdCA9IHRlbnNvcl8xLlRlbnNvci5tYWtlKGJhdGNoU2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWxzIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBzaGFwZUFuZFZhbHVlcyhhcnJheSkge1xuICAgIGlmIChhcnJheSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICByZXR1cm4gW2FycmF5LnNoYXBlLCBhcnJheS5kYXRhU3luYygpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIFtbYXJyYXkubGVuZ3RoXSwgYXJyYXldO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtbXSwgW2FycmF5XV07XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNlZWRyYW5kb20gPSByZXF1aXJlKFwic2VlZHJhbmRvbVwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ2xvYmFsc1wiKTtcbnZhciBiYXRjaF9kYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9iYXRjaF9kYXRhc2V0XCIpO1xudmFyIHN0YXRpc3RpY3NfMSA9IHJlcXVpcmUoXCIuL3N0YXRpc3RpY3NcIik7XG52YXIgZGF0YV9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmVhbXMvZGF0YV9zdHJlYW1cIik7XG52YXIgZGF0YV9zdHJlYW1fMiA9IHJlcXVpcmUoXCIuL3N0cmVhbXMvZGF0YV9zdHJlYW1cIik7XG52YXIgZGF0YV9zdHJlYW1fMyA9IHJlcXVpcmUoXCIuL3N0cmVhbXMvZGF0YV9zdHJlYW1cIik7XG52YXIgRGF0YXNldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YXNldCgpIHtcbiAgICB9XG4gICAgRGF0YXNldC5wcm90b3R5cGUuY29tcHV0ZVN0YXRpc3RpY3MgPSBmdW5jdGlvbiAoc2FtcGxlU2l6ZSwgc2h1ZmZsZVdpbmRvd1NpemUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgc3RhdGlzdGljc18xLmNvbXB1dGVEYXRhc2V0U3RhdGlzdGljcyh0aGlzLCBzYW1wbGVTaXplLCBzaHVmZmxlV2luZG93U2l6ZSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YXNldC5wcm90b3R5cGUuZmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlcmVyKSB7XG4gICAgICAgIHZhciBiYXNlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGRhdGFzZXRGcm9tU3RyZWFtRm4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJhc2UuZ2V0U3RyZWFtKCkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7IHJldHVybiBmaWx0ZXJlcih4KTsgfSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGF0YXNldEZyb21TdHJlYW1GbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gYmFzZS5nZXRTdHJlYW0oKS5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zZm9ybSh4KTsgfSk7IH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLmJhdGNoID0gZnVuY3Rpb24gKGJhdGNoU2l6ZSwgc21hbGxMYXN0QmF0Y2gpIHtcbiAgICAgICAgaWYgKHNtYWxsTGFzdEJhdGNoID09PSB2b2lkIDApIHsgc21hbGxMYXN0QmF0Y2ggPSB0cnVlOyB9XG4gICAgICAgIHJldHVybiBuZXcgYmF0Y2hfZGF0YXNldF8xLkJhdGNoRGF0YXNldCh0aGlzLCBiYXRjaFNpemUsIHNtYWxsTGFzdEJhdGNoKTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLmNvbmNhdGVuYXRlID0gZnVuY3Rpb24gKGRhdGFzZXQpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGF0YXNldEZyb21TdHJlYW1GbihmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlLmdldFN0cmVhbSgpLmNvbmNhdGVuYXRlKGRhdGFzZXQuZ2V0U3RyZWFtKCkpOyB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLnJlcGVhdCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICB2YXIgYmFzZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBkYXRhc2V0RnJvbVN0cmVhbUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW1TdHJlYW0gPSBkYXRhX3N0cmVhbV8xLnN0cmVhbUZyb21GdW5jdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiAoeyB2YWx1ZTogYmFzZS5nZXRTdHJlYW0oKSwgZG9uZTogZmFsc2UgfSk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFfc3RyZWFtXzIuc3RyZWFtRnJvbUNvbmNhdGVuYXRlZChzdHJlYW1TdHJlYW0udGFrZShjb3VudCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGF0YXNldEZyb21TdHJlYW1GbihmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlLmdldFN0cmVhbSgpLnRha2UoY291bnQpOyB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgdmFyIGJhc2UgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZGF0YXNldEZyb21TdHJlYW1GbihmdW5jdGlvbiAoKSB7IHJldHVybiBiYXNlLmdldFN0cmVhbSgpLnNraXAoY291bnQpOyB9KTtcbiAgICB9O1xuICAgIERhdGFzZXQucHJvdG90eXBlLnNodWZmbGUgPSBmdW5jdGlvbiAoYnVmZmVyU2l6ZSwgc2VlZCwgcmVzaHVmZmxlRWFjaEl0ZXJhdGlvbikge1xuICAgICAgICBpZiAocmVzaHVmZmxlRWFjaEl0ZXJhdGlvbiA9PT0gdm9pZCAwKSB7IHJlc2h1ZmZsZUVhY2hJdGVyYXRpb24gPSB0cnVlOyB9XG4gICAgICAgIHZhciBiYXNlID0gdGhpcztcbiAgICAgICAgdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oc2VlZCk7XG4gICAgICAgIHJldHVybiBkYXRhc2V0RnJvbVN0cmVhbUZuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzZWVkMiA9IHJhbmRvbS5pbnQzMigpO1xuICAgICAgICAgICAgaWYgKHJlc2h1ZmZsZUVhY2hJdGVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzZWVkMiArPSByYW5kb20uaW50MzIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiYXNlLmdldFN0cmVhbSgpLnNodWZmbGUoYnVmZmVyU2l6ZSwgc2VlZDIudG9TdHJpbmcoKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YXNldC5wcm90b3R5cGUucHJlZmV0Y2ggPSBmdW5jdGlvbiAoYnVmZmVyU2l6ZSkge1xuICAgICAgICB2YXIgYmFzZSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBkYXRhc2V0RnJvbVN0cmVhbUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJhc2UuZ2V0U3RyZWFtKCkucHJlZmV0Y2goYnVmZmVyU2l6ZSk7IH0pO1xuICAgIH07XG4gICAgRGF0YXNldC5wcm90b3R5cGUuY29sbGVjdEFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5nZXRTdHJlYW0oKS5jb2xsZWN0UmVtYWluaW5nKCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YXNldC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZ2V0U3RyZWFtKCkuZm9yRWFjaChmKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRGF0YXNldDtcbn0oKSk7XG5leHBvcnRzLkRhdGFzZXQgPSBEYXRhc2V0O1xuZnVuY3Rpb24gZGF0YXNldEZyb21TdHJlYW1GbihnZXRTdHJlYW1Gbikge1xuICAgIHJldHVybiBuZXcgKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuZ2V0U3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFN0cmVhbUZuKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oRGF0YXNldCkpKCk7XG59XG5leHBvcnRzLmRhdGFzZXRGcm9tU3RyZWFtRm4gPSBkYXRhc2V0RnJvbVN0cmVhbUZuO1xuZnVuY3Rpb24gZGF0YXNldEZyb21FbGVtZW50cyhpdGVtcykge1xuICAgIHJldHVybiBkYXRhc2V0RnJvbVN0cmVhbUZuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGRhdGFfc3RyZWFtXzMuc3RyZWFtRnJvbUl0ZW1zKGl0ZW1zKTsgfSk7XG59XG5leHBvcnRzLmRhdGFzZXRGcm9tRWxlbWVudHMgPSBkYXRhc2V0RnJvbUVsZW1lbnRzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFzZXRfMSA9IHJlcXVpcmUoXCIuLi9kYXRhc2V0XCIpO1xudmFyIHRleHRfbGluZV9kYXRhc2V0XzEgPSByZXF1aXJlKFwiLi90ZXh0X2xpbmVfZGF0YXNldFwiKTtcbnZhciBDc3ZIZWFkZXJDb25maWc7XG4oZnVuY3Rpb24gKENzdkhlYWRlckNvbmZpZykge1xuICAgIENzdkhlYWRlckNvbmZpZ1tDc3ZIZWFkZXJDb25maWdbXCJSRUFEX0ZJUlNUX0xJTkVcIl0gPSAwXSA9IFwiUkVBRF9GSVJTVF9MSU5FXCI7XG4gICAgQ3N2SGVhZGVyQ29uZmlnW0NzdkhlYWRlckNvbmZpZ1tcIk5VTUJFUkVEXCJdID0gMV0gPSBcIk5VTUJFUkVEXCI7XG59KShDc3ZIZWFkZXJDb25maWcgPSBleHBvcnRzLkNzdkhlYWRlckNvbmZpZyB8fCAoZXhwb3J0cy5Dc3ZIZWFkZXJDb25maWcgPSB7fSkpO1xudmFyIENTVkRhdGFzZXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDU1ZEYXRhc2V0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENTVkRhdGFzZXQoaW5wdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgX3RoaXMuaGFzSGVhZGVyTGluZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5iYXNlID0gbmV3IHRleHRfbGluZV9kYXRhc2V0XzEuVGV4dExpbmVEYXRhc2V0KGlucHV0LCBDU1ZEYXRhc2V0LnRleHRDb2x1bW5OYW1lKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ1NWRGF0YXNldC5wcm90b3R5cGUsIFwiY3N2Q29sdW1uTmFtZXNcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jc3ZDb2x1bW5OYW1lcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQ1NWRGF0YXNldC5wcm90b3R5cGUuc2V0Q3N2Q29sdW1uTmFtZXMgPSBmdW5jdGlvbiAoY3N2Q29sdW1uTmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0cmVhbSwgZmlyc3RFbGVtZW50LCBmaXJzdExpbmUsIHN0cmVhbSwgZmlyc3RFbGVtZW50LCBmaXJzdExpbmU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjc3ZDb2x1bW5OYW1lcyA9PSBudWxsIHx8IGNzdkNvbHVtbk5hbWVzID09PSBDc3ZIZWFkZXJDb25maWcuTlVNQkVSRUQpKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gdGhpcy5iYXNlLmdldFN0cmVhbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBzdHJlYW0ubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpcnN0RWxlbWVudC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBkYXRhIHdhcyBmb3VuZCBmb3IgQ1NWIHBhcnNpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmUgPSBmaXJzdEVsZW1lbnQudmFsdWVbQ1NWRGF0YXNldC50ZXh0Q29sdW1uTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jc3ZDb2x1bW5OYW1lcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQXJyYXkuZnJvbShmaXJzdExpbmUuc3BsaXQoJywnKS5rZXlzKCkpLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC50b1N0cmluZygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgNV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNzdkNvbHVtbk5hbWVzID09PSBDc3ZIZWFkZXJDb25maWcuUkVBRF9GSVJTVF9MSU5FKSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IHRoaXMuYmFzZS5nZXRTdHJlYW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgc3RyZWFtLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0RWxlbWVudCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdEVsZW1lbnQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZGF0YSB3YXMgZm91bmQgZm9yIENTViBwYXJzaW5nLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmlyc3RMaW5lID0gZmlyc3RFbGVtZW50LnZhbHVlW0NTVkRhdGFzZXQudGV4dENvbHVtbk5hbWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3N2Q29sdW1uTmFtZXMgPSBmaXJzdExpbmUuc3BsaXQoJywnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzSGVhZGVyTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDVdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9jc3ZDb2x1bW5OYW1lcyA9IGNzdkNvbHVtbk5hbWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSA1O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ1NWRGF0YXNldC5jcmVhdGUgPSBmdW5jdGlvbiAoaW5wdXQsIGNzdkNvbHVtbk5hbWVzKSB7XG4gICAgICAgIGlmIChjc3ZDb2x1bW5OYW1lcyA9PT0gdm9pZCAwKSB7IGNzdkNvbHVtbk5hbWVzID0gQ3N2SGVhZGVyQ29uZmlnLk5VTUJFUkVEOyB9XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgQ1NWRGF0YXNldChpbnB1dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHJlc3VsdC5zZXRDc3ZDb2x1bW5OYW1lcyhjc3ZDb2x1bW5OYW1lcyldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ1NWRGF0YXNldC5wcm90b3R5cGUuZ2V0U3RyZWFtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgbGluZXMgPSB0aGlzLmJhc2UuZ2V0U3RyZWFtKCk7XG4gICAgICAgIGlmICh0aGlzLmhhc0hlYWRlckxpbmUpIHtcbiAgICAgICAgICAgIGxpbmVzID0gbGluZXMuc2tpcCgxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBfdGhpcy5tYWtlRGF0YXNldEVsZW1lbnQoeCk7IH0pO1xuICAgIH07XG4gICAgQ1NWRGF0YXNldC5wcm90b3R5cGUubWFrZURhdGFzZXRFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBlbGVtZW50W0NTVkRhdGFzZXQudGV4dENvbHVtbk5hbWVdO1xuICAgICAgICB2YXIgdmFsdWVzID0gbGluZS5zcGxpdCgnLCcpO1xuICAgICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fY3N2Q29sdW1uTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRbdGhpcy5fY3N2Q29sdW1uTmFtZXNbaV1dID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlQXNOdW0gPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZUFzTnVtKSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbdGhpcy5fY3N2Q29sdW1uTmFtZXNbaV1dID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbdGhpcy5fY3N2Q29sdW1uTmFtZXNbaV1dID0gdmFsdWVBc051bTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIENTVkRhdGFzZXQudGV4dENvbHVtbk5hbWUgPSAnbGluZSc7XG4gICAgcmV0dXJuIENTVkRhdGFzZXQ7XG59KGRhdGFzZXRfMS5EYXRhc2V0KSk7XG5leHBvcnRzLkNTVkRhdGFzZXQgPSBDU1ZEYXRhc2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi4vZGF0YXNldFwiKTtcbnZhciBUZXh0TGluZURhdGFzZXQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZXh0TGluZURhdGFzZXQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGV4dExpbmVEYXRhc2V0KGlucHV0LCBjb2x1bW5OYW1lKSB7XG4gICAgICAgIGlmIChjb2x1bW5OYW1lID09PSB2b2lkIDApIHsgY29sdW1uTmFtZSA9ICdsaW5lJzsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICBfdGhpcy5jb2x1bW5OYW1lID0gY29sdW1uTmFtZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBUZXh0TGluZURhdGFzZXQucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlYWRTdHJlYW0gPSB0aGlzLmlucHV0LmdldFN0cmVhbSgpO1xuICAgICAgICB2YXIgdXRmOFN0cmVhbSA9IHJlYWRTdHJlYW0uZGVjb2RlVVRGOCgpO1xuICAgICAgICB2YXIgbGluZVN0cmVhbSA9IHV0ZjhTdHJlYW0uc3BsaXQoJ1xcbicpO1xuICAgICAgICByZXR1cm4gbGluZVN0cmVhbS5tYXAoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX2EgPSB7fSwgX2FbX3RoaXMuY29sdW1uTmFtZV0gPSB4LCBfYSk7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFRleHRMaW5lRGF0YXNldDtcbn0oZGF0YXNldF8xLkRhdGFzZXQpKTtcbmV4cG9ydHMuVGV4dExpbmVEYXRhc2V0ID0gVGV4dExpbmVEYXRhc2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRGF0YVNvdXJjZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRGF0YVNvdXJjZSgpIHtcbiAgICB9XG4gICAgcmV0dXJuIERhdGFTb3VyY2U7XG59KCkpO1xuZXhwb3J0cy5EYXRhU291cmNlID0gRGF0YVNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL2RhdGFzb3VyY2VcIik7XG52YXIgZmlsZXJlYWRlcl9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuLi9zdHJlYW1zL2ZpbGVyZWFkZXJfc3RyZWFtXCIpO1xudmFyIEZpbGVEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsZURhdGFTb3VyY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRmlsZURhdGFTb3VyY2UoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmlsZURhdGFTb3VyY2UucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBmaWxlcmVhZGVyX3N0cmVhbV8xLkZpbGVSZWFkZXJTdHJlYW0odGhpcy5pbnB1dCwgdGhpcy5vcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBGaWxlRGF0YVNvdXJjZTtcbn0oZGF0YXNvdXJjZV8xLkRhdGFTb3VyY2UpKTtcbmV4cG9ydHMuRmlsZURhdGFTb3VyY2UgPSBGaWxlRGF0YVNvdXJjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGF0YXNvdXJjZV8xID0gcmVxdWlyZShcIi4uL2RhdGFzb3VyY2VcIik7XG52YXIgdXJsX3N0cmVhbV8xID0gcmVxdWlyZShcIi4uL3N0cmVhbXMvdXJsX3N0cmVhbVwiKTtcbnZhciBVUkxEYXRhU291cmNlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVVJMRGF0YVNvdXJjZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUkxEYXRhU291cmNlKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVSTERhdGFTb3VyY2UucHJvdG90eXBlLmdldFN0cmVhbSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB1cmxfc3RyZWFtXzEuVVJMU3RyZWFtKHRoaXMudXJsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIFVSTERhdGFTb3VyY2U7XG59KGRhdGFzb3VyY2VfMS5EYXRhU291cmNlKSk7XG5leHBvcnRzLlVSTERhdGFTb3VyY2UgPSBVUkxEYXRhU291cmNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi8uLi90ZW5zb3JcIik7XG5mdW5jdGlvbiBzY2FsZVRvMDEobWluLCBtYXgpIHtcbiAgICB2YXIgcmFuZ2UgPSBtYXggLSBtaW47XG4gICAgdmFyIG1pblRlbnNvciA9IHRlbnNvcl8xLlNjYWxhci5uZXcobWluKTtcbiAgICB2YXIgcmFuZ2VUZW5zb3IgPSB0ZW5zb3JfMS5TY2FsYXIubmV3KHJhbmdlKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCBzY2FsZSBhIHN0cmluZy4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSB2YWx1ZS5zdWIobWluVGVuc29yKS5kaXYocmFuZ2VUZW5zb3IpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcChmdW5jdGlvbiAodikgeyByZXR1cm4gKHYgLSBtaW4pIC8gcmFuZ2U7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSAtIG1pbikgLyByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnNjYWxlVG8wMSA9IHNjYWxlVG8wMTtcbmZ1bmN0aW9uIGNvbXB1dGVEYXRhc2V0U3RhdGlzdGljcyhkYXRhc2V0LCBzYW1wbGVTaXplLCBzaHVmZmxlV2luZG93U2l6ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhbXBsZURhdGFzZXQsIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlRGF0YXNldCA9IGRhdGFzZXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaHVmZmxlV2luZG93U2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVEYXRhc2V0ID0gc2FtcGxlRGF0YXNldC5zaHVmZmxlKHNodWZmbGVXaW5kb3dTaXplKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc2FtcGxlU2l6ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVEYXRhc2V0ID0gc2FtcGxlRGF0YXNldC50YWtlKHNhbXBsZVNpemUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHNhbXBsZURhdGFzZXQuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZE1pbiA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWNvcmRNYXggPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRNaW4gPSB2YWx1ZS5taW4oKS5kYXRhU3luYygpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZE1heCA9IHZhbHVlLm1heCgpLmRhdGFTeW5jKClbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkTWluID0gdmFsdWUucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1pbihhLCBiKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb3JkTWF4ID0gdmFsdWUucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBNYXRoLm1heChhLCBiKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghaXNOYU4odmFsdWUpICYmIGlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZE1pbiA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29yZE1heCA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNvbXB1dGUgc3RhdGlzdGljczogXCIgKyBrZXkgKyBcIiA9IFwiICsgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNvbHVtblN0YXRzID0gcmVzdWx0W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29sdW1uU3RhdHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtblN0YXRzID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW46IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4OiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY29sdW1uU3RhdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TdGF0cy5taW4gPSBNYXRoLm1pbihjb2x1bW5TdGF0cy5taW4sIHJlY29yZE1pbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW5TdGF0cy5tYXggPSBNYXRoLm1heChjb2x1bW5TdGF0cy5tYXgsIHJlY29yZE1heCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmNvbXB1dGVEYXRhc2V0U3RhdGlzdGljcyA9IGNvbXB1dGVEYXRhc2V0U3RhdGlzdGljcztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGY4ID0gcmVxdWlyZShcInV0ZjhcIik7XG52YXIgZGF0YV9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2RhdGFfc3RyZWFtXCIpO1xudmFyIHN0cmluZ19zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL3N0cmluZ19zdHJlYW1cIik7XG52YXIgQnl0ZVN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJ5dGVTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQnl0ZVN0cmVhbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBCeXRlU3RyZWFtLnByb3RvdHlwZS5kZWNvZGVVVEY4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IFV0ZjhTdHJlYW0odGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gQnl0ZVN0cmVhbTtcbn0oZGF0YV9zdHJlYW1fMS5EYXRhU3RyZWFtKSk7XG5leHBvcnRzLkJ5dGVTdHJlYW0gPSBCeXRlU3RyZWFtO1xudmFyIFV0ZjhTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVdGY4U3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFV0ZjhTdHJlYW0odXBzdHJlYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuaW1wbCA9IG5ldyBVdGY4U3RyZWFtSW1wbCh1cHN0cmVhbSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVXRmOFN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5pbXBsLm5leHQoKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVXRmOFN0cmVhbTtcbn0oc3RyaW5nX3N0cmVhbV8xLlN0cmluZ1N0cmVhbSkpO1xudmFyIFV0ZjhTdHJlYW1JbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVXRmOFN0cmVhbUltcGwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVXRmOFN0cmVhbUltcGwodXBzdHJlYW0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMucGFydGlhbCA9IG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICAgICAgX3RoaXMucGFydGlhbEJ5dGVzVmFsaWQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFV0ZjhTdHJlYW1JbXBsLnByb3RvdHlwZS5wdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmtSZXN1bHQsIGNodW5rLCBwYXJ0aWFsQnl0ZXNSZW1haW5pbmcsIG5leHRJbmRleCwgb2tVcFRvSW5kZXgsIHNwbGl0VXRmV2lkdGgsIGJ1bGssIHJlYXNzZW1ibGVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQsIHRoaXMudXBzdHJlYW0ubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtSZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnBhcnRpYWwubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaHVuayA9IG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gY2h1bmtSZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsQnl0ZXNSZW1haW5pbmcgPSB0aGlzLnBhcnRpYWwubGVuZ3RoIC0gdGhpcy5wYXJ0aWFsQnl0ZXNWYWxpZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IHBhcnRpYWxCeXRlc1JlbWFpbmluZztcbiAgICAgICAgICAgICAgICAgICAgICAgIG9rVXBUb0luZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRVdGZXaWR0aCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEluZGV4IDwgY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2tVcFRvSW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3BsaXRVdGZXaWR0aCA9IHV0ZldpZHRoKGNodW5rW25leHRJbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IG9rVXBUb0luZGV4ICsgc3BsaXRVdGZXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0SW5kZXggPT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9rVXBUb0luZGV4ID0gbmV4dEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnVsayA9IHV0ZjguZGVjb2RlKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgY2h1bmsuc2xpY2UocGFydGlhbEJ5dGVzUmVtYWluaW5nLCBva1VwVG9JbmRleCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJ0aWFsQnl0ZXNSZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsLnNldChjaHVuay5zbGljZSgwLCBwYXJ0aWFsQnl0ZXNSZW1haW5pbmcpLCB0aGlzLnBhcnRpYWxCeXRlc1ZhbGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzc2VtYmxlZCA9IHV0ZjguZGVjb2RlKFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkobnVsbCwgdGhpcy5wYXJ0aWFsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKHJlYXNzZW1ibGVkICsgYnVsayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFF1ZXVlLnB1c2goYnVsayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob2tVcFRvSW5kZXggPT09IGNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbCA9IG5ldyBVaW50OEFycmF5KFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRpYWxCeXRlc1ZhbGlkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbCA9IG5ldyBVaW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcihzcGxpdFV0ZldpZHRoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0aWFsLnNldChjaHVuay5zbGljZShva1VwVG9JbmRleCksIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydGlhbEJ5dGVzVmFsaWQgPSBjaHVuay5sZW5ndGggLSBva1VwVG9JbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFV0ZjhTdHJlYW1JbXBsO1xufShkYXRhX3N0cmVhbV8xLlF1ZXVlU3RyZWFtKSk7XG5mdW5jdGlvbiB1dGZXaWR0aChmaXJzdEJ5dGUpIHtcbiAgICBpZiAoZmlyc3RCeXRlID49IDI1Mikge1xuICAgICAgICByZXR1cm4gNjtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID49IDI0OCkge1xuICAgICAgICByZXR1cm4gNTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID49IDI0MCkge1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID49IDIyNCkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgZWxzZSBpZiAoZmlyc3RCeXRlID49IDE5Mikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWVkcmFuZG9tID0gcmVxdWlyZShcInNlZWRyYW5kb21cIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL2dsb2JhbHNcIik7XG52YXIgdXRpbF8xID0gcmVxdWlyZShcIi4uLy4uLy4uL3V0aWxcIik7XG52YXIgZ3Jvd2luZ19yaW5nX2J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvZ3Jvd2luZ19yaW5nX2J1ZmZlclwiKTtcbnZhciByaW5nX2J1ZmZlcl8xID0gcmVxdWlyZShcIi4uL3V0aWwvcmluZ19idWZmZXJcIik7XG5mdW5jdGlvbiBzdHJlYW1Gcm9tSXRlbXMoaXRlbXMpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5U3RyZWFtKGl0ZW1zKTtcbn1cbmV4cG9ydHMuc3RyZWFtRnJvbUl0ZW1zID0gc3RyZWFtRnJvbUl0ZW1zO1xuZnVuY3Rpb24gc3RyZWFtRnJvbUluY3JlbWVudGluZyhzdGFydCkge1xuICAgIHZhciBpID0gc3RhcnQ7XG4gICAgcmV0dXJuIHN0cmVhbUZyb21GdW5jdGlvbihmdW5jdGlvbiAoKSB7IHJldHVybiAoeyB2YWx1ZTogaSsrLCBkb25lOiBmYWxzZSB9KTsgfSk7XG59XG5leHBvcnRzLnN0cmVhbUZyb21JbmNyZW1lbnRpbmcgPSBzdHJlYW1Gcm9tSW5jcmVtZW50aW5nO1xuZnVuY3Rpb24gc3RyZWFtRnJvbUZ1bmN0aW9uKGZ1bmMpIHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uQ2FsbFN0cmVhbShmdW5jKTtcbn1cbmV4cG9ydHMuc3RyZWFtRnJvbUZ1bmN0aW9uID0gc3RyZWFtRnJvbUZ1bmN0aW9uO1xuZnVuY3Rpb24gc3RyZWFtRnJvbUNvbmNhdGVuYXRlZChiYXNlU3RyZWFtcykge1xuICAgIHJldHVybiBDaGFpbmVkU3RyZWFtLmNyZWF0ZShiYXNlU3RyZWFtcyk7XG59XG5leHBvcnRzLnN0cmVhbUZyb21Db25jYXRlbmF0ZWQgPSBzdHJlYW1Gcm9tQ29uY2F0ZW5hdGVkO1xuZnVuY3Rpb24gc3RyZWFtRnJvbUNvbmNhdGVuYXRlZEZ1bmN0aW9uKHN0cmVhbUZ1bmMsIGNvdW50KSB7XG4gICAgcmV0dXJuIHN0cmVhbUZyb21Db25jYXRlbmF0ZWQoc3RyZWFtRnJvbUZ1bmN0aW9uKHN0cmVhbUZ1bmMpLnRha2UoY291bnQpKTtcbn1cbmV4cG9ydHMuc3RyZWFtRnJvbUNvbmNhdGVuYXRlZEZ1bmN0aW9uID0gc3RyZWFtRnJvbUNvbmNhdGVuYXRlZEZ1bmN0aW9uO1xudmFyIERhdGFTdHJlYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERhdGFTdHJlYW0oKSB7XG4gICAgfVxuICAgIERhdGFTdHJlYW0ucHJvdG90eXBlLmNvbGxlY3RSZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQsIHg7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAyO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISF4LmRvbmUpIHJldHVybiBbMywgNF07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh4LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIsIHJlc3VsdF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGF0YVN0cmVhbS5wcm90b3R5cGUucmVzb2x2ZUZ1bGx5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghIXguZG9uZSkgcmV0dXJuIFszLCA0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB4ID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERhdGFTdHJlYW0ucHJvdG90eXBlLmZpbHRlciA9IGZ1bmN0aW9uIChwcmVkaWNhdGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGaWx0ZXJTdHJlYW0odGhpcywgcHJlZGljYXRlKTtcbiAgICB9O1xuICAgIERhdGFTdHJlYW0ucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXBTdHJlYW0odGhpcywgdHJhbnNmb3JtKTtcbiAgICB9O1xuICAgIERhdGFTdHJlYW0ucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLm1hcChmKS5yZXNvbHZlRnVsbHkoKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEYXRhU3RyZWFtLnByb3RvdHlwZS5iYXRjaCA9IGZ1bmN0aW9uIChiYXRjaFNpemUsIHNtYWxsTGFzdEJhdGNoKSB7XG4gICAgICAgIGlmIChzbWFsbExhc3RCYXRjaCA9PT0gdm9pZCAwKSB7IHNtYWxsTGFzdEJhdGNoID0gdHJ1ZTsgfVxuICAgICAgICByZXR1cm4gbmV3IEJhdGNoU3RyZWFtKHRoaXMsIGJhdGNoU2l6ZSwgc21hbGxMYXN0QmF0Y2gpO1xuICAgIH07XG4gICAgRGF0YVN0cmVhbS5wcm90b3R5cGUuY29uY2F0ZW5hdGUgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBDaGFpbmVkU3RyZWFtLmNyZWF0ZShzdHJlYW1Gcm9tSXRlbXMoW3RoaXMsIHN0cmVhbV0pKTtcbiAgICB9O1xuICAgIERhdGFTdHJlYW0ucHJvdG90eXBlLnRha2UgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgaWYgKGNvdW50IDwgMCB8fCBjb3VudCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRha2VTdHJlYW0odGhpcywgY291bnQpO1xuICAgIH07XG4gICAgRGF0YVN0cmVhbS5wcm90b3R5cGUuc2tpcCA9IGZ1bmN0aW9uIChjb3VudCkge1xuICAgICAgICBpZiAoY291bnQgPCAwIHx8IGNvdW50ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgU2tpcFN0cmVhbSh0aGlzLCBjb3VudCk7XG4gICAgfTtcbiAgICBEYXRhU3RyZWFtLnByb3RvdHlwZS5wcmVmZXRjaCA9IGZ1bmN0aW9uIChidWZmZXJTaXplKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJlZmV0Y2hTdHJlYW0odGhpcywgYnVmZmVyU2l6ZSk7XG4gICAgfTtcbiAgICBEYXRhU3RyZWFtLnByb3RvdHlwZS5zaHVmZmxlID0gZnVuY3Rpb24gKHdpbmRvd1NpemUsIHNlZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTaHVmZmxlU3RyZWFtKHRoaXMsIHdpbmRvd1NpemUsIHNlZWQpO1xuICAgIH07XG4gICAgcmV0dXJuIERhdGFTdHJlYW07XG59KCkpO1xuZXhwb3J0cy5EYXRhU3RyZWFtID0gRGF0YVN0cmVhbTtcbnZhciBBcnJheVN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFycmF5U3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFycmF5U3RyZWFtKGl0ZW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIF90aGlzLnRyYXYgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFycmF5U3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYXYgPj0gdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLml0ZW1zW3RoaXMudHJhdl07XG4gICAgICAgICAgICAgICAgdGhpcy50cmF2Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IHZhbHVlOiByZXN1bHQsIGRvbmU6IGZhbHNlIH1dO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFycmF5U3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG52YXIgRnVuY3Rpb25DYWxsU3RyZWFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVuY3Rpb25DYWxsU3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEZ1bmN0aW9uQ2FsbFN0cmVhbShuZXh0Rm4pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmV4dEZuID0gbmV4dEZuO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEZ1bmN0aW9uQ2FsbFN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5uZXh0Rm4oKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25DYWxsU3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG52YXIgU2tpcFN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNraXBTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2tpcFN0cmVhbSh1cHN0cmVhbSwgbWF4Q291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMubWF4Q291bnQgPSBtYXhDb3VudDtcbiAgICAgICAgX3RoaXMuY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNraXBTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBza2lwcGVkO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5jb3VudCsrIDwgdGhpcy5tYXhDb3VudCkpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMudXBzdHJlYW0ubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcHBlZCA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHNraXBwZWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsc18xLmRpc3Bvc2Uoc2tpcHBlZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgdGhpcy51cHN0cmVhbS5uZXh0KCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTa2lwU3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG52YXIgVGFrZVN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRha2VTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGFrZVN0cmVhbSh1cHN0cmVhbSwgbWF4Q291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMubWF4Q291bnQgPSBtYXhDb3VudDtcbiAgICAgICAgX3RoaXMuY291bnQgPSAwO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRha2VTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb3VudCsrID49IHRoaXMubWF4Q291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB7IHZhbHVlOiBudWxsLCBkb25lOiB0cnVlIH1dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMudXBzdHJlYW0ubmV4dCgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBUYWtlU3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG52YXIgUXVldWVTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhRdWV1ZVN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBRdWV1ZVN0cmVhbSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMub3V0cHV0UXVldWUgPSBuZXcgZ3Jvd2luZ19yaW5nX2J1ZmZlcl8xLkdyb3dpbmdSaW5nQnVmZmVyKCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUXVldWVTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMub3V0cHV0UXVldWUubGVuZ3RoKCkgPT09IDApKSByZXR1cm4gWzMsIDJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCB0aGlzLnB1bXAoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9hLnNlbnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDBdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IHJldHVybiBbMiwgeyB2YWx1ZTogdGhpcy5vdXRwdXRRdWV1ZS5zaGlmdCgpLCBkb25lOiBmYWxzZSB9XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUXVldWVTdHJlYW07XG59KERhdGFTdHJlYW0pKTtcbmV4cG9ydHMuUXVldWVTdHJlYW0gPSBRdWV1ZVN0cmVhbTtcbnZhciBCYXRjaFN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEJhdGNoU3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEJhdGNoU3RyZWFtKHVwc3RyZWFtLCBiYXRjaFNpemUsIGVuYWJsZVNtYWxsTGFzdEJhdGNoKSB7XG4gICAgICAgIGlmIChlbmFibGVTbWFsbExhc3RCYXRjaCA9PT0gdm9pZCAwKSB7IGVuYWJsZVNtYWxsTGFzdEJhdGNoID0gdHJ1ZTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cHN0cmVhbSA9IHVwc3RyZWFtO1xuICAgICAgICBfdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIF90aGlzLmVuYWJsZVNtYWxsTGFzdEJhdGNoID0gZW5hYmxlU21hbGxMYXN0QmF0Y2g7XG4gICAgICAgIF90aGlzLmN1cnJlbnRCYXRjaCA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEJhdGNoU3RyZWFtLnByb3RvdHlwZS5wdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLnVwc3RyZWFtLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlU21hbGxMYXN0QmF0Y2ggJiYgdGhpcy5jdXJyZW50QmF0Y2gubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFF1ZXVlLnB1c2godGhpcy5jdXJyZW50QmF0Y2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRCYXRjaCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEJhdGNoLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QmF0Y2gubGVuZ3RoID09PSB0aGlzLmJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0UXVldWUucHVzaCh0aGlzLmN1cnJlbnRCYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QmF0Y2ggPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEJhdGNoU3RyZWFtO1xufShRdWV1ZVN0cmVhbSkpO1xudmFyIEZpbHRlclN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZpbHRlclN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWx0ZXJTdHJlYW0odXBzdHJlYW0sIHByZWRpY2F0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cHN0cmVhbSA9IHVwc3RyZWFtO1xuICAgICAgICBfdGhpcy5wcmVkaWNhdGUgPSBwcmVkaWNhdGU7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRmlsdGVyU3RyZWFtLnByb3RvdHlwZS5wdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgaXRlbTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0LCB0aGlzLnVwc3RyZWFtLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCBmYWxzZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcmVkaWNhdGUoaXRlbS52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm91dHB1dFF1ZXVlLnB1c2goaXRlbS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnbG9iYWxzXzEuZGlzcG9zZShpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEZpbHRlclN0cmVhbTtcbn0oUXVldWVTdHJlYW0pKTtcbnZhciBNYXBTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXBTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWFwU3RyZWFtKHVwc3RyZWFtLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hcFN0cmVhbS5wcm90b3R5cGUucHVtcCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0sIGlucHV0VGVuc29ycywgbWFwcGVkLCBvdXRwdXRUZW5zb3JzLCBfaSwgaW5wdXRUZW5zb3JzXzEsIHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy51cHN0cmVhbS5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRUZW5zb3JzID0gdXRpbF8xLmV4dHJhY3RUZW5zb3JzRnJvbUFueShpdGVtLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcHBlZCA9IHRoaXMudHJhbnNmb3JtKGl0ZW0udmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0VGVuc29ycyA9IHV0aWxfMS5leHRyYWN0VGVuc29yc0Zyb21BbnkobWFwcGVkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBpbnB1dFRlbnNvcnNfMSA9IGlucHV0VGVuc29yczsgX2kgPCBpbnB1dFRlbnNvcnNfMS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ID0gaW5wdXRUZW5zb3JzXzFbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdXRpbF8xLmlzVGVuc29ySW5MaXN0KHQsIG91dHB1dFRlbnNvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0UXVldWUucHVzaChtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0cnVlXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFwU3RyZWFtO1xufShRdWV1ZVN0cmVhbSkpO1xudmFyIENoYWluZWRTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGFpbmVkU3RyZWFtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENoYWluZWRTdHJlYW0oKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0UmVhZCA9IG51bGw7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ2hhaW5lZFN0cmVhbS5jcmVhdGUgPSBmdW5jdGlvbiAoc3RyZWFtcykge1xuICAgICAgICB2YXIgYyA9IG5ldyBDaGFpbmVkU3RyZWFtKCk7XG4gICAgICAgIGMubW9yZVN0cmVhbXMgPSBzdHJlYW1zO1xuICAgICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIENoYWluZWRTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RSZWFkID0gdGhpcy5yZWFkRnJvbUNoYWluKHRoaXMubGFzdFJlYWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5sYXN0UmVhZF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGFpbmVkU3RyZWFtLnByb3RvdHlwZS5yZWFkRnJvbUNoYWluID0gZnVuY3Rpb24gKGxhc3RSZWFkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdHJlYW1SZXN1bHQsIGl0ZW1SZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgbGFzdFJlYWRdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISh0aGlzLnN0cmVhbSA9PSBudWxsKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5tb3JlU3RyZWFtcy5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW1SZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtUmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzQsIHRoaXMuc3RyZWFtLm5leHQoKV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1SZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbVJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZWFkRnJvbUNoYWluKGxhc3RSZWFkKV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGl0ZW1SZXN1bHRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFpbmVkU3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG5leHBvcnRzLkNoYWluZWRTdHJlYW0gPSBDaGFpbmVkU3RyZWFtO1xudmFyIFByZWZldGNoU3RyZWFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUHJlZmV0Y2hTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUHJlZmV0Y2hTdHJlYW0odXBzdHJlYW0sIGJ1ZmZlclNpemUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMuYnVmZmVyU2l6ZSA9IGJ1ZmZlclNpemU7XG4gICAgICAgIF90aGlzLnRvdGFsID0gMDtcbiAgICAgICAgX3RoaXMuYnVmZmVyID0gbmV3IHJpbmdfYnVmZmVyXzEuUmluZ0J1ZmZlcihidWZmZXJTaXplKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcmVmZXRjaFN0cmVhbS5wcm90b3R5cGUucmVmaWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMuYnVmZmVyLmlzRnVsbCgpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHRoaXMudXBzdHJlYW0ubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlZmV0Y2hTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVmaWxsKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlci5zaGlmdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFByZWZldGNoU3RyZWFtO1xufShEYXRhU3RyZWFtKSk7XG5leHBvcnRzLlByZWZldGNoU3RyZWFtID0gUHJlZmV0Y2hTdHJlYW07XG52YXIgU2h1ZmZsZVN0cmVhbSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNodWZmbGVTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2h1ZmZsZVN0cmVhbSh1cHN0cmVhbSwgd2luZG93U2l6ZSwgc2VlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCB1cHN0cmVhbSwgd2luZG93U2l6ZSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudXBzdHJlYW0gPSB1cHN0cmVhbTtcbiAgICAgICAgX3RoaXMud2luZG93U2l6ZSA9IHdpbmRvd1NpemU7XG4gICAgICAgIF90aGlzLnVwc3RyZWFtRXhoYXVzdGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJhbmRvbSA9IHNlZWRyYW5kb20oc2VlZCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU2h1ZmZsZVN0cmVhbS5wcm90b3R5cGUucmFuZG9tSW50ID0gZnVuY3Rpb24gKG1heCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnJhbmRvbSgpICogbWF4KTtcbiAgICB9O1xuICAgIFNodWZmbGVTdHJlYW0ucHJvdG90eXBlLmNob29zZUluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYW5kb21JbnQodGhpcy5idWZmZXIubGVuZ3RoKCkpO1xuICAgIH07XG4gICAgU2h1ZmZsZVN0cmVhbS5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNob3NlbkluZGV4LCByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMudXBzdHJlYW1FeGhhdXN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZmlsbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2EubGFiZWwgPSAxO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISF0aGlzLmJ1ZmZlci5pc0VtcHR5KCkpIHJldHVybiBbMywgM107XG4gICAgICAgICAgICAgICAgICAgICAgICBjaG9zZW5JbmRleCA9IHRoaXMuY2hvb3NlSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5idWZmZXIuc2h1ZmZsZUV4Y2lzZShjaG9zZW5JbmRleCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwc3RyZWFtRXhoYXVzdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVmaWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCByZXN1bHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszLCAxXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIsIHsgdmFsdWU6IG51bGwsIGRvbmU6IHRydWUgfV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFNodWZmbGVTdHJlYW07XG59KFByZWZldGNoU3RyZWFtKSk7XG5leHBvcnRzLlNodWZmbGVTdHJlYW0gPSBTaHVmZmxlU3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJ5dGVfc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9ieXRlX3N0cmVhbVwiKTtcbnZhciBGaWxlUmVhZGVyU3RyZWFtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRmlsZVJlYWRlclN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGaWxlUmVhZGVyU3RyZWFtKGZpbGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuZmlsZSA9IGZpbGU7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5vZmZzZXQgPSBvcHRpb25zLm9mZnNldCB8fCAwO1xuICAgICAgICBfdGhpcy5jaHVua1NpemUgPSBvcHRpb25zLmNodW5rU2l6ZSB8fCAxMDI0ICogMTAyNDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGaWxlUmVhZGVyU3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIGNodW5rLCBfYTtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9iLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm9mZnNldCA+PSB0aGlzLmZpbGUuc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyB2YWx1ZTogbnVsbCwgZG9uZTogdHJ1ZSB9XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmaWxlUmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGZpbGVSZWFkZXIucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBUeXBlRXJyb3IoJ0ZpbGVSZWFkZXIgcmV0dXJuZWQgdW5rbm93biB0eXBlLicpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5vbmFib3J0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKCdBYm9ydGVkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmlsZVJlYWRlci5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKGV2ZW50LmVycm9yKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZW5kID0gX3RoaXMub2Zmc2V0ICsgX3RoaXMuY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzbGljZSA9IF90aGlzLmZpbGUuc2xpY2UoX3RoaXMub2Zmc2V0LCBlbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVSZWFkZXIucmVhZEFzQXJyYXlCdWZmZXIoc2xpY2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCA9IGVuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgY2h1bmtdO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiwgKF9hLnZhbHVlID0gKF9iLnNlbnQoKSksIF9hLmRvbmUgPSBmYWxzZSwgX2EpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRmlsZVJlYWRlclN0cmVhbTtcbn0oYnl0ZV9zdHJlYW1fMS5CeXRlU3RyZWFtKSk7XG5leHBvcnRzLkZpbGVSZWFkZXJTdHJlYW0gPSBGaWxlUmVhZGVyU3RyZWFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRhdGFfc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9kYXRhX3N0cmVhbVwiKTtcbnZhciBTdHJpbmdTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdHJpbmdTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RyaW5nU3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIFN0cmluZ1N0cmVhbS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3BsaXRTdHJlYW0odGhpcywgc2VwYXJhdG9yKTtcbiAgICB9O1xuICAgIHJldHVybiBTdHJpbmdTdHJlYW07XG59KGRhdGFfc3RyZWFtXzEuRGF0YVN0cmVhbSkpO1xuZXhwb3J0cy5TdHJpbmdTdHJlYW0gPSBTdHJpbmdTdHJlYW07XG52YXIgU3BsaXRTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTcGxpdFN0cmVhbSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTcGxpdFN0cmVhbSh1cHN0cmVhbSwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmltcGwgPSBuZXcgU3BsaXRTdHJlYW1JbXBsKHVwc3RyZWFtLCBzZXBhcmF0b3IpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNwbGl0U3RyZWFtLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmltcGwubmV4dCgpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTcGxpdFN0cmVhbTtcbn0oU3RyaW5nU3RyZWFtKSk7XG52YXIgU3BsaXRTdHJlYW1JbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3BsaXRTdHJlYW1JbXBsLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNwbGl0U3RyZWFtSW1wbCh1cHN0cmVhbSwgc2VwYXJhdG9yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnVwc3RyZWFtID0gdXBzdHJlYW07XG4gICAgICAgIF90aGlzLnNlcGFyYXRvciA9IHNlcGFyYXRvcjtcbiAgICAgICAgX3RoaXMuY2FycnlvdmVyID0gJyc7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3BsaXRTdHJlYW1JbXBsLnByb3RvdHlwZS5wdW1wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY2h1bmtSZXN1bHQsIGxpbmVzLCBfaSwgX2EsIGxpbmU7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9iKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCwgdGhpcy51cHN0cmVhbS5uZXh0KCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua1Jlc3VsdCA9IF9iLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaHVua1Jlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY2FycnlvdmVyID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGZhbHNlXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKHRoaXMuY2FycnlvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcnJ5b3ZlciA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lcyA9IGNodW5rUmVzdWx0LnZhbHVlLnNwbGl0KHRoaXMuc2VwYXJhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVzWzBdID0gdGhpcy5jYXJyeW92ZXIgKyBsaW5lc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoX2kgPSAwLCBfYSA9IGxpbmVzLnNsaWNlKDAsIC0xKTsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lID0gX2FbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub3V0cHV0UXVldWUucHVzaChsaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FycnlvdmVyID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRydWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBTcGxpdFN0cmVhbUltcGw7XG59KGRhdGFfc3RyZWFtXzEuUXVldWVTdHJlYW0pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBieXRlX3N0cmVhbV8xID0gcmVxdWlyZShcIi4vYnl0ZV9zdHJlYW1cIik7XG52YXIgZGF0YV9zdHJlYW1fMSA9IHJlcXVpcmUoXCIuL2RhdGFfc3RyZWFtXCIpO1xudmFyIGZpbGVyZWFkZXJfc3RyZWFtXzEgPSByZXF1aXJlKFwiLi9maWxlcmVhZGVyX3N0cmVhbVwiKTtcbnZhciBVUkxTdHJlYW0gPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhVUkxTdHJlYW0sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVVJMU3RyZWFtKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5pbXBsID0gbmV3IFVSTFN0cmVhbUltcGwodXJsLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBVUkxTdHJlYW0ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuaW1wbC5uZXh0KCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFN0cmVhbTtcbn0oYnl0ZV9zdHJlYW1fMS5CeXRlU3RyZWFtKSk7XG5leHBvcnRzLlVSTFN0cmVhbSA9IFVSTFN0cmVhbTtcbnZhciBVUkxTdHJlYW1JbXBsID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVVJMU3RyZWFtSW1wbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBVUkxTdHJlYW1JbXBsKHVybCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIF90aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICBfdGhpcy5ibG9iUHJvbWlzZSA9IGZldGNoKHVybCwgb3B0aW9ucykudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5ibG9iKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFVSTFN0cmVhbUltcGwucHJvdG90eXBlLnB1bXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBibG9iLCBjaHVua1Jlc3VsdDtcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuZmlsZVJlYWRlclN0cmVhbSA9PSBudWxsKSkgcmV0dXJuIFszLCAyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5ibG9iUHJvbWlzZV07XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2IgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVSZWFkZXJTdHJlYW0gPSBuZXcgZmlsZXJlYWRlcl9zdHJlYW1fMS5GaWxlUmVhZGVyU3RyZWFtKGJsb2IsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFs0LCB0aGlzLmZpbGVSZWFkZXJTdHJlYW0ubmV4dCgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtSZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2h1bmtSZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZmFsc2VdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vdXRwdXRRdWV1ZS5wdXNoKGNodW5rUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdHJ1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFVSTFN0cmVhbUltcGw7XG59KGRhdGFfc3RyZWFtXzEuUXVldWVTdHJlYW0pKTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgcmluZ19idWZmZXJfMSA9IHJlcXVpcmUoXCIuL3JpbmdfYnVmZmVyXCIpO1xudmFyIEdyb3dpbmdSaW5nQnVmZmVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoR3Jvd2luZ1JpbmdCdWZmZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gR3Jvd2luZ1JpbmdCdWZmZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBHcm93aW5nUmluZ0J1ZmZlci5JTklUSUFMX0NBUEFDSVRZKSB8fCB0aGlzO1xuICAgIH1cbiAgICBHcm93aW5nUmluZ0J1ZmZlci5wcm90b3R5cGUuaXNGdWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBHcm93aW5nUmluZ0J1ZmZlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoX3N1cGVyLnByb3RvdHlwZS5pc0Z1bGwuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBHcm93aW5nUmluZ0J1ZmZlci5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoX3N1cGVyLnByb3RvdHlwZS5pc0Z1bGwuY2FsbCh0aGlzKSkge1xuICAgICAgICAgICAgdGhpcy5leHBhbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLnVuc2hpZnQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBHcm93aW5nUmluZ0J1ZmZlci5wcm90b3R5cGUuZXhwYW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbmV3Q2FwYWNpdHkgPSB0aGlzLmNhcGFjaXR5ICogMjtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSBuZXcgQXJyYXkobmV3Q2FwYWNpdHkpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGgoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IHRoaXMuZ2V0KHRoaXMud3JhcCh0aGlzLmJlZ2luICsgaSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBuZXdDYXBhY2l0eTtcbiAgICAgICAgdGhpcy5kb3VibGVkQ2FwYWNpdHkgPSAyICogdGhpcy5jYXBhY2l0eTtcbiAgICAgICAgdGhpcy5iZWdpbiA9IDA7XG4gICAgICAgIHRoaXMuZW5kID0gbGVuO1xuICAgIH07XG4gICAgR3Jvd2luZ1JpbmdCdWZmZXIuSU5JVElBTF9DQVBBQ0lUWSA9IDMyO1xuICAgIHJldHVybiBHcm93aW5nUmluZ0J1ZmZlcjtcbn0ocmluZ19idWZmZXJfMS5SaW5nQnVmZmVyKSk7XG5leHBvcnRzLkdyb3dpbmdSaW5nQnVmZmVyID0gR3Jvd2luZ1JpbmdCdWZmZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBSaW5nQnVmZmVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSaW5nQnVmZmVyKGNhcGFjaXR5KSB7XG4gICAgICAgIHRoaXMuY2FwYWNpdHkgPSBjYXBhY2l0eTtcbiAgICAgICAgdGhpcy5iZWdpbiA9IDA7XG4gICAgICAgIHRoaXMuZW5kID0gMDtcbiAgICAgICAgaWYgKGNhcGFjaXR5IDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NhblxcJ3QgY3JlYXRlIHJpbmcgYnVmZmVyIG9mIGNhcGFjaXR5IDwgMS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgQXJyYXkoY2FwYWNpdHkpO1xuICAgICAgICB0aGlzLmRvdWJsZWRDYXBhY2l0eSA9IDIgKiBjYXBhY2l0eTtcbiAgICB9XG4gICAgUmluZ0J1ZmZlci5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB3aGlsZSAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLmRvdWJsZWRDYXBhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXggJSB0aGlzLmRvdWJsZWRDYXBhY2l0eTtcbiAgICB9O1xuICAgIFJpbmdCdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ2FuXFwndCBnZXQgaXRlbSBhdCBhIG5lZ2F0aXZlIGluZGV4LicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbaW5kZXggJSB0aGlzLmNhcGFjaXR5XTtcbiAgICB9O1xuICAgIFJpbmdCdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0NhblxcJ3Qgc2V0IGl0ZW0gYXQgYSBuZWdhdGl2ZSBpbmRleC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaW5kZXggJSB0aGlzLmNhcGFjaXR5XSA9IHZhbHVlO1xuICAgIH07XG4gICAgUmluZ0J1ZmZlci5wcm90b3R5cGUubGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGhpcy5lbmQgLSB0aGlzLmJlZ2luO1xuICAgICAgICBpZiAobGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgbGVuZ3RoID0gdGhpcy5kb3VibGVkQ2FwYWNpdHkgKyBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9O1xuICAgIFJpbmdCdWZmZXIucHJvdG90eXBlLmlzRnVsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoKCkgPT09IHRoaXMuY2FwYWNpdHk7XG4gICAgfTtcbiAgICBSaW5nQnVmZmVyLnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGgoKSA9PT0gMDtcbiAgICB9O1xuICAgIFJpbmdCdWZmZXIucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNGdWxsKCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSaW5nIGJ1ZmZlciBpcyBmdWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0KHRoaXMuZW5kLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy53cmFwKHRoaXMuZW5kICsgMSk7XG4gICAgfTtcbiAgICBSaW5nQnVmZmVyLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JpbmcgYnVmZmVyIGlzIGVtcHR5LicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW5kID0gdGhpcy53cmFwKHRoaXMuZW5kIC0gMSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldCh0aGlzLmVuZCk7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMuZW5kLCB1bmRlZmluZWQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmluZ0J1ZmZlci5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0Z1bGwoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JpbmcgYnVmZmVyIGlzIGZ1bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5iZWdpbiA9IHRoaXMud3JhcCh0aGlzLmJlZ2luIC0gMSk7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMuYmVnaW4sIHZhbHVlKTtcbiAgICB9O1xuICAgIFJpbmdCdWZmZXIucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdSaW5nIGJ1ZmZlciBpcyBlbXB0eS4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5nZXQodGhpcy5iZWdpbik7XG4gICAgICAgIHRoaXMuc2V0KHRoaXMuYmVnaW4sIHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuYmVnaW4gPSB0aGlzLndyYXAodGhpcy5iZWdpbiArIDEpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgUmluZ0J1ZmZlci5wcm90b3R5cGUuc2h1ZmZsZUV4Y2lzZSA9IGZ1bmN0aW9uIChyZWxhdGl2ZUluZGV4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1JpbmcgYnVmZmVyIGlzIGVtcHR5LicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMud3JhcCh0aGlzLmJlZ2luICsgcmVsYXRpdmVJbmRleCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdldChpbmRleCk7XG4gICAgICAgIHRoaXMuc2V0KGluZGV4LCB0aGlzLnBvcCgpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIHJldHVybiBSaW5nQnVmZmVyO1xufSgpKTtcbmV4cG9ydHMuUmluZ0J1ZmZlciA9IFJpbmdCdWZmZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkYXRhc2V0XzEgPSByZXF1aXJlKFwiLi9kYXRhL2RhdGFzZXRcIik7XG5leHBvcnRzLkRhdGFzZXQgPSBkYXRhc2V0XzEuRGF0YXNldDtcbnZhciBkYXRhc2V0XzIgPSByZXF1aXJlKFwiLi9kYXRhL2RhdGFzZXRcIik7XG5leHBvcnRzLmRhdGFzZXRGcm9tRWxlbWVudHMgPSBkYXRhc2V0XzIuZGF0YXNldEZyb21FbGVtZW50cztcbnZhciBjc3ZfZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS9kYXRhc2V0cy9jc3ZfZGF0YXNldFwiKTtcbmV4cG9ydHMuQ1NWRGF0YXNldCA9IGNzdl9kYXRhc2V0XzEuQ1NWRGF0YXNldDtcbnZhciB0ZXh0X2xpbmVfZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS9kYXRhc2V0cy90ZXh0X2xpbmVfZGF0YXNldFwiKTtcbmV4cG9ydHMuVGV4dExpbmVEYXRhc2V0ID0gdGV4dF9saW5lX2RhdGFzZXRfMS5UZXh0TGluZURhdGFzZXQ7XG52YXIgZmlsZV9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vZGF0YS9zb3VyY2VzL2ZpbGVfZGF0YV9zb3VyY2VcIik7XG5leHBvcnRzLkZpbGVEYXRhU291cmNlID0gZmlsZV9kYXRhX3NvdXJjZV8xLkZpbGVEYXRhU291cmNlO1xudmFyIHVybF9kYXRhX3NvdXJjZV8xID0gcmVxdWlyZShcIi4vZGF0YS9zb3VyY2VzL3VybF9kYXRhX3NvdXJjZVwiKTtcbmV4cG9ydHMuVVJMRGF0YVNvdXJjZSA9IHVybF9kYXRhX3NvdXJjZV8xLlVSTERhdGFTb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgTUFOSUZFU1RfRklMRSA9ICdtYW5pZmVzdC5qc29uJztcbnZhciBDaGVja3BvaW50TG9hZGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDaGVja3BvaW50TG9hZGVyKHVybFBhdGgpIHtcbiAgICAgICAgdGhpcy51cmxQYXRoID0gdXJsUGF0aDtcbiAgICAgICAgaWYgKHRoaXMudXJsUGF0aC5jaGFyQXQodGhpcy51cmxQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgICAgICAgIHRoaXMudXJsUGF0aCArPSAnLyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQ2hlY2twb2ludExvYWRlci5wcm90b3R5cGUubG9hZE1hbmlmZXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIF90aGlzLnVybFBhdGggKyBNQU5JRkVTVF9GSUxFKTtcbiAgICAgICAgICAgIHhoci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hlY2twb2ludE1hbmlmZXN0ID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoTUFOSUZFU1RfRklMRSArIFwiIG5vdCBmb3VuZCBhdCBcIiArIF90aGlzLnVybFBhdGggKyBcIi4gXCIgKyBlcnJvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRDaGVja3BvaW50TWFuaWZlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmxvYWRNYW5pZmVzdCgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoZWNrcG9pbnRMb2FkZXIucHJvdG90eXBlLmdldEFsbFZhcmlhYmxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShfdGhpcy52YXJpYWJsZXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIF90aGlzLmdldENoZWNrcG9pbnRNYW5pZmVzdCgpLnRoZW4oZnVuY3Rpb24gKGNoZWNrcG9pbnREZWZpbml0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlTmFtZXMgPSBPYmplY3Qua2V5cyhfdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZVByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZU5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlUHJvbWlzZXMucHVzaChfdGhpcy5nZXRWYXJpYWJsZSh2YXJpYWJsZU5hbWVzW2ldKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKHZhcmlhYmxlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKHZhcmlhYmxlcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy52YXJpYWJsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YXJpYWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlc1t2YXJpYWJsZU5hbWVzW2ldXSA9IHZhcmlhYmxlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKF90aGlzLnZhcmlhYmxlcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDaGVja3BvaW50TG9hZGVyLnByb3RvdHlwZS5nZXRWYXJpYWJsZSA9IGZ1bmN0aW9uICh2YXJOYW1lKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghKHZhck5hbWUgaW4gdGhpcy5jaGVja3BvaW50TWFuaWZlc3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBsb2FkIG5vbi1leGlzdGFudCB2YXJpYWJsZSAnICsgdmFyTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhcmlhYmxlUmVxdWVzdFByb21pc2VNZXRob2QgPSBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgICAgIHZhciBmbmFtZSA9IF90aGlzLmNoZWNrcG9pbnRNYW5pZmVzdFt2YXJOYW1lXS5maWxlbmFtZTtcbiAgICAgICAgICAgIHhoci5vcGVuKCdHRVQnLCBfdGhpcy51cmxQYXRoICsgZm5hbWUpO1xuICAgICAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PT0gNDA0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBmb3VuZCB2YXJpYWJsZSBcIiArIHZhck5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHZhciB0ZW5zb3IgPSB0ZW5zb3JfMS5UZW5zb3IubWFrZShfdGhpcy5jaGVja3BvaW50TWFuaWZlc3RbdmFyTmFtZV0uc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0ZW5zb3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZldGNoIHZhcmlhYmxlIFwiICsgdmFyTmFtZSArIFwiOiBcIiArIGVycm9yKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB4aHIuc2VuZCgpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jaGVja3BvaW50TWFuaWZlc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sb2FkTWFuaWZlc3QoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IFByb21pc2UodmFyaWFibGVSZXF1ZXN0UHJvbWlzZU1ldGhvZCkudGhlbihyZXNvbHZlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSh2YXJpYWJsZVJlcXVlc3RQcm9taXNlTWV0aG9kKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGVja3BvaW50TG9hZGVyO1xufSgpKTtcbmV4cG9ydHMuQ2hlY2twb2ludExvYWRlciA9IENoZWNrcG9pbnRMb2FkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIFNUQVRTX1NBTVBMRV9QRVJDRU5UQUdFID0gMC4xO1xudmFyIEluTWVtb3J5RGF0YXNldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gSW5NZW1vcnlEYXRhc2V0KGRhdGFTaGFwZXMpIHtcbiAgICAgICAgdGhpcy5kYXRhU2hhcGVzID0gZGF0YVNoYXBlcztcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mbyA9IHt9O1xuICAgIH1cbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmdldERhdGFTaGFwZSA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNoYXBlc1tkYXRhSW5kZXhdO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXREYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0O1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGEgaXMgbnVsbC4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kYXRhc2V0Lm1hcChmdW5jdGlvbiAoZCkgeyByZXR1cm4gX3RoaXMuZ2V0U3RhdHNGb3JEYXRhKGQpOyB9KTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZ2V0U3RhdHNGb3JEYXRhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIGlucHV0TWluID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICB2YXIgaW5wdXRNYXggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIHZhciBleGFtcGxlSW5kaWNlcyA9IGRhdGEubWFwKGZ1bmN0aW9uIChleGFtcGxlLCBpKSB7IHJldHVybiBpOyB9KTtcbiAgICAgICAgdXRpbC5zaHVmZmxlKGV4YW1wbGVJbmRpY2VzKTtcbiAgICAgICAgZXhhbXBsZUluZGljZXMgPVxuICAgICAgICAgICAgZXhhbXBsZUluZGljZXMuc2xpY2UoZXhhbXBsZUluZGljZXMubGVuZ3RoICogU1RBVFNfU0FNUExFX1BFUkNFTlRBR0UpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4YW1wbGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBkYXRhW2V4YW1wbGVJbmRpY2VzW2ldXS5kYXRhU3luYygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnB1dFZhbHVlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlucHV0TWluID0gTWF0aC5taW4oaW5wdXRNaW4sIGlucHV0VmFsdWVzW2pdKTtcbiAgICAgICAgICAgICAgICBpbnB1dE1heCA9IE1hdGgubWF4KGlucHV0TWF4LCBpbnB1dFZhbHVlc1tqXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0TWluOiBpbnB1dE1pbixcbiAgICAgICAgICAgIGlucHV0TWF4OiBpbnB1dE1heCxcbiAgICAgICAgICAgIGV4YW1wbGVDb3VudDogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICBzaGFwZTogZGF0YVswXS5zaGFwZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlID0gZnVuY3Rpb24gKGV4YW1wbGVzLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIG5ld0xvd2VyQm91bmRzLCBuZXdVcHBlckJvdW5kcykge1xuICAgICAgICB2YXIgY3VyQm91bmRzSXNQZXJEaW1lbnNpb24gPSAoY3VyVXBwZXJCb3VuZHMgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgJiZcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KTtcbiAgICAgICAgdmFyIG5ld0JvdW5kc0lzUGVyRGltZW5zaW9uID0gKG5ld0xvd2VyQm91bmRzIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmXG4gICAgICAgICAgICBuZXdVcHBlckJvdW5kcyBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSk7XG4gICAgICAgIHZhciBpbnB1dFNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoZXhhbXBsZXNbMF0uc2hhcGUpO1xuICAgICAgICB2YXIgbmV3RXhhbXBsZXMgPSBbXTtcbiAgICAgICAgZXhhbXBsZXMuZm9yRWFjaChmdW5jdGlvbiAoZXhhbXBsZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0VmFsdWVzID0gZXhhbXBsZS5kYXRhU3luYygpO1xuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGlucHV0U2l6ZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGlucHV0U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1ckxvd2VyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgY3VyTG93ZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIGN1clVwcGVyQm91bmQgPSBjdXJCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIGN1clVwcGVyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIGN1clJhbmdlID0gY3VyVXBwZXJCb3VuZCAtIGN1ckxvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0xvd2VyQm91bmQgPSBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIG5ld0xvd2VyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3TG93ZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1VwcGVyQm91bmQgPSBuZXdCb3VuZHNJc1BlckRpbWVuc2lvbiA/XG4gICAgICAgICAgICAgICAgICAgIG5ld1VwcGVyQm91bmRzW2pdIDpcbiAgICAgICAgICAgICAgICAgICAgbmV3VXBwZXJCb3VuZHM7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1JhbmdlID0gbmV3VXBwZXJCb3VuZCAtIG5ld0xvd2VyQm91bmQ7XG4gICAgICAgICAgICAgICAgaWYgKGN1clJhbmdlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRWYWx1ZXNbal0gPSBuZXdMb3dlckJvdW5kO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZFZhbHVlc1tqXSA9IG5ld0xvd2VyQm91bmQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UmFuZ2UgKiAoaW5wdXRWYWx1ZXNbal0gLSBjdXJMb3dlckJvdW5kKSAvIGN1clJhbmdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0V4YW1wbGVzLnB1c2godGVuc29yXzEuVGVuc29yLm1ha2UoZXhhbXBsZS5zaGFwZSwgeyB2YWx1ZXM6IG5vcm1hbGl6ZWRWYWx1ZXMgfSwgJ2Zsb2F0MzInKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3RXhhbXBsZXM7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmNvbXB1dGVCb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5kYXRhc2V0W2RhdGFJbmRleF1bMF0uc2hhcGUpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPSB7XG4gICAgICAgICAgICBpc05vcm1hbGl6ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbWluVmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpLFxuICAgICAgICAgICAgbWF4VmFsdWVzOiBuZXcgRmxvYXQzMkFycmF5KHNpemUpXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2ldID0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1tpXSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XS5mb3JFYWNoKGZ1bmN0aW9uIChleGFtcGxlKSB7XG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZXMgPSBleGFtcGxlLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNpemU7IGsrKykge1xuICAgICAgICAgICAgICAgIF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzW2tdID0gTWF0aC5taW4oX3RoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5taW5WYWx1ZXNba10sIGlucHV0VmFsdWVzW2tdKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlc1trXSA9IE1hdGgubWF4KF90aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzW2tdLCBpbnB1dFZhbHVlc1trXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgSW5NZW1vcnlEYXRhc2V0LnByb3RvdHlwZS5ub3JtYWxpemVXaXRoaW5Cb3VuZHMgPSBmdW5jdGlvbiAoZGF0YUluZGV4LCBsb3dlckJvdW5kLCB1cHBlckJvdW5kKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFzZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGlzIG51bGwuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFJbmRleCA+PSB0aGlzLmRhdGFzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RhdGFJbmRleCBvdXQgb2YgYm91bmRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQm91bmRzKGRhdGFJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1ckxvd2VyQm91bmRzO1xuICAgICAgICB2YXIgY3VyVXBwZXJCb3VuZHM7XG4gICAgICAgIGlmICh0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkKSB7XG4gICAgICAgICAgICBjdXJMb3dlckJvdW5kcyA9IHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kO1xuICAgICAgICAgICAgY3VyVXBwZXJCb3VuZHMgPSB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1ckxvd2VyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcztcbiAgICAgICAgICAgIGN1clVwcGVyQm91bmRzID0gdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXRbZGF0YUluZGV4XSA9IHRoaXMubm9ybWFsaXplRXhhbXBsZXNUb1JhbmdlKHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdLCBjdXJMb3dlckJvdW5kcywgY3VyVXBwZXJCb3VuZHMsIGxvd2VyQm91bmQsIHVwcGVyQm91bmQpO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0uaXNOb3JtYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQgPSBsb3dlckJvdW5kO1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCA9IHVwcGVyQm91bmQ7XG4gICAgfTtcbiAgICBJbk1lbW9yeURhdGFzZXQucHJvdG90eXBlLmlzTm9ybWFsaXplZCA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkluZm8gIT0gbnVsbCAmJlxuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmlzTm9ybWFsaXplZDtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUucmVtb3ZlTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChkYXRhSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYWluaW5nIG9yIHRlc3QgZGF0YSBpcyBudWxsLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YXNldFtkYXRhSW5kZXhdID0gdGhpcy5ub3JtYWxpemVFeGFtcGxlc1RvUmFuZ2UodGhpcy5kYXRhc2V0W2RhdGFJbmRleF0sIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5sb3dlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0udXBwZXJCb3VuZCwgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1pblZhbHVlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLm1heFZhbHVlcyk7XG4gICAgICAgIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS5pc05vcm1hbGl6ZWQgPSBmYWxzZTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUudW5ub3JtYWxpemVFeGFtcGxlcyA9IGZ1bmN0aW9uIChleGFtcGxlcywgZGF0YUluZGV4KSB7XG4gICAgICAgIGlmICghdGhpcy5pc05vcm1hbGl6ZWQoZGF0YUluZGV4KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4YW1wbGVzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5vcm1hbGl6ZUV4YW1wbGVzVG9SYW5nZShleGFtcGxlcywgdGhpcy5ub3JtYWxpemF0aW9uSW5mb1tkYXRhSW5kZXhdLmxvd2VyQm91bmQsIHRoaXMubm9ybWFsaXphdGlvbkluZm9bZGF0YUluZGV4XS51cHBlckJvdW5kLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWluVmFsdWVzLCB0aGlzLm5vcm1hbGl6YXRpb25JbmZvW2RhdGFJbmRleF0ubWF4VmFsdWVzKTtcbiAgICB9O1xuICAgIEluTWVtb3J5RGF0YXNldC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YXNldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGFzZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5kYXRhc2V0W2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhc2V0W2ldW2pdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFzZXQgPSBbXTtcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeURhdGFzZXQ7XG59KCkpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBJbk1lbW9yeURhdGFzZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcihpbnB1dHMpIHtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIgPSAwO1xuICAgICAgICB0aGlzLmVwb2NoID0gMDtcbiAgICAgICAgdGhpcy5zaHVmZmxlZEluZGljZXMgPSB1dGlsLmNyZWF0ZVNodWZmbGVkSW5kaWNlcyhpbnB1dHNbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5udW1JbnB1dHMgPSBpbnB1dHMubGVuZ3RoO1xuICAgICAgICB2YXIgbnVtRXhhbXBsZXMgPSB0aGlzLmlucHV0c1swXS5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5pbnB1dHNbaV0ubGVuZ3RoID09PSBudW1FeGFtcGxlcywgJ051bWJlciBvZiBleGFtcGxlcyBtdXN0IG1hdGNoIGFjcm9zcyBkaWZmZXJlbnQgaW5wdXRzLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgdmFyIGlucHV0U2hhcGUgPSB0aGlzLmlucHV0c1tpXVswXS5zaGFwZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5pbnB1dHNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGlucHV0U2hhcGUsIHRoaXMuaW5wdXRzW2ldW2pdLnNoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldEN1cnJlbnRFeGFtcGxlSW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXR1cm5JZHggPSB0aGlzLmlkeDtcbiAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIrKztcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRDb3VudGVyID49IHRoaXMubnVtSW5wdXRzKSB7XG4gICAgICAgICAgICB0aGlzLmlkeCsrO1xuICAgICAgICAgICAgdGhpcy5pbnB1dENvdW50ZXIgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMuaWR4ID49IHRoaXMuaW5wdXRzWzBdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaWR4ID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLmVwb2NoKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybklkeDtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0TmV4dElucHV0ID0gZnVuY3Rpb24gKGlucHV0SWQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRFeGFtcGxlSW5kZXggPSB0aGlzLmdldEN1cnJlbnRFeGFtcGxlSW5kZXgoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRzW2lucHV0SWRdW3RoaXMuc2h1ZmZsZWRJbmRpY2VzW2N1cnJlbnRFeGFtcGxlSW5kZXhdXTtcbiAgICB9O1xuICAgIEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlci5wcm90b3R5cGUuZ2V0RXBvY2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVwb2NoO1xuICAgIH07XG4gICAgSW5NZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLnByb3RvdHlwZS5nZXRJbnB1dFByb3ZpZGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlucHV0UHJvdmlkZXJzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5udW1JbnB1dHM7IGkrKykge1xuICAgICAgICAgICAgaW5wdXRQcm92aWRlcnMucHVzaCh0aGlzLmdldElucHV0UHJvdmlkZXIoaSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnB1dFByb3ZpZGVycztcbiAgICB9O1xuICAgIHJldHVybiBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KCkpO1xuZXhwb3J0cy5Jbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbk1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5DUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXIgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5leHRDb3B5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEluR1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcigpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIucHJvdG90eXBlLmdldElucHV0UHJvdmlkZXIgPSBmdW5jdGlvbiAoaW5wdXRJZCkge1xuICAgICAgICB2YXIgc2h1ZmZsZWRJbnB1dFByb3ZpZGVyID0gdGhpcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldE5leHRDb3B5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNodWZmbGVkSW5wdXRQcm92aWRlci5nZXROZXh0SW5wdXQoaW5wdXRJZCkuY2xvbmUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkaXNwb3NlQ29weTogZnVuY3Rpb24gKGNvcHkpIHtcbiAgICAgICAgICAgICAgICBjb3B5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG59KEluTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcikpO1xuZXhwb3J0cy5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBJbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YXNldFwiKTtcbnZhciBQQVJTSU5HX0lNQUdFX0NBTlZBU19IRUlHSFRfUFggPSAxMDAwO1xuZnVuY3Rpb24gZ2V0WGhyRGF0YXNldENvbmZpZyhqc29uQ29uZmlnUGF0aCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgeGhyLm9wZW4oJ0dFVCcsIGpzb25Db25maWdQYXRoKTtcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5nZXRYaHJEYXRhc2V0Q29uZmlnID0gZ2V0WGhyRGF0YXNldENvbmZpZztcbnZhciBYaHJEYXRhc2V0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoWGhyRGF0YXNldCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYaHJEYXRhc2V0KHhockRhdGFzZXRDb25maWcpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgeGhyRGF0YXNldENvbmZpZy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5zaGFwZTsgfSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhockRhdGFzZXRDb25maWcgPSB4aHJEYXRhc2V0Q29uZmlnO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFhockRhdGFzZXQucHJvdG90eXBlLmdldFRlbnNvciA9IGZ1bmN0aW9uIChpbmZvKSB7XG4gICAgICAgIHZhciBkYXRhUHJvbWlzZSA9IGluZm8uZGF0YVR5cGUgPT09ICdwbmcnID9cbiAgICAgICAgICAgIHBhcnNlVHlwZWRBcnJheUZyb21QbmcoaW5mbywgaW5mby5zaGFwZSkgOlxuICAgICAgICAgICAgcGFyc2VUeXBlZEFycmF5RnJvbUJpbmFyeShpbmZvKTtcbiAgICAgICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShpbmZvLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGRhdGFQcm9taXNlLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0ZW5zb3JzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoIC8gaW5wdXRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWVzID0gZGF0YS5zdWJhcnJheShpICogaW5wdXRTaXplLCAoaSArIDEpICogaW5wdXRTaXplKTtcbiAgICAgICAgICAgICAgICB2YXIgdGVuc29yID0gdGVuc29yXzEuVGVuc29yLm1ha2UoaW5mby5zaGFwZSwgeyB2YWx1ZXM6IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzKSB9LCAnZmxvYXQzMicpO1xuICAgICAgICAgICAgICAgIHRlbnNvcnMucHVzaCh0ZW5zb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRlbnNvcnM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgWGhyRGF0YXNldC5wcm90b3R5cGUuZmV0Y2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VzID0gX3RoaXMueGhyRGF0YXNldENvbmZpZy5kYXRhLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gX3RoaXMuZ2V0VGVuc29yKHgpOyB9KTtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGF0YXNldCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFhockRhdGFzZXQ7XG59KGRhdGFzZXRfMS5Jbk1lbW9yeURhdGFzZXQpKTtcbmV4cG9ydHMuWGhyRGF0YXNldCA9IFhockRhdGFzZXQ7XG5mdW5jdGlvbiBwYXJzZVR5cGVkQXJyYXlGcm9tQmluYXJ5KGluZm8pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgICAgIHhoci5vcGVuKCdHRVQnLCBpbmZvLnBhdGgpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcbiAgICAgICAgeGhyLm9ubG9hZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSAoaW5mby5kYXRhVHlwZSA9PT0gJ2Zsb2F0MzInKSA/XG4gICAgICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh4aHIucmVzcG9uc2UpIDpcbiAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheSh4aHIucmVzcG9uc2UpO1xuICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiByZWplY3QoZXJyKTsgfTtcbiAgICAgICAgeGhyLnNlbmQoKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgcmVzdWx0T2Zmc2V0KSB7XG4gICAgdmFyIGlkeCA9IHJlc3VsdE9mZnNldDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgcmVzdWx0W2lkeCsrXSA9IGRhdGFbaV07XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VSR0JJbWFnZURhdGEoZGF0YSwgcmVzdWx0LCByZXN1bHRPZmZzZXQpIHtcbiAgICB2YXIgaWR4ID0gcmVzdWx0T2Zmc2V0O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHRbaWR4XSA9IGRhdGFbaV07XG4gICAgICAgIHJlc3VsdFtpZHggKyAxXSA9IGRhdGFbaSArIDFdO1xuICAgICAgICByZXN1bHRbaWR4ICsgMl0gPSBkYXRhW2kgKyAyXTtcbiAgICAgICAgaWR4ICs9IDM7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VJbWFnZShpbWcsIHNoYXBlKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB2YXIgTiA9IGltZy5oZWlnaHQ7XG4gICAgdmFyIGlucHV0U2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KE4gKiBpbnB1dFNpemUpO1xuICAgIGlmIChpbWcud2lkdGggIT09IHNoYXBlWzBdICogc2hhcGVbMV0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW1hZ2Ugd2lkdGggKFwiICsgaW1nLndpZHRoICsgXCIpIG11c3QgYmUgbXVsdGlwbGUgb2YgXCIgK1xuICAgICAgICAgICAgKFwicm93cypjb2x1bW5zIChcIiArIHNoYXBlWzBdICsgXCIqXCIgKyBzaGFwZVsxXSArIFwiKSBvZiB0aGUgdGVuc29yXCIpKTtcbiAgICB9XG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSBQQVJTSU5HX0lNQUdFX0NBTlZBU19IRUlHSFRfUFg7XG4gICAgdmFyIHN4ID0gMDtcbiAgICB2YXIgc1dpZHRoID0gY2FudmFzLndpZHRoO1xuICAgIHZhciBzSGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB2YXIgZHggPSAwO1xuICAgIHZhciBkeSA9IDA7XG4gICAgdmFyIGRXaWR0aCA9IHNXaWR0aDtcbiAgICB2YXIgZEhlaWdodCA9IHNIZWlnaHQ7XG4gICAgdmFyIGRlcHRoID0gc2hhcGVbMl07XG4gICAgdmFyIG9mZnNldCA9IDA7XG4gICAgdmFyIG51bVBhc3NlcyA9IE1hdGguY2VpbChOIC8gY2FudmFzLmhlaWdodCk7XG4gICAgZm9yICh2YXIgcGFzcyA9IDA7IHBhc3MgPCBudW1QYXNzZXM7ICsrcGFzcykge1xuICAgICAgICB2YXIgc3kgPSBwYXNzICogY2FudmFzLmhlaWdodDtcbiAgICAgICAgaWYgKChwYXNzID09PSBudW1QYXNzZXMgLSAxKSAmJiAoTiAlIGNhbnZhcy5oZWlnaHQgPiAwKSkge1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IE4gJSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICAgICAgc0hlaWdodCA9IGNhbnZhcy5oZWlnaHQ7XG4gICAgICAgICAgICBkSGVpZ2h0ID0gc0hlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBjdHguZHJhd0ltYWdlKGltZywgc3gsIHN5LCBzV2lkdGgsIHNIZWlnaHQsIGR4LCBkeSwgZFdpZHRoLCBkSGVpZ2h0KTtcbiAgICAgICAgdmFyIGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCkuZGF0YTtcbiAgICAgICAgKGRlcHRoID09PSAxKSA/IHBhcnNlR3JheXNjYWxlSW1hZ2VEYXRhKGRhdGEsIHJlc3VsdCwgb2Zmc2V0KSA6XG4gICAgICAgICAgICBwYXJzZVJHQkltYWdlRGF0YShkYXRhLCByZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjYW52YXMuaGVpZ2h0ICogaW5wdXRTaXplO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gcGFyc2VUeXBlZEFycmF5RnJvbVBuZyhpbmZvLCBzaGFwZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCAnJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gcGFyc2VJbWFnZShpbWcsIHNoYXBlKTtcbiAgICAgICAgICAgIGltZy5zcmMgPSAnJztcbiAgICAgICAgICAgIGltZyA9IG51bGw7XG4gICAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIGltZy5zcmMgPSBpbmZvLnBhdGg7XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzTW9iaWxlKCkge1xuICAgIHZhciBhID0gbmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYTtcbiAgICByZXR1cm4gLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pXG4gICAgICAgIC50ZXN0KGEpIHx8XG4gICAgICAgIC8xMjA3fDYzMTB8NjU5MHwzZ3NvfDR0aHB8NTBbMS02XWl8Nzcwc3w4MDJzfGEgd2F8YWJhY3xhYyhlcnxvb3xzXFwtKXxhaShrb3xybil8YWwoYXZ8Y2F8Y28pfGFtb2l8YW4oZXh8bnl8eXcpfGFwdHV8YXIoY2h8Z28pfGFzKHRlfHVzKXxhdHR3fGF1KGRpfFxcLW18ciB8cyApfGF2YW58YmUoY2t8bGx8bnEpfGJpKGxifHJkKXxibChhY3xheil8YnIoZXx2KXd8YnVtYnxid1xcLShufHUpfGM1NVxcL3xjYXBpfGNjd2F8Y2RtXFwtfGNlbGx8Y2h0bXxjbGRjfGNtZFxcLXxjbyhtcHxuZCl8Y3Jhd3xkYShpdHxsbHxuZyl8ZGJ0ZXxkY1xcLXN8ZGV2aXxkaWNhfGRtb2J8ZG8oY3xwKW98ZHMoMTJ8XFwtZCl8ZWwoNDl8YWkpfGVtKGwyfHVsKXxlcihpY3xrMCl8ZXNsOHxleihbNC03XTB8b3N8d2F8emUpfGZldGN8Zmx5KFxcLXxfKXxnMSB1fGc1NjB8Z2VuZXxnZlxcLTV8Z1xcLW1vfGdvKFxcLnd8b2QpfGdyKGFkfHVuKXxoYWllfGhjaXR8aGRcXC0obXxwfHQpfGhlaVxcLXxoaShwdHx0YSl8aHAoIGl8aXApfGhzXFwtY3xodChjKFxcLXwgfF98YXxnfHB8c3x0KXx0cCl8aHUoYXd8dGMpfGlcXC0oMjB8Z298bWEpfGkyMzB8aWFjKCB8XFwtfFxcLyl8aWJyb3xpZGVhfGlnMDF8aWtvbXxpbTFrfGlubm98aXBhcXxpcmlzfGphKHR8dilhfGpicm98amVtdXxqaWdzfGtkZGl8a2VqaXxrZ3QoIHxcXC8pfGtsb258a3B0IHxrd2NcXC18a3lvKGN8ayl8bGUobm98eGkpfGxnKCBnfFxcLyhrfGx8dSl8NTB8NTR8XFwtW2Etd10pfGxpYnd8bHlueHxtMVxcLXd8bTNnYXxtNTBcXC98bWEodGV8dWl8eG8pfG1jKDAxfDIxfGNhKXxtXFwtY3J8bWUocmN8cmkpfG1pKG84fG9hfHRzKXxtbWVmfG1vKDAxfDAyfGJpfGRlfGRvfHQoXFwtfCB8b3x2KXx6eil8bXQoNTB8cDF8diApfG13YnB8bXl3YXxuMTBbMC0yXXxuMjBbMi0zXXxuMzAoMHwyKXxuNTAoMHwyfDUpfG43KDAoMHwxKXwxMCl8bmUoKGN8bSlcXC18b258dGZ8d2Z8d2d8d3QpfG5vayg2fGkpfG56cGh8bzJpbXxvcCh0aXx3dil8b3Jhbnxvd2cxfHA4MDB8cGFuKGF8ZHx0KXxwZHhnfHBnKDEzfFxcLShbMS04XXxjKSl8cGhpbHxwaXJlfHBsKGF5fHVjKXxwblxcLTJ8cG8oY2t8cnR8c2UpfHByb3h8cHNpb3xwdFxcLWd8cWFcXC1hfHFjKDA3fDEyfDIxfDMyfDYwfFxcLVsyLTddfGlcXC0pfHF0ZWt8cjM4MHxyNjAwfHJha3N8cmltOXxybyh2ZXx6byl8czU1XFwvfHNhKGdlfG1hfG1tfG1zfG55fHZhKXxzYygwMXxoXFwtfG9vfHBcXC0pfHNka1xcL3xzZShjKFxcLXwwfDEpfDQ3fG1jfG5kfHJpKXxzZ2hcXC18c2hhcnxzaWUoXFwtfG0pfHNrXFwtMHxzbCg0NXxpZCl8c20oYWx8YXJ8YjN8aXR8dDUpfHNvKGZ0fG55KXxzcCgwMXxoXFwtfHZcXC18diApfHN5KDAxfG1iKXx0MigxOHw1MCl8dDYoMDB8MTB8MTgpfHRhKGd0fGxrKXx0Y2xcXC18dGRnXFwtfHRlbChpfG0pfHRpbVxcLXx0XFwtbW98dG8ocGx8c2gpfHRzKDcwfG1cXC18bTN8bTUpfHR4XFwtOXx1cChcXC5ifGcxfHNpKXx1dHN0fHY0MDB8djc1MHx2ZXJpfHZpKHJnfHRlKXx2ayg0MHw1WzAtM118XFwtdil8dm00MHx2b2RhfHZ1bGN8dngoNTJ8NTN8NjB8NjF8NzB8ODB8ODF8ODN8ODV8OTgpfHczYyhcXC18ICl8d2ViY3x3aGl0fHdpKGcgfG5jfG53KXx3bWxifHdvbnV8eDcwMHx5YXNcXC18eW91cnx6ZXRvfHp0ZVxcLS9pXG4gICAgICAgICAgICAudGVzdChhLnN1YnN0cigwLCA0KSk7XG59XG5leHBvcnRzLmlzTW9iaWxlID0gaXNNb2JpbGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGRvYyhpbmZvKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmRvYyA9IGRvYztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzL29wc1wiKTtcbnZhciBwcm9maWxlcl8xID0gcmVxdWlyZShcIi4vcHJvZmlsZXJcIik7XG52YXIgdGFwZV8xID0gcmVxdWlyZShcIi4vdGFwZVwiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBFbmdpbmUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVuZ2luZShiYWNrZW5kLCBjdXN0b21CYWNrZW5kLCBzYWZlTW9kZSkge1xuICAgICAgICB0aGlzLmJhY2tlbmQgPSBiYWNrZW5kO1xuICAgICAgICB0aGlzLmN1c3RvbUJhY2tlbmQgPSBjdXN0b21CYWNrZW5kO1xuICAgICAgICB0aGlzLnNhZmVNb2RlID0gc2FmZU1vZGU7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlcyA9IHt9O1xuICAgICAgICB0aGlzLnJlZkNvdW50ZXIgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLm5leHRUYXBlTm9kZUlkID0gMDtcbiAgICAgICAgdGhpcy5udW1CeXRlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtVGVuc29ycyA9IDA7XG4gICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMgPSAwO1xuICAgICAgICB0aGlzLmdyYWRpZW50U2NvcGVDb3VudCA9IDA7XG4gICAgICAgIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCA9IDA7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB7IGtlZXA6IFtdLCB0cmFjazogW10gfTtcbiAgICAgICAgdGhpcy5zY29wZVN0YWNrID0gW3RoaXMuYWN0aXZlU2NvcGVdO1xuICAgICAgICB0aGlzLnByb2ZpbGVyID0gbmV3IHByb2ZpbGVyXzEuUHJvZmlsZXIoYmFja2VuZCk7XG4gICAgfVxuICAgIEVuZ2luZS5wcm90b3R5cGUucnVuS2VybmVsID0gZnVuY3Rpb24gKGZvcndhcmRGdW5jLCBpbnB1dHMsIGJhY2t3YXJkc0Z1bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIHNhdmVkID0gW107XG4gICAgICAgIHZhciBzYXZlRnVuYyA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICBzYXZlZC5wdXNoKHgpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzY29wZU5hbWUgPSB0aGlzLmFjdGl2ZVNjb3BlLm5hbWU7XG4gICAgICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdERUJVRycpKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmb3J3YXJkRnVuYyh0aGlzLmJhY2tlbmQsIHNhdmVGdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMucHJvZmlsZXIucHJvZmlsZUtlcm5lbChzY29wZU5hbWUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGZvcndhcmRGdW5jKF90aGlzLmJhY2tlbmQsIHNhdmVGdW5jKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlY29yZEtlcm5lbCA9IHRoaXMuYWN0aXZlVGFwZSAhPSBudWxsICYmIHRoaXMuY3VzdG9tR3JhZGllbnREZXB0aCA9PT0gMDtcbiAgICAgICAgaWYgKHJlY29yZEtlcm5lbCkge1xuICAgICAgICAgICAgdmFyIHRhcGVOb2RlID0ge1xuICAgICAgICAgICAgICAgIGlkOiB0aGlzLm5leHRUYXBlTm9kZUlkKyssXG4gICAgICAgICAgICAgICAgbmFtZTogc2NvcGVOYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0czogaW5wdXRzLFxuICAgICAgICAgICAgICAgIG91dHB1dDogcmVzdWx0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChiYWNrd2FyZHNGdW5jICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXBlTm9kZS5ncmFkaWVudCA9IGZ1bmN0aW9uIChkeSkgeyByZXR1cm4gYmFja3dhcmRzRnVuYyhkeSwgc2F2ZWQpOyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXBlLnB1c2godGFwZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnJlZ2lzdGVyVGVuc29yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIHJlZkNvdW50ID0gdGhpcy5yZWZDb3VudGVyLmhhcyhhLmRhdGFJZCkgPyB0aGlzLnJlZkNvdW50ZXIuZ2V0KGEuZGF0YUlkKSA6IDA7XG4gICAgICAgIHRoaXMubnVtVGVuc29ycysrO1xuICAgICAgICBpZiAocmVmQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMrKztcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgKz1cbiAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZSkgKiB1dGlsLmJ5dGVzUGVyRWxlbWVudChhLmR0eXBlKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZC5yZWdpc3RlcihhLmRhdGFJZCwgYS5zaGFwZSwgYS5kdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWZDb3VudGVyLnNldChhLmRhdGFJZCwgcmVmQ291bnQgKyAxKTtcbiAgICAgICAgaWYgKCEoYSBpbnN0YW5jZW9mIHRlbnNvcl8xLlZhcmlhYmxlKSkge1xuICAgICAgICAgICAgdGhpcy50cmFjayhhKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5yZWdpc3RlclZhcmlhYmxlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgaWYgKHRoaXMucmVnaXN0ZXJlZFZhcmlhYmxlc1t2Lm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhcmlhYmxlIHdpdGggbmFtZSBcIiArIHYubmFtZSArIFwiIHdhcyBhbHJlYWR5IHJlZ2lzdGVyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWdpc3RlcmVkVmFyaWFibGVzW3YubmFtZV0gPSB2O1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5kaXNwb3NlVGVuc29yID0gZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlZkNvdW50ZXIuaGFzKGEuZGF0YUlkKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtVGVuc29ycy0tO1xuICAgICAgICB2YXIgcmVmQ291bnQgPSB0aGlzLnJlZkNvdW50ZXIuZ2V0KGEuZGF0YUlkKTtcbiAgICAgICAgaWYgKHJlZkNvdW50IDw9IDEpIHtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRlci5kZWxldGUoYS5kYXRhSWQpO1xuICAgICAgICAgICAgdGhpcy5iYWNrZW5kLmRpc3Bvc2VEYXRhKGEuZGF0YUlkKTtcbiAgICAgICAgICAgIHRoaXMubnVtRGF0YUJ1ZmZlcnMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtQnl0ZXMgLT1cbiAgICAgICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZSkgKiB1dGlsLmJ5dGVzUGVyRWxlbWVudChhLmR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVmQ291bnRlci5zZXQoYS5kYXRhSWQsIHJlZkNvdW50IC0gMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaW5mbyA9IHRoaXMuYmFja2VuZC5tZW1vcnkoKTtcbiAgICAgICAgaW5mby5udW1UZW5zb3JzID0gdGhpcy5udW1UZW5zb3JzO1xuICAgICAgICBpbmZvLm51bURhdGFCdWZmZXJzID0gdGhpcy5udW1EYXRhQnVmZmVycztcbiAgICAgICAgaW5mby5udW1CeXRlcyA9IHRoaXMubnVtQnl0ZXM7XG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5zaG91bGRSZWNvcmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVRhcGUgIT0gbnVsbCAmJiB0aGlzLmN1c3RvbUdyYWRpZW50RGVwdGggPT09IDA7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmFkZFRhcGVOb2RlID0gZnVuY3Rpb24gKGlucHV0cywgcmVzdWx0LCBncmFkaWVudHNGdW5jKSB7XG4gICAgICAgIHZhciBpbnB1dHNNYXAgPSB7fTtcbiAgICAgICAgaW5wdXRzLmZvckVhY2goZnVuY3Rpb24gKGlucHV0LCBpZHgpIHtcbiAgICAgICAgICAgIGlucHV0c01hcFtpZHhdID0gaW5wdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgZ3JhZGllbnQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBncmFkaWVudHNGdW5jKGR5KTtcbiAgICAgICAgICAgIHZhciByZXNNYXAgPSB7fTtcbiAgICAgICAgICAgIHJlcy5mb3JFYWNoKGZ1bmN0aW9uIChyLCBpZHgpIHtcbiAgICAgICAgICAgICAgICByZXNNYXBbaWR4XSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHI7IH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNNYXA7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0YXBlTm9kZSA9IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLm5leHRUYXBlTm9kZUlkKyssXG4gICAgICAgICAgICBuYW1lOiB0aGlzLmFjdGl2ZVNjb3BlLm5hbWUsXG4gICAgICAgICAgICBpbnB1dHM6IGlucHV0c01hcCxcbiAgICAgICAgICAgIG91dHB1dDogcmVzdWx0LFxuICAgICAgICAgICAgZ3JhZGllbnQ6IGdyYWRpZW50XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWN0aXZlVGFwZS5wdXNoKHRhcGVOb2RlKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUua2VlcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVTdGFjay5sZW5ndGggPT09IDEgJiYgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnNhZmVNb2RlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhZmUgbW9kZSBpcyBPTi4gRW5jbG9zZSBhbGwgdGVuc29yIG9wZXJhdGlvbnMgaW5zaWRlIGRsLnRpZHkoKTogJyArXG4gICAgICAgICAgICAgICAgJ2RsLnRpZHkoKCkgPT4gey4uLn0pIHRvIGF2b2lkIG1lbW9yeSBsZWFrcy4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlLmtlZXAucHVzaChyZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5zdGFydFNjb3BlID0gZnVuY3Rpb24gKG5hbWUsIGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUgPT09IHZvaWQgMCkgeyBncmFkaWVudHNNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUgJiYgdGhpcy5ncmFkaWVudFNjb3BlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFwZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmFkaWVudHNNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50U2NvcGVDb3VudCsrO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY29wZUluZm8gPSB7IGtlZXA6IFtdLCB0cmFjazogW10gfTtcbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHNjb3BlSW5mby5uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sucHVzaChzY29wZUluZm8pO1xuICAgICAgICB0aGlzLmFjdGl2ZVNjb3BlID0gc2NvcGVJbmZvO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5lbmRTY29wZSA9IGZ1bmN0aW9uIChyZXN1bHQsIGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUgPT09IHZvaWQgMCkgeyBncmFkaWVudHNNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKGdyYWRpZW50c01vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRTY29wZUNvdW50LS07XG4gICAgICAgICAgICBpZiAodGhpcy5ncmFkaWVudFNjb3BlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhcGUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciB0ZW5zb3JzVG9LZWVwID0gdGhpcy5hY3RpdmVTY29wZS5rZWVwO1xuICAgICAgICB2YXIgdGVuc29yc1RvVHJhY2tJblBhcmVudCA9IHV0aWwuZXh0cmFjdFRlbnNvcnNGcm9tQ29udGFpbmVyKHJlc3VsdCk7XG4gICAgICAgIHRlbnNvcnNUb0tlZXAgPSB0ZW5zb3JzVG9LZWVwLmNvbmNhdCh0ZW5zb3JzVG9UcmFja0luUGFyZW50KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmFjdGl2ZVNjb3BlLnRyYWNrLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdGVuc29yID0gdGhpcy5hY3RpdmVTY29wZS50cmFja1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVGVuc29ySW5MaXN0KHRlbnNvciwgdGVuc29yc1RvS2VlcCkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGl2ZVRhcGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRlbnNvcnNUb1RyYWNrSW5QYXJlbnQucHVzaCh0ZW5zb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGVuc29yLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjb3BlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMuYWN0aXZlU2NvcGUgPSB0aGlzLnNjb3BlU3RhY2subGVuZ3RoID09PSAwID9cbiAgICAgICAgICAgIHsga2VlcDogW10sIHRyYWNrOiBbXSB9IDpcbiAgICAgICAgICAgIHRoaXMuc2NvcGVTdGFja1t0aGlzLnNjb3BlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgICAgIHRlbnNvcnNUb1RyYWNrSW5QYXJlbnQuZm9yRWFjaChmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgICAgICBpZiAoIXV0aWwuaXNUZW5zb3JJbkxpc3QodGVuc29yLCBfdGhpcy5hY3RpdmVTY29wZS5rZWVwKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLnRyYWNrKHRlbnNvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXN0b21CYWNrZW5kKSB7XG4gICAgICAgICAgICB0aGlzLmJhY2tlbmQuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmdyYWRpZW50cyA9IGZ1bmN0aW9uIChmLCB4cywgZHksIGFsbG93Tm9HcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGFsbG93Tm9HcmFkaWVudHMgPT09IHZvaWQgMCkgeyBhbGxvd05vR3JhZGllbnRzID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeHMubGVuZ3RoID4gMCwgJ2dyYWRpZW50cygpIHJlY2VpdmVkIGFuIGVtcHR5IGxpc3Qgb2YgeHMuJyk7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeSgnZ3JhZGllbnRzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHkgPSBmKCk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh5IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIHJlc3VsdCB5IHJldHVybmVkIGJ5IGYoKSBtdXN0IGJlIGEgdGVuc29yLicpO1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkVGFwZSA9IHRhcGVfMS5nZXRGaWx0ZXJlZE5vZGVzWFRvWShfdGhpcy5hY3RpdmVUYXBlLCB4cywgeSk7XG4gICAgICAgICAgICBpZiAoIWFsbG93Tm9HcmFkaWVudHMgJiYgZmlsdGVyZWRUYXBlLmxlbmd0aCA9PT0gMCAmJiB4cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoYXQgdGhlIGYgeW91IHBhc3NlZCBlbmNsb3NlcyBhbGwgb3BlcmF0aW9ucyB0aGF0IGxlYWQgZnJvbSB4ICcgK1xuICAgICAgICAgICAgICAgICAgICAndG8geS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWRpZW50TWFwID0ge307XG4gICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50TWFwW3kuaWRdID0gKGR5ID09IG51bGwpID8gb3BzLm9uZXMoeS5zaGFwZSkgOiBkeTtcbiAgICAgICAgICAgIHRhcGVfMS5iYWNrcHJvcGFnYXRlR3JhZGllbnRzKGFjY3VtdWxhdGVkR3JhZGllbnRNYXAsIGZpbHRlcmVkVGFwZSk7XG4gICAgICAgICAgICB2YXIgZ3JhZHMgPSB4cy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF07IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHksIGdyYWRzOiBncmFkcyB9O1xuICAgICAgICB9LCB0cnVlKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUuY3VzdG9tR3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBpbnB1dHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXRzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1dGlsLmFzc2VydChpbnB1dHMuZXZlcnkoZnVuY3Rpb24gKHQpIHsgcmV0dXJuIHQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3I7IH0pLCAnVGhlIGFyZ3MgcGFzc2VkIGluIGN1c3RvbUdyYWQoZikoeDEsIHgyLC4uLikgbXVzdCBhbGwgYmUgdGVuc29ycycpO1xuICAgICAgICAgICAgX3RoaXMuY3VzdG9tR3JhZGllbnREZXB0aCsrO1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50c0Z1bmM7XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnRzTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2xvYmFsc18xLnRpZHkoZi5uYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hID0gZi5hcHBseSh2b2lkIDAsIGlucHV0cyksIHZhbHVlID0gX2EudmFsdWUsIGdyYWRGdW5jID0gX2EuZ3JhZEZ1bmM7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnQodmFsdWUgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLnZhbHVlYCBpcyBhIHRlbnNvcicpO1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihncmFkRnVuYyksICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uLicpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50c0Z1bmMgPSBncmFkRnVuYztcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCBncmFkaWVudHNNb2RlKTtcbiAgICAgICAgICAgIF90aGlzLmN1c3RvbUdyYWRpZW50RGVwdGgtLTtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zaG91bGRSZWNvcmQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gZ3JhZGllbnRzRnVuYyhkeSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmFkcyA9IEFycmF5LmlzQXJyYXkocmVzKSA/IHJlcyA6IFtyZXNdO1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydChncmFkcy5sZW5ndGggPT09IGlucHV0cy5sZW5ndGgsICdUaGUgZnVuY3Rpb24gZiBwYXNzZWQgaW4gY3VzdG9tR3JhZChmKSBtdXN0IHJldHVybiBhbiBvYmplY3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnd2hlcmUgYG9iai5ncmFkRnVuY2AgaXMgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHNhbWUgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnbnVtYmVyIG9mIHRlbnNvcnMgYXMgaW5wdXRzIHBhc3NlZCB0byBmKC4uLikuJyk7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGdyYWRzLmV2ZXJ5KGZ1bmN0aW9uICh0KSB7IHJldHVybiB0IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KSwgJ1RoZSBmdW5jdGlvbiBmIHBhc3NlZCBpbiBjdXN0b21HcmFkKGYpIG11c3QgcmV0dXJuIGFuIG9iamVjdCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd3aGVyZSBgb2JqLmdyYWRGdW5jYCBpcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGxpc3Qgb2YgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnb25seSB0ZW5zb3JzLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ3JhZHM7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGRUYXBlTm9kZShpbnB1dHMsIHJlc3VsdCwgZ3JhZEZ1bmMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kLndyaXRlKGRhdGFJZCwgdmFsdWVzKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUucmVhZFN5bmMgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJhY2tlbmQucmVhZFN5bmMoZGF0YUlkKTtcbiAgICB9O1xuICAgIEVuZ2luZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZC5yZWFkKGRhdGFJZCk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICByZXR1cm4gdGhpcy5iYWNrZW5kLmZyb21QaXhlbHMocGl4ZWxzLCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBFbmdpbmUucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0LCB0aW1pbmdJbmZvO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5iYWNrZW5kLnRpbWUocXVlcnkpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGltaW5nSW5mbyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWluZ0luZm8ud2FsbE1zID0gcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGltaW5nSW5mb107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRW5naW5lLnByb3RvdHlwZS50cmFjayA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMuc2NvcGVTdGFjay5sZW5ndGggPT09IDEgJiYgdGhpcy5zYWZlTW9kZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYWZlIG1vZGUgaXMgT04uIEVuY2xvc2UgYWxsIHRlbnNvciBvcGVyYXRpb25zIGluc2lkZSBkbC50aWR5KCk6ICcgK1xuICAgICAgICAgICAgICAgICdkbC50aWR5KCgpID0+IHtvcCgpOy4uLn0pOyB0byBhdm9pZCBtZW1vcnkgbGVha3MuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hY3RpdmVTY29wZS50cmFjay5wdXNoKHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gRW5naW5lO1xufSgpKTtcbmV4cG9ydHMuRW5naW5lID0gRW5naW5lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZGV2aWNlX3V0aWwgPSByZXF1aXJlKFwiLi9kZXZpY2VfdXRpbFwiKTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbnZhciBlbmdpbmVfMSA9IHJlcXVpcmUoXCIuL2VuZ2luZVwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFR5cGU7XG4oZnVuY3Rpb24gKFR5cGUpIHtcbiAgICBUeXBlW1R5cGVbXCJOVU1CRVJcIl0gPSAwXSA9IFwiTlVNQkVSXCI7XG4gICAgVHlwZVtUeXBlW1wiQk9PTEVBTlwiXSA9IDFdID0gXCJCT09MRUFOXCI7XG4gICAgVHlwZVtUeXBlW1wiU1RSSU5HXCJdID0gMl0gPSBcIlNUUklOR1wiO1xufSkoVHlwZSA9IGV4cG9ydHMuVHlwZSB8fCAoZXhwb3J0cy5UeXBlID0ge30pKTtcbmV4cG9ydHMuVVJMX1BST1BFUlRJRVMgPSBbXG4gICAgeyBuYW1lOiAnREVCVUcnLCB0eXBlOiBUeXBlLkJPT0xFQU4gfSxcbiAgICB7IG5hbWU6ICdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1JFTElBQkxFJywgdHlwZTogVHlwZS5CT09MRUFOIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfVkVSU0lPTicsIHR5cGU6IFR5cGUuTlVNQkVSIH0sXG4gICAgeyBuYW1lOiAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJywgdHlwZTogVHlwZS5CT09MRUFOIH0sIHtcbiAgICAgICAgbmFtZTogJ1dFQkdMX0dFVF9CVUZGRVJfU1VCX0RBVEFfQVNZTkNfRVhURU5TSU9OX0VOQUJMRUQnLFxuICAgICAgICB0eXBlOiBUeXBlLkJPT0xFQU5cbiAgICB9LFxuICAgIHsgbmFtZTogJ0JBQ0tFTkQnLCB0eXBlOiBUeXBlLlNUUklORyB9XG5dO1xuZnVuY3Rpb24gaGFzRXh0ZW5zaW9uKGdsLCBleHRlbnNpb25OYW1lKSB7XG4gICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTtcbiAgICByZXR1cm4gZXh0ICE9IG51bGw7XG59XG5mdW5jdGlvbiBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBnZXQgV2ViR0wgcmVuZGVyaW5nIGNvbnRleHQsIFdlYkdMIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgICB2YXIgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICh0ZW1wQ2FudmFzLmdldENvbnRleHQoJ3dlYmdsJykgfHxcbiAgICAgICAgICAgIHRlbXBDYW52YXMuZ2V0Q29udGV4dCgnZXhwZXJpbWVudGFsLXdlYmdsJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcENhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbDInKTtcbn1cbmZ1bmN0aW9uIGxvc2VDb250ZXh0KGdsKSB7XG4gICAgaWYgKGdsICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGxvc2VDb250ZXh0RXh0ZW5zaW9uID0gZ2wuZ2V0RXh0ZW5zaW9uKCdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGxvc2VDb250ZXh0RXh0ZW5zaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5zaW9uIFdFQkdMX2xvc2VfY29udGV4dCBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgfVxuICAgICAgICBsb3NlQ29udGV4dEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzV2ViR0xWZXJzaW9uRW5hYmxlZCh3ZWJHTFZlcnNpb24pIHtcbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRXZWJHTERpc2pvaW50UXVlcnlUaW1lclZlcnNpb24od2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIHF1ZXJ5VGltZXJWZXJzaW9uO1xuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmIChoYXNFeHRlbnNpb24oZ2wsICdFWFRfZGlzam9pbnRfdGltZXJfcXVlcnlfd2ViZ2wyJykgJiZcbiAgICAgICAgd2ViR0xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIHF1ZXJ5VGltZXJWZXJzaW9uID0gMjtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzRXh0ZW5zaW9uKGdsLCAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5JykpIHtcbiAgICAgICAgcXVlcnlUaW1lclZlcnNpb24gPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcXVlcnlUaW1lclZlcnNpb24gPSAwO1xuICAgIH1cbiAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICBsb3NlQ29udGV4dChnbCk7XG4gICAgfVxuICAgIHJldHVybiBxdWVyeVRpbWVyVmVyc2lvbjtcbn1cbmZ1bmN0aW9uIGlzRmxvYXRUZXh0dXJlUmVhZFBpeGVsc0VuYWJsZWQod2ViR0xWZXJzaW9uKSB7XG4gICAgaWYgKHdlYkdMVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBnbCA9IGdldFdlYkdMUmVuZGVyaW5nQ29udGV4dCh3ZWJHTFZlcnNpb24pO1xuICAgIGlmICh3ZWJHTFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgaWYgKCFoYXNFeHRlbnNpb24oZ2wsICdPRVNfdGV4dHVyZV9mbG9hdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghaGFzRXh0ZW5zaW9uKGdsLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZyYW1lQnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICB2YXIgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICB2YXIgaW50ZXJuYWxGb3JtYXQgPSB3ZWJHTFZlcnNpb24gPT09IDIgPyBnbC5SR0JBMzJGIDogZ2wuUkdCQTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGludGVybmFsRm9ybWF0LCAxLCAxLCAwLCBnbC5SR0JBLCBnbC5GTE9BVCwgbnVsbCk7XG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZUJ1ZmZlcik7XG4gICAgZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTtcbiAgICB2YXIgZnJhbWVCdWZmZXJDb21wbGV0ZSA9IChnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKSA9PT0gZ2wuRlJBTUVCVUZGRVJfQ09NUExFVEUpO1xuICAgIGdsLnJlYWRQaXhlbHMoMCwgMCwgMSwgMSwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG5ldyBGbG9hdDMyQXJyYXkoNCkpO1xuICAgIHZhciByZWFkUGl4ZWxzTm9FcnJvciA9IGdsLmdldEVycm9yKCkgPT09IGdsLk5PX0VSUk9SO1xuICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICByZXR1cm4gZnJhbWVCdWZmZXJDb21wbGV0ZSAmJiByZWFkUGl4ZWxzTm9FcnJvcjtcbn1cbmZ1bmN0aW9uIGlzV2ViR0xHZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb25FbmFibGVkKHdlYkdMVmVyc2lvbikge1xuICAgIGlmICh3ZWJHTFZlcnNpb24gIT09IDIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZ2wgPSBnZXRXZWJHTFJlbmRlcmluZ0NvbnRleHQod2ViR0xWZXJzaW9uKTtcbiAgICB2YXIgaXNFbmFibGVkID0gaGFzRXh0ZW5zaW9uKGdsLCAnV0VCR0xfZ2V0X2J1ZmZlcl9zdWJfZGF0YV9hc3luYycpO1xuICAgIGxvc2VDb250ZXh0KGdsKTtcbiAgICByZXR1cm4gaXNFbmFibGVkO1xufVxudmFyIFNVUFBPUlRFRF9CQUNLRU5EUyA9IFsnd2ViZ2wnLCAnY3B1J107XG52YXIgRW52aXJvbm1lbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVudmlyb25tZW50KGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMuZmVhdHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5CQUNLRU5EX1JFR0lTVFJZID0ge307XG4gICAgICAgIHRoaXMuYmFja2VuZHMgPSB0aGlzLkJBQ0tFTkRfUkVHSVNUUlk7XG4gICAgICAgIGlmIChmZWF0dXJlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZ2V0KCdERUJVRycpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlYnVnZ2luZyBtb2RlIGlzIE9OLiBUaGUgb3V0cHV0IG9mIGV2ZXJ5IG1hdGggY2FsbCB3aWxsICcgK1xuICAgICAgICAgICAgICAgICdiZSBkb3dubG9hZGVkIHRvIENQVSBhbmQgY2hlY2tlZCBmb3IgTmFOcy4gJyArXG4gICAgICAgICAgICAgICAgJ1RoaXMgc2lnbmlmaWNhbnRseSBpbXBhY3RzIHBlcmZvcm1hbmNlLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIEVudmlyb25tZW50LnNldEJhY2tlbmQgPSBmdW5jdGlvbiAoYmFja2VuZFR5cGUsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKCEoYmFja2VuZFR5cGUgaW4gZXhwb3J0cy5FTlYuYmFja2VuZHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZW5kIHR5cGUgJ1wiICsgYmFja2VuZFR5cGUgKyBcIicgbm90IGZvdW5kIGluIHJlZ2lzdHJ5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGV4cG9ydHMuRU5WLmdsb2JhbE1hdGggPSBuZXcgbWF0aF8xLk5EQXJyYXlNYXRoKGJhY2tlbmRUeXBlLCBzYWZlTW9kZSk7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5nZXRCYWNrZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBleHBvcnRzLkVOVi5pbml0RW5naW5lKCk7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkVOVi5jdXJyZW50QmFja2VuZFR5cGU7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5tZW1vcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLkVOVi5lbmdpbmUubWVtb3J5KCk7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUgaW4gdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZXNbZmVhdHVyZV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mZWF0dXJlc1tmZWF0dXJlXSA9IHRoaXMuZXZhbHVhdGVGZWF0dXJlKGZlYXR1cmUpO1xuICAgICAgICByZXR1cm4gdGhpcy5mZWF0dXJlc1tmZWF0dXJlXTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoZmVhdHVyZSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlc1tmZWF0dXJlXSA9IHZhbHVlO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmdldEJlc3RCYWNrZW5kVHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBTVVBQT1JURURfQkFDS0VORFMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBiYWNrZW5kSWQgPSBTVVBQT1JURURfQkFDS0VORFNbaV07XG4gICAgICAgICAgICBpZiAoYmFja2VuZElkIGluIHRoaXMuYmFja2VuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFja2VuZElkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gYmFja2VuZCBmb3VuZCBpbiByZWdpc3RyeS4nKTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5ldmFsdWF0ZUZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoZmVhdHVyZSA9PT0gJ0RFQlVHJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdCQUNLRU5EJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVzdEJhY2tlbmRUeXBlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykge1xuICAgICAgICAgICAgdmFyIHdlYkdMVmVyc2lvbiA9IHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJyk7XG4gICAgICAgICAgICBpZiAod2ViR0xWZXJzaW9uID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0V2ViR0xEaXNqb2ludFF1ZXJ5VGltZXJWZXJzaW9uKHdlYkdMVmVyc2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9SRUxJQUJMRScpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDAgJiZcbiAgICAgICAgICAgICAgICAhZGV2aWNlX3V0aWwuaXNNb2JpbGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmZWF0dXJlID09PSAnV0VCR0xfVkVSU0lPTicpIHtcbiAgICAgICAgICAgIGlmIChpc1dlYkdMVmVyc2lvbkVuYWJsZWQoMikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzV2ViR0xWZXJzaW9uRW5hYmxlZCgxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmVhdHVyZSA9PT0gJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0Zsb2F0VGV4dHVyZVJlYWRQaXhlbHNFbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZlYXR1cmUgPT09ICdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykge1xuICAgICAgICAgICAgcmV0dXJuIGlzV2ViR0xHZXRCdWZmZXJTdWJEYXRhQXN5bmNFeHRlbnNpb25FbmFibGVkKHRoaXMuZ2V0KCdXRUJHTF9WRVJTSU9OJykpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZmVhdHVyZSBcIiArIGZlYXR1cmUgKyBcIi5cIik7XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuc2V0RmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICB0aGlzLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgICAgIHRoaXMuYmFja2VuZHMgPSB7fTtcbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IGdldEZlYXR1cmVzRnJvbVVSTCgpO1xuICAgICAgICBpZiAodGhpcy5nbG9iYWxNYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTWF0aC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbE1hdGggPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxFbmdpbmUgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmJhY2tlbmRzICE9PSB0aGlzLkJBQ0tFTkRfUkVHSVNUUlkpIHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVfMSBpbiB0aGlzLmJhY2tlbmRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5iYWNrZW5kc1tuYW1lXzFdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmFja2VuZHMgPSB0aGlzLkJBQ0tFTkRfUkVHSVNUUlk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEVudmlyb25tZW50LnByb3RvdHlwZS5zZXRNYXRoID0gZnVuY3Rpb24gKG1hdGgsIGJhY2tlbmQsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsTWF0aCA9PT0gbWF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjdXN0b21CYWNrZW5kID0gZmFsc2U7XG4gICAgICAgIGlmICh0eXBlb2YgYmFja2VuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEJhY2tlbmRUeXBlID0gYmFja2VuZDtcbiAgICAgICAgICAgIGJhY2tlbmQgPSBleHBvcnRzLkVOVi5maW5kQmFja2VuZChiYWNrZW5kKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGN1c3RvbUJhY2tlbmQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QmFja2VuZFR5cGUgPSAnY3VzdG9tJztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdsb2JhbEVuZ2luZSA9IG5ldyBlbmdpbmVfMS5FbmdpbmUoYmFja2VuZCwgY3VzdG9tQmFja2VuZCwgc2FmZU1vZGUpO1xuICAgICAgICB0aGlzLmdsb2JhbE1hdGggPSBtYXRoO1xuICAgIH07XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmZpbmRCYWNrZW5kID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFja2VuZHNbbmFtZV07XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUuYWRkQ3VzdG9tQmFja2VuZCA9IGZ1bmN0aW9uIChuYW1lLCBmYWN0b3J5KSB7XG4gICAgICAgIGlmIChuYW1lIGluIHRoaXMuYmFja2VuZHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihuYW1lICsgXCIgYmFja2VuZCB3YXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgYmFja2VuZCA9IGZhY3RvcnkoKTtcbiAgICAgICAgICAgIHRoaXMuYmFja2VuZHNbbmFtZV0gPSBiYWNrZW5kO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBFbnZpcm9ubWVudC5wcm90b3R5cGUucmVnaXN0ZXJCYWNrZW5kID0gZnVuY3Rpb24gKG5hbWUsIGZhY3RvcnkpIHtcbiAgICAgICAgaWYgKG5hbWUgaW4gdGhpcy5CQUNLRU5EX1JFR0lTVFJZKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobmFtZSArIFwiIGJhY2tlbmQgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCBhcyBnbG9iYWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBiYWNrZW5kID0gZmFjdG9yeSgpO1xuICAgICAgICAgICAgdGhpcy5CQUNLRU5EX1JFR0lTVFJZW25hbWVdID0gYmFja2VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVudmlyb25tZW50LnByb3RvdHlwZSwgXCJtYXRoXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRFbmdpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbE1hdGg7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFbnZpcm9ubWVudC5wcm90b3R5cGUsIFwiZW5naW5lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmluaXRFbmdpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdsb2JhbEVuZ2luZTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgRW52aXJvbm1lbnQucHJvdG90eXBlLmluaXRFbmdpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmdsb2JhbEVuZ2luZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbE1hdGggPVxuICAgICAgICAgICAgICAgIG5ldyBtYXRoXzEuTkRBcnJheU1hdGgoZXhwb3J0cy5FTlYuZ2V0KCdCQUNLRU5EJyksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdFbnZpcm9ubWVudCcgfSlcbiAgICBdLCBFbnZpcm9ubWVudCwgXCJzZXRCYWNrZW5kXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnRW52aXJvbm1lbnQnIH0pXG4gICAgXSwgRW52aXJvbm1lbnQsIFwiZ2V0QmFja2VuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ01lbW9yeScgfSlcbiAgICBdLCBFbnZpcm9ubWVudCwgXCJtZW1vcnlcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEVudmlyb25tZW50O1xufSgpKTtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBFbnZpcm9ubWVudDtcbnZhciBERUVQTEVBUk5KU19GTEFHU19QUkVGSVggPSAnZGxqc2ZsYWdzJztcbmZ1bmN0aW9uIGdldEZlYXR1cmVzRnJvbVVSTCgpIHtcbiAgICB2YXIgZmVhdHVyZXMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICB2YXIgdXJsUGFyYW1zID0gdXRpbC5nZXRRdWVyeVBhcmFtcyh3aW5kb3cubG9jYXRpb24uc2VhcmNoKTtcbiAgICBpZiAoREVFUExFQVJOSlNfRkxBR1NfUFJFRklYIGluIHVybFBhcmFtcykge1xuICAgICAgICB2YXIgdXJsRmxhZ3NfMSA9IHt9O1xuICAgICAgICB2YXIga2V5VmFsdWVzID0gdXJsUGFyYW1zW0RFRVBMRUFSTkpTX0ZMQUdTX1BSRUZJWF0uc3BsaXQoJywnKTtcbiAgICAgICAga2V5VmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKGtleVZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgX2EgPSBrZXlWYWx1ZS5zcGxpdCgnOicpLCBrZXkgPSBfYVswXSwgdmFsdWUgPSBfYVsxXTtcbiAgICAgICAgICAgIHVybEZsYWdzXzFba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgZXhwb3J0cy5VUkxfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uICh1cmxQcm9wZXJ0eSkge1xuICAgICAgICAgICAgaWYgKHVybFByb3BlcnR5Lm5hbWUgaW4gdXJsRmxhZ3NfMSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2V0dGluZyBmZWF0dXJlIG92ZXJyaWRlIGZyb20gVVJMIFwiICsgdXJsUHJvcGVydHkubmFtZSArIFwiOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIlwiICsgdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXSkpO1xuICAgICAgICAgICAgICAgIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLk5VTUJFUikge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc1t1cmxQcm9wZXJ0eS5uYW1lXSA9ICt1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1cmxQcm9wZXJ0eS50eXBlID09PSBUeXBlLkJPT0xFQU4pIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZXNbdXJsUHJvcGVydHkubmFtZV0gPSB1cmxGbGFnc18xW3VybFByb3BlcnR5Lm5hbWVdID09PSAndHJ1ZSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHVybFByb3BlcnR5LnR5cGUgPT09IFR5cGUuU1RSSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzW3VybFByb3BlcnR5Lm5hbWVdID0gdXJsRmxhZ3NfMVt1cmxQcm9wZXJ0eS5uYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gVVJMIHBhcmFtOiBcIiArIHVybFByb3BlcnR5Lm5hbWUgKyBcIi5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuZnVuY3Rpb24gZ2V0R2xvYmFsTmFtZXNwYWNlKCkge1xuICAgIHZhciBucztcbiAgICBpZiAodHlwZW9mICh3aW5kb3cpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBucyA9IHdpbmRvdztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChnbG9iYWwpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBucyA9IGdsb2JhbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYSBnbG9iYWwgb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBucztcbn1cbmZ1bmN0aW9uIGdldE9yTWFrZUVudmlyb25tZW50KCkge1xuICAgIHZhciBucyA9IGdldEdsb2JhbE5hbWVzcGFjZSgpO1xuICAgIG5zLkVOViA9IG5zLkVOViB8fCBuZXcgRW52aXJvbm1lbnQoZ2V0RmVhdHVyZXNGcm9tVVJMKCkpO1xuICAgIHJldHVybiBucy5FTlY7XG59XG5leHBvcnRzLkVOViA9IGdldE9yTWFrZUVudmlyb25tZW50KCk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBncmFkaWVudHNfMSA9IHJlcXVpcmUoXCIuL2dyYWRpZW50c1wiKTtcbnZhciB0cmFja2luZ18xID0gcmVxdWlyZShcIi4vdHJhY2tpbmdcIik7XG5leHBvcnRzLnRpZHkgPSB0cmFja2luZ18xLlRyYWNraW5nLnRpZHk7XG5leHBvcnRzLmtlZXAgPSB0cmFja2luZ18xLlRyYWNraW5nLmtlZXA7XG5leHBvcnRzLmRpc3Bvc2UgPSB0cmFja2luZ18xLlRyYWNraW5nLmRpc3Bvc2U7XG5leHBvcnRzLnRpbWUgPSB0cmFja2luZ18xLlRyYWNraW5nLnRpbWU7XG5leHBvcnRzLmdyYWQgPSBncmFkaWVudHNfMS5HcmFkaWVudHMuZ3JhZDtcbmV4cG9ydHMudmFsdWVBbmRHcmFkID0gZ3JhZGllbnRzXzEuR3JhZGllbnRzLnZhbHVlQW5kR3JhZDtcbmV4cG9ydHMuZ3JhZHMgPSBncmFkaWVudHNfMS5HcmFkaWVudHMuZ3JhZHM7XG5leHBvcnRzLnZhbHVlQW5kR3JhZHMgPSBncmFkaWVudHNfMS5HcmFkaWVudHMudmFsdWVBbmRHcmFkcztcbmV4cG9ydHMudmFyaWFibGVHcmFkcyA9IGdyYWRpZW50c18xLkdyYWRpZW50cy52YXJpYWJsZUdyYWRzO1xuZXhwb3J0cy5jdXN0b21HcmFkID0gZ3JhZGllbnRzXzEuR3JhZGllbnRzLmN1c3RvbUdyYWQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBHcmFkaWVudHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYWRpZW50cygpIHtcbiAgICB9XG4gICAgR3JhZGllbnRzLmdyYWRTY29wZSA9IGZ1bmN0aW9uIChuYW1lT3JTY29wZUZuLCBzY29wZUZuKSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShuYW1lT3JTY29wZUZuLCBzY29wZUZuLCB0cnVlKTtcbiAgICB9O1xuICAgIEdyYWRpZW50cy5ncmFkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGYpLCAnVGhlIGYgcGFzc2VkIGluIGdyYWQoZikgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoeCwgZHkpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHggaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IsICdUaGUgeCBwYXNzZWQgaW4gZ3JhZChmKSh4KSBtdXN0IGJlIGEgdGVuc29yJyk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChkeSA9PSBudWxsIHx8IGR5IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIGR5IHBhc3NlZCBpbiBncmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yJyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoeCk7IH0sIFt4XSwgZHkpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICAgICAgaWYgKGR5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKHZhbHVlLnNoYXBlLCBkeS5zaGFwZSwgJ1RoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gZ3JhZChmKSh4LCBkeSkgbXVzdCBtYXRjaCB0aGUgc2hhcGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdyZXR1cm5lZCBieSBmKHgpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICBjaGVja0dyYWRzKGdyYWRzKTtcbiAgICAgICAgICAgIHJldHVybiBncmFkc1swXTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIEdyYWRpZW50cy5ncmFkcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiBncmFkcyhmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhcmdzLCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmV2ZXJ5KGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIGFyZyBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcjsgfSksICdUaGUgYXJncyBwYXNzZWQgaW4gZ3JhZHMoZikoYXJncykgbXVzdCBiZSBhbiBhcnJheSBvZiB0ZW5zb3JzJyk7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChkeSA9PSBudWxsIHx8IGR5IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yLCAnVGhlIGR5IHBhc3NlZCBpbiBncmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdmFyIF9hID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmdyYWRpZW50cyhmdW5jdGlvbiAoKSB7IHJldHVybiBmLmFwcGx5KHZvaWQgMCwgYXJncyk7IH0sIGFyZ3MsIGR5KSwgdmFsdWUgPSBfYS52YWx1ZSwgZ3JhZHMgPSBfYS5ncmFkcztcbiAgICAgICAgICAgIGlmIChkeSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh2YWx1ZS5zaGFwZSwgZHkuc2hhcGUsICdUaGUgc2hhcGUgb2YgZHkgcGFzc2VkIGluIGdyYWRzKGYpKFt4MSwuLi5dLCBkeSkgbXVzdCBtYXRjaCB0aGUgJyArXG4gICAgICAgICAgICAgICAgICAgICdzaGFwZSByZXR1cm5lZCBieSBmKFt4MSwuLi5dKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgY2hlY2tHcmFkcyhncmFkcyk7XG4gICAgICAgICAgICByZXR1cm4gZ3JhZHM7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFsdWVBbmRHcmFkID0gZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0Z1bmN0aW9uKGYpLCAnVGhlIGYgcGFzc2VkIGluIHZhbHVlQW5kR3JhZChmKSBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh4LCBkeSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoeCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSB4IHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWQoZikoeCkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZHkgPT0gbnVsbCB8fCBkeSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkKGYpKHgsIGR5KSBtdXN0IGJlIGEgdGVuc29yJyk7XG4gICAgICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGZ1bmN0aW9uICgpIHsgcmV0dXJuIGYoeCk7IH0sIFt4XSwgZHkpLCBncmFkcyA9IF9hLmdyYWRzLCB2YWx1ZSA9IF9hLnZhbHVlO1xuICAgICAgICAgICAgY2hlY2tHcmFkcyhncmFkcyk7XG4gICAgICAgICAgICByZXR1cm4geyBncmFkOiBncmFkc1swXSwgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFsdWVBbmRHcmFkcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFyZ3MsIGR5KSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MuZXZlcnkoZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gYXJnIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KSwgJ1RoZSBhcmdzIHBhc3NlZCBpbiB2YWx1ZUFuZEdyYWRzKGYpKGFyZ3MpIG11c3QgYmUgYXJyYXkgb2YgdGVuc29ycycpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoZHkgPT0gbnVsbCB8fCBkeSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvciwgJ1RoZSBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShhcmdzLCBkeSkgbXVzdCBiZSBhIHRlbnNvcicpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ncmFkaWVudHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gZi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9LCBhcmdzLCBkeSk7XG4gICAgICAgICAgICBpZiAoZHkgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gocmVzLnZhbHVlLnNoYXBlLCBkeS5zaGFwZSwgJ1RoZSBzaGFwZSBvZiBkeSBwYXNzZWQgaW4gdmFsdWVBbmRHcmFkcyhmKShbeDEsLi4uXSwgZHkpIG11c3QgJyArXG4gICAgICAgICAgICAgICAgICAgICdtYXRjaCB0aGUgc2hhcGUgcmV0dXJuZWQgYnkgZihbeDEsLi4uXSknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoZWNrR3JhZHMocmVzLmdyYWRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMudmFyaWFibGVHcmFkcyA9IGZ1bmN0aW9uIChmLCB2YXJMaXN0KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNGdW5jdGlvbihmKSwgJ1RoZSBmIHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYpIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICB1dGlsLmFzc2VydCh2YXJMaXN0ID09IG51bGwgfHxcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkodmFyTGlzdCkgJiYgdmFyTGlzdC5ldmVyeShmdW5jdGlvbiAodikgeyByZXR1cm4gdiBpbnN0YW5jZW9mIHRlbnNvcl8xLlZhcmlhYmxlOyB9KSwgJ1RoZSB2YXJMaXN0IHBhc3NlZCBpbiB2YXJpYWJsZUdyYWRzKGYsIHZhckxpc3QpIG11c3QgYmUgYW4gYXJyYXkgJyArXG4gICAgICAgICAgICAnb2YgdmFyaWFibGVzJyk7XG4gICAgICAgIGlmICh2YXJMaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhckxpc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIHZhck5hbWUgaW4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXJMaXN0LnB1c2goZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvcmlnaW5hbFZhckNvdW50ID0gdmFyTGlzdC5sZW5ndGg7XG4gICAgICAgIHZhckxpc3QgPSB2YXJMaXN0LmZpbHRlcihmdW5jdGlvbiAodmFyaWFibGUpIHsgcmV0dXJuIHZhcmlhYmxlLnRyYWluYWJsZTsgfSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhckxpc3QubGVuZ3RoID4gMCwgXCJ2YXJpYWJsZUdyYWRzKCkgZXhwZWN0cyBhdCBsZWFzdCBvbmUgb2YgdGhlIGlucHV0IHZhcmlhYmxlcyB0byBiZSBcIiArXG4gICAgICAgICAgICAoXCJ0cmFpbmFibGUsIGJ1dCBub25lIG9mIHRoZSBcIiArIG9yaWdpbmFsVmFyQ291bnQgKyBcIiB2YXJpYWJsZXMgaXMgXCIpICtcbiAgICAgICAgICAgIFwidHJhaW5hYmxlLlwiKTtcbiAgICAgICAgdmFyIGFsbG93Tm9HcmFkaWVudHMgPSB0cnVlO1xuICAgICAgICB2YXIgX2EgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuZ3JhZGllbnRzKGYsIHZhckxpc3QsIG51bGwsIGFsbG93Tm9HcmFkaWVudHMpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICB1dGlsLmFzc2VydChncmFkcy5zb21lKGZ1bmN0aW9uIChnKSB7IHJldHVybiBnICE9IG51bGw7IH0pLCAnQ2Fubm90IGZpbmQgYSBjb25uZWN0aW9uIGJldHdlZW4gYW55IHZhcmlhYmxlIGFuZCB0aGUgcmVzdWx0IG9mIHRoZSAnICtcbiAgICAgICAgICAgICdsb3NzIGZ1bmN0aW9uIHk9Zih4KS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgb3BlcmF0aW9ucyB0aGF0IHVzZSAnICtcbiAgICAgICAgICAgICd2YXJpYWJsZXMgYXJlIGluc2lkZSB0aGUgZnVuY3Rpb24gZiBwYXNzZWQgdG8gbWluaW1pemUoKS4nKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodmFsdWUucmFuayA9PT0gMCwgXCJUaGUgZiBwYXNzZWQgaW4gdmFyaWFibGVHcmFkcyhmKSBtdXN0IHJldHVybiBhIHNjYWxhciwgYnV0IGl0IFwiICtcbiAgICAgICAgICAgIChcInJldHVybmVkIGEgcmFuay1cIiArIHZhbHVlLnJhbmsgKyBcIiB0ZW5zb3JcIikpO1xuICAgICAgICB2YXIgbmFtZWRHcmFkcyA9IHt9O1xuICAgICAgICB2YXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKHYsIGkpIHtcbiAgICAgICAgICAgIGlmIChncmFkc1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbmFtZWRHcmFkc1t2Lm5hbWVdID0gZ3JhZHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRzOiBuYW1lZEdyYWRzIH07XG4gICAgfTtcbiAgICBHcmFkaWVudHMuY3VzdG9tR3JhZCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuY3VzdG9tR3JhZChmKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJncmFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJncmFkc1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ0dyYWRpZW50cycgfSlcbiAgICBdLCBHcmFkaWVudHMsIFwidmFsdWVBbmRHcmFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJ2YWx1ZUFuZEdyYWRzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJ2YXJpYWJsZUdyYWRzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnR3JhZGllbnRzJyB9KVxuICAgIF0sIEdyYWRpZW50cywgXCJjdXN0b21HcmFkXCIsIG51bGwpO1xuICAgIHJldHVybiBHcmFkaWVudHM7XG59KCkpO1xuZXhwb3J0cy5HcmFkaWVudHMgPSBHcmFkaWVudHM7XG5mdW5jdGlvbiBjaGVja0dyYWRzKGdyYWRzKSB7XG4gICAgdmFyIG51bU51bGxHcmFkaWVudHMgPSBncmFkcy5maWx0ZXIoZnVuY3Rpb24gKGcpIHsgcmV0dXJuIGcgPT0gbnVsbDsgfSkubGVuZ3RoO1xuICAgIGlmIChudW1OdWxsR3JhZGllbnRzID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudCBvZiB5PWYoeCkgd2l0aCByZXNwZWN0IHRvIHguIE1ha2Ugc3VyZSB0aGF0XFxuICAgIHRoZSBmIHlvdSBwYXNzZWQgZW5jbG9zZXMgYWxsIG9wZXJhdGlvbnMgdGhhdCBsZWFkIGZyb20geCB0byB5LlwiKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgVGFuSEZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRhbkhGdW5jKCkge1xuICAgICAgICB0aGlzLm9uZSA9IHRlbnNvcl8xLlNjYWxhci5uZXcoMSk7XG4gICAgfVxuICAgIFRhbkhGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC50YW5oKHgpO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeVNxdWFyZWQgPSBtYXRoLm11bHRpcGx5U3RyaWN0KHksIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCB5U3F1YXJlZCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGFuSEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIHJldHVybiBUYW5IRnVuYztcbn0oKSk7XG5leHBvcnRzLlRhbkhGdW5jID0gVGFuSEZ1bmM7XG52YXIgUmVMVUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlTFVGdW5jKCkge1xuICAgIH1cbiAgICBSZUxVRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgucmVsdSh4KTtcbiAgICB9O1xuICAgIFJlTFVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5zdGVwKHgpO1xuICAgIH07XG4gICAgUmVMVUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIFJlTFVGdW5jO1xufSgpKTtcbmV4cG9ydHMuUmVMVUZ1bmMgPSBSZUxVRnVuYztcbnZhciBMZWFreVJlbHVGdW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMZWFreVJlbHVGdW5jKGFscGhhKSB7XG4gICAgICAgIHRoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICB9XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubGVha3lSZWx1KHgsIHRoaXMuYWxwaGEpO1xuICAgIH07XG4gICAgTGVha3lSZWx1RnVuYy5wcm90b3R5cGUuZGVyID0gZnVuY3Rpb24gKG1hdGgsIHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGguc3RlcCh4LCB0aGlzLmFscGhhKTtcbiAgICB9O1xuICAgIExlYWt5UmVsdUZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgcmV0dXJuIExlYWt5UmVsdUZ1bmM7XG59KCkpO1xuZXhwb3J0cy5MZWFreVJlbHVGdW5jID0gTGVha3lSZWx1RnVuYztcbnZhciBTaWdtb2lkRnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2lnbW9pZEZ1bmMoKSB7XG4gICAgfVxuICAgIFNpZ21vaWRGdW5jLnByb3RvdHlwZS5vdXRwdXQgPSBmdW5jdGlvbiAobWF0aCwgeCkge1xuICAgICAgICByZXR1cm4gbWF0aC5zaWdtb2lkKHgpO1xuICAgIH07XG4gICAgU2lnbW9pZEZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgeVNxdWFyZWQgPSBtYXRoLm11bHRpcGx5U3RyaWN0KHksIHkpO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGguc3ViU3RyaWN0KHksIHlTcXVhcmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTaWdtb2lkRnVuYy5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gU2lnbW9pZEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TaWdtb2lkRnVuYyA9IFNpZ21vaWRGdW5jO1xudmFyIFNxdWFyZUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNxdWFyZUZ1bmMoKSB7XG4gICAgICAgIHRoaXMudHdvID0gdGVuc29yXzEuU2NhbGFyLm5ldygyKTtcbiAgICB9XG4gICAgU3F1YXJlRnVuYy5wcm90b3R5cGUub3V0cHV0ID0gZnVuY3Rpb24gKG1hdGgsIHgpIHtcbiAgICAgICAgcmV0dXJuIG1hdGgubXVsdGlwbHlTdHJpY3QoeCwgeCk7XG4gICAgfTtcbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAobWF0aCwgeCwgeSkge1xuICAgICAgICByZXR1cm4gbWF0aC5tdWx0aXBseSh0aGlzLnR3bywgeCk7XG4gICAgfTtcbiAgICBTcXVhcmVGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnR3by5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlRnVuYztcbn0oKSk7XG5leHBvcnRzLlNxdWFyZUZ1bmMgPSBTcXVhcmVGdW5jO1xudmFyIEVsdUZ1bmMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEVsdUZ1bmMoKSB7XG4gICAgfVxuICAgIEVsdUZ1bmMucHJvdG90eXBlLm91dHB1dCA9IGZ1bmN0aW9uIChtYXRoLCB4KSB7XG4gICAgICAgIHJldHVybiBtYXRoLmVsdSh4KTtcbiAgICB9O1xuICAgIEVsdUZ1bmMucHJvdG90eXBlLmRlciA9IGZ1bmN0aW9uIChtYXRoLCB4LCB5KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICBFbHVGdW5jLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBFbHVGdW5jO1xufSgpKTtcbmV4cG9ydHMuRWx1RnVuYyA9IEVsdUZ1bmM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBTcXVhcmVDb3N0RnVuYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3F1YXJlQ29zdEZ1bmMoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZSA9IGdsb2JhbHNfMS5rZWVwKG9wcy5zY2FsYXIoMC41KSk7XG4gICAgfVxuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5jb3N0ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICB2YXIgZGlmZiA9IHgxLnN1YlN0cmljdCh4Mik7XG4gICAgICAgIHZhciBkaWZmU3F1YXJlZCA9IGRpZmYuc3F1YXJlKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmhhbGZPbmUubXVsKGRpZmZTcXVhcmVkKTtcbiAgICAgICAgZGlmZi5kaXNwb3NlKCk7XG4gICAgICAgIGRpZmZTcXVhcmVkLmRpc3Bvc2UoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFNxdWFyZUNvc3RGdW5jLnByb3RvdHlwZS5kZXIgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB4MS5zdWJTdHJpY3QoeDIpO1xuICAgIH07XG4gICAgU3F1YXJlQ29zdEZ1bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGFsZk9uZS5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gU3F1YXJlQ29zdEZ1bmM7XG59KCkpO1xuZXhwb3J0cy5TcXVhcmVDb3N0RnVuYyA9IFNxdWFyZUNvc3RGdW5jO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvY29uY2F0X3V0aWxcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uL29wcy9jb252X3V0aWxcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuL2luaXRpYWxpemVyc1wiKTtcbnZhciBHcmFwaExheWVycyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhMYXllcnMoZykge1xuICAgICAgICB0aGlzLmcgPSBnO1xuICAgIH1cbiAgICBHcmFwaExheWVycy5wcm90b3R5cGUuZGVuc2UgPSBmdW5jdGlvbiAobmFtZSwgeCwgdW5pdHMsIGFjdGl2YXRpb24sIHVzZUJpYXMsIGtlcm5lbEluaXRpYWxpemVyLCBiaWFzSW5pdGlhbGl6ZXIpIHtcbiAgICAgICAgaWYgKGFjdGl2YXRpb24gPT09IHZvaWQgMCkgeyBhY3RpdmF0aW9uID0gbnVsbDsgfVxuICAgICAgICBpZiAodXNlQmlhcyA9PT0gdm9pZCAwKSB7IHVzZUJpYXMgPSB0cnVlOyB9XG4gICAgICAgIGlmIChrZXJuZWxJbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IGtlcm5lbEluaXRpYWxpemVyID0gbmV3IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyKCk7IH1cbiAgICAgICAgaWYgKGJpYXNJbml0aWFsaXplciA9PT0gdm9pZCAwKSB7IGJpYXNJbml0aWFsaXplciA9IG5ldyBpbml0aWFsaXplcnNfMS5aZXJvc0luaXRpYWxpemVyKCk7IH1cbiAgICAgICAgdmFyIHdlaWdodHMgPSB0aGlzLmcudmFyaWFibGUobmFtZSArICctd2VpZ2h0cycsIGtlcm5lbEluaXRpYWxpemVyLmluaXRpYWxpemUoW3guc2hhcGVbMF0sIHVuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcbiAgICAgICAgdmFyIG91dCA9IHRoaXMuZy5tYXRtdWwoeCwgd2VpZ2h0cyk7XG4gICAgICAgIGlmICh1c2VCaWFzKSB7XG4gICAgICAgICAgICB2YXIgYmlhcyA9IHRoaXMuZy52YXJpYWJsZShuYW1lICsgJy1iaWFzJywgYmlhc0luaXRpYWxpemVyLmluaXRpYWxpemUoW3VuaXRzXSwgeC5zaGFwZVswXSwgdW5pdHMpKTtcbiAgICAgICAgICAgIG91dCA9IHRoaXMuZy5hZGQob3V0LCBiaWFzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgICBvdXQgPSBhY3RpdmF0aW9uKG91dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9O1xuICAgIHJldHVybiBHcmFwaExheWVycztcbn0oKSk7XG5leHBvcnRzLkdyYXBoTGF5ZXJzID0gR3JhcGhMYXllcnM7XG52YXIgR3JhcGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdyYXBoKCkge1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMubGF5ZXJzID0gbmV3IEdyYXBoTGF5ZXJzKHRoaXMpO1xuICAgIH1cbiAgICBHcmFwaC5wcm90b3R5cGUudmFyaWFibGUgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBWYXJpYWJsZU5vZGUodGhpcywgbmFtZSwgZGF0YSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnBsYWNlaG9sZGVyID0gZnVuY3Rpb24gKG5hbWUsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFBsYWNlaG9sZGVyTm9kZSh0aGlzLCBuYW1lLCBzaGFwZSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbnN0YW50ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBmaW5hbFZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHRlbnNvcl8xLlNjYWxhci5uZXcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgICAgICBmaW5hbFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgdmFyIGZsYXRWYWx1ZXMgPSB1dGlsLmZsYXR0ZW4odmFsdWUpO1xuICAgICAgICAgICAgdmFyIHZhbHMgPSBuZXcgRmxvYXQzMkFycmF5KGZsYXRWYWx1ZXMpO1xuICAgICAgICAgICAgZmluYWxWYWx1ZSA9IHRlbnNvcl8xLlRlbnNvci5tYWtlKHV0aWwuaW5mZXJTaGFwZSh2YWx1ZSksIHsgdmFsdWVzOiB2YWxzIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmltcGxlbWVudGVkIGNvbnN0YW50IHR5cGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uc3RhbnROb2RlKHRoaXMsIGZpbmFsVmFsdWUpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5yZXNoYXBlID0gZnVuY3Rpb24gKHgsIHNoYXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlc2hhcGVOb2RlKHRoaXMsICdSZXNoYXBlJywgeCwgc2hhcGUpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5mdXNlZExpbmVhckNvbWJpbmF0aW9uID0gZnVuY3Rpb24gKHgxLCB4MiwgYzEsIGMyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlKHRoaXMsIHgxLCB4MiwgYzEsIGMyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBZGROb2RlKHRoaXMsIHgxLCB4MikpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTdWJ0cmFjdE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE11bHRpcGx5Tm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IERpdmlkZU5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVkdWNlU3VtID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgUmVkdWNlU3VtTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uY2F0MWQgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbmNhdDFETm9kZSh0aGlzLCB4MSwgeDIpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5jb25jYXQyZCA9IGZ1bmN0aW9uICh4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgQ29uY2F0MkROb2RlKHRoaXMsIHgxLCB4MiwgYXhpcykpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmNvbmNhdDNkID0gZnVuY3Rpb24gKHgxLCB4MiwgYXhpcykge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb25jYXQzRE5vZGUodGhpcywgeDEsIHgyLCBheGlzKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29uY2F0NGQgPSBmdW5jdGlvbiAoeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IENvbmNhdDRETm9kZSh0aGlzLCB4MSwgeDIsIGF4aXMpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tYXRtdWwgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1hdE11bE5vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKHgsIHcsIGIsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBDb252b2x1dGlvbjJETm9kZSh0aGlzLCB4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5tYXhQb29sID0gZnVuY3Rpb24gKHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1heFBvb2xOb2RlKHRoaXMsIHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZXhwID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgRXhwTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTG9nTm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUucmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFJlTFVOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgTGVha3lSZUxVTm9kZSh0aGlzLCB4LCBhbHBoYSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnByZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFBSZUxVTm9kZSh0aGlzLCB4LCBhbHBoYSkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEVsdU5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBUYW5ITm9kZSh0aGlzLCB4KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IFNpZ21vaWROb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTcXVhcmVOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5zb2Z0bWF4ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRkTm9kZUFuZFJldHVybk91dHB1dChuZXcgU29mdG1heE5vZGUodGhpcywgeCkpO1xuICAgIH07XG4gICAgR3JhcGgucHJvdG90eXBlLnNvZnRtYXhDcm9zc0VudHJvcHlDb3N0ID0gZnVuY3Rpb24gKHgsIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUodGhpcywgeCwgdGFyZ2V0KSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUubWVhblNxdWFyZWRDb3N0ID0gZnVuY3Rpb24gKGxhYmVsLCBwcmVkaWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IE1lYW5TcXVhcmVkQ29zdE5vZGUodGhpcywgbGFiZWwsIHByZWRpY3Rpb24pKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hcmdtYXggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGROb2RlQW5kUmV0dXJuT3V0cHV0KG5ldyBBcmdNYXhOb2RlKHRoaXMsIHgpKTtcbiAgICB9O1xuICAgIEdyYXBoLnByb3RvdHlwZS5hcmdtYXhFcXVhbHMgPSBmdW5jdGlvbiAoeDEsIHgyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZE5vZGVBbmRSZXR1cm5PdXRwdXQobmV3IEFyZ01heEVxdWFsc05vZGUodGhpcywgeDEsIHgyKSk7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuYWRkTm9kZUFuZFJldHVybk91dHB1dCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHRoaXMubm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgbm9kZS52YWxpZGF0ZSgpO1xuICAgICAgICByZXR1cm4gbm9kZS5vdXRwdXQ7XG4gICAgfTtcbiAgICBHcmFwaC5wcm90b3R5cGUuZ2V0Tm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5vZGVzO1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoO1xufSgpKTtcbmV4cG9ydHMuR3JhcGggPSBHcmFwaDtcbnZhciBTeW1ib2xpY1RlbnNvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN5bWJvbGljVGVuc29yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFN5bWJvbGljVGVuc29yKHNoYXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIFtdLCAnZmxvYXQzMicpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIF90aGlzLmlkID0gU3ltYm9saWNUZW5zb3IubmV4dElEKys7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3ltYm9saWNUZW5zb3IubmV4dElEID0gMDtcbiAgICByZXR1cm4gU3ltYm9saWNUZW5zb3I7XG59KHRlbnNvcl8xLlRlbnNvcikpO1xuZXhwb3J0cy5TeW1ib2xpY1RlbnNvciA9IFN5bWJvbGljVGVuc29yO1xudmFyIE5vZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5vZGUoZ3JhcGgsIG5hbWUsIGlucHV0cywgb3V0cHV0KSB7XG4gICAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBpbnB1dHM7XG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xuICAgICAgICB0aGlzLmlkID0gTm9kZS5uZXh0SUQrKztcbiAgICAgICAgb3V0cHV0Lm5vZGUgPSB0aGlzO1xuICAgIH1cbiAgICBOb2RlLm5leHRJRCA9IDA7XG4gICAgcmV0dXJuIE5vZGU7XG59KCkpO1xuZXhwb3J0cy5Ob2RlID0gTm9kZTtcbnZhciBWYXJpYWJsZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhWYXJpYWJsZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFyaWFibGVOb2RlKGdyYXBoLCBuYW1lLCBkYXRhKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7fSwgbmV3IFN5bWJvbGljVGVuc29yKGRhdGEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBWYXJpYWJsZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmRhdGEgIT0gbnVsbCwgJ0Vycm9yIGFkZGluZyB2YXJpYWJsZSBvcDogRGF0YSBmb3IgdmFyaWFibGUgXFwnJyArIHRoaXMubmFtZSArXG4gICAgICAgICAgICAnXFwnIGlzIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gVmFyaWFibGVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlZhcmlhYmxlTm9kZSA9IFZhcmlhYmxlTm9kZTtcbnZhciBQbGFjZWhvbGRlck5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQbGFjZWhvbGRlck5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGxhY2Vob2xkZXJOb2RlKGdyYXBoLCBuYW1lLCBzaGFwZSkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsIG5hbWUsIHt9LCBuZXcgU3ltYm9saWNUZW5zb3Ioc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBQbGFjZWhvbGRlck5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBQbGFjZWhvbGRlck5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuUGxhY2Vob2xkZXJOb2RlID0gUGxhY2Vob2xkZXJOb2RlO1xudmFyIENvbnN0YW50Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnN0YW50Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25zdGFudE5vZGUoZ3JhcGgsIGRhdGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25zdGFudCcsIHt9LCBuZXcgU3ltYm9saWNUZW5zb3IoZGF0YS5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbnN0YW50Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMuZGF0YSAhPSBudWxsLCAnRXJyb3IgYWRkaW5nIGNvbnN0YW50OiBkYXRhIGZvciBwbGFjZWhvbGRlciBcXCcnICsgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICdcXCcgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uc3RhbnROb2RlID0gQ29uc3RhbnROb2RlO1xudmFyIFJlc2hhcGVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVzaGFwZU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZU5vZGUoZ3JhcGgsIG5hbWUsIHgsIHNoYXBlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCBuYW1lLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKHNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5zaGFwZSA9IHNoYXBlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlc2hhcGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSk7XG4gICAgICAgIHZhciBzaGFwZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy5zaGFwZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaXplID09PSBzaGFwZVNpemUsIFwiRXJyb3IgbWFraW5nIHJlc2hhcGUgb3BlcmF0aW9uOiBpbnB1dCB0byByZXNoYXBlICdcIiArIHRoaXMubmFtZSArIFwiJ1wiICtcbiAgICAgICAgICAgIChcIiBvZiBzaGFwZSAoXCIgKyB0aGlzLnguc2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggc2l6ZSBvZiBcIikgK1xuICAgICAgICAgICAgKFwicmVxdWVzdGVkIHNoYXBlIFwiICsgdGhpcy5zaGFwZSArIFwiLlwiKSk7XG4gICAgfTtcbiAgICBSZXNoYXBlTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBSZXNoYXBlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5SZXNoYXBlTm9kZSA9IFJlc2hhcGVOb2RlO1xudmFyIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUoZ3JhcGgsIHQxLCB0MiwgYzEsIGMyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTGluZWFyIENvbWJpbmF0aW9uJywgeyB0MTogdDEsIHQyOiB0MiwgYzE6IGMxLCBjMjogYzIgfSwgbmV3IFN5bWJvbGljVGVuc29yKHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgX3RoaXMuYzEgPSBjMTtcbiAgICAgICAgX3RoaXMuYzIgPSBjMjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2godGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSk7XG4gICAgICAgIGlmICghdXRpbC5pc1NjYWxhclNoYXBlKHRoaXMuYzEuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGFkZGluZyBmdXNlZExpbmVhckNvbWJpbmF0aW9uOiBjMSBpcyBub3QgYSBzY2FsYXIsIGdvdCAnICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZTogXCIgKyB0aGlzLmMxLnNoYXBlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmlzU2NhbGFyU2hhcGUodGhpcy5jMi5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgYWRkaW5nIGZ1c2VkTGluZWFyQ29tYmluYXRpb246IGMyIGlzIG5vdCBhIHNjYWxhciwgZ290ICcgK1xuICAgICAgICAgICAgICAgIChcInNoYXBlOiBcIiArIHRoaXMuYzIuc2hhcGUpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDEgPSAndDEnO1xuICAgIEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLlQyID0gJ3QyJztcbiAgICBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMSA9ICdjMSc7XG4gICAgRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuQzIgPSAnYzInO1xuICAgIHJldHVybiBGdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZSA9IEZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlO1xudmFyIEFkZE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBZGROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkZE5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0FkZCcsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFN5bWJvbGljVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgP1xuICAgICAgICAgICAgdDIuc2hhcGUgOlxuICAgICAgICAgICAgKHQxLnNoYXBlLmxlbmd0aCA8IHQyLnNoYXBlLmxlbmd0aCA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBZGROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSkgfHxcbiAgICAgICAgICAgICh0aGlzLnQxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLnQyLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgIHRoaXMudDEuc2hhcGVbMV0gPT09IHRoaXMudDIuc2hhcGVbMF0pIHx8XG4gICAgICAgICAgICAodGhpcy50MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy50Mi5zaGFwZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnQxLnNoYXBlWzBdID09PSB0aGlzLnQyLnNoYXBlWzFdKSwgJ0Vycm9yIGFkZGluZyBhZGQgb3BlcmF0aW9uIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyLCAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaCxcIikgK1xuICAgICAgICAgICAgJ29yIG9uZSBvZiB0aGVtIGNhbiBiZSBicm9hZGNhc3RlZCAoMkQgYW5kIDFEKS4nKTtcbiAgICB9O1xuICAgIEFkZE5vZGUuVDEgPSAndDEnO1xuICAgIEFkZE5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBBZGROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkFkZE5vZGUgPSBBZGROb2RlO1xudmFyIFN1YnRyYWN0Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFN1YnRyYWN0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdE5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1N1YnRyYWN0JywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgU3ltYm9saWNUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFN1YnRyYWN0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIHN1YnRyYWN0IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgU3VidHJhY3ROb2RlLlQxID0gJ3QxJztcbiAgICBTdWJ0cmFjdE5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBTdWJ0cmFjdE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU3VidHJhY3ROb2RlID0gU3VidHJhY3ROb2RlO1xudmFyIE11bHRpcGx5Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE11bHRpcGx5Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseU5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ011bHRpcGx5JywgeyB0MTogdDEsIHQyOiB0MiB9LCBuZXcgU3ltYm9saWNUZW5zb3IodXRpbC5zaXplRnJvbVNoYXBlKHQxLnNoYXBlKSA9PT0gMSA/IHQyLnNoYXBlIDogdDEuc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE11bHRpcGx5Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0aGlzLnQxLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDIuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLmFycmF5c0VxdWFsKHRoaXMudDEuc2hhcGUsIHRoaXMudDIuc2hhcGUpLCAnRXJyb3IgYWRkaW5nIG11bHRpcGx5IG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgTXVsdGlwbHlOb2RlLlQxID0gJ3QxJztcbiAgICBNdWx0aXBseU5vZGUuVDIgPSAndDInO1xuICAgIHJldHVybiBNdWx0aXBseU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuTXVsdGlwbHlOb2RlID0gTXVsdGlwbHlOb2RlO1xudmFyIERpdmlkZU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXZpZGVOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERpdmlkZU5vZGUoZ3JhcGgsIHQxLCB0Mikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0RpdmlkZScsIHsgdDE6IHQxLCB0MjogdDIgfSwgbmV3IFN5bWJvbGljVGVuc29yKHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgPyB0Mi5zaGFwZSA6IHQxLnNoYXBlKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMudDEgPSB0MTtcbiAgICAgICAgX3RoaXMudDIgPSB0MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXZpZGVOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMudDEuc2hhcGUpID09PSAxIHx8XG4gICAgICAgICAgICB1dGlsLnNpemVGcm9tU2hhcGUodGhpcy50Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodGhpcy50MS5zaGFwZSwgdGhpcy50Mi5zaGFwZSksICdFcnJvciBhZGRpbmcgZGl2aWRlIG9wOiBvbmUgb2YgaW5wdXRzIG11c3QgYmUgc2NhbGFyIG9yIHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyBcIiArIHRoaXMudDEuc2hhcGUgKyBcIiBhbmQgXCIgKyB0aGlzLnQyLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgRGl2aWRlTm9kZS5UMSA9ICd0MSc7XG4gICAgRGl2aWRlTm9kZS5UMiA9ICd0Mic7XG4gICAgcmV0dXJuIERpdmlkZU5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuRGl2aWRlTm9kZSA9IERpdmlkZU5vZGU7XG52YXIgUmVkdWNlU3VtTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1bU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVkdWNlU3VtTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdSZWR1Y2VTdW0nLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVkdWNlU3VtTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgUmVkdWNlU3VtTm9kZS5YID0gJ3gnO1xuICAgIHJldHVybiBSZWR1Y2VTdW1Ob2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlZHVjZVN1bU5vZGUgPSBSZWR1Y2VTdW1Ob2RlO1xudmFyIENvbmNhdDFETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDFETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQxRE5vZGUoZ3JhcGgsIHgxLCB4Mikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25jYXQxRCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFN5bWJvbGljVGVuc29yKGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZTFEKHgxLnNoYXBlLCB4Mi5zaGFwZSkpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBDb25jYXQxRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIENvbmNhdDFETm9kZS5YMSA9ICd4MSc7XG4gICAgQ29uY2F0MUROb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gQ29uY2F0MUROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbmNhdDFETm9kZSA9IENvbmNhdDFETm9kZTtcbnZhciBDb25jYXQyRE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQyRE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0MkROb2RlKGdyYXBoLCB4MSwgeDIsIGF4aXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb25jYXQyRCcsIHsgeDE6IHgxLCB4MjogeDIgfSwgbmV3IFN5bWJvbGljVGVuc29yKGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUsIGF4aXMpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0MkROb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHRoaXMueDEuc2hhcGUsIHRoaXMueDIuc2hhcGUsIHRoaXMuYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXQyRE5vZGUuWDEgPSAneDEnO1xuICAgIENvbmNhdDJETm9kZS5YMiA9ICd4Mic7XG4gICAgQ29uY2F0MkROb2RlLkFYSVMgPSAnYXhpcyc7XG4gICAgcmV0dXJuIENvbmNhdDJETm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db25jYXQyRE5vZGUgPSBDb25jYXQyRE5vZGU7XG52YXIgQ29uY2F0M0ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0M0ROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDNETm9kZShncmFwaCwgeDEsIHgyLCBheGlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQ29uY2F0M0QnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBTeW1ib2xpY1RlbnNvcihjb25jYXRfdXRpbC5jb21wdXRlT3V0U2hhcGUoeDEuc2hhcGUsIHgyLnNoYXBlLCBheGlzKSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxID0geDE7XG4gICAgICAgIF90aGlzLngyID0geDI7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDNETm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh0aGlzLngxLnNoYXBlLCB0aGlzLngyLnNoYXBlLCB0aGlzLmF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0M0ROb2RlLlgxID0gJ3gxJztcbiAgICBDb25jYXQzRE5vZGUuWDIgPSAneDInO1xuICAgIENvbmNhdDNETm9kZS5BWElTID0gJ2F4aXMnO1xuICAgIHJldHVybiBDb25jYXQzRE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQ29uY2F0M0ROb2RlID0gQ29uY2F0M0ROb2RlO1xudmFyIENvbmNhdDRETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDRETm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQ0RE5vZGUoZ3JhcGgsIHgxLCB4MiwgYXhpcykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0NvbmNhdDREJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgU3ltYm9saWNUZW5zb3IoY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKHgxLnNoYXBlLCB4Mi5zaGFwZSwgYXhpcykpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MSA9IHgxO1xuICAgICAgICBfdGhpcy54MiA9IHgyO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQ0RE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXModGhpcy54MS5zaGFwZSwgdGhpcy54Mi5zaGFwZSwgdGhpcy5heGlzKTtcbiAgICB9O1xuICAgIENvbmNhdDRETm9kZS5YMSA9ICd4MSc7XG4gICAgQ29uY2F0NEROb2RlLlgyID0gJ3gyJztcbiAgICBDb25jYXQ0RE5vZGUuQVhJUyA9ICdheGlzJztcbiAgICByZXR1cm4gQ29uY2F0NEROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLkNvbmNhdDRETm9kZSA9IENvbmNhdDRETm9kZTtcbmZ1bmN0aW9uIGdldE1hdE11bE91dHB1dFNoYXBlKHgxU2hhcGUsIHgyU2hhcGUpIHtcbiAgICBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDEgJiYgeDJTaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIFt4MlNoYXBlWzFdXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeDFTaGFwZS5sZW5ndGggPT09IDIgJiYgeDJTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIFt4MVNoYXBlWzBdXTtcbiAgICB9XG4gICAgcmV0dXJuIFt4MVNoYXBlWzBdLCB4MlNoYXBlWzFdXTtcbn1cbnZhciBNYXRNdWxOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF0TXVsTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWxOb2RlKGdyYXBoLCB4MSwgeDIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdNYXRNdWwnLCB7IHgxOiB4MSwgeDI6IHgyIH0sIG5ldyBTeW1ib2xpY1RlbnNvcihnZXRNYXRNdWxPdXRwdXRTaGFwZSh4MS5zaGFwZSwgeDIuc2hhcGUpKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXRNdWxOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMueDEuc2hhcGUubGVuZ3RoID09PSAyICYmIHRoaXMueDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLngxLnNoYXBlWzFdID09PSB0aGlzLngyLnNoYXBlWzBdLCAnRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogaW5uZXIgc2hhcGVzIG9mIG1hdHJpY2VzIHdpdGggc2hhcGVzICcgK1xuICAgICAgICAgICAgICAgICh0aGlzLngxLnNoYXBlICsgXCIgYW5kIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLngxLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB0aGlzLngyLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54MS5zaGFwZVsxXSA9PT0gdGhpcy54Mi5zaGFwZVswXSwgJ0Vycm9yIGFkZGluZyBtYXRtdWwgb3A6IHNlY29uZCBkaW1lbnNpb24gb2YgbWF0cml4IHdpdGggc2hhcGUgJyArXG4gICAgICAgICAgICAgICAgdGhpcy54MS5zaGFwZS50b1N0cmluZygpICtcbiAgICAgICAgICAgICAgICAoXCIgbXVzdCBtYXRjaCBzaXplIG9mIHZlY3RvciB3aXRoIHNoYXBlIFwiICsgdGhpcy54Mi5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy54MS5zaGFwZS5sZW5ndGggPT09IDEgJiYgdGhpcy54Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMueDEuc2hhcGVbMF0gPT09IHRoaXMueDIuc2hhcGVbMF0sIFwiRXJyb3IgYWRkaW5nIG1hdG11bCBvcDogc2l6ZSBvZiB2ZWN0b3Igd2l0aCBzaGFwZSBcIiArIHRoaXMueDEuc2hhcGUgK1xuICAgICAgICAgICAgICAgIFwiIG11c3QgbWF0Y2ggZmlyc3QgZGltZW5zaW9uIG9mIG1hdHJpeCB3aXRoIFwiICtcbiAgICAgICAgICAgICAgICAoXCJzaGFwZSBcIiArIHRoaXMueDIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvciBhZGRpbmcgbWF0bXVsIG9wOiBpbnB1dHMgbXVzdCBiZSB2ZWN0b3JzIG9yIG1hdHJpY2VzLicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRNdWxOb2RlLlgxID0gJ3gxJztcbiAgICBNYXRNdWxOb2RlLlgyID0gJ3gyJztcbiAgICByZXR1cm4gTWF0TXVsTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NYXRNdWxOb2RlID0gTWF0TXVsTm9kZTtcbnZhciBDb252b2x1dGlvbjJETm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbnZvbHV0aW9uMkROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbnZvbHV0aW9uMkROb2RlKGdyYXBoLCB4LCB3LCBiLCBmaWVsZFNpemUsIG91dHB1dERlcHRoLCBzdHJpZGUsIHplcm9QYWQpIHtcbiAgICAgICAgaWYgKHN0cmlkZSA9PT0gdm9pZCAwKSB7IHN0cmlkZSA9IDE7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdDb252b2x1dGlvbiAyRCcsIHsgeDogeCwgdzogdywgYjogYiB9LCBuZXcgU3ltYm9saWNUZW5zb3IoY29udl91dGlsLmNvbXB1dGVPdXRwdXRTaGFwZTNEKHguc2hhcGUsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMudyA9IHc7XG4gICAgICAgIF90aGlzLmIgPSBiO1xuICAgICAgICBfdGhpcy5maWVsZFNpemUgPSBmaWVsZFNpemU7XG4gICAgICAgIF90aGlzLm91dHB1dERlcHRoID0gb3V0cHV0RGVwdGg7XG4gICAgICAgIF90aGlzLnN0cmlkZSA9IHN0cmlkZTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29udm9sdXRpb24yRE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGUubGVuZ3RoID09PSAzLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogaW5wdXQgbXVzdCBiZSBvZiByYW5rIDMsIGJ1dCBnb3Qgc2hhcGU6ICcgK1xuICAgICAgICAgICAgKHRoaXMueC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRoaXMudy5zaGFwZS5sZW5ndGggPT09IDQsICdFcnJvciBhZGRpbmcgY29udjJkIG9wOiB3ZWlnaHRzIG11c3QgYmUgb2YgcmFuayA0LCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLncuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLmIuc2hhcGUubGVuZ3RoID09PSAxLCAnRXJyb3IgYWRkaW5nIGNvbnYyZCBvcDogYmlhc2VzIG11c3QgYmUgb2YgcmFuayAxLCBidXQgZ290IHNoYXBlOiAnICtcbiAgICAgICAgICAgICh0aGlzLmIuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnguc2hhcGVbMl0gPT09IHRoaXMudy5zaGFwZVsyXSwgXCJFcnJvciBhZGRpbmcgY29udjJkIG9wOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB0aGlzLnguc2hhcGVbMl0gKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBpbnB1dCBkZXB0aCBmb3Igd2VpZ2h0cyAoXCIgKyB0aGlzLncuc2hhcGVbMl0gKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIENvbnZvbHV0aW9uMkROb2RlLlggPSAneCc7XG4gICAgQ29udm9sdXRpb24yRE5vZGUuVyA9ICd3JztcbiAgICBDb252b2x1dGlvbjJETm9kZS5CID0gJ2InO1xuICAgIHJldHVybiBDb252b2x1dGlvbjJETm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Db252b2x1dGlvbjJETm9kZSA9IENvbnZvbHV0aW9uMkROb2RlO1xudmFyIE1heFBvb2xOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWF4UG9vbE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTWF4UG9vbE5vZGUoZ3JhcGgsIHgsIGZpZWxkU2l6ZSwgc3RyaWRlLCB6ZXJvUGFkKSB7XG4gICAgICAgIGlmIChzdHJpZGUgPT09IHZvaWQgMCkgeyBzdHJpZGUgPSAxOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnTWF4IHBvb2wnLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKGNvbnZfdXRpbC5jb21wdXRlT3V0cHV0U2hhcGUzRCh4LnNoYXBlLCBmaWVsZFNpemUsIHguc2hhcGVbMl0sIHN0cmlkZSwgemVyb1BhZCkpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLnplcm9QYWQgPSB6ZXJvUGFkO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1heFBvb2xOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMywgJ0Vycm9yIGFkZGluZyBtYXhQb29sIG9wOiBpbnB1dCBtdXN0IGJlIG9mIHJhbmsgMywgYnV0IGdvdCBzaGFwZTogJyArXG4gICAgICAgICAgICAodGhpcy54LnNoYXBlICsgXCIuXCIpKTtcbiAgICB9O1xuICAgIE1heFBvb2xOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIE1heFBvb2xOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLk1heFBvb2xOb2RlID0gTWF4UG9vbE5vZGU7XG52YXIgUmVMVU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhSZUxVTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZUxVTm9kZShncmFwaCwgeCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdSZUxVJywgeyB4OiB4IH0sIG5ldyBTeW1ib2xpY1RlbnNvcih4LnNoYXBlKSkgfHwgdGhpcztcbiAgICB9XG4gICAgUmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFJlTFVOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIFJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlJlTFVOb2RlID0gUmVMVU5vZGU7XG52YXIgTGVha3lSZUxVTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTGVha3lSZUxVTm9kZShncmFwaCwgeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdMZWFreVJlTFUnLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5hbHBoYSA9IGFscGhhO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExlYWt5UmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIExlYWt5UmVMVU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTGVha3lSZUxVTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5MZWFreVJlTFVOb2RlID0gTGVha3lSZUxVTm9kZTtcbnZhciBQUmVMVU5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQUmVMVU5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUFJlTFVOb2RlKGdyYXBoLCB4LCBhbHBoYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1BSZUxVJywgeyB4OiB4LCBhbHBoYTogYWxwaGEgfSwgbmV3IFN5bWJvbGljVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgX3RoaXMuYWxwaGEgPSBhbHBoYTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQUmVMVU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueC5zaGFwZSwgdGhpcy5hbHBoYS5zaGFwZSksICdFcnJvciBhZGRpbmcgcFJlbHUgb3A6IHRoZSAnICtcbiAgICAgICAgICAgIChcInNoYXBlcyB4OiBcIiArIHRoaXMueC5zaGFwZSArIFwiIGFuZCBhbHBoYTogXCIgKyB0aGlzLmFscGhhLnNoYXBlICsgXCIgbXVzdCBtYXRjaC5cIikpO1xuICAgIH07XG4gICAgUFJlTFVOb2RlLlggPSAneCc7XG4gICAgUFJlTFVOb2RlLkFMUEhBID0gJ2FscGhhJztcbiAgICByZXR1cm4gUFJlTFVOb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlBSZUxVTm9kZSA9IFBSZUxVTm9kZTtcbnZhciBFbHVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWx1Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFbHVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0VsdScsIHsgeDogeCB9LCBuZXcgU3ltYm9saWNUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIEVsdU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEVsdU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gRWx1Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5FbHVOb2RlID0gRWx1Tm9kZTtcbnZhciBFeHBOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRXhwTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBFeHBOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0V4cCcsIHsgeDogeCB9LCBuZXcgU3ltYm9saWNUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIEV4cE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIEV4cE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gRXhwTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5FeHBOb2RlID0gRXhwTm9kZTtcbnZhciBMb2dOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMb2dOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ0xvZycsIHsgeDogeCB9LCBuZXcgU3ltYm9saWNUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIExvZ05vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIExvZ05vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gTG9nTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5Mb2dOb2RlID0gTG9nTm9kZTtcbnZhciBUYW5ITm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFRhbkhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhbkhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1RhbkgnLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUYW5ITm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgVGFuSE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gVGFuSE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuVGFuSE5vZGUgPSBUYW5ITm9kZTtcbnZhciBTaWdtb2lkTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNpZ21vaWROb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNpZ21vaWROb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NpZ21vaWQnLCB7IHg6IHggfSwgbmV3IFN5bWJvbGljVGVuc29yKHguc2hhcGUpKSB8fCB0aGlzO1xuICAgIH1cbiAgICBTaWdtb2lkTm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgU2lnbW9pZE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU2lnbW9pZE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU2lnbW9pZE5vZGUgPSBTaWdtb2lkTm9kZTtcbnZhciBTcXVhcmVOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3F1YXJlTm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTcXVhcmVOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ1NxdWFyZScsIHsgeDogeCB9LCBuZXcgU3ltYm9saWNUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgfVxuICAgIFNxdWFyZU5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFNxdWFyZU5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU3F1YXJlTm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5TcXVhcmVOb2RlID0gU3F1YXJlTm9kZTtcbnZhciBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlKGdyYXBoLCB4LCB0YXJnZXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgZ3JhcGgsICdTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCcsIHsgeDogeCwgdGFyZ2V0OiB0YXJnZXQgfSwgbmV3IFN5bWJvbGljVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueCA9IHg7XG4gICAgICAgIF90aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKHRoaXMueC5zaGFwZSwgdGhpcy50YXJnZXQuc2hhcGUpLCBcIkVycm9yIGFkZGluZyBzb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCBvcDogeCBzaGFwZSAoXCIgKyB0aGlzLnguc2hhcGUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCB0YXJnZXQgc2hhcGUgKFwiICsgdGhpcy50YXJnZXQuc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5YID0gJ3gnO1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZS5UQVJHRVQgPSAndGFyZ2V0JztcbiAgICByZXR1cm4gU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlO1xufShOb2RlKSk7XG5leHBvcnRzLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSA9IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZTtcbnZhciBTb2Z0bWF4Tm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNvZnRtYXhOb2RlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnU29mdG1heCcsIHsgeDogeCB9LCBuZXcgU3ltYm9saWNUZW5zb3IoeC5zaGFwZSkpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlLmxlbmd0aCA9PT0gMSwgJ1RoZSBpbnB1dCB0byBhIHNvZnRtYXggbXVzdCBiZSBhIDEtRCB0ZW5zb3InKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy54LnNoYXBlWzBdID49IDIsICdUaGUgaW5wdXQgdG8gYSBzb2Z0bWF4IG11c3QgaGF2ZSBhdCBsZWFzdCAyIHZhbHVlcycpO1xuICAgIH07XG4gICAgU29mdG1heE5vZGUuWCA9ICd4JztcbiAgICByZXR1cm4gU29mdG1heE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuU29mdG1heE5vZGUgPSBTb2Z0bWF4Tm9kZTtcbnZhciBNZWFuU3F1YXJlZENvc3ROb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhblNxdWFyZWRDb3N0Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZWFuU3F1YXJlZENvc3ROb2RlKGdyYXBoLCBsYWJlbCwgcHJlZGljdGlvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBncmFwaCwgJ01lYW4gU3F1YXJlZCBDb3N0JywgeyBsYWJlbDogbGFiZWwsIHByZWRpY3Rpb246IHByZWRpY3Rpb24gfSwgbmV3IFN5bWJvbGljVGVuc29yKFtdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGFiZWwgPSBsYWJlbDtcbiAgICAgICAgX3RoaXMucHJlZGljdGlvbiA9IHByZWRpY3Rpb247XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVhblNxdWFyZWRDb3N0Tm9kZS5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuYXJyYXlzRXF1YWwodGhpcy5sYWJlbC5zaGFwZSwgdGhpcy5wcmVkaWN0aW9uLnNoYXBlKSwgXCJFcnJvciBhZGRpbmcgbWVhblNxdWFyZWRDb3N0IG9wOiBsYWJlbCBzaGFwZSAoXCIgKyB0aGlzLmxhYmVsLnNoYXBlICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggcHJlZGljdGlvbiBzaGFwZSAoXCIgKyB0aGlzLnByZWRpY3Rpb24uc2hhcGUgKyBcIikuXCIpKTtcbiAgICB9O1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUwgPSAnbGFiZWwnO1xuICAgIE1lYW5TcXVhcmVkQ29zdE5vZGUuUFJFRElDVElPTiA9ICdwcmVkaWN0aW9uJztcbiAgICByZXR1cm4gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbn0oTm9kZSkpO1xuZXhwb3J0cy5NZWFuU3F1YXJlZENvc3ROb2RlID0gTWVhblNxdWFyZWRDb3N0Tm9kZTtcbnZhciBBcmdNYXhOb2RlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4Tm9kZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXhOb2RlKGdyYXBoLCB4KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4JywgeyB4OiB4IH0sIG5ldyBTeW1ib2xpY1RlbnNvcihbMV0pKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54ID0geDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHRoaXMueC5zaGFwZSkgPiAwLCAnRXJyb3IgYWRkaW5nIGFyZ21heCBvcDogaW5wdXQgdGVuc29yIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZW50cnkuJyk7XG4gICAgfTtcbiAgICBBcmdNYXhOb2RlLlggPSAneCc7XG4gICAgcmV0dXJuIEFyZ01heE5vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQXJnTWF4Tm9kZSA9IEFyZ01heE5vZGU7XG52YXIgQXJnTWF4RXF1YWxzTm9kZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heEVxdWFsc05vZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQXJnTWF4RXF1YWxzTm9kZShncmFwaCwgeDEsIHgyKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGdyYXBoLCAnQXJnTWF4RXF1YWxzJywgeyB4MTogeDEsIHgyOiB4MiB9LCBuZXcgU3ltYm9saWNUZW5zb3IoWzFdKSkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDEgPSB4MTtcbiAgICAgICAgX3RoaXMueDIgPSB4MjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBBcmdNYXhFcXVhbHNOb2RlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5hcnJheXNFcXVhbCh0aGlzLngxLnNoYXBlLCB0aGlzLngyLnNoYXBlKSwgXCJFcnJvciBhZGRpbmcgQXJnTWF4RXF1YWxzIG9wOiB4MSBzaGFwZSAoXCIgKyB0aGlzLngxLnNoYXBlICsgXCIpIFwiICtcbiAgICAgICAgICAgIChcIm11c3QgbWF0Y2ggeDIgc2hhcGUgKFwiICsgdGhpcy54Mi5zaGFwZSArIFwiKS5cIikpO1xuICAgIH07XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5YMSA9ICd4MSc7XG4gICAgQXJnTWF4RXF1YWxzTm9kZS5YMiA9ICd4Mic7XG4gICAgcmV0dXJuIEFyZ01heEVxdWFsc05vZGU7XG59KE5vZGUpKTtcbmV4cG9ydHMuQXJnTWF4RXF1YWxzTm9kZSA9IEFyZ01heEVxdWFsc05vZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgc2Vzc2lvbl8xID0gcmVxdWlyZShcIi4vc2Vzc2lvblwiKTtcbnZhciBERUZBVUxUX0VWQUxfSU5URVJWQUxfTVMgPSAxNTAwO1xudmFyIERFRkFVTFRfQ09TVF9JTlRFUlZBTF9NUyA9IDUwMDtcbnZhciBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TID0gMzAwMDtcbnZhciBNZXRyaWNSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKE1ldHJpY1JlZHVjdGlvbikge1xuICAgIE1ldHJpY1JlZHVjdGlvbltNZXRyaWNSZWR1Y3Rpb25bXCJTVU1cIl0gPSAwXSA9IFwiU1VNXCI7XG4gICAgTWV0cmljUmVkdWN0aW9uW01ldHJpY1JlZHVjdGlvbltcIk1FQU5cIl0gPSAxXSA9IFwiTUVBTlwiO1xufSkoTWV0cmljUmVkdWN0aW9uID0gZXhwb3J0cy5NZXRyaWNSZWR1Y3Rpb24gfHwgKGV4cG9ydHMuTWV0cmljUmVkdWN0aW9uID0ge30pKTtcbnZhciBHcmFwaFJ1bm5lciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gR3JhcGhSdW5uZXIobWF0aCwgc2Vzc2lvbiwgZXZlbnRPYnNlcnZlcikge1xuICAgICAgICB0aGlzLm1hdGggPSBtYXRoO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIgPSBldmVudE9ic2VydmVyO1xuICAgICAgICB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IDA7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0aXN0aWNzKCk7XG4gICAgICAgIHRoaXMuemVyb1NjYWxhciA9IHRlbnNvcl8xLlNjYWxhci5uZXcoMCk7XG4gICAgfVxuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5yZXNldFN0YXRpc3RpY3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudG90YWxCYXRjaGVzVHJhaW5lZCA9IDA7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiAoY29zdFRlbnNvciwgdHJhaW5GZWVkRW50cmllcywgYmF0Y2hTaXplLCBvcHRpbWl6ZXIsIG51bUJhdGNoZXMsIG1ldHJpY1RlbnNvciwgbWV0cmljRmVlZEVudHJpZXMsIG1ldHJpY0JhdGNoU2l6ZSwgbWV0cmljUmVkdWN0aW9uLCBldmFsSW50ZXJ2YWxNcywgY29zdEludGVydmFsTXMpIHtcbiAgICAgICAgaWYgKG1ldHJpY1JlZHVjdGlvbiA9PT0gdm9pZCAwKSB7IG1ldHJpY1JlZHVjdGlvbiA9IE1ldHJpY1JlZHVjdGlvbi5NRUFOOyB9XG4gICAgICAgIGlmIChldmFsSW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGV2YWxJbnRlcnZhbE1zID0gREVGQVVMVF9FVkFMX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChjb3N0SW50ZXJ2YWxNcyA9PT0gdm9pZCAwKSB7IGNvc3RJbnRlcnZhbE1zID0gREVGQVVMVF9DT1NUX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIHRoaXMuY29zdFRlbnNvciA9IGNvc3RUZW5zb3I7XG4gICAgICAgIHRoaXMudHJhaW5GZWVkRW50cmllcyA9IHRyYWluRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMubWV0cmljVGVuc29yID0gbWV0cmljVGVuc29yO1xuICAgICAgICB0aGlzLm1ldHJpY0ZlZWRFbnRyaWVzID0gbWV0cmljRmVlZEVudHJpZXM7XG4gICAgICAgIGlmIChtZXRyaWNCYXRjaFNpemUgIT0gbnVsbCAmJiB0aGlzLm1ldHJpY0JhdGNoU2l6ZSAhPT0gbWV0cmljQmF0Y2hTaXplKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tZXRyaWNCYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyID0gdGVuc29yXzEuU2NhbGFyLm5ldyhtZXRyaWNCYXRjaFNpemUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWV0cmljQmF0Y2hTaXplID0gbWV0cmljQmF0Y2hTaXplO1xuICAgICAgICB0aGlzLm1ldHJpY1JlZHVjdGlvbiA9IG1ldHJpY1JlZHVjdGlvbjtcbiAgICAgICAgdGhpcy5iYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgIHRoaXMub3B0aW1pemVyID0gb3B0aW1pemVyO1xuICAgICAgICB0aGlzLm1ldHJpY0ludGVydmFsTXMgPSBldmFsSW50ZXJ2YWxNcztcbiAgICAgICAgdGhpcy5jb3N0SW50ZXJ2YWxNcyA9IGNvc3RJbnRlcnZhbE1zO1xuICAgICAgICB0aGlzLmN1cnJlbnRUcmFpbkxvb3BOdW1CYXRjaGVzID0gbnVtQmF0Y2hlcztcbiAgICAgICAgdGhpcy5iYXRjaGVzVHJhaW5lZFRoaXNSdW4gPSAwO1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYWluU3RhcnRUaW1lc3RhbXAgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdGhpcy50cmFpbk5ldHdvcmsoKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zdG9wVHJhaW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaXNUcmFpbmluZyA9IGZhbHNlO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnJlc3VtZVRyYWluaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzVHJhaW5pbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYWluTmV0d29yaygpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLnRyYWluTmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hlc1RyYWluZWRUaGlzUnVuID09PSB0aGlzLmN1cnJlbnRUcmFpbkxvb3BOdW1CYXRjaGVzKSB7XG4gICAgICAgICAgICB0aGlzLnN0b3BUcmFpbmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc1RyYWluaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudE9ic2VydmVyLmRvbmVUcmFpbmluZ0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuZG9uZVRyYWluaW5nQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgdmFyIHNob3VsZENvbXB1dGVDb3N0ID0gdGhpcy5ldmVudE9ic2VydmVyLmF2Z0Nvc3RDYWxsYmFjayAhPSBudWxsICYmXG4gICAgICAgICAgICAoc3RhcnQgLSB0aGlzLmxhc3RDb3N0VGltZXN0YW1wID4gdGhpcy5jb3N0SW50ZXJ2YWxNcyk7XG4gICAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29zdFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb3N0UmVkdWN0aW9uID0gc2hvdWxkQ29tcHV0ZUNvc3QgPyBzZXNzaW9uXzEuQ29zdFJlZHVjdGlvbi5NRUFOIDogc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb24uTk9ORTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGF2Z0Nvc3QgPSBfdGhpcy5zZXNzaW9uLnRyYWluKF90aGlzLmNvc3RUZW5zb3IsIF90aGlzLnRyYWluRmVlZEVudHJpZXMsIF90aGlzLmJhdGNoU2l6ZSwgX3RoaXMub3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzaG91bGRDb21wdXRlQ29zdCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpblRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuYXZnQ29zdENhbGxiYWNrKGF2Z0Nvc3QpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLnRyYWluRXhhbXBsZXNQZXJTZWNDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBleGFtcGxlc1BlclNlYyA9IChfdGhpcy5iYXRjaFNpemUgKiAxMDAwIC8gdHJhaW5UaW1lKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci50cmFpbkV4YW1wbGVzUGVyU2VjQ2FsbGJhY2soZXhhbXBsZXNQZXJTZWMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfdGhpcy5ldmVudE9ic2VydmVyLm1ldHJpY0NhbGxiYWNrICE9IG51bGwgJiZcbiAgICAgICAgICAgICAgICBfdGhpcy5tZXRyaWNGZWVkRW50cmllcyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgc3RhcnQgLSBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA+IF90aGlzLm1ldHJpY0ludGVydmFsTXMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0RXZhbFRpbWVzdGFtcCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMgPSBfdGhpcy5jb21wdXRlTWV0cmljKCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5tZXRyaWNDYWxsYmFjayhfdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIudG90YWxUaW1lQ2FsbGJhY2soKHN0YXJ0IC0gX3RoaXMudHJhaW5TdGFydFRpbWVzdGFtcCkgLyAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmJhdGNoZXNUcmFpbmVkVGhpc1J1bisrO1xuICAgICAgICAgICAgX3RoaXMudG90YWxCYXRjaGVzVHJhaW5lZCsrO1xuICAgICAgICAgICAgaWYgKF90aGlzLmV2ZW50T2JzZXJ2ZXIuYmF0Y2hlc1RyYWluZWRDYWxsYmFjayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZXZlbnRPYnNlcnZlci5iYXRjaGVzVHJhaW5lZENhbGxiYWNrKF90aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLnRyYWluTmV0d29yaygpOyB9KTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5pbmZlciA9IGZ1bmN0aW9uIChpbmZlcmVuY2VUZW5zb3IsIGluZmVyZW5jZUZlZWRFbnRyaWVzLCBpbmZlcmVuY2VFeGFtcGxlSW50ZXJ2YWxNcywgaW5mZXJlbmNlRXhhbXBsZUNvdW50LCBudW1QYXNzZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKGluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID09PSB2b2lkIDApIHsgaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXMgPSBERUZBVUxUX0lORkVSRU5DRV9FWEFNUExFX0lOVEVSVkFMX01TOyB9XG4gICAgICAgIGlmIChpbmZlcmVuY2VFeGFtcGxlQ291bnQgPT09IHZvaWQgMCkgeyBpbmZlcmVuY2VFeGFtcGxlQ291bnQgPSA1OyB9XG4gICAgICAgIGlmICh0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNDYWxsYmFjayA9PSBudWxsICYmXG4gICAgICAgICAgICB0aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2UgbG9vcCwgbm8gaW5mZXJlbmNlIGV4YW1wbGUgb3IgJyArXG4gICAgICAgICAgICAgICAgJ2V4YW1wbGVzL3NlYyBvYnNlcnZlciBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmVlZEVudHJ5ID0gaW5mZXJlbmNlRmVlZEVudHJpZXNbaV07XG4gICAgICAgICAgICBpZiAoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzdGFydCBpbmZlcmVuY2Ugb24gdGhlIG1vZGVsIHJ1bm5lciB3aXRoIGZlZWQgZW50cmllcyBvZiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3R5cGUgTkRBcnJheS4gUGxlYXNlIHVzZSBJbnB1dFByb3ZpZGVycy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zID0gaW5mZXJlbmNlRXhhbXBsZUludGVydmFsTXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlVGVuc29yID0gaW5mZXJlbmNlVGVuc29yO1xuICAgICAgICB0aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzID0gaW5mZXJlbmNlRmVlZEVudHJpZXM7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmZlcmVuY2VMb29wTnVtUGFzc2VzID0gbnVtUGFzc2VzO1xuICAgICAgICBpZiAoIXRoaXMuaXNJbmZlcnJpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaW5mZXJlbmNlUGFzc2VzVGhpc1J1biA9IDA7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuaW5mZXJOZXR3b3JrKCk7IH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNJbmZlcnJpbmcgPSB0cnVlO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmluZmVyTmV0d29yayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmlzSW5mZXJyaW5nIHx8XG4gICAgICAgICAgICB0aGlzLmluZmVyZW5jZVBhc3Nlc1RoaXNSdW4gPT09IHRoaXMuY3VycmVudEluZmVyZW5jZUxvb3BOdW1QYXNzZXMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmVlZHMgPSBbXTtcbiAgICAgICAgICAgIHZhciBpbmZlcmVuY2VWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5pbmZlcmVuY2VFeGFtcGxlQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuZGFycmF5RmVlZEVudHJpZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IF90aGlzLmluZmVyZW5jZUZlZWRFbnRyaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWVkRW50cnkgPSBfdGhpcy5pbmZlcmVuY2VGZWVkRW50cmllc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRDb3B5ID0gZmVlZEVudHJ5LmRhdGEuZ2V0TmV4dENvcHkoKTtcbiAgICAgICAgICAgICAgICAgICAgbmRhcnJheUZlZWRFbnRyaWVzLnB1c2goeyB0ZW5zb3I6IGZlZWRFbnRyeS50ZW5zb3IsIGRhdGE6IG5leHRDb3B5IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmZWVkcy5wdXNoKG5kYXJyYXlGZWVkRW50cmllcyk7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlVmFsdWVzLnB1c2goX3RoaXMuc2Vzc2lvbi5ldmFsKF90aGlzLmluZmVyZW5jZVRlbnNvciwgbmRhcnJheUZlZWRFbnRyaWVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc1BlclNlY0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VWYWx1ZXNbaW5mZXJlbmNlVmFsdWVzLmxlbmd0aCAtIDFdLmRhdGFTeW5jKCk7XG4gICAgICAgICAgICAgICAgdmFyIGluZmVyZW5jZUV4YW1wbGVzUGVyU2VjVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGV4YW1wbGVzUGVyU2VjID0gKF90aGlzLmluZmVyZW5jZUV4YW1wbGVDb3VudCAqIDEwMDAgLyBpbmZlcmVuY2VFeGFtcGxlc1BlclNlY1RpbWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmV2ZW50T2JzZXJ2ZXIuaW5mZXJlbmNlRXhhbXBsZXNQZXJTZWNDYWxsYmFjayhleGFtcGxlc1BlclNlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuZXZlbnRPYnNlcnZlci5pbmZlcmVuY2VFeGFtcGxlc0NhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5ldmVudE9ic2VydmVyLmluZmVyZW5jZUV4YW1wbGVzQ2FsbGJhY2soZmVlZHMsIGluZmVyZW5jZVZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5pbmZlcmVuY2VQYXNzZXNUaGlzUnVuKys7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmxhc3RJbmZlclRpbWVvdXRJRCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmluZmVyTmV0d29yaygpOyB9LCB0aGlzLmluZmVyZW5jZUV4YW1wbGVJbnRlcnZhbE1zKTtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zdG9wSW5mZXJyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmlzSW5mZXJyaW5nID0gZmFsc2U7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5sYXN0SW5mZXJUaW1lb3V0SUQpO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmlzSW5mZXJlbmNlUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNJbmZlcnJpbmc7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuY29tcHV0ZU1ldHJpYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMubWV0cmljRmVlZEVudHJpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBtZXRyaWMsIG5vIG1ldHJpYyBGZWVkRW50cmllcyBwcm92aWRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWV0cmljID0gdGhpcy56ZXJvU2NhbGFyO1xuICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBfdGhpcy5tZXRyaWNCYXRjaFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtZXRyaWNWYWx1ZSA9IF90aGlzLnNlc3Npb24uZXZhbChfdGhpcy5tZXRyaWNUZW5zb3IsIF90aGlzLm1ldHJpY0ZlZWRFbnRyaWVzKTtcbiAgICAgICAgICAgICAgICBtZXRyaWMgPSBfdGhpcy5tYXRoLmFkZChtZXRyaWMsIG1ldHJpY1ZhbHVlLnRvRmxvYXQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMubWV0cmljUmVkdWN0aW9uID09PSBNZXRyaWNSZWR1Y3Rpb24uTUVBTikge1xuICAgICAgICAgICAgICAgIG1ldHJpYyA9IF90aGlzLm1hdGguZGl2aWRlKG1ldHJpYywgX3RoaXMubWV0cmljQmF0Y2hTaXplU2NhbGFyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtZXRyaWM7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR3JhcGhSdW5uZXIucHJvdG90eXBlLmdldFRvdGFsQmF0Y2hlc1RyYWluZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsQmF0Y2hlc1RyYWluZWQ7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuZ2V0TGFzdENvbXB1dGVkTWV0cmljID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0Q29tcHV0ZWRNZXRyaWM7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0TWF0aCA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgIHRoaXMubWF0aCA9IG1hdGg7XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChzZXNzaW9uKSB7XG4gICAgICAgIHRoaXMuc2Vzc2lvbiA9IHNlc3Npb247XG4gICAgfTtcbiAgICBHcmFwaFJ1bm5lci5wcm90b3R5cGUuc2V0SW5mZXJlbmNlVGVuc29yID0gZnVuY3Rpb24gKGluZmVyZW5jZVRlbnNvcikge1xuICAgICAgICB0aGlzLmluZmVyZW5jZVRlbnNvciA9IGluZmVyZW5jZVRlbnNvcjtcbiAgICB9O1xuICAgIEdyYXBoUnVubmVyLnByb3RvdHlwZS5zZXRJbmZlcmVuY2VFeGFtcGxlQ291bnQgPSBmdW5jdGlvbiAoaW5mZXJlbmNlRXhhbXBsZUNvdW50KSB7XG4gICAgICAgIHRoaXMuaW5mZXJlbmNlRXhhbXBsZUNvdW50ID0gaW5mZXJlbmNlRXhhbXBsZUNvdW50O1xuICAgIH07XG4gICAgcmV0dXJuIEdyYXBoUnVubmVyO1xufSgpKTtcbmV4cG9ydHMuR3JhcGhSdW5uZXIgPSBHcmFwaFJ1bm5lcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBwcmlvcml0eV9xdWV1ZSA9IHJlcXVpcmUoXCIuL3ByaW9yaXR5X3F1ZXVlXCIpO1xudmFyIHByaW9yaXR5X3F1ZXVlXzEgPSByZXF1aXJlKFwiLi9wcmlvcml0eV9xdWV1ZVwiKTtcbmZ1bmN0aW9uIGdldFVub3JkZXJlZEV2YWx1YXRpb25TZXQobm9kZXMsIHRlcm1pbmF0aW5nTm9kZXMpIHtcbiAgICB2YXIgdGVybWluYXRpbmdOb2RlTWFwID0ge307XG4gICAgdmFyIHNlZW4gPSB7fTtcbiAgICB2YXIgc2V0ID0gW107XG4gICAgdmFyIHZpc2l0ID0gbm9kZXMuc2xpY2UoKTtcbiAgICB0ZXJtaW5hdGluZ05vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIHRlcm1pbmF0aW5nTm9kZU1hcFtub2RlLmlkXSA9IG5vZGU7IH0pO1xuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VyID0gdmlzaXQucG9wKCk7XG4gICAgICAgIGlmIChzZWVuW2N1ci5pZF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRlcm1pbmF0aW5nTm9kZU1hcFtjdXIuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhjdXIuaW5wdXRzKVxuICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uIChpbnB1dE5hbWUpIHsgcmV0dXJuIGN1ci5pbnB1dHNbaW5wdXROYW1lXTsgfSlcbiAgICAgICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKGlucHV0KSB7IHJldHVybiB2aXNpdC5wdXNoKGlucHV0Lm5vZGUpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNldC5wdXNoKGN1cik7XG4gICAgICAgICAgICBzZWVuW2N1ci5pZF0gPSBjdXI7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHdoaWxlICh2aXNpdC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgX2xvb3BfMSgpO1xuICAgIH1cbiAgICByZXR1cm4gc2V0O1xufVxuZXhwb3J0cy5nZXRVbm9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIGdldE9yZGVyZWRFdmFsdWF0aW9uU2V0KHVub3JkZXJlZEV2YWx1YXRpb25TZXQpIHtcbiAgICB2YXIgc2V0ID0gW107XG4gICAgdmFyIG5vZGVJbmRpY2VzID0ge307XG4gICAgdmFyIHBlbmRpbmdEZXBlbmRlbmNpZXMgPSB7fTtcbiAgICB2YXIgbm9kZVF1ZXVlID0gbmV3IHByaW9yaXR5X3F1ZXVlXzEuUHJpb3JpdHlRdWV1ZShmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gcHJpb3JpdHlfcXVldWUuZGVmYXVsdENvbXBhcmUocGVuZGluZ0RlcGVuZGVuY2llc1thLmlkXSwgcGVuZGluZ0RlcGVuZGVuY2llc1tiLmlkXSk7IH0sIGZ1bmN0aW9uIChub2RlLCBuZXdJbmRleCkgeyByZXR1cm4gbm9kZUluZGljZXNbbm9kZS5pZF0gPSBuZXdJbmRleDsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBwZW5kaW5nRGVwZW5kZW5jaWVzW25vZGUuaWRdID0gMDsgfSk7XG4gICAgdW5vcmRlcmVkRXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBPYmplY3Qua2V5cyhub2RlLmlucHV0cylcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBub2RlLmlucHV0c1trZXldOyB9KVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHBlbmRpbmdEZXBlbmRlbmNpZXNbaW5wdXQubm9kZS5pZF0rKztcbiAgICAgICAgfVxuICAgIH0pOyB9KTtcbiAgICB1bm9yZGVyZWRFdmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIG5vZGVRdWV1ZS5lbnF1ZXVlKG5vZGUpOyB9KTtcbiAgICB3aGlsZSAoIW5vZGVRdWV1ZS5lbXB0eSgpKSB7XG4gICAgICAgIHNldC51bnNoaWZ0KG5vZGVRdWV1ZS5kZXF1ZXVlKCkpO1xuICAgICAgICBPYmplY3Qua2V5cyhzZXRbMF0uaW5wdXRzKS5tYXAoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc2V0WzBdLmlucHV0c1trZXldOyB9KS5mb3JFYWNoKGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICAgICAgaWYgKHVub3JkZXJlZEV2YWx1YXRpb25TZXQuaW5kZXhPZihpbnB1dC5ub2RlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwZW5kaW5nRGVwZW5kZW5jaWVzW2lucHV0Lm5vZGUuaWRdLS07XG4gICAgICAgICAgICBub2RlUXVldWUudXBkYXRlKGlucHV0Lm5vZGUsIG5vZGVJbmRpY2VzW2lucHV0Lm5vZGUuaWRdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG5leHBvcnRzLmdldE9yZGVyZWRFdmFsdWF0aW9uU2V0ID0gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBpc0lucHV0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG5vZGUuaW5wdXRzKS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzSW5wdXROb2RlID0gaXNJbnB1dE5vZGU7XG5mdW5jdGlvbiBzaG91bGRCYWNrUHJvcCh0KSB7XG4gICAgcmV0dXJuICEodC5ub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25zdGFudE5vZGUpO1xufVxuZXhwb3J0cy5zaG91bGRCYWNrUHJvcCA9IHNob3VsZEJhY2tQcm9wO1xuZnVuY3Rpb24gaXNQYXNzdGhyb3VnaE5vZGUobm9kZSwgbWFwKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhub2RlLmlucHV0cyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpbnB1dCA9IG5vZGUuaW5wdXRzW2tleXNbaV1dO1xuICAgICAgICBpZiAobWFwLmdldChpbnB1dCwgdHJ1ZSkgPT09IG1hcC5nZXQobm9kZS5vdXRwdXQsIHRydWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnRzLmlzUGFzc3Rocm91Z2hOb2RlID0gaXNQYXNzdGhyb3VnaE5vZGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIoc2NhbGUsIG1vZGUsIGRpc3RyaWJ1dGlvbikge1xuICAgICAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDEuMDsgfVxuICAgICAgICBpZiAobW9kZSA9PT0gdm9pZCAwKSB7IG1vZGUgPSAnZmFuX2luJzsgfVxuICAgICAgICBpZiAoZGlzdHJpYnV0aW9uID09PSB2b2lkIDApIHsgZGlzdHJpYnV0aW9uID0gJ25vcm1hbCc7IH1cbiAgICAgICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgICAgICB0aGlzLm1vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLmRpc3RyaWJ1dGlvbiA9IGRpc3RyaWJ1dGlvbjtcbiAgICB9XG4gICAgVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICB2YXIgbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09ICdmYW5faW4nKSB7XG4gICAgICAgICAgICBuID0gaW5wdXRVbml0cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1vZGUgPT09ICdmYW5fb3V0Jykge1xuICAgICAgICAgICAgbiA9IG91dHB1dFVuaXRzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbl9hdmcnKSB7XG4gICAgICAgICAgICBuID0gKGlucHV0VW5pdHMgKyBvdXRwdXRVbml0cykgLyAyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtb2RlIGZvciB2YXJpYW5jZSBzY2FsaW5nIGluaXRpYWxpemVyOiBcIiArIHRoaXMubW9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAnbm9ybWFsJykge1xuICAgICAgICAgICAgcmV0dXJuIG9wcy50cnVuY2F0ZWROb3JtYWwod2VpZ2h0c1NoYXBlLCAwLjAsIE1hdGguc3FydCh0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzdHJpYnV0aW9uID09PSAndW5pZm9ybScpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHMucmFuZG9tVW5pZm9ybSh3ZWlnaHRzU2hhcGUsIDAuMCwgTWF0aC5zcXJ0KDMgKiB0aGlzLnNjYWxlIC8gbikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBkaXN0cmlidXRpb24gZm9yIHZhcmlhbmNlIHNjYWxpbmcgaW5pdGlhbGl6ZXI6IFwiICtcbiAgICAgICAgICAgICAgICAoXCJcIiArIHRoaXMuZGlzdHJpYnV0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyID0gVmFyaWFuY2VTY2FsaW5nSW5pdGlhbGl6ZXI7XG52YXIgWmVyb3NJbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWmVyb3NJbml0aWFsaXplcigpIHtcbiAgICB9XG4gICAgWmVyb3NJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBvcHMuemVyb3Mod2VpZ2h0c1NoYXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBaZXJvc0luaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuWmVyb3NJbml0aWFsaXplciA9IFplcm9zSW5pdGlhbGl6ZXI7XG52YXIgT25lc0luaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPbmVzSW5pdGlhbGl6ZXIoKSB7XG4gICAgfVxuICAgIE9uZXNJbml0aWFsaXplci5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICh3ZWlnaHRzU2hhcGUsIGlucHV0VW5pdHMsIG91dHB1dFVuaXRzKSB7XG4gICAgICAgIHJldHVybiBvcHMub25lcyh3ZWlnaHRzU2hhcGUpO1xuICAgIH07XG4gICAgcmV0dXJuIE9uZXNJbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IE9uZXNJbml0aWFsaXplcjtcbnZhciBDb25zdGFudEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25zdGFudEluaXRpYWxpemVyKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gMDsgfVxuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIENvbnN0YW50SW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gb3BzLmZpbGwod2VpZ2h0c1NoYXBlLCB0aGlzLnZhbHVlKTtcbiAgICB9O1xuICAgIHJldHVybiBDb25zdGFudEluaXRpYWxpemVyO1xufSgpKTtcbmV4cG9ydHMuQ29uc3RhbnRJbml0aWFsaXplciA9IENvbnN0YW50SW5pdGlhbGl6ZXI7XG52YXIgVGVuc29ySW5pdGlhbGl6ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvckluaXRpYWxpemVyKHRlbnNvcikge1xuICAgICAgICB0aGlzLnRlbnNvciA9IHRlbnNvcjtcbiAgICB9XG4gICAgVGVuc29ySW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW5zb3I7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29ySW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3JJbml0aWFsaXplciA9IFRlbnNvckluaXRpYWxpemVyO1xudmFyIFJhbmRvbU5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21Ob3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gb3BzLnJhbmRvbU5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21Ob3JtYWxJbml0aWFsaXplciA9IFJhbmRvbU5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcihtZWFuLCBzdGRldikge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGRldiA9PT0gdm9pZCAwKSB7IHN0ZGV2ID0gLjA1OyB9XG4gICAgICAgIHRoaXMubWVhbiA9IG1lYW47XG4gICAgICAgIHRoaXMuc3RkZXYgPSBzdGRldjtcbiAgICB9XG4gICAgUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gb3BzLnRydW5jYXRlZE5vcm1hbCh3ZWlnaHRzU2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRldik7XG4gICAgfTtcbiAgICByZXR1cm4gUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXI7XG59KCkpO1xuZXhwb3J0cy5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplciA9IFJhbmRvbVRydW5jYXRlZE5vcm1hbEluaXRpYWxpemVyO1xudmFyIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyKG1pbnZhbCwgbWF4dmFsKSB7XG4gICAgICAgIGlmIChtaW52YWwgPT09IHZvaWQgMCkgeyBtaW52YWwgPSAtLjA1OyB9XG4gICAgICAgIGlmIChtYXh2YWwgPT09IHZvaWQgMCkgeyBtYXh2YWwgPSAuMDU7IH1cbiAgICAgICAgdGhpcy5taW52YWwgPSBtaW52YWw7XG4gICAgICAgIHRoaXMubWF4dmFsID0gbWF4dmFsO1xuICAgIH1cbiAgICBSYW5kb21Vbmlmb3JtSW5pdGlhbGl6ZXIucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAod2VpZ2h0c1NoYXBlLCBpbnB1dFVuaXRzLCBvdXRwdXRVbml0cykge1xuICAgICAgICByZXR1cm4gb3BzLnJhbmRvbVVuaWZvcm0od2VpZ2h0c1NoYXBlLCB0aGlzLm1pbnZhbCwgdGhpcy5tYXh2YWwpO1xuICAgIH07XG4gICAgcmV0dXJuIFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbn0oKSk7XG5leHBvcnRzLlJhbmRvbVVuaWZvcm1Jbml0aWFsaXplciA9IFJhbmRvbVVuaWZvcm1Jbml0aWFsaXplcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBhZGRfMSA9IHJlcXVpcmUoXCIuL29wcy9hZGRcIik7XG52YXIgYXJnbWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvYXJnbWF4XCIpO1xudmFyIGFyZ21heGVxdWFsc18xID0gcmVxdWlyZShcIi4vb3BzL2FyZ21heGVxdWFsc1wiKTtcbnZhciBjb25jYXRfMSA9IHJlcXVpcmUoXCIuL29wcy9jb25jYXRcIik7XG52YXIgY29udm9sdXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9jb252b2x1dGlvblwiKTtcbnZhciBkaXZpZGVfMSA9IHJlcXVpcmUoXCIuL29wcy9kaXZpZGVcIik7XG52YXIgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9lbGVtZW50X3dpc2VfYWN0aXZhdGlvblwiKTtcbnZhciBlbGVtZW50X3dpc2VfY29zdF8xID0gcmVxdWlyZShcIi4vb3BzL2VsZW1lbnRfd2lzZV9jb3N0XCIpO1xudmFyIGV4cF8xID0gcmVxdWlyZShcIi4vb3BzL2V4cFwiKTtcbnZhciBsaW5lYXJfY29tYmluYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wcy9saW5lYXJfY29tYmluYXRpb25cIik7XG52YXIgbG9nXzEgPSByZXF1aXJlKFwiLi9vcHMvbG9nXCIpO1xudmFyIG1hdG11bF8xID0gcmVxdWlyZShcIi4vb3BzL21hdG11bFwiKTtcbnZhciBtYXhfcG9vbF8xID0gcmVxdWlyZShcIi4vb3BzL21heF9wb29sXCIpO1xudmFyIG11bHRpcGx5XzEgPSByZXF1aXJlKFwiLi9vcHMvbXVsdGlwbHlcIik7XG52YXIgcmVkdWNlX3N1bV8xID0gcmVxdWlyZShcIi4vb3BzL3JlZHVjZV9zdW1cIik7XG52YXIgcmVzaGFwZV8xID0gcmVxdWlyZShcIi4vb3BzL3Jlc2hhcGVcIik7XG52YXIgc29mdG1heF8xID0gcmVxdWlyZShcIi4vb3BzL3NvZnRtYXhcIik7XG52YXIgc3VidHJhY3RfMSA9IHJlcXVpcmUoXCIuL29wcy9zdWJ0cmFjdFwiKTtcbmZ1bmN0aW9uIGVtaXRGcm9tR3JhcGhOb2Rlcyhub2Rlcykge1xuICAgIHZhciBvcHMgPSBbXTtcbiAgICBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShvcHMsIGVtaXRPcEZyb21Ob2RlKG5vZGUpKTsgfSk7XG4gICAgcmV0dXJuIG9wcztcbn1cbmV4cG9ydHMuZW1pdEZyb21HcmFwaE5vZGVzID0gZW1pdEZyb21HcmFwaE5vZGVzO1xuZnVuY3Rpb24gZW1pdE9wRnJvbU5vZGUobm9kZSkge1xuICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZXNoYXBlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyByZXNoYXBlXzEuUmVzaGFwZShub2RlLmlucHV0c1tncmFwaF8xLlJlc2hhcGVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NYXRNdWxOb2RlKSB7XG4gICAgICAgIHZhciB4MSA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF0TXVsTm9kZS5YMV07XG4gICAgICAgIHZhciB4MiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWF0TXVsTm9kZS5YMl07XG4gICAgICAgIHJldHVybiBbbmV3IG1hdG11bF8xLk1hdE11bCh4MSwgeDIsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlKSB7XG4gICAgICAgIHZhciB3ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db252b2x1dGlvbjJETm9kZS5XXTtcbiAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tncmFwaF8xLkNvbnZvbHV0aW9uMkROb2RlLlhdO1xuICAgICAgICB2YXIgYiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29udm9sdXRpb24yRE5vZGUuQl07XG4gICAgICAgIHJldHVybiBbbmV3IGNvbnZvbHV0aW9uXzEuQ29udm9sdXRpb24yRCh3LCB4LCBiLCBub2RlLm91dHB1dCwgbm9kZS5maWVsZFNpemUsIG5vZGUub3V0cHV0RGVwdGgsIG5vZGUuc3RyaWRlLCBub2RlLnplcm9QYWQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWF4UG9vbE5vZGUpIHtcbiAgICAgICAgdmFyIHggPSBub2RlLmlucHV0c1tncmFwaF8xLk1heFBvb2xOb2RlLlhdO1xuICAgICAgICByZXR1cm4gW25ldyBtYXhfcG9vbF8xLk1heFBvb2woeCwgbm9kZS5vdXRwdXQsIG5vZGUuZmllbGRTaXplLCBub2RlLnN0cmlkZSwgbm9kZS56ZXJvUGFkKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkV4cE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZXhwXzEuRXhwKG5vZGUuaW5wdXRzW2dyYXBoXzEuRXhwTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTG9nTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBsb2dfMS5Mb2cobm9kZS5pbnB1dHNbZ3JhcGhfMS5Mb2dOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5SZUxVTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlJlTFUobm9kZS5pbnB1dHNbZ3JhcGhfMS5SZUxVTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTGVha3lSZUxVTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLkxlYWt5UmVMVShub2RlLmlucHV0c1tncmFwaF8xLkxlYWt5UmVMVU5vZGUuWF0sIG5vZGUub3V0cHV0LCBub2RlLmFscGhhKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlBSZUxVTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlBSZUxVKG5vZGUuaW5wdXRzW2dyYXBoXzEuUFJlTFVOb2RlLlhdLCBub2RlLmlucHV0c1tncmFwaF8xLlBSZUxVTm9kZS5BTFBIQV0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkVsdU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5FbHUobm9kZS5pbnB1dHNbZ3JhcGhfMS5FbHVOb2RlLlhdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5UYW5ITm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlRhbkgobm9kZS5pbnB1dHNbZ3JhcGhfMS5UYW5ITm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU2lnbW9pZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2FjdGl2YXRpb25fMS5TaWdtb2lkKG5vZGUuaW5wdXRzW2dyYXBoXzEuU2lnbW9pZE5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0Tm9kZSkge1xuICAgICAgICB2YXIgeCA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuU29mdG1heENyb3NzRW50cm9weUNvc3ROb2RlLlhdO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gbm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdE5vZGUuVEFSR0VUXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgc29mdG1heF8xLlNvZnRtYXhDcm9zc0VudHJvcHlDb3N0KHgsIHRhcmdldCwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU29mdG1heE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgc29mdG1heF8xLlNvZnRtYXgobm9kZS5pbnB1dHNbZ3JhcGhfMS5Tb2Z0bWF4Tm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZSkge1xuICAgICAgICB2YXIgbGFiZWwgPSBub2RlLmlucHV0c1tncmFwaF8xLk1lYW5TcXVhcmVkQ29zdE5vZGUuTEFCRUxdO1xuICAgICAgICB2YXIgcHJlZGljdGlvbiA9IG5vZGUuaW5wdXRzW2dyYXBoXzEuTWVhblNxdWFyZWRDb3N0Tm9kZS5QUkVESUNUSU9OXTtcbiAgICAgICAgcmV0dXJuIFtuZXcgZWxlbWVudF93aXNlX2Nvc3RfMS5NZWFuU3F1YXJlZENvc3QobGFiZWwsIHByZWRpY3Rpb24sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFyZ01heEVxdWFsc05vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYXJnbWF4ZXF1YWxzXzEuQXJnTWF4RXF1YWxzKG5vZGUuaW5wdXRzW2dyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQXJnTWF4RXF1YWxzTm9kZS5YMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFyZ01heE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYXJnbWF4XzEuQXJnTWF4KG5vZGUueCwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbGluZWFyX2NvbWJpbmF0aW9uXzEuTGluZWFyQ29tYmluYXRpb24obm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuRnVzZWRMaW5lYXJDb21iaW5hdGlvbk5vZGUuVDJdLCBub2RlLmlucHV0c1tncmFwaF8xLkZ1c2VkTGluZWFyQ29tYmluYXRpb25Ob2RlLkMxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5GdXNlZExpbmVhckNvbWJpbmF0aW9uTm9kZS5DMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbmNhdDFETm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBjb25jYXRfMS5Db25jYXQxRChub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDFETm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0MUROb2RlLlgyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uY2F0MkROb2RlKSB7XG4gICAgICAgIHJldHVybiBbbmV3IGNvbmNhdF8xLkNvbmNhdDJEKG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0MkROb2RlLlgxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQyRE5vZGUuWDJdLCBub2RlLmF4aXMsIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkNvbmNhdDNETm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBjb25jYXRfMS5Db25jYXQzRChub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDNETm9kZS5YMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQ29uY2F0M0ROb2RlLlgyXSwgbm9kZS5heGlzLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5Db25jYXQ0RE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgY29uY2F0XzEuQ29uY2F0NEQobm9kZS5pbnB1dHNbZ3JhcGhfMS5Db25jYXQ0RE5vZGUuWDFdLCBub2RlLmlucHV0c1tncmFwaF8xLkNvbmNhdDRETm9kZS5YMl0sIG5vZGUuYXhpcywgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuU3F1YXJlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBlbGVtZW50X3dpc2VfYWN0aXZhdGlvbl8xLlNxdWFyZShub2RlLmlucHV0c1tncmFwaF8xLlNxdWFyZU5vZGUuWF0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLkFkZE5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgYWRkXzEuQWRkKG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuQWRkTm9kZS5UMl0sIG5vZGUub3V0cHV0KV07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBncmFwaF8xLlN1YnRyYWN0Tm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBzdWJ0cmFjdF8xLlN1YnRyYWN0KG5vZGUuaW5wdXRzW2dyYXBoXzEuU3VidHJhY3ROb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5TdWJ0cmFjdE5vZGUuVDJdLCBub2RlLm91dHB1dCldO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5NdWx0aXBseU5vZGUpIHtcbiAgICAgICAgcmV0dXJuIFtuZXcgbXVsdGlwbHlfMS5NdWx0aXBseShub2RlLmlucHV0c1tncmFwaF8xLk11bHRpcGx5Tm9kZS5UMV0sIG5vZGUuaW5wdXRzW2dyYXBoXzEuTXVsdGlwbHlOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuRGl2aWRlTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyBkaXZpZGVfMS5EaXZpZGUobm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQxXSwgbm9kZS5pbnB1dHNbZ3JhcGhfMS5EaXZpZGVOb2RlLlQyXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuUmVkdWNlU3VtTm9kZSkge1xuICAgICAgICByZXR1cm4gW25ldyByZWR1Y2Vfc3VtXzEuUmVkdWNlU3VtKG5vZGUuaW5wdXRzW2dyYXBoXzEuUmVkdWNlU3VtTm9kZS5YXSwgbm9kZS5vdXRwdXQpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZ3JhcGhfdXRpbC5pc0lucHV0Tm9kZShub2RlKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVuc3VwcG9ydGVkIG5vZGUgdHlwZTogXCIgKyBub2RlLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQWRkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRkLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkZCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSB8fFxuICAgICAgICAgICAgKHgxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMiAmJiB4MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICB4MVRlbnNvci5zaGFwZVsxXSA9PT0geDJUZW5zb3Iuc2hhcGVbMF0pIHx8XG4gICAgICAgICAgICAoeDFUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAxICYmIHgyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgICAgIHgxVGVuc29yLnNoYXBlWzBdID09PSB4MlRlbnNvci5zaGFwZVsxXSksICdPbmUgb2YgdDEgb3IgdDIgbXVzdCBiZSBhIHNjYWxhciwgb3IgdDEgYW5kIHQyIG11c3QgaGF2ZSAnICtcbiAgICAgICAgICAgICd0aGUgc2FtZSBzaGFwZSwgJyArXG4gICAgICAgICAgICAnb3Igb25lIG9mIHRoZW0gY2FuIGJlIGJyb2FkY2FzdGVkICgyRCBhbmQgMUQpLicpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkZC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc2NhbGFyUGx1c0FycmF5KHgxLCB4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoeDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5zY2FsYXJQbHVzQXJyYXkoeDIsIHgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguYWRkKHgxLCB4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKHJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkZC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLngxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy54MlRlbnNvci5zaGFwZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMueDFUZW5zb3Iuc2hhcGVbMF0gPT09IF90aGlzLngyVGVuc29yLnNoYXBlWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgc3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLngxVGVuc29yLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIHN1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMueDFUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLngyVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy54MVRlbnNvci5zaGFwZVsxXSA9PT0gX3RoaXMueDJUZW5zb3Iuc2hhcGVbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN1bSA9IG1hdGguc3VtKGR5LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBzdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDJUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShkeSk7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgc3VtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5jbG9uZShkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmR5U2l6ZVNjYWxhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmR5U2l6ZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZGQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFkZCA9IEFkZDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIEFyZ01heCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFyZ01heCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBcmdNYXgoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAobWF0aC5hcmdNYXgoeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBcmdNYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBcmdNYXggYmFja3Byb3AgdW5pbXBsZW1lbnRlZCcpO1xuICAgIH07XG4gICAgcmV0dXJuIEFyZ01heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQXJnTWF4ID0gQXJnTWF4O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ2xvYmFsc1wiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQXJnTWF4RXF1YWxzID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQXJnTWF4RXF1YWxzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFyZ01heEVxdWFscyh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQXJnTWF4RXF1YWxzLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLmFyZ01heEVxdWFscyh4MSwgeDIpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQXJnTWF4RXF1YWxzLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJnTWF4RXF1YWxzIGJhY2twcm9wIHVuaW1wbGVtZW50ZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBBcmdNYXhFcXVhbHM7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkFyZ01heEVxdWFscyA9IEFyZ01heEVxdWFscztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgY29uY2F0X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2NvbmNhdF91dGlsXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgQ29uY2F0MUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQxRCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0MUQucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZWNlbkFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVjZW5BcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVjZW5BcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uY2F0UmVzdWx0ID0gbWF0aC5jb25jYXQxRCh4MSwgeDIpO1xuICAgICAgICAgICAgaW5mZXJlY2VuQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChjb25jYXRSZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXQxRC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25jYXRCYWNrUHJvcChtYXRoLCBfdGhpcy54MVRlbnNvciwgX3RoaXMueDJUZW5zb3IsIF90aGlzLnlUZW5zb3IsIDAsIGdyYWRpZW50QXJyYXlzLCBpbmZlcmVuY2VBcnJheXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQxRDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0MUQgPSBDb25jYXQxRDtcbnZhciBDb25jYXQyRCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKENvbmNhdDJELCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIENvbmNhdDJEKHgxVGVuc29yLCB4MlRlbnNvciwgYXhpcywgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy5heGlzID0gYXhpcztcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIGNvbmNhdF91dGlsLmFzc2VydFBhcmFtcyh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENvbmNhdDJELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVjZW5BcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlY2VuQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlY2VuQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvbmNhdFJlc3VsdCA9IG1hdGguY29uY2F0MkQoeDEsIHgyLCBfdGhpcy5heGlzKTtcbiAgICAgICAgICAgIGluZmVyZWNlbkFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAoY29uY2F0UmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29uY2F0MkQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uY2F0QmFja1Byb3AobWF0aCwgX3RoaXMueDFUZW5zb3IsIF90aGlzLngyVGVuc29yLCBfdGhpcy55VGVuc29yLCBfdGhpcy5heGlzLCBncmFkaWVudEFycmF5cywgaW5mZXJlbmNlQXJyYXlzKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gQ29uY2F0MkQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbmNhdDJEID0gQ29uY2F0MkQ7XG52YXIgQ29uY2F0M0QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDb25jYXQzRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25jYXQzRCh4MVRlbnNvciwgeDJUZW5zb3IsIGF4aXMsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMuYXhpcyA9IGF4aXM7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICBjb25jYXRfdXRpbC5hc3NlcnRQYXJhbXMoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25jYXQzRC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBjb25jYXRSZXN1bHQgPSBtYXRoLmNvbmNhdDNEKHgxLCB4MiwgX3RoaXMuYXhpcyk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKGNvbmNhdFJlc3VsdCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbmNhdDNELnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbmNhdEJhY2tQcm9wKG1hdGgsIF90aGlzLngxVGVuc29yLCBfdGhpcy54MlRlbnNvciwgX3RoaXMueVRlbnNvciwgX3RoaXMuYXhpcywgZ3JhZGllbnRBcnJheXMsIGluZmVyZW5jZUFycmF5cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIENvbmNhdDNEO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Db25jYXQzRCA9IENvbmNhdDNEO1xudmFyIENvbmNhdDREID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29uY2F0NEQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29uY2F0NEQoeDFUZW5zb3IsIHgyVGVuc29yLCBheGlzLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLmF4aXMgPSBheGlzO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKHgxVGVuc29yLnNoYXBlLCB4MlRlbnNvci5zaGFwZSwgYXhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQ29uY2F0NEQucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZWNlbkFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVjZW5BcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVjZW5BcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgY29uY2F0UmVzdWx0ID0gbWF0aC5jb25jYXQ0RCh4MSwgeDIsIF90aGlzLmF4aXMpO1xuICAgICAgICAgICAgaW5mZXJlY2VuQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChjb25jYXRSZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25jYXQ0RC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25jYXRCYWNrUHJvcChtYXRoLCBfdGhpcy54MVRlbnNvciwgX3RoaXMueDJUZW5zb3IsIF90aGlzLnlUZW5zb3IsIF90aGlzLmF4aXMsIGdyYWRpZW50QXJyYXlzLCBpbmZlcmVuY2VBcnJheXMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBDb25jYXQ0RDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuQ29uY2F0NEQgPSBDb25jYXQ0RDtcbmZ1bmN0aW9uIGNvbmNhdEJhY2tQcm9wKG1hdGgsIGFUZW5zb3IsIGJUZW5zb3IsIHlUZW5zb3IsIGF4aXMsIGdyYWRBcnJheXMsIGluZkFycmF5cykge1xuICAgIHZhciBkeSA9IGdyYWRBcnJheXMuZ2V0KHlUZW5zb3IpO1xuICAgIHZhciBhID0gaW5mQXJyYXlzLmdldChhVGVuc29yKTtcbiAgICB2YXIgYiA9IGluZkFycmF5cy5nZXQoYlRlbnNvcik7XG4gICAgdmFyIGEyRCA9IGEuYXMyRCgtMSwgdXRpbC5zaXplRnJvbVNoYXBlKGEuc2hhcGUuc2xpY2UoYXhpcykpKTtcbiAgICB2YXIgYjJEID0gYi5hczJEKC0xLCB1dGlsLnNpemVGcm9tU2hhcGUoYi5zaGFwZS5zbGljZShheGlzKSkpO1xuICAgIHZhciBfYSA9IGNvbmNhdF91dGlsLmNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzKGEyRC5zaGFwZSwgYjJELnNoYXBlKSwgYUJlZ2luID0gX2EuYUJlZ2luLCBhU2l6ZSA9IF9hLmFTaXplLCBiQmVnaW4gPSBfYS5iQmVnaW4sIGJTaXplID0gX2EuYlNpemU7XG4gICAgdmFyIGR5MkQgPSBkeS5hczJEKC0xLCBhMkQuc2hhcGVbMV0gKyBiMkQuc2hhcGVbMV0pO1xuICAgIHZhciBzbGljZTFSZXN1bHQgPSBtYXRoLnNsaWNlMkQoZHkyRCwgYUJlZ2luLCBhU2l6ZSkucmVzaGFwZUFzKGEpO1xuICAgIHZhciBzbGljZTJSZXN1bHQgPSBtYXRoLnNsaWNlMkQoZHkyRCwgYkJlZ2luLCBiU2l6ZSkucmVzaGFwZUFzKGIpO1xuICAgIGdyYWRBcnJheXMuYWRkKGFUZW5zb3IsIHNsaWNlMVJlc3VsdCk7XG4gICAgZ3JhZEFycmF5cy5hZGQoYlRlbnNvciwgc2xpY2UyUmVzdWx0KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4uLy4uL29wcy9jb252X3V0aWxcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBDb252b2x1dGlvbjJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29udm9sdXRpb24yRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb252b2x1dGlvbjJEKHdUZW5zb3IsIHhUZW5zb3IsIGJUZW5zb3IsIHlUZW5zb3IsIGZpZWxkU2l6ZSwgb3V0cHV0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy53VGVuc29yID0gd1RlbnNvcjtcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLmJUZW5zb3IgPSBiVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZmllbGRTaXplID0gZmllbGRTaXplO1xuICAgICAgICBfdGhpcy5vdXRwdXREZXB0aCA9IG91dHB1dERlcHRoO1xuICAgICAgICBfdGhpcy5zdHJpZGUgPSBzdHJpZGU7XG4gICAgICAgIF90aGlzLmFzc2VydFdlaWdodHNTaGFwZSh3VGVuc29yLnNoYXBlKTtcbiAgICAgICAgX3RoaXMuemVyb1BhZCA9IHplcm9QYWQgIT0gbnVsbCA/XG4gICAgICAgICAgICB6ZXJvUGFkIDpcbiAgICAgICAgICAgIGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZChfdGhpcy54VGVuc29yLnNoYXBlLCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQoX3RoaXMuemVyb1BhZCksIFwiVGhlIHplcm8gcGFkZGluZyAoXCIgKyBfdGhpcy56ZXJvUGFkICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb252b2x1dGlvbjJELnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHdlaWdodHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMud1RlbnNvcik7XG4gICAgICAgIHZhciBiaWFzZXMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYlRlbnNvcik7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKG1hdGguY29udjJkKHgsIHdlaWdodHMsIGJpYXNlcywgX3RoaXMuc3RyaWRlLCBfdGhpcy56ZXJvUGFkKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENvbnZvbHV0aW9uMkQucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGZpbHRlciA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy53VGVuc29yKTtcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHcgPSBtYXRoLmNvbnYyZERlckZpbHRlcih4LCBkeSwgZmlsdGVyLnNoYXBlLCBfdGhpcy5zdHJpZGUsIF90aGlzLnplcm9QYWQpO1xuICAgICAgICAgICAgdmFyIGRiID0gbWF0aC5zdW0oZHksIFswLCAxXSk7XG4gICAgICAgICAgICB2YXIgZHggPSBtYXRoLmNvbnYyZERlcklucHV0KHguc2hhcGUsIGR5LCBmaWx0ZXIsIF90aGlzLnN0cmlkZSwgX3RoaXMuemVyb1BhZCk7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMud1RlbnNvciwgZHcpO1xuICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmJUZW5zb3IsIGRiKTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBkeCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29udm9sdXRpb24yRC5wcm90b3R5cGUuYXNzZXJ0V2VpZ2h0c1NoYXBlID0gZnVuY3Rpb24gKHdlaWdodHNTaGFwZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh3ZWlnaHRzU2hhcGVbMF0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMV0gPT09IHRoaXMuZmllbGRTaXplICYmXG4gICAgICAgICAgICB3ZWlnaHRzU2hhcGVbMl0gPT09IHRoaXMueFRlbnNvci5zaGFwZVsyXSAmJlxuICAgICAgICAgICAgd2VpZ2h0c1NoYXBlWzNdID09PSB0aGlzLm91dHB1dERlcHRoLCBcIndlaWdodHMgbXVzdCBiZSBvZiBzaGFwZSBbXCIgKyB0aGlzLmZpZWxkU2l6ZSArIFwiLFwiICsgdGhpcy5maWVsZFNpemUgKyBcIixcIiArXG4gICAgICAgICAgICAodGhpcy54VGVuc29yLnNoYXBlWzJdICsgXCIsXCIgKyB0aGlzLm91dHB1dERlcHRoICsgXCJdIGJ1dCB0aGV5IGFyZSBvZlwiKSArXG4gICAgICAgICAgICAoXCJzaGFwZSBbXCIgKyB3ZWlnaHRzU2hhcGUgKyBcIl1cIikpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbnZvbHV0aW9uMkQ7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkNvbnZvbHV0aW9uMkQgPSBDb252b2x1dGlvbjJEO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ2xvYmFsc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBEaXZpZGUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEaXZpZGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGl2aWRlKHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54MVRlbnNvciA9IHgxVGVuc29yO1xuICAgICAgICBfdGhpcy54MlRlbnNvciA9IHgyVGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHgyVGVuc29yLnNoYXBlKSA9PT0gMSB8fFxuICAgICAgICAgICAgdXRpbC5hcnJheXNFcXVhbCh4MVRlbnNvci5zaGFwZSwgeDJUZW5zb3Iuc2hhcGUpLCAnT25lIG9mIHQxIG9yIHQyIG11c3QgYmUgYSBzY2FsYXIsIG9yIHQxIGFuZCB0MiBtdXN0IGhhdmUgJyArXG4gICAgICAgICAgICAndGhlIHNhbWUgc2hhcGUnKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBEaXZpZGUucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHQxLCB0Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUodDIuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih0MSwgdDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gbWF0aC5kaXZpZGUodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRGl2aWRlLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgeDFJc1NjYWxhciA9IHV0aWwuaXNTY2FsYXJTaGFwZSh4MS5zaGFwZSk7XG4gICAgICAgIHZhciB4MklzU2NhbGFyID0gdXRpbC5pc1NjYWxhclNoYXBlKHgyLnNoYXBlKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDFUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHgxSXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpdiA9IG1hdGguZGl2aWRlKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0oZGl2KSk7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmFycmF5RGl2aWRlZEJ5U2NhbGFyKGR5LCB4MikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLmRpdmlkZShkeSwgeDIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgeDJTcXVhcmVkID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgeDIpO1xuICAgICAgICAgICAgICAgIHZhciB4MU92ZXJYMlNxdWFyZWQgPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5hcnJheURpdmlkZWRCeVNjYWxhcih4MSwgeDJTcXVhcmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeDFJc1NjYWxhcikge1xuICAgICAgICAgICAgICAgICAgICB4MU92ZXJYMlNxdWFyZWQgPSBtYXRoLnNjYWxhckRpdmlkZWRCeUFycmF5KHgxLCB4MlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeDFPdmVyWDJTcXVhcmVkID0gbWF0aC5kaXZpZGUoeDEsIHgyU3F1YXJlZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBkeDIgPSBtYXRoLm5lZyh4MU92ZXJYMlNxdWFyZWQpO1xuICAgICAgICAgICAgICAgIHZhciBkeVRpbWVzRGVyaXZhdGl2ZSA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIGR4Mik7XG4gICAgICAgICAgICAgICAgaWYgKHgySXNTY2FsYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShkeVRpbWVzRGVyaXZhdGl2ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBkeVRpbWVzRGVyaXZhdGl2ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBEaXZpZGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkRpdmlkZSA9IERpdmlkZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9hY3RpdmF0aW9uX2Z1bmN0aW9uc1wiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRWxlbWVudFdpc2VBY3RpdmF0aW9uID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFdpc2VBY3RpdmF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRXaXNlQWN0aXZhdGlvbih4VGVuc29yLCB5VGVuc29yLCBmdW5jKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgX3RoaXMuZnVuYyA9IGZ1bmM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRWxlbWVudFdpc2VBY3RpdmF0aW9uLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAoX3RoaXMuZnVuYy5vdXRwdXQobWF0aCwgeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGR5ZHggPSBfdGhpcy5mdW5jLmRlcihtYXRoLCB4LCB5KTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCBkeWR4KSk7XG4gICAgICAgICAgICBkeWR4LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBFbGVtZW50V2lzZUFjdGl2YXRpb24ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZnVuYy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFdpc2VBY3RpdmF0aW9uO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FbGVtZW50V2lzZUFjdGl2YXRpb24gPSBFbGVtZW50V2lzZUFjdGl2YXRpb247XG52YXIgUmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlTFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVMVSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5SZUxVRnVuYygpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gUmVMVTtcbn0oRWxlbWVudFdpc2VBY3RpdmF0aW9uKSk7XG5leHBvcnRzLlJlTFUgPSBSZUxVO1xudmFyIExlYWt5UmVMVSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExlYWt5UmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBMZWFreVJlTFUoeFRlbnNvciwgeVRlbnNvciwgYWxwaGEpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLkxlYWt5UmVsdUZ1bmMoYWxwaGEpKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTGVha3lSZUxVO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuTGVha3lSZUxVID0gTGVha3lSZUxVO1xudmFyIFRhbkggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUYW5ILCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRhbkgoeFRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICByZXR1cm4gX3N1cGVyLmNhbGwodGhpcywgeFRlbnNvciwgeVRlbnNvciwgbmV3IGFjdGl2YXRpb25fZnVuY3Rpb25zXzEuVGFuSEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIFRhbkg7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5UYW5IID0gVGFuSDtcbnZhciBTaWdtb2lkID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2lnbW9pZCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTaWdtb2lkKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHhUZW5zb3IsIHlUZW5zb3IsIG5ldyBhY3RpdmF0aW9uX2Z1bmN0aW9uc18xLlNpZ21vaWRGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTaWdtb2lkO1xufShFbGVtZW50V2lzZUFjdGl2YXRpb24pKTtcbmV4cG9ydHMuU2lnbW9pZCA9IFNpZ21vaWQ7XG52YXIgU3F1YXJlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3F1YXJlLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNxdWFyZSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5TcXVhcmVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBTcXVhcmU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5TcXVhcmUgPSBTcXVhcmU7XG52YXIgRWx1ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWx1LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsdSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIuY2FsbCh0aGlzLCB4VGVuc29yLCB5VGVuc29yLCBuZXcgYWN0aXZhdGlvbl9mdW5jdGlvbnNfMS5FbHVGdW5jKCkpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBFbHU7XG59KEVsZW1lbnRXaXNlQWN0aXZhdGlvbikpO1xuZXhwb3J0cy5FbHUgPSBFbHU7XG52YXIgUFJlTFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhQUmVMVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQUmVMVSh4VGVuc29yLCBhbHBoYVRlbnNvciwgeVRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMuYWxwaGFUZW5zb3IgPSBhbHBoYVRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUFJlTFUucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGFscGhhID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmFscGhhVGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLnByZWx1KHgsIGFscGhhKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBSZUxVLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm90IGltcGxlbWVudGVkJyk7XG4gICAgfTtcbiAgICByZXR1cm4gUFJlTFU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlBSZUxVID0gUFJlTFU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vLi4vdGVuc29yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBjb3N0X2Z1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2Nvc3RfZnVuY3Rpb25zXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgRWxlbWVudFdpc2VDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRWxlbWVudFdpc2VDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEVsZW1lbnRXaXNlQ29zdCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IsIGZ1bmMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZ1bmMgPSBmdW5jO1xuICAgICAgICBfdGhpcy5vbmVPdmVyTlNjYWxhciA9XG4gICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5tYXRoLmtlZXAodGVuc29yXzEuU2NhbGFyLm5ldygxIC8gdXRpbC5zaXplRnJvbVNoYXBlKHgxVGVuc29yLnNoYXBlKSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50V2lzZUNvc3QgPSBfdGhpcy5mdW5jLmNvc3QoeDEsIHgyKTtcbiAgICAgICAgICAgIHZhciBzdW0gPSBtYXRoLnN1bShlbGVtZW50V2lzZUNvc3QpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGguc2NhbGFyVGltZXNBcnJheShfdGhpcy5vbmVPdmVyTlNjYWxhciwgc3VtKTtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRWxlbWVudFdpc2VDb3N0LnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgX3RoaXMuZnVuYy5kZXIoeDEsIHgyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy54MlRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIF90aGlzLmZ1bmMuZGVyKHgyLCB4MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEVsZW1lbnRXaXNlQ29zdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5mdW5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVPdmVyTlNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gRWxlbWVudFdpc2VDb3N0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5FbGVtZW50V2lzZUNvc3QgPSBFbGVtZW50V2lzZUNvc3Q7XG52YXIgTWVhblNxdWFyZWRDb3N0ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhblNxdWFyZWRDb3N0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYW5TcXVhcmVkQ29zdCh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIHgxVGVuc29yLCB4MlRlbnNvciwgeVRlbnNvciwgbmV3IGNvc3RfZnVuY3Rpb25zXzEuU3F1YXJlQ29zdEZ1bmMoKSkgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE1lYW5TcXVhcmVkQ29zdDtcbn0oRWxlbWVudFdpc2VDb3N0KSk7XG5leHBvcnRzLk1lYW5TcXVhcmVkQ29zdCA9IE1lYW5TcXVhcmVkQ29zdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBFeHAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhFeHAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXhwKHhUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueFRlbnNvciA9IHhUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEV4cC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnhUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKG1hdGguZXhwKHgpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXhwLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB5ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLnlUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueFRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh5LCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBFeHA7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkV4cCA9IEV4cDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgZ3JhcGhfdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaF91dGlsXCIpO1xudmFyIG9wXzEgPSByZXF1aXJlKFwiLi9vcFwiKTtcbnZhciBMaW5lYXJDb21iaW5hdGlvbiA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbmVhckNvbWJpbmF0aW9uLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbmVhckNvbWJpbmF0aW9uKHgxVGVuc29yLCB4MlRlbnNvciwgYzFUZW5zb3IsIGMyVGVuc29yLCBvdXRUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMuYzFUZW5zb3IgPSBjMVRlbnNvcjtcbiAgICAgICAgX3RoaXMuYzJUZW5zb3IgPSBjMlRlbnNvcjtcbiAgICAgICAgX3RoaXMub3V0VGVuc29yID0gb3V0VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIExpbmVhckNvbWJpbmF0aW9uLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGMxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLmMxVGVuc29yKS5hc1NjYWxhcigpO1xuICAgICAgICB2YXIgYzIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuYzJUZW5zb3IpLmFzU2NhbGFyKCk7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLnNjYWxlZEFycmF5QWRkKGMxLCB4MSwgYzIsIHgyKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmVhckNvbWJpbmF0aW9uLnByb3RvdHlwZS5iYWNrUHJvcCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIHZhciBjMSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMVRlbnNvcik7XG4gICAgICAgIHZhciBjMiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5jMlRlbnNvcik7XG4gICAgICAgIHZhciBkeSA9IGdyYWRpZW50QXJyYXlzLmdldCh0aGlzLm91dFRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zY2FsYXJUaW1lc0FycmF5KGMxLCBkeSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoYzIsIGR5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy5jMVRlbnNvcikpIHtcbiAgICAgICAgICAgICAgICB2YXIgZG90UHJvZHVjdDEgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKHgxLCBkeSk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLmMxVGVuc29yLCBtYXRoLnN1bShkb3RQcm9kdWN0MSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMuYzJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvdFByb2R1Y3QyID0gbWF0aC5lbGVtZW50V2lzZU11bCh4MiwgZHkpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5jMlRlbnNvciwgbWF0aC5zdW0oZG90UHJvZHVjdDIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTGluZWFyQ29tYmluYXRpb247XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLkxpbmVhckNvbWJpbmF0aW9uID0gTGluZWFyQ29tYmluYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9nbG9iYWxzXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTG9nID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTG9nLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExvZyh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBMb2cucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLmxvZyh4KSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExvZy5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLnhUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnhUZW5zb3IsIG1hdGguZGl2aWRlKGR5LCB4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIExvZztcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTG9nID0gTG9nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ2xvYmFsc1wiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE1hdE11bCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hdE11bCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNYXRNdWwoeDFUZW5zb3IsIHgyVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLngxVGVuc29yID0geDFUZW5zb3I7XG4gICAgICAgIF90aGlzLngyVGVuc29yID0geDJUZW5zb3I7XG4gICAgICAgIF90aGlzLnlUZW5zb3IgPSB5VGVuc29yO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIE1hdE11bC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4MSA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MVRlbnNvcik7XG4gICAgICAgIHZhciB4MiA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54MlRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLm1hdE11bCh4MSwgeDIpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh4MS5zaGFwZS5sZW5ndGggPT09IDIgJiYgeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy55VGVuc29yLCBnbG9iYWxzXzEua2VlcChtYXRoLm1hdHJpeFRpbWVzVmVjdG9yKHgxLCB4MikpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4Mi5zaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKG1hdGgudmVjdG9yVGltZXNNYXRyaXgoeDEsIHgyKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdE11bC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgeDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy55VGVuc29yKTtcbiAgICAgICAgaWYgKHgxLnNoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgeDEgPSB4MS5yZXNoYXBlKFsxLCB4MS5zaXplXSk7XG4gICAgICAgICAgICBkeSA9IGR5LnJlc2hhcGUoWzEsIGR5LnNpemVdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoeDIuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB4MiA9IHgyLnJlc2hhcGUoW3gyLnNpemUsIDFdKTtcbiAgICAgICAgICAgIGR5ID0gZHkucmVzaGFwZShbZHkuc2l6ZSwgMV0pO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkeDEgPSBtYXRoLm1hdE11bChkeSwgeDIsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIF90aGlzLngxVGVuc29yLnNoYXBlLmxlbmd0aCA9PT0gMSA/IGR4MS5hczFEKCkgOiBkeDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4MiA9IG1hdGgubWF0TXVsKHgxLCBkeSwgdHJ1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgX3RoaXMueDJUZW5zb3Iuc2hhcGUubGVuZ3RoID09PSAxID8gZHgyLmFzMUQoKSA6IGR4Mik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE1hdE11bDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuTWF0TXVsID0gTWF0TXVsO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vZ2xvYmFsc1wiKTtcbnZhciBjb252X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL2NvbnZfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIE1heFBvb2wgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNYXhQb29sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1heFBvb2woeFRlbnNvciwgeVRlbnNvciwgZmllbGRTaXplLCBzdHJpZGUsIHBhZCkge1xuICAgICAgICBpZiAoc3RyaWRlID09PSB2b2lkIDApIHsgc3RyaWRlID0gMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy54VGVuc29yID0geFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLmZpZWxkU2l6ZSA9IGZpZWxkU2l6ZTtcbiAgICAgICAgX3RoaXMuc3RyaWRlID0gc3RyaWRlO1xuICAgICAgICBpZiAocGFkICE9IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLnBhZCA9IHBhZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF90aGlzLnBhZCA9IGNvbnZfdXRpbC5jb21wdXRlRGVmYXVsdFBhZCh4VGVuc29yLnNoYXBlLCBfdGhpcy5maWVsZFNpemUsIF90aGlzLnN0cmlkZSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChfdGhpcy5wYWQpLCBcIlRoZSB6ZXJvIHBhZGRpbmcgKFwiICsgX3RoaXMucGFkICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgICAgICBcInN0cmlkZSBhbmQvb3IgemVybyBwYWQgcGFyYW1ldGVyc1wiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYXhQb29sLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAobWF0aC5tYXhQb29sKHgsIF90aGlzLmZpZWxkU2l6ZSwgX3RoaXMuc3RyaWRlLCBfdGhpcy5wYWQpKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF4UG9vbC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgeCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy54VGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54VGVuc29yLCBtYXRoLm1heFBvb2xCYWNrcHJvcChkeSwgeCwgX3RoaXMuZmllbGRTaXplLCBfdGhpcy5zdHJpZGUsIF90aGlzLnBhZCkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBNYXhQb29sO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NYXhQb29sID0gTWF4UG9vbDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgTXVsdGlwbHkgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNdWx0aXBseSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNdWx0aXBseSh4MVRlbnNvciwgeDJUZW5zb3IsIHlUZW5zb3IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMueDFUZW5zb3IgPSB4MVRlbnNvcjtcbiAgICAgICAgX3RoaXMueDJUZW5zb3IgPSB4MlRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh4MVRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh4MlRlbnNvci5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwoeDFUZW5zb3Iuc2hhcGUsIHgyVGVuc29yLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDFUZW5zb3IpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueDJUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhclRpbWVzQXJyYXkodDIsIHQxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguZWxlbWVudFdpc2VNdWwodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTXVsdGlwbHkucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHgxID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngxVGVuc29yKTtcbiAgICAgICAgdmFyIHgyID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngyVGVuc29yKTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKF90aGlzLngxVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIGlmICh1dGlsLmlzU2NhbGFyU2hhcGUoX3RoaXMueDFUZW5zb3Iuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtdWwgPSBtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB4Mik7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MVRlbnNvciwgbWF0aC5zdW0obXVsKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh4Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngxVGVuc29yLCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDFUZW5zb3IsIG1hdGguZWxlbWVudFdpc2VNdWwoeDIsIGR5KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMueDJUZW5zb3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZShfdGhpcy54MlRlbnNvci5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG11bCA9IG1hdGguZWxlbWVudFdpc2VNdWwoZHksIHgxKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLngyVGVuc29yLCBtYXRoLnN1bShtdWwpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodXRpbC5pc1NjYWxhclNoYXBlKHgxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueDJUZW5zb3IsIG1hdGguc2NhbGFyVGltZXNBcnJheSh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54MlRlbnNvciwgbWF0aC5lbGVtZW50V2lzZU11bCh4MSwgZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpcGx5O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5NdWx0aXBseSA9IE11bHRpcGx5O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgT3BlcmF0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcGVyYXRpb24oKSB7XG4gICAgfVxuICAgIE9wZXJhdGlvbi5wcm90b3R5cGUuZGlzcG9zZVRyYW5zaWVudEFycmF5cyA9IGZ1bmN0aW9uIChpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7IH07XG4gICAgT3BlcmF0aW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIHJldHVybiBPcGVyYXRpb247XG59KCkpO1xuZXhwb3J0cy5PcGVyYXRpb24gPSBPcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vLi4vdGVuc29yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFJlZHVjZVN1bSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlZHVjZVN1bSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWR1Y2VTdW0oeCwgb3V0VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnggPSB4O1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gob3V0VGVuc29yLnNoYXBlLCBbXSk7XG4gICAgICAgIF90aGlzLm9uZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5tYXRoLmtlZXAodGVuc29yXzEuVGVuc29yLm9uZXMoeC5zaGFwZSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlZHVjZVN1bS5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciB4ID0gaW5mZXJlbmNlQXJyYXlzLmdldCh0aGlzLngpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLm91dFRlbnNvciwgZ2xvYmFsc18xLmtlZXAobWF0aC5zdW0oeCkpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLnNob3VsZEJhY2tQcm9wKHRoaXMueCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQoX3RoaXMub3V0VGVuc29yKTtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy54LCBtYXRoLnNjYWxhclRpbWVzQXJyYXkoZHksIF90aGlzLm9uZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBSZWR1Y2VTdW0ucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMub25lcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICByZXR1cm4gUmVkdWNlU3VtO1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5SZWR1Y2VTdW0gPSBSZWR1Y2VTdW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9nbG9iYWxzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgUmVzaGFwZSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlc2hhcGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVzaGFwZSh4VGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnhUZW5zb3IgPSB4VGVuc29yO1xuICAgICAgICBfdGhpcy55VGVuc29yID0geVRlbnNvcjtcbiAgICAgICAgdmFyIHhTaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHhUZW5zb3Iuc2hhcGUpO1xuICAgICAgICB2YXIgeVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoeVRlbnNvci5zaGFwZSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHhTaXplID09PSB5U2l6ZSwgXCJUaGUgaW5wdXQgc2l6ZSAoXCIgKyB4U2l6ZSArIFwiKSBhbmQgb3V0cHV0IHNpemUgKFwiICsgeVNpemUgKyBcIikgbXVzdCBtYXRjaFwiKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZXNoYXBlLnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMueFRlbnNvcik7XG4gICAgICAgIHZhciBjbG9uZSA9IG1hdGguY2xvbmUoeCk7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMueVRlbnNvciwgZ2xvYmFsc18xLmtlZXAoY2xvbmUucmVzaGFwZShfdGhpcy55VGVuc29yLnNoYXBlKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc2hhcGUucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMueVRlbnNvcik7XG4gICAgICAgIHZhciBjbG9uZSA9IG1hdGguY2xvbmUoZHkpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMueFRlbnNvciwgY2xvbmUucmVzaGFwZShfdGhpcy54VGVuc29yLnNoYXBlKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFJlc2hhcGU7XG59KG9wXzEuT3BlcmF0aW9uKSk7XG5leHBvcnRzLlJlc2hhcGUgPSBSZXNoYXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi8uLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uLy4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaFwiKTtcbnZhciBncmFwaF91dGlsID0gcmVxdWlyZShcIi4uL2dyYXBoX3V0aWxcIik7XG52YXIgb3BfMSA9IHJlcXVpcmUoXCIuL29wXCIpO1xudmFyIFNvZnRtYXggPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFNvZnRtYXgobG9naXRzVGVuc29yLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubG9naXRzVGVuc29yID0gbG9naXRzVGVuc29yO1xuICAgICAgICBfdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU29mdG1heC5wcm90b3R5cGUuZmVlZEZvcndhcmQgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBsb2dpdHMgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubG9naXRzVGVuc29yKTtcbiAgICAgICAgcmV0dXJuIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0cHV0LCBnbG9iYWxzXzEua2VlcChtYXRoLnNvZnRtYXgobG9naXRzKSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNvZnRtYXgucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHkgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMub3V0cHV0KTtcbiAgICAgICAgdmFyIGR5ID0gZ3JhZGllbnRBcnJheXMuZ2V0KHRoaXMub3V0cHV0KTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGdyYXBoX3V0aWwuc2hvdWxkQmFja1Byb3AoX3RoaXMubG9naXRzVGVuc29yKSkge1xuICAgICAgICAgICAgICAgIHZhciBkbG9naXRzID0gbWF0aC5lbGVtZW50V2lzZU11bChtYXRoLnN1YnRyYWN0KGR5LCBtYXRoLnN1bShtYXRoLmVsZW1lbnRXaXNlTXVsKGR5LCB5KSkpLCB5KTtcbiAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMubG9naXRzVGVuc29yLCBkbG9naXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gU29mdG1heDtcbn0ob3BfMS5PcGVyYXRpb24pKTtcbmV4cG9ydHMuU29mdG1heCA9IFNvZnRtYXg7XG52YXIgU29mdG1heENyb3NzRW50cm9weUNvc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdChsb2dpdHNUZW5zb3IsIGxhYmVsVGVuc29yLCB5VGVuc29yKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxvZ2l0c1RlbnNvciA9IGxvZ2l0c1RlbnNvcjtcbiAgICAgICAgX3RoaXMubGFiZWxUZW5zb3IgPSBsYWJlbFRlbnNvcjtcbiAgICAgICAgX3RoaXMueVRlbnNvciA9IHlUZW5zb3I7XG4gICAgICAgIF90aGlzLnNvZnRtYXhUZW5zb3IgPSBuZXcgZ3JhcGhfMS5TeW1ib2xpY1RlbnNvcihsb2dpdHNUZW5zb3Iuc2hhcGUpO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZW52aXJvbm1lbnRfMS5FTlYubWF0aC5rZWVwKHRlbnNvcl8xLlNjYWxhci5uZXcoMWUtNSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5mZWVkRm9yd2FyZCA9IGZ1bmN0aW9uIChtYXRoLCBpbmZlcmVuY2VBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxvZ2l0cyA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sb2dpdHNUZW5zb3IpO1xuICAgICAgICB2YXIgbGFiZWwgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMubGFiZWxUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc29mdG1heFJlc3VsdCA9IG1hdGguc29mdG1heChsb2dpdHMpO1xuICAgICAgICAgICAgaW5mZXJlbmNlQXJyYXlzLnNldChfdGhpcy5zb2Z0bWF4VGVuc29yLCBnbG9iYWxzXzEua2VlcChzb2Z0bWF4UmVzdWx0KSk7XG4gICAgICAgICAgICBpbmZlcmVuY2VBcnJheXMuc2V0KF90aGlzLnlUZW5zb3IsIGdsb2JhbHNfMS5rZWVwKGNyb3NzRW50cm9weUNvc3QobWF0aCwgc29mdG1heFJlc3VsdCwgbGFiZWwsIF90aGlzLmVwc2lsb24pKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgU29mdG1heENyb3NzRW50cm9weUNvc3QucHJvdG90eXBlLmJhY2tQcm9wID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cywgZ3JhZGllbnRBcnJheXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHNvZnRtYXggPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMuc29mdG1heFRlbnNvcik7XG4gICAgICAgIHZhciBsYWJlbCA9IGluZmVyZW5jZUFycmF5cy5nZXQodGhpcy5sYWJlbFRlbnNvcik7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGdyYWRpZW50QXJyYXlzLmFkZChfdGhpcy5sb2dpdHNUZW5zb3IsIG1hdGguc3VidHJhY3Qoc29mdG1heCwgbGFiZWwpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdC5wcm90b3R5cGUuZGlzcG9zZVRyYW5zaWVudEFycmF5cyA9IGZ1bmN0aW9uIChpbmZlcmVuY2VBcnJheXMsIGdyYWRpZW50QXJyYXlzKSB7XG4gICAgICAgIGluZmVyZW5jZUFycmF5cy5kaXNwb3NlQXJyYXkodGhpcy5zb2Z0bWF4VGVuc29yKTtcbiAgICB9O1xuICAgIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVwc2lsb24uZGlzcG9zZSgpO1xuICAgIH07XG4gICAgcmV0dXJuIFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5Tb2Z0bWF4Q3Jvc3NFbnRyb3B5Q29zdCA9IFNvZnRtYXhDcm9zc0VudHJvcHlDb3N0O1xuZnVuY3Rpb24gY3Jvc3NFbnRyb3B5Q29zdChtYXRoLCB5LCB0YXJnZXQsIGVwc2lsb24pIHtcbiAgICB1dGlsLmFzc2VydCh5LnNpemUgPT09IHRhcmdldC5zaXplLCAnVGhlIG91dHB1dCBhbmQgdGFyZ2V0IG11c3QgYmUgdGhlIHNhbWUgc2l6ZScpO1xuICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5UGx1c0VwcyA9IG1hdGguc2NhbGFyUGx1c0FycmF5KGVwc2lsb24sIHkpO1xuICAgICAgICB2YXIgbG9nT3V0cHV0ID0gbWF0aC5sb2coeVBsdXNFcHMpO1xuICAgICAgICB2YXIgdGFyTG9nT3V0cHV0ID0gbWF0aC5lbGVtZW50V2lzZU11bCh0YXJnZXQsIGxvZ091dHB1dCk7XG4gICAgICAgIHZhciBjb3N0VmVjdG9yID0gbWF0aC5uZWcodGFyTG9nT3V0cHV0KTtcbiAgICAgICAgcmV0dXJuIG1hdGguc3VtKGNvc3RWZWN0b3IpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jcm9zc0VudHJvcHlDb3N0ID0gY3Jvc3NFbnRyb3B5Q29zdDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uLy4uL2dsb2JhbHNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi4vZ3JhcGhfdXRpbFwiKTtcbnZhciBvcF8xID0gcmVxdWlyZShcIi4vb3BcIik7XG52YXIgU3VidHJhY3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhTdWJ0cmFjdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTdWJ0cmFjdCh0MSwgdDIsIG91dFRlbnNvcikge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50MSA9IHQxO1xuICAgICAgICBfdGhpcy50MiA9IHQyO1xuICAgICAgICBfdGhpcy5vdXRUZW5zb3IgPSBvdXRUZW5zb3I7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuc2l6ZUZyb21TaGFwZSh0MS5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuc2l6ZUZyb21TaGFwZSh0Mi5zaGFwZSkgPT09IDEgfHxcbiAgICAgICAgICAgIHV0aWwuYXJyYXlzRXF1YWwodDEuc2hhcGUsIHQyLnNoYXBlKSwgJ09uZSBvZiB0MSBvciB0MiBtdXN0IGJlIGEgc2NhbGFyLCBvciB0MSBhbmQgdDIgbXVzdCBoYXZlICcgK1xuICAgICAgICAgICAgJ3RoZSBzYW1lIHNoYXBlJyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU3VidHJhY3QucHJvdG90eXBlLmZlZWRGb3J3YXJkID0gZnVuY3Rpb24gKG1hdGgsIGluZmVyZW5jZUFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdDEgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDEpO1xuICAgICAgICB2YXIgdDIgPSBpbmZlcmVuY2VBcnJheXMuZ2V0KHRoaXMudDIpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0MS5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLnNjYWxhck1pbnVzQXJyYXkodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHV0aWwuaXNTY2FsYXJTaGFwZSh0Mi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBtYXRoLmFycmF5TWludXNTY2FsYXIodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG1hdGguc3VidHJhY3QodDEsIHQyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluZmVyZW5jZUFycmF5cy5zZXQoX3RoaXMub3V0VGVuc29yLCBnbG9iYWxzXzEua2VlcChyZXN1bHQpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJ0cmFjdC5wcm90b3R5cGUuYmFja1Byb3AgPSBmdW5jdGlvbiAobWF0aCwgaW5mZXJlbmNlQXJyYXlzLCBncmFkaWVudEFycmF5cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZHkgPSBncmFkaWVudEFycmF5cy5nZXQodGhpcy5vdXRUZW5zb3IpO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy50MSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLnQxLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDEsIHN1bSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncmFkaWVudEFycmF5cy5hZGQoX3RoaXMudDEsIG1hdGguY2xvbmUoZHkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ3JhcGhfdXRpbC5zaG91bGRCYWNrUHJvcChfdGhpcy50MikpIHtcbiAgICAgICAgICAgICAgICBpZiAodXRpbC5pc1NjYWxhclNoYXBlKF90aGlzLnQyLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3VtID0gbWF0aC5zdW0oZHkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmVnU3VtID0gbWF0aC5uZWcoc3VtKTtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQyLCBuZWdTdW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnRBcnJheXMuYWRkKF90aGlzLnQyLCBtYXRoLm5lZyhkeSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTdWJ0cmFjdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZHlTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZHlTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFN1YnRyYWN0O1xufShvcF8xLk9wZXJhdGlvbikpO1xuZXhwb3J0cy5TdWJ0cmFjdCA9IFN1YnRyYWN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdENvbXBhcmUgPSBkZWZhdWx0Q29tcGFyZTtcbnZhciBQcmlvcml0eVF1ZXVlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKGNvbXBhcmF0b3IsIGluZGV4T2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5jb21wYXJhdG9yID0gY29tcGFyYXRvcjtcbiAgICAgICAgdGhpcy5pbmRleE9ic2VydmVyID0gaW5kZXhPYnNlcnZlcjtcbiAgICAgICAgdGhpcy5oZWFwID0gW107XG4gICAgfVxuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmVucXVldWUgPSBmdW5jdGlvbiAodCkge1xuICAgICAgICB0aGlzLmhlYXAucHVzaCh0KTtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0LCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuc2lmdFVwKHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmRlcXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmVtcHR5KCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGVxdWV1ZSBjYWxsZWQgb24gZW1wdHkgcHJpb3JpdHkgcXVldWUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHQgPSB0aGlzLmhlYXBbMF07XG4gICAgICAgIHRoaXMuc3dhcCgwLCB0aGlzLmhlYXAubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMuaGVhcC5wb3AoKTtcbiAgICAgICAgdGhpcy5zaWZ0RG93bigwKTtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICBQcmlvcml0eVF1ZXVlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAobmV3VCwgaW5kZXgpIHtcbiAgICAgICAgdmFyIGxhc3QgPSAoaW5kZXggPT09IHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgaWYgKCFsYXN0KSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHRoaXMuaGVhcC5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhlYXAucG9wKCk7XG4gICAgICAgIGlmICghbGFzdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lmdFVwSW5kZXgoaW5kZXgpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2lmdFVwKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMuc2lmdERvd25JbmRleChpbmRleCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaWZ0RG93bihpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnF1ZXVlKG5ld1QpO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhlYXAubGVuZ3RoID09PSAwO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUub25JbmRleENoYW5nZWQgPSBmdW5jdGlvbiAodCwgbmV3SW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXhPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5pbmRleE9ic2VydmVyKHQsIG5ld0luZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UGFyZW50SW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoKGluZGV4IC0gMSkgLyAyKTtcbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmdldExlZnRDaGlsZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAxO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlIDwgdGhpcy5oZWFwLmxlbmd0aCA/IGNhbmRpZGF0ZSA6IC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuZ2V0UmlnaHRDaGlsZEluZGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBjYW5kaWRhdGUgPSBpbmRleCAqIDIgKyAyO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlIDwgdGhpcy5oZWFwLmxlbmd0aCA/IGNhbmRpZGF0ZSA6IC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdFVwSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHBhcmVudEluZGV4ID0gdGhpcy5nZXRQYXJlbnRJbmRleChpbmRleCk7XG4gICAgICAgIGlmIChwYXJlbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wYXJlKHBhcmVudEluZGV4LCBpbmRleCkgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyZW50SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdFVwID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHZhciBzaWZ0SW5kZXggPSB0aGlzLnNpZnRVcEluZGV4KGluZGV4KTtcbiAgICAgICAgd2hpbGUgKHNpZnRJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuc3dhcChpbmRleCwgc2lmdEluZGV4KTtcbiAgICAgICAgICAgIGluZGV4ID0gc2lmdEluZGV4O1xuICAgICAgICAgICAgc2lmdEluZGV4ID0gdGhpcy5zaWZ0VXBJbmRleChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLnNpZnREb3duSW5kZXggPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4ID49IHRoaXMuaGVhcC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFyZ2VzdENoaWxkSW5kZXggPSBpbmRleDtcbiAgICAgICAgdmFyIGxlZnRDaGlsZEluZGV4ID0gdGhpcy5nZXRMZWZ0Q2hpbGRJbmRleChpbmRleCk7XG4gICAgICAgIGlmICgobGVmdENoaWxkSW5kZXggIT09IC0xKSAmJlxuICAgICAgICAgICAgKHRoaXMuY29tcGFyZShsZWZ0Q2hpbGRJbmRleCwgbGFyZ2VzdENoaWxkSW5kZXgpIDwgMCkpIHtcbiAgICAgICAgICAgIGxhcmdlc3RDaGlsZEluZGV4ID0gbGVmdENoaWxkSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJpZ2h0Q2hpbGRJbmRleCA9IHRoaXMuZ2V0UmlnaHRDaGlsZEluZGV4KGluZGV4KTtcbiAgICAgICAgaWYgKChyaWdodENoaWxkSW5kZXggIT09IC0xKSAmJlxuICAgICAgICAgICAgKHRoaXMuY29tcGFyZShyaWdodENoaWxkSW5kZXgsIGxhcmdlc3RDaGlsZEluZGV4KSA8IDApKSB7XG4gICAgICAgICAgICBsYXJnZXN0Q2hpbGRJbmRleCA9IHJpZ2h0Q2hpbGRJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGxhcmdlc3RDaGlsZEluZGV4ID09PSBpbmRleCkgPyAtMSA6IGxhcmdlc3RDaGlsZEluZGV4O1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc2lmdERvd24gPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIHNpZnRJbmRleCA9IHRoaXMuc2lmdERvd25JbmRleChpbmRleCk7XG4gICAgICAgIHdoaWxlIChzaWZ0SW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLnN3YXAoaW5kZXgsIHNpZnRJbmRleCk7XG4gICAgICAgICAgICBpbmRleCA9IHNpZnRJbmRleDtcbiAgICAgICAgICAgIHNpZnRJbmRleCA9IHRoaXMuc2lmdERvd25JbmRleChpbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXR5UXVldWUucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiAoYUluZGV4LCBiSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyYXRvcih0aGlzLmhlYXBbYUluZGV4XSwgdGhpcy5oZWFwW2JJbmRleF0pO1xuICAgIH07XG4gICAgUHJpb3JpdHlRdWV1ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciB0ZW1wID0gdGhpcy5oZWFwW2FdO1xuICAgICAgICB0aGlzLmhlYXBbYV0gPSB0aGlzLmhlYXBbYl07XG4gICAgICAgIHRoaXMuaGVhcFtiXSA9IHRlbXA7XG4gICAgICAgIHRoaXMub25JbmRleENoYW5nZWQodGhpcy5oZWFwW2FdLCBhKTtcbiAgICAgICAgdGhpcy5vbkluZGV4Q2hhbmdlZCh0aGlzLmhlYXBbYl0sIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIFByaW9yaXR5UXVldWU7XG59KCkpO1xuZXhwb3J0cy5Qcmlvcml0eVF1ZXVlID0gUHJpb3JpdHlRdWV1ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uX2VtaXR0ZXIgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25fZW1pdHRlclwiKTtcbnZhciBzZXNzaW9uX3V0aWwgPSByZXF1aXJlKFwiLi9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4vdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBGZWVkRGljdGlvbmFyeSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmVlZERpY3Rpb25hcnkoZmVlZEVudHJpZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWN0ID0ge307XG4gICAgICAgIGlmIChmZWVkRW50cmllcykge1xuICAgICAgICAgICAgZmVlZEVudHJpZXMuZm9yRWFjaChmdW5jdGlvbiAoZW50cnkpIHsgcmV0dXJuIF90aGlzLmRpY3RbZW50cnkudGVuc29yLmlkXSA9IGVudHJ5OyB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gRmVlZERpY3Rpb25hcnk7XG59KCkpO1xuZXhwb3J0cy5GZWVkRGljdGlvbmFyeSA9IEZlZWREaWN0aW9uYXJ5O1xudmFyIENvc3RSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKENvc3RSZWR1Y3Rpb24pIHtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJOT05FXCJdID0gMF0gPSBcIk5PTkVcIjtcbiAgICBDb3N0UmVkdWN0aW9uW0Nvc3RSZWR1Y3Rpb25bXCJTVU1cIl0gPSAxXSA9IFwiU1VNXCI7XG4gICAgQ29zdFJlZHVjdGlvbltDb3N0UmVkdWN0aW9uW1wiTUVBTlwiXSA9IDJdID0gXCJNRUFOXCI7XG59KShDb3N0UmVkdWN0aW9uID0gZXhwb3J0cy5Db3N0UmVkdWN0aW9uIHx8IChleHBvcnRzLkNvc3RSZWR1Y3Rpb24gPSB7fSkpO1xudmFyIFNlc3Npb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNlc3Npb24oZ3JhcGgsIG1hdGgpIHtcbiAgICAgICAgdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIHRoaXMucnVudGltZUNhY2hlID0ge307XG4gICAgICAgIHRoaXMub25lU2NhbGFyID0gdGVuc29yXzEuU2NhbGFyLm5ldygxKTtcbiAgICAgICAgdGhpcy5ncmFkaWVudEFycmF5TWFwID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5TdW1tZWRUZW5zb3JBcnJheU1hcCh0aGlzLm1hdGgpO1xuICAgIH1cbiAgICBTZXNzaW9uLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmFjdGl2YXRpb25BcnJheU1hcC5kaXNwb3NlKCk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMucnVudGltZUNhY2hlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBydW50aW1lID0gX3RoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICAgICAgICBpZiAocnVudGltZS5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcnVudGltZS5vcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5kaXNwb3NlKCk7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5ydW50aW1lQ2FjaGUgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuYmF0Y2hTaXplU2NhbGFyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uZVNjYWxhci5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ldmFsQWxsID0gZnVuY3Rpb24gKHRlbnNvcnMsIGZlZWRFbnRyaWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICAgICAgICB2YXIgcnVudGltZSA9IF90aGlzLmdldE9yQ3JlYXRlUnVudGltZSh0ZW5zb3JzLCBmZWVkKTtcbiAgICAgICAgICAgIHZhciBhY3RpdmF0aW9ucyA9IF90aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMocnVudGltZS5vcGVyYXRpb25zLCBfdGhpcy5hY3RpdmF0aW9uQXJyYXlNYXAsIF90aGlzLmdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKHJ1bnRpbWUubm9kZXMsIGFjdGl2YXRpb25zKTtcbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5sb2FkSW5wdXRzRnJvbUZlZWREaWN0aW9uYXJ5VG9UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICBydW50aW1lLm9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmZlZWRGb3J3YXJkKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zKTsgfSk7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHRlbnNvcnMubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhY3RpdmF0aW9ucy5nZXQoeCk7IH0pO1xuICAgICAgICAgICAgdGVuc29ycy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7IHJldHVybiBhY3RpdmF0aW9ucy5kZWxldGUoeCk7IH0pO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcChmZWVkLCBhY3RpdmF0aW9ucywgX3RoaXMubWF0aCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5ldmFsID0gZnVuY3Rpb24gKHRlbnNvciwgZmVlZEVudHJpZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXZhbEFsbChbdGVuc29yXSwgZmVlZEVudHJpZXMpWzBdO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUudHJhaW4gPSBmdW5jdGlvbiAoY29zdFRlbnNvciwgZmVlZEVudHJpZXMsIGJhdGNoU2l6ZSwgb3B0aW1pemVyLCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSB2b2lkIDApIHsgY29zdFJlZHVjdGlvbiA9IENvc3RSZWR1Y3Rpb24uTk9ORTsgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzU2NhbGFyU2hhcGUoY29zdFRlbnNvci5zaGFwZSksICdDb3N0IHRlbnNvciBmb3IgdHJhaW5pbmcgbXVzdCBiZSBhIHNjYWxhciB2YWx1ZS4nKTtcbiAgICAgICAgaWYgKHRoaXMucHJldkJhdGNoU2l6ZSAhPT0gYmF0Y2hTaXplKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZCYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXRjaFNpemVTY2FsYXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYmF0Y2hTaXplU2NhbGFyID0gdGhpcy5tYXRoLmtlZXAodGVuc29yXzEuU2NhbGFyLm5ldyhiYXRjaFNpemUpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmVlZCA9IG5ldyBGZWVkRGljdGlvbmFyeShmZWVkRW50cmllcyk7XG4gICAgICAgIHNlc3Npb25fdXRpbC50aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzKGZlZWQpO1xuICAgICAgICB2YXIgcnVudGltZSA9IHRoaXMuZ2V0T3JDcmVhdGVSdW50aW1lKFtjb3N0VGVuc29yXSwgZmVlZCk7XG4gICAgICAgIHZhciBpbmZlcmVuY2VPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zO1xuICAgICAgICB2YXIgYmFja1Byb3BPcGVyYXRpb25zID0gcnVudGltZS5vcGVyYXRpb25zLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgICAgICB2YXIgYWN0aXZhdGlvbnMgPSB0aGlzLmFjdGl2YXRpb25BcnJheU1hcDtcbiAgICAgICAgdmFyIGdyYWRpZW50cyA9IHRoaXMuZ3JhZGllbnRBcnJheU1hcDtcbiAgICAgICAgZ3JhZGllbnRzLm51bGxpZnkoY29zdFRlbnNvcik7XG4gICAgICAgIGdyYWRpZW50cy5hZGQoY29zdFRlbnNvciwgdGhpcy5vbmVTY2FsYXIpO1xuICAgICAgICBzZXNzaW9uX3V0aWwuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICBvcHRpbWl6ZXIuYmVmb3JlQmF0Y2godGhpcy5tYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25zLCBncmFkaWVudHMpO1xuICAgICAgICByZXR1cm4gZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGNvc3QgPSB0ZW5zb3JfMS5TY2FsYXIubmV3KDApO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXRjaFNpemU7ICsraSkge1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMocnVudGltZS5ub2RlcywgYWN0aXZhdGlvbnMpO1xuICAgICAgICAgICAgICAgIHNlc3Npb25fdXRpbC5kaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzKHJ1bnRpbWUubm9kZXMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMocnVudGltZS5vcGVyYXRpb25zLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwubG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoZmVlZCwgYWN0aXZhdGlvbnMsIF90aGlzLm1hdGgpO1xuICAgICAgICAgICAgICAgIGluZmVyZW5jZU9wZXJhdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAob3ApIHsgcmV0dXJuIG9wLmZlZWRGb3J3YXJkKF90aGlzLm1hdGgsIGFjdGl2YXRpb25zKTsgfSk7XG4gICAgICAgICAgICAgICAgYmFja1Byb3BPcGVyYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKG9wKSB7IHJldHVybiBvcC5iYWNrUHJvcChfdGhpcy5tYXRoLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTsgfSk7XG4gICAgICAgICAgICAgICAgb3B0aW1pemVyLmFmdGVyRXhhbXBsZShfdGhpcy5tYXRoLCBydW50aW1lLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uX3V0aWwucmVsZWFzZUZlZWREaWN0aW9uYXJ5SW5wdXRzRnJvbVRlbnNvckFycmF5TWFwKGZlZWQsIGFjdGl2YXRpb25zLCBfdGhpcy5tYXRoKTtcbiAgICAgICAgICAgICAgICBjb3N0ID0gX3RoaXMudXBkYXRlQ29zdEZvckV4YW1wbGUoY29zdCwgYWN0aXZhdGlvbnMuZ2V0KGNvc3RUZW5zb3IpLCBjb3N0UmVkdWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGltaXplci5hZnRlckJhdGNoKF90aGlzLm1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbnMsIGdyYWRpZW50cyk7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMudXBkYXRlQ29zdEZvckJhdGNoKGNvc3QsIGNvc3RSZWR1Y3Rpb24pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNlc3Npb24ucHJvdG90eXBlLnVwZGF0ZUNvc3RGb3JFeGFtcGxlID0gZnVuY3Rpb24gKHRvdGFsQ29zdCwgY3VyckNvc3QsIGNvc3RSZWR1Y3Rpb24pIHtcbiAgICAgICAgaWYgKGNvc3RSZWR1Y3Rpb24gPT09IENvc3RSZWR1Y3Rpb24uTUVBTiB8fFxuICAgICAgICAgICAgY29zdFJlZHVjdGlvbiA9PT0gQ29zdFJlZHVjdGlvbi5TVU0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGguYWRkKHRvdGFsQ29zdCwgY3VyckNvc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbENvc3Q7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS51cGRhdGVDb3N0Rm9yQmF0Y2ggPSBmdW5jdGlvbiAodG90YWxDb3N0LCBjb3N0UmVkdWN0aW9uKSB7XG4gICAgICAgIGlmIChjb3N0UmVkdWN0aW9uID09PSBDb3N0UmVkdWN0aW9uLk1FQU4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1hdGguZGl2aWRlKHRvdGFsQ29zdCwgdGhpcy5iYXRjaFNpemVTY2FsYXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbENvc3Q7XG4gICAgfTtcbiAgICBTZXNzaW9uLnByb3RvdHlwZS5nZXRPckNyZWF0ZVJ1bnRpbWUgPSBmdW5jdGlvbiAodGVuc29ycywgZmVlZCkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5tYWtlUnVudGltZUNhY2hlS2V5KHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICB2YXIgcnVudGltZSA9IHRoaXMucnVudGltZUNhY2hlW2tleV07XG4gICAgICAgIGlmIChydW50aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhciBub2RlcyA9IHNlc3Npb25fdXRpbC5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKHRlbnNvcnMsIGZlZWQpO1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLnJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldChmZWVkLCBub2Rlcyk7XG4gICAgICAgICAgICBzZXNzaW9uX3V0aWwudGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICB2YXIgb3BlcmF0aW9ucyA9IG9wZXJhdGlvbl9lbWl0dGVyLmVtaXRGcm9tR3JhcGhOb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICBydW50aW1lID0geyBub2Rlczogbm9kZXMsIG9wZXJhdGlvbnM6IG9wZXJhdGlvbnMgfTtcbiAgICAgICAgICAgIHRoaXMucnVudGltZUNhY2hlW2tleV0gPSBydW50aW1lO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBydW50aW1lO1xuICAgIH07XG4gICAgU2Vzc2lvbi5wcm90b3R5cGUubWFrZVJ1bnRpbWVDYWNoZUtleSA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBmZWVkKSB7XG4gICAgICAgIHJldHVybiB0ZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5pZDsgfSkuc29ydCgpLmpvaW4oJ18nKSArICdfXycgK1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmVlZC5kaWN0KS5zb3J0KCkuam9pbignXycpO1xuICAgIH07XG4gICAgcmV0dXJuIFNlc3Npb247XG59KCkpO1xuZXhwb3J0cy5TZXNzaW9uID0gU2Vzc2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgZ3JhcGhfMSA9IHJlcXVpcmUoXCIuL2dyYXBoXCIpO1xudmFyIGdyYXBoX3V0aWwgPSByZXF1aXJlKFwiLi9ncmFwaF91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KVxuICAgICAgICAubWFwKGZ1bmN0aW9uICh0ZW5zb3JJRCkgeyByZXR1cm4gZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLnRlbnNvci5ub2RlOyB9KTtcbn1cbmV4cG9ydHMuZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeSA9IGdldFRlcm1pbmF0aW5nTm9kZXNGcm9tRmVlZERpY3Rpb25hcnk7XG5mdW5jdGlvbiBnZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yKGV2YWxUZW5zb3JzLCBmZWVkRGljdGlvbmFyeSkge1xuICAgIHZhciB0ZXJtaW5hdGluZ05vZGVzID0gZ2V0VGVybWluYXRpbmdOb2Rlc0Zyb21GZWVkRGljdGlvbmFyeShmZWVkRGljdGlvbmFyeSk7XG4gICAgdmFyIGV2YWxOb2RlcyA9IGV2YWxUZW5zb3JzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geC5ub2RlOyB9KTtcbiAgICB2YXIgdW5vcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0VW5vcmRlcmVkRXZhbHVhdGlvblNldChldmFsTm9kZXMsIHRlcm1pbmF0aW5nTm9kZXMpO1xuICAgIHZhciBvcmRlcmVkRXZhbHVhdGlvblNldCA9IGdyYXBoX3V0aWwuZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXQodW5vcmRlcmVkRXZhbHVhdGlvblNldCk7XG4gICAgcmV0dXJuIG9yZGVyZWRFdmFsdWF0aW9uU2V0O1xufVxuZXhwb3J0cy5nZXRPcmRlcmVkRXZhbHVhdGlvblNldEZyb21FdmFsVGVuc29yID0gZ2V0T3JkZXJlZEV2YWx1YXRpb25TZXRGcm9tRXZhbFRlbnNvcjtcbmZ1bmN0aW9uIGFkZFBlcnNpc3RlbnRBcnJheXNUb1RlbnNvckFycmF5TWFwKGV2YWx1YXRpb25TZXQsIHRlbnNvckFycmF5TWFwKSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUgfHwgbm9kZSBpbnN0YW5jZW9mIGdyYXBoXzEuQ29uc3RhbnROb2RlKSB7XG4gICAgICAgICAgICB0ZW5zb3JBcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIG5vZGUuZGF0YSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuYWRkUGVyc2lzdGVudEFycmF5c1RvVGVuc29yQXJyYXlNYXAgPSBhZGRQZXJzaXN0ZW50QXJyYXlzVG9UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChldmFsdWF0aW9uU2V0KSB7XG4gICAgdmFyIG5vZGVzID0gW107XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5WYXJpYWJsZU5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5leHBvcnRzLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldCA9IGdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldDtcbmZ1bmN0aW9uIHRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMoZmVlZERpY3Rpb25hcnkpIHtcbiAgICBPYmplY3Qua2V5cyhmZWVkRGljdGlvbmFyeS5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICBpZiAoZmVlZERpY3Rpb25hcnkuZGljdFsrdGVuc29ySURdLmRhdGEgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhaW5pbmcgcmVxdWlyZXMgRmVlZERpY3Rpb25hcnkgZW50cmllcyB0byBiZSBJbnB1dFByb3ZpZGVycycgK1xuICAgICAgICAgICAgICAgICdhbmQgbm90IE5EQXJyYXlzLicpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLnRocm93SWZGZWVkRGljdGlvbmFyeUNvbnRhaW5zTkRBcnJheXMgPSB0aHJvd0lmRmVlZERpY3Rpb25hcnlDb250YWluc05EQXJyYXlzO1xuZnVuY3Rpb24gbG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXAoYmF0Y2hGZWVkLCBhY3RpdmF0aW9ucywgbWF0aCkge1xuICAgIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICB2YXIgZmVlZEVudHJ5ID0gYmF0Y2hGZWVkLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmIChmZWVkRW50cnkuZGF0YSBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICAgICAgZGF0YSA9IGZlZWRFbnRyeS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByb3ZpZGVyID0gZmVlZEVudHJ5LmRhdGE7XG4gICAgICAgICAgICBkYXRhID0gcHJvdmlkZXIuZ2V0TmV4dENvcHkoKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmFycmF5c0VxdWFsKGZlZWRFbnRyeS50ZW5zb3Iuc2hhcGUsIGRhdGEuc2hhcGUpLCBcIkVycm9yIGxvYWRpbmcgRmVlZEVudHJ5OiBmZWVkaW5nIE5EQXJyYXkgb2Ygc2hhcGUgXCIgKyBkYXRhLnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwiZG9lcyBub3QgbWF0Y2ggVGVuc29yIChpZDogXCIgKyBmZWVkRW50cnkudGVuc29yLmlkICsgXCIpIHNoYXBlOiBcIikgK1xuICAgICAgICAgICAgKGZlZWRFbnRyeS50ZW5zb3Iuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICBhY3RpdmF0aW9ucy5zZXQoZmVlZEVudHJ5LnRlbnNvciwgZGF0YSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRJbnB1dHNGcm9tRmVlZERpY3Rpb25hcnlUb1RlbnNvckFycmF5TWFwID0gbG9hZElucHV0c0Zyb21GZWVkRGljdGlvbmFyeVRvVGVuc29yQXJyYXlNYXA7XG5mdW5jdGlvbiByZWxlYXNlRmVlZERpY3Rpb25hcnlJbnB1dHNGcm9tVGVuc29yQXJyYXlNYXAoYmF0Y2hGZWVkLCBhY3RpdmF0aW9ucywgbWF0aCkge1xuICAgIE9iamVjdC5rZXlzKGJhdGNoRmVlZC5kaWN0KS5mb3JFYWNoKGZ1bmN0aW9uICh0ZW5zb3JJRCkge1xuICAgICAgICB2YXIgZmVlZEVudHJ5ID0gYmF0Y2hGZWVkLmRpY3RbK3RlbnNvcklEXTtcbiAgICAgICAgaWYgKCEoZmVlZEVudHJ5LmRhdGEgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpKSB7XG4gICAgICAgICAgICB2YXIgcHJvdmlkZXIgPSBmZWVkRW50cnkuZGF0YTtcbiAgICAgICAgICAgIHZhciBmZWVkRW50cnlBcnJheSA9IGFjdGl2YXRpb25zLmdldChmZWVkRW50cnkudGVuc29yKTtcbiAgICAgICAgICAgIHByb3ZpZGVyLmRpc3Bvc2VDb3B5KGZlZWRFbnRyeUFycmF5KTtcbiAgICAgICAgfVxuICAgICAgICBhY3RpdmF0aW9ucy5kZWxldGUoZmVlZEVudHJ5LnRlbnNvcik7XG4gICAgfSk7XG59XG5leHBvcnRzLnJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcCA9IHJlbGVhc2VGZWVkRGljdGlvbmFyeUlucHV0c0Zyb21UZW5zb3JBcnJheU1hcDtcbmZ1bmN0aW9uIHJlbW92ZUZlZWREaWN0aW9uYXJ5Tm9kZXNGcm9tRXZhbHVhdGlvblNldChmZWVkRGljdGlvbmFyeSwgZXZhbHVhdGlvblNldCkge1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGV2YWx1YXRpb25TZXQubGVuZ3RoKSB7XG4gICAgICAgIHZhciBub2RlID0gZXZhbHVhdGlvblNldFtpXTtcbiAgICAgICAgaWYgKGZlZWREaWN0aW9uYXJ5LmRpY3Rbbm9kZS5vdXRwdXQuaWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIGV2YWx1YXRpb25TZXQuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKytpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5yZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQgPSByZW1vdmVGZWVkRGljdGlvbmFyeU5vZGVzRnJvbUV2YWx1YXRpb25TZXQ7XG5mdW5jdGlvbiBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbk91dHB1dHMoZXZhbHVhdGlvblNldCwgdGVuc29yQXJyYXlNYXApIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgaWYgKCFncmFwaF91dGlsLmlzSW5wdXROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoIWdyYXBoX3V0aWwuaXNQYXNzdGhyb3VnaE5vZGUobm9kZSwgdGVuc29yQXJyYXlNYXApKSB7XG4gICAgICAgICAgICAgICAgdGVuc29yQXJyYXlNYXAuZGlzcG9zZUFycmF5KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbnNvckFycmF5TWFwLnNldChub2RlLm91dHB1dCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzID0gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25PdXRwdXRzO1xuZnVuY3Rpb24gZGlzcG9zZUFuZEluaXRpYWxpemVPcGVyYXRpb25JbnB1dEdyYWRpZW50cyhldmFsdWF0aW9uU2V0LCBncmFkaWVudHMpIHtcbiAgICBldmFsdWF0aW9uU2V0LmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgT2JqZWN0LmtleXMobm9kZS5pbnB1dHMpLmZvckVhY2goZnVuY3Rpb24gKGlucHV0TmFtZSkge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmIChncmFkaWVudHMuZ2V0KGlucHV0LCB0cnVlKSAhPT0gZ3JhZGllbnRzLmdldChub2RlLm91dHB1dCwgdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICBncmFkaWVudHMuZGlzcG9zZUFycmF5KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyYWRpZW50cy5udWxsaWZ5KGlucHV0KTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VBbmRJbml0aWFsaXplT3BlcmF0aW9uSW5wdXRHcmFkaWVudHMgPSBkaXNwb3NlQW5kSW5pdGlhbGl6ZU9wZXJhdGlvbklucHV0R3JhZGllbnRzO1xuZnVuY3Rpb24gZGlzcG9zZVRyYW5zaWVudE9wZXJhdGlvbkFycmF5cyhvcGVyYXRpb25zLCBhY3RpdmF0aW9ucywgZ3JhZGllbnRzKSB7XG4gICAgb3BlcmF0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChvcCkgeyByZXR1cm4gb3AuZGlzcG9zZVRyYW5zaWVudEFycmF5cyhhY3RpdmF0aW9ucywgZ3JhZGllbnRzKTsgfSk7XG59XG5leHBvcnRzLmRpc3Bvc2VUcmFuc2llbnRPcGVyYXRpb25BcnJheXMgPSBkaXNwb3NlVHJhbnNpZW50T3BlcmF0aW9uQXJyYXlzO1xuZnVuY3Rpb24gdGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyhldmFsdWF0aW9uU2V0KSB7XG4gICAgZXZhbHVhdGlvblNldC5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgZ3JhcGhfMS5QbGFjZWhvbGRlck5vZGUpIHtcbiAgICAgICAgICAgIHZhciBzaGFwZSA9ICdbJyArIG5vZGUub3V0cHV0LnNoYXBlLmpvaW4oJywgJykgKyAnXSc7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsYWNlaG9sZGVyIG5vZGUgXCInICsgbm9kZS5uYW1lICsgJ1wiICcgKyBzaGFwZSArXG4gICAgICAgICAgICAgICAgJyBub3QgcHJlc2VudCBpbiBmZWVkIGRpY3Rpb25hcnkuJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudGhyb3dFcnJvcklmRXZhbHVhdGlvblNldENvbnRhaW5zUGxhY2Vob2xkZXJOb2RlcyA9IHRocm93RXJyb3JJZkV2YWx1YXRpb25TZXRDb250YWluc1BsYWNlaG9sZGVyTm9kZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRlbnNvckFycmF5TWFwQmFzZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXBCYXNlKCkge1xuICAgICAgICB0aGlzLmRpY3QgPSB7fTtcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodGVuc29yLCBza2lwQ2hlY2tzKSB7XG4gICAgICAgIGlmIChza2lwQ2hlY2tzID09PSB2b2lkIDApIHsgc2tpcENoZWNrcyA9IGZhbHNlOyB9XG4gICAgICAgIGlmICghc2tpcENoZWNrcyAmJiB0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBub3QgaW4gYXJyYXkgbWFwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmRhID0gdGhpcy5kaWN0W3RlbnNvci5pZF07XG4gICAgICAgIGlmICghc2tpcENoZWNrcyAmJiBuZGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRlbnNvciBcIiArIHRlbnNvci5pZCArIFwiIGhhcyBudWxsIGFycmF5LlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmRhO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmRpY3RbdGVuc29yLmlkXTtcbiAgICB9O1xuICAgIFRlbnNvckFycmF5TWFwQmFzZS5wcm90b3R5cGUubnVsbGlmeSA9IGZ1bmN0aW9uICh0ZW5zb3IpIHtcbiAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBudWxsO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5kaXNwb3NlQXJyYXkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5kYSA9IHRoaXMuZGljdFt0ZW5zb3IuaWRdO1xuICAgICAgICBpZiAobmRhID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbmRhLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kaWN0W3RlbnNvci5pZF0gPSBudWxsO1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5zaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kaWN0KS5sZW5ndGg7XG4gICAgfTtcbiAgICBUZW5zb3JBcnJheU1hcEJhc2UucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMuZGljdCkuZm9yRWFjaChmdW5jdGlvbiAodGVuc29ySUQpIHtcbiAgICAgICAgICAgIHZhciBuZGEgPSBfdGhpcy5kaWN0Wyt0ZW5zb3JJRF07XG4gICAgICAgICAgICBpZiAobmRhKSB7XG4gICAgICAgICAgICAgICAgbmRhLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZGljdCA9IHt9O1xuICAgIH07XG4gICAgVGVuc29yQXJyYXlNYXBCYXNlLnByb3RvdHlwZS5oYXNOdWxsQXJyYXkgPSBmdW5jdGlvbiAodGVuc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmRpY3RbdGVuc29yLmlkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0ZW5zb3IgXCIgKyB0ZW5zb3IuaWQgKyBcIiBub3QgaW4gYXJyYXkgbWFwLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5kaWN0W3RlbnNvci5pZF0gPT09IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXBCYXNlO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yQXJyYXlNYXBCYXNlID0gVGVuc29yQXJyYXlNYXBCYXNlO1xudmFyIFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yQXJyYXlNYXAoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yQXJyYXlNYXAucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh0ZW5zb3IsIGFycmF5KSB7XG4gICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gYXJyYXk7XG4gICAgfTtcbiAgICByZXR1cm4gVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5UZW5zb3JBcnJheU1hcCA9IFRlbnNvckFycmF5TWFwO1xudmFyIFN1bW1lZFRlbnNvckFycmF5TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU3VtbWVkVGVuc29yQXJyYXlNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3VtbWVkVGVuc29yQXJyYXlNYXAobWF0aCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5tYXRoID0gbWF0aDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdW1tZWRUZW5zb3JBcnJheU1hcC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHRlbnNvciwgYXJyYXkpIHtcbiAgICAgICAgaWYgKHRoaXMuZGljdFt0ZW5zb3IuaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZGljdFt0ZW5zb3IuaWRdID0gdGhpcy5tYXRoLmtlZXAoYXJyYXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXQodGVuc29yKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMubWF0aC5rZWVwKHRoaXMubWF0aC5hZGRTdHJpY3Qob2xkVmFsdWUsIGFycmF5KSk7XG4gICAgICAgICAgICB0aGlzLmRpY3RbdGVuc29yLmlkXSA9IG5ld1ZhbHVlO1xuICAgICAgICAgICAgb2xkVmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU3VtbWVkVGVuc29yQXJyYXlNYXA7XG59KFRlbnNvckFycmF5TWFwQmFzZSkpO1xuZXhwb3J0cy5TdW1tZWRUZW5zb3JBcnJheU1hcCA9IFN1bW1lZFRlbnNvckFycmF5TWFwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBfX2V4cG9ydChtKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xufVxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb3dzZXJfdXRpbF8xID0gcmVxdWlyZShcIi4vYnJvd3Nlcl91dGlsXCIpO1xudmFyIGNvbnRyaWIgPSByZXF1aXJlKFwiLi9jb250cmliXCIpO1xuZXhwb3J0cy5jb250cmliID0gY29udHJpYjtcbnZhciB4aHJfZGF0YXNldCA9IHJlcXVpcmUoXCIuL2RhdGEveGhyLWRhdGFzZXRcIik7XG5leHBvcnRzLnhocl9kYXRhc2V0ID0geGhyX2RhdGFzZXQ7XG52YXIgZW52aXJvbm1lbnQgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbmV4cG9ydHMuZW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudDtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvZ3BncHVfdXRpbFwiKTtcbmV4cG9ydHMuZ3BncHVfdXRpbCA9IGdwZ3B1X3V0aWw7XG52YXIgd2ViZ2xfdXRpbCA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbmV4cG9ydHMud2ViZ2xfdXRpbCA9IHdlYmdsX3V0aWw7XG52YXIgY29udl91dGlsID0gcmVxdWlyZShcIi4vb3BzL2NvbnZfdXRpbFwiKTtcbmV4cG9ydHMuY29udl91dGlsID0gY29udl91dGlsO1xudmFyIHRlc3RfdXRpbCA9IHJlcXVpcmUoXCIuL3Rlc3RfdXRpbFwiKTtcbmV4cG9ydHMudGVzdF91dGlsID0gdGVzdF91dGlsO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy51dGlsID0gdXRpbDtcbnZhciB2ZXJzaW9uXzEgPSByZXF1aXJlKFwiLi92ZXJzaW9uXCIpO1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbl8xLnZlcnNpb247XG52YXIgY2hlY2twb2ludF9sb2FkZXJfMSA9IHJlcXVpcmUoXCIuL2RhdGEvY2hlY2twb2ludF9sb2FkZXJcIik7XG5leHBvcnRzLkNoZWNrcG9pbnRMb2FkZXIgPSBjaGVja3BvaW50X2xvYWRlcl8xLkNoZWNrcG9pbnRMb2FkZXI7XG52YXIgZGF0YXNldF8xID0gcmVxdWlyZShcIi4vZGF0YS9kYXRhc2V0XCIpO1xuZXhwb3J0cy5Jbk1lbW9yeURhdGFzZXQgPSBkYXRhc2V0XzEuSW5NZW1vcnlEYXRhc2V0O1xudmFyIGlucHV0X3Byb3ZpZGVyXzEgPSByZXF1aXJlKFwiLi9kYXRhL2lucHV0X3Byb3ZpZGVyXCIpO1xuZXhwb3J0cy5JbkNQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXIgPSBpbnB1dF9wcm92aWRlcl8xLkluQ1BVTWVtb3J5U2h1ZmZsZWRJbnB1dFByb3ZpZGVyQnVpbGRlcjtcbmV4cG9ydHMuSW5HUFVNZW1vcnlTaHVmZmxlZElucHV0UHJvdmlkZXJCdWlsZGVyID0gaW5wdXRfcHJvdmlkZXJfMS5JbkdQVU1lbW9yeVNodWZmbGVkSW5wdXRQcm92aWRlckJ1aWxkZXI7XG52YXIgeGhyX2RhdGFzZXRfMSA9IHJlcXVpcmUoXCIuL2RhdGEveGhyLWRhdGFzZXRcIik7XG5leHBvcnRzLlhockRhdGFzZXQgPSB4aHJfZGF0YXNldF8xLlhockRhdGFzZXQ7XG52YXIgZW52aXJvbm1lbnRfMiA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xuZXhwb3J0cy5FTlYgPSBlbnZpcm9ubWVudF8yLkVOVjtcbmV4cG9ydHMuRW52aXJvbm1lbnQgPSBlbnZpcm9ubWVudF8yLkVudmlyb25tZW50O1xudmFyIGdyYXBoXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9ncmFwaFwiKTtcbmV4cG9ydHMuR3JhcGggPSBncmFwaF8xLkdyYXBoO1xuZXhwb3J0cy5TeW1ib2xpY1RlbnNvciA9IGdyYXBoXzEuU3ltYm9saWNUZW5zb3I7XG52YXIgZ3JhcGhfcnVubmVyXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9ncmFwaF9ydW5uZXJcIik7XG5leHBvcnRzLkdyYXBoUnVubmVyID0gZ3JhcGhfcnVubmVyXzEuR3JhcGhSdW5uZXI7XG5leHBvcnRzLk1ldHJpY1JlZHVjdGlvbiA9IGdyYXBoX3J1bm5lcl8xLk1ldHJpY1JlZHVjdGlvbjtcbnZhciBpbml0aWFsaXplcnNfMSA9IHJlcXVpcmUoXCIuL2dyYXBoL2luaXRpYWxpemVyc1wiKTtcbmV4cG9ydHMuQ29uc3RhbnRJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLkNvbnN0YW50SW5pdGlhbGl6ZXI7XG5leHBvcnRzLk9uZXNJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLk9uZXNJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21Ob3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVHJ1bmNhdGVkTm9ybWFsSW5pdGlhbGl6ZXIgPSBpbml0aWFsaXplcnNfMS5SYW5kb21UcnVuY2F0ZWROb3JtYWxJbml0aWFsaXplcjtcbmV4cG9ydHMuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuUmFuZG9tVW5pZm9ybUluaXRpYWxpemVyO1xuZXhwb3J0cy5UZW5zb3JJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlRlbnNvckluaXRpYWxpemVyO1xuZXhwb3J0cy5WYXJpYW5jZVNjYWxpbmdJbml0aWFsaXplciA9IGluaXRpYWxpemVyc18xLlZhcmlhbmNlU2NhbGluZ0luaXRpYWxpemVyO1xuZXhwb3J0cy5aZXJvc0luaXRpYWxpemVyID0gaW5pdGlhbGl6ZXJzXzEuWmVyb3NJbml0aWFsaXplcjtcbnZhciBzZXNzaW9uXzEgPSByZXF1aXJlKFwiLi9ncmFwaC9zZXNzaW9uXCIpO1xuZXhwb3J0cy5Db3N0UmVkdWN0aW9uID0gc2Vzc2lvbl8xLkNvc3RSZWR1Y3Rpb247XG5leHBvcnRzLlNlc3Npb24gPSBzZXNzaW9uXzEuU2Vzc2lvbjtcbnZhciBiYWNrZW5kX2NwdV8xID0gcmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX2NwdVwiKTtcbmV4cG9ydHMuTWF0aEJhY2tlbmRDUFUgPSBiYWNrZW5kX2NwdV8xLk1hdGhCYWNrZW5kQ1BVO1xuZXhwb3J0cy5OREFycmF5TWF0aENQVSA9IGJhY2tlbmRfY3B1XzEuTkRBcnJheU1hdGhDUFU7XG52YXIgYmFja2VuZF93ZWJnbF8xID0gcmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX3dlYmdsXCIpO1xuZXhwb3J0cy5NYXRoQmFja2VuZFdlYkdMID0gYmFja2VuZF93ZWJnbF8xLk1hdGhCYWNrZW5kV2ViR0w7XG5leHBvcnRzLk5EQXJyYXlNYXRoR1BVID0gYmFja2VuZF93ZWJnbF8xLk5EQXJyYXlNYXRoR1BVO1xudmFyIGdwZ3B1X2NvbnRleHRfMSA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvd2ViZ2wvZ3BncHVfY29udGV4dFwiKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gZ3BncHVfY29udGV4dF8xLkdQR1BVQ29udGV4dDtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi9tYXRoXCIpO1xuZXhwb3J0cy5OREFycmF5TWF0aCA9IG1hdGhfMS5OREFycmF5TWF0aDtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL29wcy9tYXRtdWxcIik7XG5leHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0gbWF0bXVsXzEuTWF0cml4T3JpZW50YXRpb247XG52YXIgYWRhZGVsdGFfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBhZGFkZWx0YV9vcHRpbWl6ZXJfMS5BZGFkZWx0YU9wdGltaXplcjtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFncmFkX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IGFkYWdyYWRfb3B0aW1pemVyXzEuQWRhZ3JhZE9wdGltaXplcjtcbnZhciBhZGFtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFtX29wdGltaXplclwiKTtcbmV4cG9ydHMuQWRhbU9wdGltaXplciA9IGFkYW1fb3B0aW1pemVyXzEuQWRhbU9wdGltaXplcjtcbnZhciBhZGFtYXhfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLkFkYW1heE9wdGltaXplciA9IGFkYW1heF9vcHRpbWl6ZXJfMS5BZGFtYXhPcHRpbWl6ZXI7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplclwiKTtcbmV4cG9ydHMuTW9tZW50dW1PcHRpbWl6ZXIgPSBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcjtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5PcHRpbWl6ZXIgPSBvcHRpbWl6ZXJfMS5PcHRpbWl6ZXI7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG5leHBvcnRzLlJNU1Byb3BPcHRpbWl6ZXIgPSBybXNwcm9wX29wdGltaXplcl8xLlJNU1Byb3BPcHRpbWl6ZXI7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4vdGVuc29yXCIpO1xuZXhwb3J0cy5BcnJheTFEID0gdGVuc29yXzEuQXJyYXkxRDtcbmV4cG9ydHMuQXJyYXkyRCA9IHRlbnNvcl8xLkFycmF5MkQ7XG5leHBvcnRzLkFycmF5M0QgPSB0ZW5zb3JfMS5BcnJheTNEO1xuZXhwb3J0cy5BcnJheTREID0gdGVuc29yXzEuQXJyYXk0RDtcbmV4cG9ydHMuTkRBcnJheSA9IHRlbnNvcl8xLk5EQXJyYXk7XG5leHBvcnRzLlNjYWxhciA9IHRlbnNvcl8xLlNjYWxhcjtcbmV4cG9ydHMuVGVuc29yID0gdGVuc29yXzEuVGVuc29yO1xuZXhwb3J0cy5UZW5zb3IxRCA9IHRlbnNvcl8xLlRlbnNvcjFEO1xuZXhwb3J0cy5UZW5zb3IyRCA9IHRlbnNvcl8xLlRlbnNvcjJEO1xuZXhwb3J0cy5UZW5zb3IzRCA9IHRlbnNvcl8xLlRlbnNvcjNEO1xuZXhwb3J0cy5UZW5zb3I0RCA9IHRlbnNvcl8xLlRlbnNvcjREO1xuZXhwb3J0cy52YXJpYWJsZSA9IHRlbnNvcl8xLnZhcmlhYmxlO1xuZXhwb3J0cy5WYXJpYWJsZSA9IHRlbnNvcl8xLlZhcmlhYmxlO1xudmFyIHR5cGVzXzEgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMuUmFuayA9IHR5cGVzXzEuUmFuaztcbnZhciB3ZWlnaHRzX2xvYWRlcl8xID0gcmVxdWlyZShcIi4vd2VpZ2h0c19sb2FkZXJcIik7XG5leHBvcnRzLmxvYWRXZWlnaHRzID0gd2VpZ2h0c19sb2FkZXJfMS5sb2FkV2VpZ2h0cztcbl9fZXhwb3J0KHJlcXVpcmUoXCIuL29wcy9vcHNcIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vdHJhaW5cIikpO1xuX19leHBvcnQocmVxdWlyZShcIi4vZ2xvYmFsc1wiKSk7XG5leHBvcnRzLnNldEJhY2tlbmQgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50LnNldEJhY2tlbmQ7XG5leHBvcnRzLmdldEJhY2tlbmQgPSBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50LmdldEJhY2tlbmQ7XG5leHBvcnRzLm1lbW9yeSA9IGVudmlyb25tZW50XzEuRW52aXJvbm1lbnQubWVtb3J5O1xuZXhwb3J0cy5uZXh0RnJhbWUgPSBicm93c2VyX3V0aWxfMS5Ccm93c2VyVXRpbC5uZXh0RnJhbWU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2VlZHJhbmRvbSA9IHJlcXVpcmUoXCJzZWVkcmFuZG9tXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgbWF0aF8xID0gcmVxdWlyZShcIi4uL21hdGhcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4uL29wcy9heGlzX3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4uL29wcy9jb25jYXRfdXRpbFwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHNlbHVfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvc2VsdV91dGlsXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0eXBlcyA9IHJlcXVpcmUoXCIuLi90eXBlc1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgTWF0aEJhY2tlbmRDUFUgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdGhCYWNrZW5kQ1BVKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGF0YUlkLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBidWZmZXIgaXMgYWxyZWFkeSByZWdpc3RlcmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoZGF0YUlkLCBudWxsKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhSWQsIHZhbHVlcykge1xuICAgICAgICBpZiAodmFsdWVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0aEJhY2tlbmRDUFUud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB0aGlzLmRhdGEuc2V0KGRhdGFJZCwgdmFsdWVzKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKHBpeGVscyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kQ1BVLndyaXRlUGl4ZWxzKCk6IHBpeGVscyBjYW4gbm90IGJlIG51bGwnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFscztcbiAgICAgICAgaWYgKHBpeGVscyBpbnN0YW5jZW9mIEltYWdlRGF0YSkge1xuICAgICAgICAgICAgdmFscyA9IHBpeGVscy5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBpeGVscyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSB7XG4gICAgICAgICAgICB2YWxzID0gcGl4ZWxzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgICAgICAuZ2V0SW1hZ2VEYXRhKDAsIDAsIHBpeGVscy53aWR0aCwgcGl4ZWxzLmhlaWdodClcbiAgICAgICAgICAgICAgICAuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwaXhlbHMgaW5zdGFuY2VvZiBIVE1MSW1hZ2VFbGVtZW50IHx8XG4gICAgICAgICAgICBwaXhlbHMgaW5zdGFuY2VvZiBIVE1MVmlkZW9FbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FuXFwndCByZWFkIHBpeGVscyBmcm9tIEhUTUxJbWFnZUVsZW1lbnQgb3V0c2lkZSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ3RoZSBicm93c2VyLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYW52YXMud2lkdGggPSBwaXhlbHMud2lkdGg7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSBwaXhlbHMuaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UocGl4ZWxzLCAwLCAwLCBwaXhlbHMud2lkdGgsIHBpeGVscy5oZWlnaHQpO1xuICAgICAgICAgICAgdmFscyA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICAgICAgICAgICAgICAuZ2V0SW1hZ2VEYXRhKDAsIDAsIHBpeGVscy53aWR0aCwgcGl4ZWxzLmhlaWdodClcbiAgICAgICAgICAgICAgICAuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInBpeGVscyBpcyBvZiB1bmtub3duIHR5cGU6IFwiICsgcGl4ZWxzLmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWx1ZXM7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgdmFsdWVzID0gbmV3IEludDMyQXJyYXkodmFscyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbnVtUGl4ZWxzID0gcGl4ZWxzLndpZHRoICogcGl4ZWxzLmhlaWdodDtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KG51bVBpeGVscyAqIG51bUNoYW5uZWxzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtUGl4ZWxzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjaGFubmVsID0gMDsgY2hhbm5lbCA8IG51bUNoYW5uZWxzOyArK2NoYW5uZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2kgKiBudW1DaGFubmVscyArIGNoYW5uZWxdID0gdmFsc1tpICogNCArIGNoYW5uZWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgb3V0U2hhcGUgPSBbcGl4ZWxzLmhlaWdodCwgcGl4ZWxzLndpZHRoLCBudW1DaGFubmVsc107XG4gICAgICAgIHJldHVybiBvcHNfMS50ZW5zb3IzZCh2YWx1ZXMsIG91dFNoYXBlLCAnaW50MzInKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlYWRTeW5jKGRhdGFJZCldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnJlYWRTeW5jID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICB0aGlzLnRocm93SWZOb0RhdGEoZGF0YUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5nZXQoZGF0YUlkKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5kaXNwb3NlRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhpcy5kYXRhLmRlbGV0ZShkYXRhSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudGltZSA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCwga2VybmVsTXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICAgICAga2VybmVsTXMgPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgeyBrZXJuZWxNczoga2VybmVsTXMgfV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWVtb3J5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5yZWxpYWJsZTogdHJ1ZVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRocm93SWZOb0RhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIGlmICghdGhpcy5kYXRhLmhhcyhkYXRhSWQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDUFUgYmFja2VuZDogTm8gZGF0YSBmb3VuZCBmb3IgdGhpcyB0ZW5zb3IuIFwiICtcbiAgICAgICAgICAgICAgICBcIkRpZCB5b3UgY2hhbmdlIHlvdXIgYmFja2VuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9ncmFtPyBcIiArXG4gICAgICAgICAgICAgICAgXCJOZXcgYmFja2VuZHMgY2FuJ3QgdXNlIFRlbnNvcnMgY3JlYXRlZCB3aXRoIHByZXZpb3VzIGJhY2tlbmRzXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG9wcy5idWZmZXIoc2l6ZSwgeC5kdHlwZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGJ1ZmZlci5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIHhMb2MgPSBsb2MubWFwKGZ1bmN0aW9uIChpZHgsIGopIHsgcmV0dXJuIGlkeCArIGJlZ2luW2pdOyB9KTtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQuYXBwbHkoYnVmZmVyLCBbeC5nZXQuYXBwbHkoeCwgeExvYyldLmNvbmNhdChsb2MpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBvcHMuYnVmZmVyKHguc2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgeEJ1ZmZlciA9IHguYnVmZmVyKCk7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBvdXRMb2MgPSBidWZmZXIuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBpbkxvYyA9IG91dExvYy5zbGljZSgpO1xuICAgICAgICAgICAgYXhpcy5mb3JFYWNoKGZ1bmN0aW9uIChheCkgeyByZXR1cm4gaW5Mb2NbYXhdID0geC5zaGFwZVtheF0gLSAxIC0gaW5Mb2NbYXhdOyB9KTtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQuYXBwbHkoYnVmZmVyLCBbeEJ1ZmZlci5nZXQuYXBwbHkoeEJ1ZmZlciwgaW5Mb2MpXS5jb25jYXQob3V0TG9jKSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLnNpemU7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVmZmVyLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUsIDEpO1xuICAgICAgICB2YXIgYnVmZmVyID0gb3BzLmJ1ZmZlcihvdXRTaGFwZSwgYS5kdHlwZSk7XG4gICAgICAgIGlmIChhLnNoYXBlWzBdID09PSAxICYmIGIuc2hhcGVbMF0gPT09IDEpIHtcbiAgICAgICAgICAgIHZhciBhVmFscyA9IGEuZGF0YVN5bmMoKTtcbiAgICAgICAgICAgIHZhciBiVmFscyA9IGIuZGF0YVN5bmMoKTtcbiAgICAgICAgICAgIHZhciB2YWxzID0gYnVmZmVyLnZhbHVlcztcbiAgICAgICAgICAgIHZhbHMuc2V0KGFWYWxzLCAwKTtcbiAgICAgICAgICAgIHZhbHMuc2V0KGJWYWxzLCBhLnNpemUpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci50b1RlbnNvcigpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0U2hhcGVbMF07ICsraSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBhLnNoYXBlWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICBidWZmZXIuc2V0KGEuZ2V0KGksIGopLCBpLCBqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgYi5zaGFwZVsxXTsgKytqKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyLnNldChiLmdldChpLCBqKSwgaSwgaiArIGEuc2hhcGVbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShvcHMuc2NhbGFyKC0xKSwgeCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSArIGJWYWx1ZTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSksIGZ1bmN0aW9uIChhVmFsdWUsIGJWYWx1ZSkgeyByZXR1cm4gYVZhbHVlIC0gYlZhbHVlOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsIGEuZHR5cGUsIGZ1bmN0aW9uIChhVmFsdWUsIGJWYWx1ZSkgeyByZXR1cm4gTWF0aC5wb3coYVZhbHVlLCBiVmFsdWUpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICB2YXIgc2hhcmVkRGltID0gdHJhbnNwb3NlQSA/IGEuc2hhcGVbMF0gOiBhLnNoYXBlWzFdO1xuICAgICAgICB2YXIgbGVmdERpbSA9IHRyYW5zcG9zZUEgPyBhLnNoYXBlWzFdIDogYS5zaGFwZVswXTtcbiAgICAgICAgdmFyIHJpZ2h0RGltID0gdHJhbnNwb3NlQiA/IGIuc2hhcGVbMF0gOiBiLnNoYXBlWzFdO1xuICAgICAgICB2YXIgbm9ybWFsR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaSwgaik7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0cmFuc3Bvc2VkR2V0dGVyID0gZnVuY3Rpb24gKG1hdHJpeCwgaSwgaikge1xuICAgICAgICAgICAgcmV0dXJuIG1hdHJpeC5nZXQoaiwgaSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBhR2V0dGVyID0gdHJhbnNwb3NlQSA/IHRyYW5zcG9zZWRHZXR0ZXIgOiBub3JtYWxHZXR0ZXI7XG4gICAgICAgIHZhciBiR2V0dGVyID0gdHJhbnNwb3NlQiA/IHRyYW5zcG9zZWRHZXR0ZXIgOiBub3JtYWxHZXR0ZXI7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KGxlZnREaW0gKiByaWdodERpbSk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVmdERpbTsgKytpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpZ2h0RGltOyArK2opIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNoYXJlZERpbTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBhR2V0dGVyKGEsIGksIGspICogYkdldHRlcihiLCBrLCBqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWVzW2luZGV4KytdID0gc3VtO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yMmQodmFsdWVzLCBbbGVmdERpbSwgcmlnaHREaW1dKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSwgZnVuY3Rpb24gKGFWYWx1ZSwgYlZhbHVlKSB7IHJldHVybiBhVmFsdWUgKiBiVmFsdWU7IH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRpdmlkZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Zsb2F0MzInLCBmdW5jdGlvbiAoYVZhbHVlLCBiVmFsdWUpIHsgcmV0dXJuIGFWYWx1ZSAvIGJWYWx1ZTsgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKHgsIGF4ZXMpIHtcbiAgICAgICAgYXhpc191dGlsLmFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zKCdzdW0nLCBheGVzLCB4LnJhbmspO1xuICAgICAgICB2YXIgX2EgPSBheGlzX3V0aWwuY29tcHV0ZU91dEFuZFJlZHVjZVNoYXBlcyh4LnNoYXBlLCBheGVzKSwgb3V0U2hhcGUgPSBfYVswXSwgcmVkdWNlU2hhcGUgPSBfYVsxXTtcbiAgICAgICAgdmFyIHJlc3VsdER0eXBlID0gdHlwZXMudXBjYXN0VHlwZSh4LmR0eXBlLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy56ZXJvcyhvdXRTaGFwZSwgcmVzdWx0RHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgc3VtID0gMDtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmVkdWNlU2l6ZTsgKytqKSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsc1tpXSA9IHN1bTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtaW5JbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWluSW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtaW5JbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmFyZ01heCA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWF4JywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsICdpbnQzMicpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWF4ID0gYVZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIHZhciBtYXhJbmRleCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSB1dGlsLk5BTl9JTlQzMjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbWF4SW5kZXggPSBqO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHNbaV0gPSBtYXhJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFWYWwgPT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGFWYWwgIT09IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVZhbCA8IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxlc3NFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsIDw9IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gdGhpcy5icm9hZGNhc3RlZEJpbmFyeU9wKGEsIGIsICdib29sJywgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKGFWYWwsIGEuZHR5cGUpIHx8IHV0aWwuaXNWYWxOYU4oYlZhbCwgYi5kdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoYVZhbCA+IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChhVmFsID49IGJWYWwpID8gMSA6IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmxvZ2ljYWxOb3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEludDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWx1ZXNbaV0sIHguZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gdXRpbC5nZXROYU4oJ2Jvb2wnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IHZhbHVlc1tpXSA/IDAgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0sICdib29sJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9naWNhbEFuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgJ2Jvb2wnLCBmdW5jdGlvbiAoYVZhbCwgYlZhbCkge1xuICAgICAgICAgICAgaWYgKHV0aWwuaXNWYWxOYU4oYVZhbCwgYS5kdHlwZSkgfHwgdXRpbC5pc1ZhbE5hTihiVmFsLCBiLmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1dGlsLmdldE5hTignYm9vbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFWYWwgJiYgYlZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9naWNhbE9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVZhbCB8fCBiVmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sb2dpY2FsWG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnJvYWRjYXN0ZWRCaW5hcnlPcChhLCBiLCAnYm9vbCcsIGZ1bmN0aW9uIChhVmFsLCBiVmFsKSB7XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTihhVmFsLCBhLmR0eXBlKSB8fCB1dGlsLmlzVmFsTmFOKGJWYWwsIGIuZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHV0aWwuZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYVZhbCBeIGJWYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYiwgZHR5cGUpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IGNvbmRpdGlvbi5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHVlcyA9IGEuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGJWYWx1ZXMgPSBiLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3MoYS5zaGFwZSwgZHR5cGUpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICAgIHZhciBvZmZzZXQgPSBjb25kaXRpb24ucmFuayA9PT0gMCB8fCBjb25kaXRpb24ucmFuayA+IDEgfHwgYS5yYW5rID09PSAxID9cbiAgICAgICAgICAgIDEgOlxuICAgICAgICAgICAgYS5zaGFwZVsxXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb2Zmc2V0OyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlc1tpbmRleCsrXSA9IGFWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZXNbaW5kZXgrK10gPSBiVmFsdWVzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRvcEtWYWx1ZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICByZXR1cm4gdGhpcy50b3BLKHgsIGspLnZhbHVlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50b3BLSW5kaWNlcyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvcEsoeCwgaykuaW5kaWNlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50b3BLID0gZnVuY3Rpb24gKHgsIGspIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhbHVlc0FuZEluZGljZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc0FuZEluZGljZXMucHVzaCh7IHZhbHVlOiB2YWx1ZXNbaV0sIGluZGV4OiBpIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc0FuZEluZGljZXMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIudmFsdWUgLSBhLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHRvcGtWYWx1ZXMgPSB1dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoeC5kdHlwZSwgayk7XG4gICAgICAgIHZhciB0b3BrSW5kaWNlcyA9IG5ldyBJbnQzMkFycmF5KGspO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGs7IGkrKykge1xuICAgICAgICAgICAgdG9wa1ZhbHVlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0udmFsdWU7XG4gICAgICAgICAgICB0b3BrSW5kaWNlc1tpXSA9IHZhbHVlc0FuZEluZGljZXNbaV0uaW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlczogb3BzLnRlbnNvcjFkKHRvcGtWYWx1ZXMsIHguZHR5cGUpLFxuICAgICAgICAgICAgaW5kaWNlczogdGVuc29yXzEuVGVuc29yMUQubmV3KHRvcGtJbmRpY2VzKVxuICAgICAgICB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnbWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3Mob3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgcmVkdWNlU2l6ZSA9IHV0aWwuc2l6ZUZyb21TaGFwZShyZWR1Y2VTaGFwZSk7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBhVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaSAqIHJlZHVjZVNpemU7XG4gICAgICAgICAgICB2YXIgbWluID0gYVZhbHNbMF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgICAgICAgICAgICAgICBtaW4gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWluO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHsgcmV0dXJuIE1hdGgubWluKGFWYWwsIGJWYWwpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gb3BzLnplcm9zKG91dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgdmFscyA9IHJlc3VsdC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYVZhbHMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGkgKiByZWR1Y2VTaXplO1xuICAgICAgICAgICAgdmFyIG1heCA9IGFWYWxzW29mZnNldF07XG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlZHVjZVNpemU7ICsraikge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGFWYWxzW29mZnNldCArIGpdO1xuICAgICAgICAgICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gTnVtYmVyLk5hTjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgICAgICAgICAgICAgICBtYXggPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWxzW2ldID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJyb2FkY2FzdGVkQmluYXJ5T3AoYSwgYiwgYS5kdHlwZSwgZnVuY3Rpb24gKGFWYWwsIGJWYWwpIHsgcmV0dXJuIE1hdGgubWF4KGFWYWwsIGJWYWwpOyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLmNlaWwodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5mbG9vciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5mbG9vcih2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gTWF0aC5leHAodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbmV3VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh2YWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1tpXSA9IE1hdGgubG9nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmFsdWVzLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBuZXdWYWx1ZXNbaV0gPSBNYXRoLnNxcnQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogbmV3VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBuZXdWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHZhbHVlcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgbmV3VmFsdWVzW2ldID0gdmFsdWUgKiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IG5ld1ZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlcyA9IG9wcy56ZXJvcyh4LnNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGluVmFscyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpblZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBpblZhbHNbaV07XG4gICAgICAgICAgICBpZiAodXRpbC5pc1ZhbE5hTih2YWwsIHguZHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgcmVzVmFsc1tpXSA9IHV0aWwuZ2V0TmFOKHJlcy5kdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNWYWxzW2ldID0gTWF0aC5tYXgoMCwgaW5WYWxzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gKE1hdGguZXhwKHYpIC0gMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZWx1RGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmV4cCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5zZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHNjYWxlQWxwaGEgPSBzZWx1X3V0aWwuU0VMVV9TQ0FMRUFMUEhBO1xuICAgICAgICB2YXIgc2NhbGUgPSBzZWx1X3V0aWwuU0VMVV9TQ0FMRTtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHNjYWxlICogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHNjYWxlQWxwaGEgKiAoTWF0aC5leHAodikgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5sZWFreVJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBhbHBoYSAqIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUucHJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIGFscGhhcyA9IGFscGhhLmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgdiA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2ID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gYWxwaGFzW2ldICogdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5wcmVsdURlciA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYWxwaGFzID0gYWxwaGEuZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB2ID0gdmFsdWVzW2ldO1xuICAgICAgICAgICAgaWYgKHYgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHYgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gYWxwaGFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24gKHgsIG1pbiwgbWF4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KG1pbiwgdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWJzKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuaW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSB2YWx1ZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSwgJ2ludDMyJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSAxIC8gKDEgKyBNYXRoLmV4cCgtdmFsdWVzW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguc2luKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguY29zKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGgudGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLmFzaW4odmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5hY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguYWNvcyh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gTWF0aC5hdGFuKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXN1bHRWYWx1ZXNbaV0gPSBNYXRoLnNpbmgodmFsdWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IE1hdGguY29zaCh2YWx1ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gbmV3IEZsb2F0MzJBcnJheSh4LnNpemUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdXRpbC50YW5oKHZhbHVlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHguc2hhcGUsIHsgdmFsdWVzOiByZXN1bHRWYWx1ZXMgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDA7IH1cbiAgICAgICAgdmFyIHJlc3VsdFZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoeC5zaXplKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHguZGF0YVN5bmMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh1dGlsLmlzVmFsTmFOKHZhbHVlLCB4LmR0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHV0aWwuZ2V0TmFOKHguZHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0VmFsdWVzW2ldID0gdmFsdWUgPiAwID8gMSA6IGFscGhhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZSh4LnNoYXBlLCB7IHZhbHVlczogcmVzdWx0VmFsdWVzIH0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgeSA9IG9wcy5idWZmZXIoY29udkluZm8ub3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgY29udkluZm8ub3V0Q2hhbm5lbHM7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogY29udkluZm8uc3RyaWRlSGVpZ2h0IC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWluID0gTWF0aC5tYXgoMCwgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNYXggPSBNYXRoLm1pbihjb252SW5mby5pbkhlaWdodCwgZmlsdGVySGVpZ2h0ICsgeFJDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5QyA9IDA7IHlDIDwgY29udkluZm8ub3V0V2lkdGg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q0Nvcm5lciA9IHlDICogY29udkluZm8uc3RyaWRlV2lkdGggLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0geFJNaW47IHhSIDwgeFJNYXg7ICsreFIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHhDID0geENNaW47IHhDIDwgeENNYXg7ICsreEMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geEMgLSB4Q0Nvcm5lcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZDEgPSAwOyBkMSA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IHguZ2V0KGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodCA9IGZpbHRlci5nZXQod1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZG90UHJvZCArPSBwaXhlbCAqIHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHkuc2V0KGRvdFByb2QsIGIsIHlSLCB5QywgZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuY29udjJkRGVySW5wdXQgPSBmdW5jdGlvbiAoZHksIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciB0b3BQYWQgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBsZWZ0UGFkID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcihjb252SW5mby5pblNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkMSA9IDA7IGQxIDwgY29udkluZm8uaW5DaGFubmVsczsgKytkMSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHhSID0gMDsgeFIgPCBjb252SW5mby5pbkhlaWdodDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB4UiAtIGxlZnRQYWQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh4UkNvcm5lciAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeVJNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRIZWlnaHQsIChmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IDA7IHhDIDwgY29udkluZm8uaW5XaWR0aDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geEMgLSB0b3BQYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoeENDb3JuZXIgLyBzdHJpZGVXaWR0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHlDTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0V2lkdGgsIChmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKSAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkb3RQcm9kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geFJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB5UiAqIHN0cmlkZUhlaWdodCAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0geENNaW47IHlDIDwgeUNNYXg7ICsreUMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdDID0geUMgKiBzdHJpZGVXaWR0aCAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkMiA9IDA7IGQyIDwgY29udkluZm8ub3V0Q2hhbm5lbHM7ICsrZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwaXhlbCA9IGR5LmdldChiLCB5UiwgeUMsIGQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBmaWx0ZXIuZ2V0KGZpbHRlckhlaWdodCAtIDEgLSB3UiwgZmlsdGVyV2lkdGggLSAxIC0gd0MsIGQxLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogd2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZHguc2V0KGRvdFByb2QsIGIsIHhSLCB4QywgZDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmNvbnYyZERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgZFcgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLmZpbHRlclNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgbGVmdFBhZCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHRvcFBhZCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICBmb3IgKHZhciB3UiA9IDA7IHdSIDwgZmlsdGVySGVpZ2h0OyArK3dSKSB7XG4gICAgICAgICAgICB2YXIgeVJNaW4gPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoKHRvcFBhZCAtIHdSKSAvIHN0cmlkZUhlaWdodCkpO1xuICAgICAgICAgICAgdmFyIHlSTWF4ID0gTWF0aC5taW4oY29udkluZm8ub3V0SGVpZ2h0LCAoY29udkluZm8uaW5IZWlnaHQgKyB0b3BQYWQgLSB3UikgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICAgICAgZm9yICh2YXIgd0MgPSAwOyB3QyA8IGZpbHRlcldpZHRoOyArK3dDKSB7XG4gICAgICAgICAgICAgICAgdmFyIHlDTWluID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKChsZWZ0UGFkIC0gd0MpIC8gc3RyaWRlV2lkdGgpKTtcbiAgICAgICAgICAgICAgICB2YXIgeUNNYXggPSBNYXRoLm1pbihjb252SW5mby5vdXRXaWR0aCwgKGNvbnZJbmZvLmluV2lkdGggKyBsZWZ0UGFkIC0gd0MpIC8gc3RyaWRlV2lkdGgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQyID0gMDsgZDIgPCBjb252SW5mby5vdXRDaGFubmVsczsgKytkMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0geVJNaW47IHlSIDwgeVJNYXg7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhSID0gd1IgKyB5UiAqIHN0cmlkZUhlaWdodCAtIHRvcFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSB5Q01pbjsgeUMgPCB5Q01heDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDID0gd0MgKyB5QyAqIHN0cmlkZVdpZHRoIC0gbGVmdFBhZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0geC5nZXQoYiwgeFIsIHhDLCBkMSkgKiBkeS5nZXQoYiwgeVIsIHlDLCBkMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkVy5zZXQoZG90UHJvZCwgd1IsIHdDLCBkMSwgZDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkVy50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgY2hNdWwgPSBjb252SW5mby5vdXRDaGFubmVscyAvIGNvbnZJbmZvLmluQ2hhbm5lbHM7XG4gICAgICAgIHZhciB5ID0gb3BzLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIGZvciAodmFyIGIgPSAwOyBiIDwgY29udkluZm8uYmF0Y2hTaXplOyArK2IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQxID0gMDsgZDEgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QxKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeVIgPSAwOyB5UiA8IGNvbnZJbmZvLm91dEhlaWdodDsgKyt5Uikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJDb3JuZXIgPSB5UiAqIGNvbnZJbmZvLnN0cmlkZUhlaWdodCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIGNvbnZJbmZvLnN0cmlkZVdpZHRoIC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWluID0gTWF0aC5tYXgoMCwgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5XaWR0aCwgZmlsdGVyV2lkdGggKyB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBxID0gMDsgcSA8IGNoTXVsOyArK3EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZG90UHJvZCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd1IgPSB4UiAtIHhSQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4QyA9IHhDTWluOyB4QyA8IHhDTWF4OyArK3hDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBpeGVsID0geC5nZXQoYiwgeFIsIHhDLCBkMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd2VpZ2h0ID0gZmlsdGVyLmdldCh3Uiwgd0MsIGQxLCBxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdFByb2QgKz0gcGl4ZWwgKiB3ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeS5zZXQoZG90UHJvZCwgYiwgeVIsIHlDLCBkMSAqIGNoTXVsICsgcSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHkudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHgsIHJlcHMpIHtcbiAgICAgICAgdmFyIG5ld1NoYXBlID0gbmV3IEFycmF5KHgucmFuayk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3U2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1NoYXBlW2ldID0geC5zaGFwZVtpXSAqIHJlcHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy5idWZmZXIobmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC52YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbExvYyA9IG5ldyBBcnJheSh4LnJhbmspO1xuICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgb3JpZ2luYWxMb2MubGVuZ3RoOyBpXzErKykge1xuICAgICAgICAgICAgICAgIG9yaWdpbmFsTG9jW2lfMV0gPSBuZXdMb2NbaV8xXSAlIHguc2hhcGVbaV8xXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0geC5sb2NUb0luZGV4KG9yaWdpbmFsTG9jKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZXNbaV0gPSB2YWx1ZXNbb3JpZ2luYWxJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBhZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBwYWRkaW5ncy5tYXAoZnVuY3Rpb24gKHAsIGkpIHsgcmV0dXJuIHBbMF0gKyB4LnNoYXBlW2ldICsgcFsxXTsgfSk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgICAgIHZhciB4QnVmZmVyID0geC5idWZmZXIoKTtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IG9wcy5idWZmZXIob3V0U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSAhPT0gMCkge1xuICAgICAgICAgICAgYnVmZmVyLnZhbHVlcy5maWxsKGNvbnN0YW50VmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeC5zaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSB4QnVmZmVyLmluZGV4VG9Mb2MoaSk7XG4gICAgICAgICAgICB2YXIgb3V0Q29vcmRzID0gY29vcmRzLm1hcChmdW5jdGlvbiAoYywgaSkgeyByZXR1cm4gYyArIHN0YXJ0W2ldOyB9KTtcbiAgICAgICAgICAgIGJ1ZmZlci5zZXQuYXBwbHkoYnVmZmVyLCBbeC5nZXQuYXBwbHkoeCwgY29vcmRzKV0uY29uY2F0KG91dENvb3JkcykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWZmZXIudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgcGVybSkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBuZXcgQXJyYXkoeC5yYW5rKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U2hhcGVbaV0gPSB4LnNoYXBlW3Blcm1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHguc2l6ZSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSB4LmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZW5zb3JfMS5UZW5zb3IubWFrZShuZXdTaGFwZSwgeyB2YWx1ZXM6IHJlc3VsdFZhbHVlcyB9KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4LnNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIGxvYyA9IHguaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBuZXdMb2MgPSBuZXcgQXJyYXkobG9jLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpXzIgPSAwOyBpXzIgPCBuZXdMb2MubGVuZ3RoOyBpXzIrKykge1xuICAgICAgICAgICAgICAgIG5ld0xvY1tpXzJdID0gbG9jW3Blcm1baV8yXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3SW5kZXggPSByZXN1bHQubG9jVG9JbmRleChuZXdMb2MpO1xuICAgICAgICAgICAgcmVzdWx0VmFsdWVzW25ld0luZGV4XSA9IHZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmdhdGhlciA9IGZ1bmN0aW9uICh4LCBpbmRpY2VzLCBheGlzKSB7XG4gICAgICAgIHZhciBuZXdTaGFwZSA9IHguc2hhcGUuc2xpY2UoKTtcbiAgICAgICAgdmFyIGluZGljZXNWYWx1ZXMgPSBpbmRpY2VzLmRhdGFTeW5jKCk7XG4gICAgICAgIG5ld1NoYXBlW2F4aXNdID0gaW5kaWNlc1ZhbHVlcy5sZW5ndGg7XG4gICAgICAgIHZhciByZXN1bHQgPSBvcHMuemVyb3MobmV3U2hhcGUsIHguZHR5cGUpO1xuICAgICAgICB2YXIgdmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgcmVzdWx0VmFsdWVzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnNpemU7ICsraSkge1xuICAgICAgICAgICAgdmFyIG5ld0xvYyA9IHJlc3VsdC5pbmRleFRvTG9jKGkpO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsTG9jID0gbmV3TG9jLnNsaWNlKCk7XG4gICAgICAgICAgICBvcmlnaW5hbExvY1theGlzXSA9IGluZGljZXNWYWx1ZXNbbmV3TG9jW2F4aXNdXTtcbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEluZGV4ID0geC5sb2NUb0luZGV4KG9yaWdpbmFsTG9jKTtcbiAgICAgICAgICAgIHJlc3VsdFZhbHVlc1tpXSA9IHZhbHVlc1tvcmlnaW5hbEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLnBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8sIHBvb2xUeXBlKSB7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHkgPSBvcHMuYnVmZmVyKGNvbnZJbmZvLm91dFNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHlSID0gMDsgeVIgPCBjb252SW5mby5vdXRIZWlnaHQ7ICsreVIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSQ29ybmVyID0geVIgKiBzdHJpZGVIZWlnaHQgLSBwYWRUb3A7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1pbiA9IE1hdGgubWF4KDAsIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHhSTWF4ID0gTWF0aC5taW4oY29udkluZm8uaW5IZWlnaHQsIGZpbHRlckhlaWdodCArIHhSQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeUMgPSAwOyB5QyA8IGNvbnZJbmZvLm91dFdpZHRoOyArK3lDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENDb3JuZXIgPSB5QyAqIHN0cmlkZVdpZHRoIC0gcGFkTGVmdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01pbiA9IE1hdGgubWF4KDAsIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB4Q01heCA9IE1hdGgubWluKGNvbnZJbmZvLmluV2lkdGgsIGZpbHRlcldpZHRoICsgeENDb3JuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1pbk1heFZhbHVlID0gKHBvb2xUeXBlID09PSAnbWF4JyA/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdmdWYWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4UiA9IHhSTWluOyB4UiA8IHhSTWF4OyArK3hSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNOYU4ocGl4ZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IE5hTjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF2Z1ZhbHVlID0gTmFOO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChwb29sVHlwZSA9PT0gJ21heCcgJiYgcGl4ZWwgPiBtaW5NYXhWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChwb29sVHlwZSA9PT0gJ21pbicgJiYgcGl4ZWwgPCBtaW5NYXhWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbk1heFZhbHVlID0gcGl4ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocG9vbFR5cGUgPT09ICdhdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdmdWYWx1ZSArPSBwaXhlbCAvIChmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKG1pbk1heFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB5LnNldChwb29sVHlwZSA9PT0gJ2F2ZycgPyBhdmdWYWx1ZSA6IG1pbk1heFZhbHVlLCBiLCB5UiwgeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB5LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICByZXR1cm4gdGhpcy5wb29sKHgsIGNvbnZJbmZvLCAnbWF4Jyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbFBvc2l0aW9ucyA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gb3BzLmJ1ZmZlcihjb252SW5mby5vdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBjb252SW5mby5iYXRjaFNpemU7ICsrYikge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBjb252SW5mby5pbkNoYW5uZWxzOyArK2QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB5UiA9IDA7IHlSIDwgY29udkluZm8ub3V0SGVpZ2h0OyArK3lSKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4UkNvcm5lciA9IHlSICogc3RyaWRlSGVpZ2h0IC0gcGFkVG9wO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeFJNaW4gPSBNYXRoLm1heCgwLCB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4Uk1heCA9IE1hdGgubWluKGNvbnZJbmZvLmluSGVpZ2h0LCBmaWx0ZXJIZWlnaHQgKyB4UkNvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHlDID0gMDsgeUMgPCBjb252SW5mby5vdXRXaWR0aDsgKyt5Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHhDQ29ybmVyID0geUMgKiBzdHJpZGVXaWR0aCAtIHBhZExlZnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNaW4gPSBNYXRoLm1heCgwLCB4Q0Nvcm5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgeENNYXggPSBNYXRoLm1pbihjb252SW5mby5pbldpZHRoLCBmaWx0ZXJXaWR0aCArIHhDQ29ybmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtYXhQb3NpdGlvbiA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeFIgPSB4Uk1pbjsgeFIgPCB4Uk1heDsgKyt4Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3UiA9IHhSIC0geFJDb3JuZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeEMgPSB4Q01pbjsgeEMgPCB4Q01heDsgKyt4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd0MgPSB4QyAtIHhDQ29ybmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSB4LmdldChiLCB4UiwgeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGl4ZWwgPiBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4VmFsdWUgPSBwaXhlbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9uID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4UG9zaXRpb25zLnNldChtYXhQb3NpdGlvbiwgYiwgeVIsIHlDLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4UG9zaXRpb25zLnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgbWF4UG9zaXRpb25zID0gdGhpcy5tYXhQb29sUG9zaXRpb25zKHgsIGNvbnZJbmZvKTtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Uikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBjb252SW5mby5pbldpZHRoOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF4UG9zID0gZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGggLSAxIC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heFBvc2l0aW9ucy5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3VyUG9zID0gd1IgKiBmaWx0ZXJXaWR0aCArIHdDO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWFzayA9IG1heFBvcyA9PT0gY3VyUG9zID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsICogbWFzaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkeC5zZXQoZG90UHJvZCwgYiwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF2Z1Bvb2xCYWNrcHJvcCA9IGZ1bmN0aW9uIChkeSwgeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIGR4ID0gb3BzLmJ1ZmZlcih4LnNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGNvbnZJbmZvLmJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBkID0gMDsgZCA8IGNvbnZJbmZvLmluQ2hhbm5lbHM7ICsrZCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGR4UiA9IDA7IGR4UiA8IGNvbnZJbmZvLmluSGVpZ2h0OyArK2R4Uikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBkeEMgPSAwOyBkeEMgPCBjb252SW5mby5pbldpZHRoOyArK2R4Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGR5UkNvcm5lciA9IGR4UiAtIHBhZFRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeUNDb3JuZXIgPSBkeEMgLSBwYWRMZWZ0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRvdFByb2QgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgd1IgPSAwOyB3UiA8IGZpbHRlckhlaWdodDsgKyt3Uikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkeVIgPSAoZHlSQ29ybmVyICsgd1IpIC8gc3RyaWRlSGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeVIgPCAwIHx8IGR5UiA+PSBjb252SW5mby5vdXRIZWlnaHQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5mbG9vcihkeVIpICE9PSBkeVIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHdDID0gMDsgd0MgPCBmaWx0ZXJXaWR0aDsgKyt3Qykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZHlDID0gKGR5Q0Nvcm5lciArIHdDKSAvIHN0cmlkZVdpZHRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZHlDIDwgMCB8fCBkeUMgPj0gY29udkluZm8ub3V0V2lkdGggfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguZmxvb3IoZHlDKSAhPT0gZHlDKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGl4ZWwgPSBkeS5nZXQoYiwgZHlSLCBkeUMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3RQcm9kICs9IHBpeGVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGR4LnNldChkb3RQcm9kICogYXZnTXVsdGlwbGllciwgYiwgZHhSLCBkeEMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkeC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm1pblBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ21pbicpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9vbCh4LCBjb252SW5mbywgJ2F2ZycpLnRvRmxvYXQoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5yZXNpemVCaWxpbmVhciA9IGZ1bmN0aW9uICh4LCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpIHtcbiAgICAgICAgdmFyIF9hID0geC5zaGFwZSwgYmF0Y2ggPSBfYVswXSwgb2xkSGVpZ2h0ID0gX2FbMV0sIG9sZFdpZHRoID0gX2FbMl0sIG51bUNoYW5uZWxzID0gX2FbM107XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuYnVmZmVyKFtiYXRjaCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgbnVtQ2hhbm5lbHNdLCB4LmR0eXBlKTtcbiAgICAgICAgdmFyIGVmZmVjdGl2ZUlucHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtvbGRIZWlnaHQgLSAxLCBvbGRXaWR0aCAtIDFdIDogW29sZEhlaWdodCwgb2xkV2lkdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlT3V0cHV0U2l6ZSA9IGFsaWduQ29ybmVycyA/IFtuZXdIZWlnaHQgLSAxLCBuZXdXaWR0aCAtIDFdIDogW25ld0hlaWdodCwgbmV3V2lkdGhdO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoOyBiKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgbmV3SGVpZ2h0OyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG5ld1dpZHRoOyBjKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBudW1DaGFubmVsczsgZCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlRnJhY1JvdyA9IChlZmZlY3RpdmVJbnB1dFNpemVbMF0pICogciAvIChlZmZlY3RpdmVPdXRwdXRTaXplWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VGcmFjQ29sID0gKGVmZmVjdGl2ZUlucHV0U2l6ZVsxXSkgKiBjIC8gKGVmZmVjdGl2ZU91dHB1dFNpemVbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNvdXJjZVJvd0Zsb29yID0gTWF0aC5mbG9vcihzb3VyY2VGcmFjUm93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VSb3dDZWlsID0gTWF0aC5taW4ob2xkSGVpZ2h0IC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNSb3cpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzb3VyY2VDb2xGbG9vciA9IE1hdGguZmxvb3Ioc291cmNlRnJhY0NvbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc291cmNlQ29sQ2VpbCA9IE1hdGgubWluKG9sZFdpZHRoIC0gMSwgTWF0aC5jZWlsKHNvdXJjZUZyYWNDb2wpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b3BMZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbEZsb29yLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b21MZWZ0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sRmxvb3IsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcFJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Rmxvb3IsIHNvdXJjZUNvbENlaWwsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvdHRvbVJpZ2h0ID0geC5nZXQoYiwgc291cmNlUm93Q2VpbCwgc291cmNlQ29sQ2VpbCwgZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm93RnJhYyA9IHNvdXJjZUZyYWNSb3cgLSBzb3VyY2VSb3dGbG9vcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjb2xGcmFjID0gc291cmNlRnJhY0NvbCAtIHNvdXJjZUNvbEZsb29yO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRvcF8xID0gdG9wTGVmdCArICh0b3BSaWdodCAtIHRvcExlZnQpICogY29sRnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3R0b20gPSBib3R0b21MZWZ0ICsgKGJvdHRvbVJpZ2h0IC0gYm90dG9tTGVmdCkgKiBjb2xGcmFjO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdG9wXzEgKyAoYm90dG9tIC0gdG9wXzEpICogcm93RnJhYztcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5zZXQobmV3VmFsdWUsIGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQudG9UZW5zb3IoKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciB4VmFsdWVzID0geC5kYXRhU3luYygpO1xuICAgICAgICB2YXIgbWVhblZhbHVlcyA9IG1lYW4uZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHZhcmlhbmNlVmFsdWVzID0gdmFyaWFuY2UuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHNjYWxlVmFsdWVzID0gc2NhbGUgPyBzY2FsZS5kYXRhU3luYygpIDogbmV3IEZsb2F0MzJBcnJheShbMV0pO1xuICAgICAgICB2YXIgb2Zmc2V0VmFsdWVzID0gb2Zmc2V0ID8gb2Zmc2V0LmRhdGFTeW5jKCkgOiBuZXcgRmxvYXQzMkFycmF5KFswXSk7XG4gICAgICAgIHZhciBvdXRWYWx1ZXMgPSBuZXcgRmxvYXQzMkFycmF5KHhWYWx1ZXMubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4VmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRWYWx1ZXNbaV0gPSBvZmZzZXRWYWx1ZXNbaSAlIG9mZnNldFZhbHVlcy5sZW5ndGhdICtcbiAgICAgICAgICAgICAgICAoeFZhbHVlc1tpXSAtIG1lYW5WYWx1ZXNbaSAlIG1lYW5WYWx1ZXMubGVuZ3RoXSkgKlxuICAgICAgICAgICAgICAgICAgICBzY2FsZVZhbHVlc1tpICUgc2NhbGVWYWx1ZXMubGVuZ3RoXSAvXG4gICAgICAgICAgICAgICAgICAgIE1hdGguc3FydCh2YXJpYW5jZVZhbHVlc1tpICUgdmFyaWFuY2VWYWx1ZXMubGVuZ3RoXSArIHZhcmlhbmNlRXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wc18xLnRlbnNvcjRkKG91dFZhbHVlcywgeC5zaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCByYWRpdXMsIGJpYXMsIGFscGhhLCBiZXRhLCBub3JtUmVnaW9uKSB7XG4gICAgICAgIHZhciBvdXRwdXQgPSBvcHMuYnVmZmVyKHguc2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHZhciByYWQgPSByYWRpdXM7XG4gICAgICAgIHZhciBtYXhXID0gb3V0cHV0LnNoYXBlWzFdIC0gMTtcbiAgICAgICAgdmFyIG1heEggPSBvdXRwdXQuc2hhcGVbMl0gLSAxO1xuICAgICAgICB2YXIgbWF4RCA9IG91dHB1dC5zaGFwZVszXSAtIDE7XG4gICAgICAgIHZhciBzdW1BY3Jvc3NDaGFubmVscyA9IGZ1bmN0aW9uIChiLCByLCBjLCBkKSB7XG4gICAgICAgICAgICB2YXIgc3VtID0gMC4wO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGQgLSByYWQpOyBqIDw9IE1hdGgubWluKGQgKyByYWQsIG1heEQpOyBqKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgeiA9IHguZ2V0KGIsIHIsIGMsIGopO1xuICAgICAgICAgICAgICAgIHN1bSArPSB6ICogejtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBzdW1XaXRoaW5DaGFubmVsID0gZnVuY3Rpb24gKGIsIHIsIGMsIGQpIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwLjA7XG4gICAgICAgICAgICBmb3IgKHZhciB1ID0gTWF0aC5tYXgoMCwgciAtIHJhZCk7IHUgPD0gTWF0aC5taW4ociArIHJhZCwgbWF4Vyk7IHUrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHYgPSBNYXRoLm1heCgwLCBjIC0gcmFkKTsgdiA8PSBNYXRoLm1pbihjICsgcmFkLCBtYXhIKTsgdisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBNYXRoLnBvdyh4LmdldChiLCB1LCB2LCBkKSwgMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHN1bTtcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICh2YXIgYiA9IDA7IGIgPCBvdXRwdXQuc2hhcGVbMF07IGIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPD0gb3V0cHV0LnNoYXBlWzFdOyByKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IG91dHB1dC5zaGFwZVsyXTsgYysrKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgb3V0cHV0LnNoYXBlWzNdOyBkKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSBub3JtUmVnaW9uID09PSAnd2l0aGluQ2hhbm5lbCcgP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bVdpdGhpbkNoYW5uZWwoYiwgciwgYywgZCkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1bUFjcm9zc0NoYW5uZWxzKGIsIHIsIGMsIGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHZhbCA9IHguZ2V0KGIsIHIsIGMsIGQpICogTWF0aC5wb3coYmlhcyArIGFscGhhICogc3VtLCAtYmV0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQuc2V0KHZhbCwgYiwgciwgYywgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dC50b1RlbnNvcigpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRDUFUucHJvdG90eXBlLm11bHRpbm9taWFsID0gZnVuY3Rpb24gKHByb2JhYmlsaXRpZXMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JhYmlsaXRpZXMuc2hhcGVbMF07XG4gICAgICAgIHZhciBudW1FdmVudHMgPSBwcm9iYWJpbGl0aWVzLnNoYXBlWzFdO1xuICAgICAgICB2YXIgcmVzID0gb3BzLnplcm9zKFtiYXRjaFNpemUsIG51bVNhbXBsZXNdLCAnaW50MzInKTtcbiAgICAgICAgdmFyIHJlc1ZhbHMgPSByZXMuZGF0YVN5bmMoKTtcbiAgICAgICAgdmFyIHByb2JWYWxzID0gcHJvYmFiaWxpdGllcy5kYXRhU3luYygpO1xuICAgICAgICBmb3IgKHZhciBiID0gMDsgYiA8IGJhdGNoU2l6ZTsgKytiKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gYiAqIG51bUV2ZW50cztcbiAgICAgICAgICAgIHZhciBjZGYgPSBuZXcgRmxvYXQzMkFycmF5KG51bUV2ZW50cyAtIDEpO1xuICAgICAgICAgICAgY2RmWzBdID0gcHJvYlZhbHNbb2Zmc2V0XTtcbiAgICAgICAgICAgIGZvciAodmFyIGV2ZW50XzEgPSAxOyBldmVudF8xIDwgY2RmLmxlbmd0aDsgKytldmVudF8xKSB7XG4gICAgICAgICAgICAgICAgY2RmW2V2ZW50XzFdID0gY2RmW2V2ZW50XzEgLSAxXSArIHByb2JWYWxzW29mZnNldCArIGV2ZW50XzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20uYWxlYShzZWVkLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdmFyIG91dE9mZnNldCA9IGIgKiBudW1TYW1wbGVzO1xuICAgICAgICAgICAgZm9yICh2YXIgc2FtcGxlSWQgPSAwOyBzYW1wbGVJZCA8IG51bVNhbXBsZXM7ICsrc2FtcGxlSWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgciA9IHJhbmRvbSgpO1xuICAgICAgICAgICAgICAgIHJlc1ZhbHNbb3V0T2Zmc2V0ICsgc2FtcGxlSWRdID0gY2RmLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBldmVudF8yID0gMDsgZXZlbnRfMiA8IGNkZi5sZW5ndGg7IGV2ZW50XzIrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAociA8IGNkZltldmVudF8yXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzVmFsc1tvdXRPZmZzZXQgKyBzYW1wbGVJZF0gPSBldmVudF8yO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5vbmVIb3QgPSBmdW5jdGlvbiAoaW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHZhciByZXMgPSBuZXcgRmxvYXQzMkFycmF5KGluZGljZXMuc2l6ZSAqIGRlcHRoKTtcbiAgICAgICAgcmVzLmZpbGwob2ZmVmFsdWUpO1xuICAgICAgICBmb3IgKHZhciBldmVudF8zID0gMDsgZXZlbnRfMyA8IGluZGljZXMuc2l6ZTsgKytldmVudF8zKSB7XG4gICAgICAgICAgICByZXNbZXZlbnRfMyAqIGRlcHRoICsgaW5kaWNlcy5nZXQoZXZlbnRfMyldID0gb25WYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BzLnRlbnNvcjJkKHJlcywgW2luZGljZXMuc2l6ZSwgZGVwdGhdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kQ1BVLnByb3RvdHlwZS5icm9hZGNhc3RlZEJpbmFyeU9wID0gZnVuY3Rpb24gKGEsIGIsIGR0eXBlLCBvcCkge1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG9wcy5idWZmZXIobmV3U2hhcGUsIGR0eXBlKTtcbiAgICAgICAgdmFyIGFWYWx1ZXMgPSBhLmRhdGFTeW5jKCk7XG4gICAgICAgIHZhciBiVmFsdWVzID0gYi5kYXRhU3luYygpO1xuICAgICAgICB2YXIgYUJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGEuc2hhcGUsIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIGJCcm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhiLnNoYXBlLCBuZXdTaGFwZSk7XG4gICAgICAgIHZhciBfbG9vcF8yID0gZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSByZXN1bHQuaW5kZXhUb0xvYyhpKTtcbiAgICAgICAgICAgIHZhciBhTG9jID0gbG9jLnNsaWNlKC1hLnJhbmspO1xuICAgICAgICAgICAgYUJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYUxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGFJbmRleCA9IGEubG9jVG9JbmRleChhTG9jKTtcbiAgICAgICAgICAgIHZhciBiTG9jID0gbG9jLnNsaWNlKC1iLnJhbmspO1xuICAgICAgICAgICAgYkJyb2FkY2FzdERpbXMuZm9yRWFjaChmdW5jdGlvbiAoZCkgeyByZXR1cm4gYkxvY1tkXSA9IDA7IH0pO1xuICAgICAgICAgICAgdmFyIGJJbmRleCA9IGIubG9jVG9JbmRleChiTG9jKTtcbiAgICAgICAgICAgIHJlc3VsdC52YWx1ZXNbaV0gPSBvcChhVmFsdWVzW2FJbmRleF0sIGJWYWx1ZXNbYkluZGV4XSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0LnZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgX2xvb3BfMihpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRvVGVuc29yKCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZENQVS5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRDUFU7XG59KCkpO1xuZXhwb3J0cy5NYXRoQmFja2VuZENQVSA9IE1hdGhCYWNrZW5kQ1BVO1xuZW52aXJvbm1lbnRfMS5FTlYucmVnaXN0ZXJCYWNrZW5kKCdjcHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgTWF0aEJhY2tlbmRDUFUoKTsgfSk7XG52YXIgTkRBcnJheU1hdGhDUFUgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOREFycmF5TWF0aENQVSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBOREFycmF5TWF0aENQVShzYWZlTW9kZSkge1xuICAgICAgICBpZiAoc2FmZU1vZGUgPT09IHZvaWQgMCkgeyBzYWZlTW9kZSA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnNvbGUud2FybignbmV3IE5EQXJyYXlNYXRoQ1BVKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSAnICtcbiAgICAgICAgICAgICdkbC5zZXRCYWNrZW5kKFxcJ2NwdVxcJykuJyk7XG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgJ2NwdScsIHNhZmVNb2RlKSB8fCB0aGlzO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHJldHVybiBOREFycmF5TWF0aENQVTtcbn0obWF0aF8xLk5EQXJyYXlNYXRoKSk7XG5leHBvcnRzLk5EQXJyYXlNYXRoQ1BVID0gTkRBcnJheU1hdGhDUFU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBtYXRoXzEgPSByZXF1aXJlKFwiLi4vbWF0aFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi4vb3BzL2F4aXNfdXRpbFwiKTtcbnZhciByZWR1Y2VfdXRpbCA9IHJlcXVpcmUoXCIuLi9vcHMvcmVkdWNlX3V0aWxcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIHR5cGVzID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBhcmdtaW5tYXhfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9hcmdtaW5tYXhfZ3B1XCIpO1xudmFyIGF2Z19wb29sX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYXZnX3Bvb2xfYmFja3Byb3BfZ3B1XCIpO1xudmFyIGJhdGNobm9ybV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL2JhdGNobm9ybV9ncHVcIik7XG52YXIgYmluYXJ5b3BfZ3B1ID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGJpbmFyeW9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvYmluYXJ5b3BfZ3B1XCIpO1xudmFyIGNsaXBfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jbGlwX2dwdVwiKTtcbnZhciBjb25jYXRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb25jYXRfZ3B1XCIpO1xudmFyIGNvbnZfYmFja3Byb3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2JhY2twcm9wX2dwdVwiKTtcbnZhciBjb252X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvY29udl9ncHVcIik7XG52YXIgY29udl9ncHVfZGVwdGh3aXNlXzEgPSByZXF1aXJlKFwiLi93ZWJnbC9jb252X2dwdV9kZXB0aHdpc2VcIik7XG52YXIgZnJvbV9waXhlbHNfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9mcm9tX3BpeGVsc19ncHVcIik7XG52YXIgZ2F0aGVyX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvZ2F0aGVyX2dwdVwiKTtcbnZhciBncGdwdV9jb250ZXh0XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9jb250ZXh0XCIpO1xudmFyIGdwZ3B1X21hdGggPSByZXF1aXJlKFwiLi93ZWJnbC9ncGdwdV9tYXRoXCIpO1xudmFyIGxvZ2ljYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9sb2dpY2FsX2dwdVwiKTtcbnZhciBscm5fZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9scm5fZ3B1XCIpO1xudmFyIG1heF9wb29sX2JhY2twcm9wX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvbWF4X3Bvb2xfYmFja3Byb3BfZ3B1XCIpO1xudmFyIG11bG1hdF9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL211bG1hdF9ncHVcIik7XG52YXIgbXVsdGlub21pYWxfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9tdWx0aW5vbWlhbF9ncHVcIik7XG52YXIgb25laG90X2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvb25laG90X2dwdVwiKTtcbnZhciBwYWRfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9wYWRfZ3B1XCIpO1xudmFyIHBvb2xfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9wb29sX2dwdVwiKTtcbnZhciByZWR1Y2VfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC9yZWR1Y2VfZ3B1XCIpO1xudmFyIHJlc2l6ZV9iaWxpbmVhcl9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3Jlc2l6ZV9iaWxpbmVhcl9ncHVcIik7XG52YXIgcmV2ZXJzZV9ncHVfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3JldmVyc2VfZ3B1XCIpO1xudmFyIHNsaWNlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvc2xpY2VfZ3B1XCIpO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi93ZWJnbC90ZXhfdXRpbFwiKTtcbnZhciB0ZXh0dXJlX21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3dlYmdsL3RleHR1cmVfbWFuYWdlclwiKTtcbnZhciB0aWxlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdGlsZV9ncHVcIik7XG52YXIgdHJhbnNwb3NlX2dwdV8xID0gcmVxdWlyZShcIi4vd2ViZ2wvdHJhbnNwb3NlX2dwdVwiKTtcbnZhciB1bmFyeV9vcCA9IHJlcXVpcmUoXCIuL3dlYmdsL3VuYXJ5b3BfZ3B1XCIpO1xudmFyIHVuYXJ5b3BfZ3B1XzEgPSByZXF1aXJlKFwiLi93ZWJnbC91bmFyeW9wX2dwdVwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2wvd2ViZ2xfdXRpbFwiKTtcbnZhciBNYXRoQmFja2VuZFdlYkdMID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRoQmFja2VuZFdlYkdMKGdwZ3B1LCBkZWxheWVkU3RvcmFnZSkge1xuICAgICAgICBpZiAoZGVsYXllZFN0b3JhZ2UgPT09IHZvaWQgMCkgeyBkZWxheWVkU3RvcmFnZSA9IHRydWU7IH1cbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLmRlbGF5ZWRTdG9yYWdlID0gZGVsYXllZFN0b3JhZ2U7XG4gICAgICAgIHRoaXMudGV4RGF0YSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMudXBsb2FkV2FpdE1zID0gMDtcbiAgICAgICAgdGhpcy5kb3dubG9hZFdhaXRNcyA9IDA7XG4gICAgICAgIHRoaXMuYmluYXJ5Q2FjaGUgPSB7fTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYkdMIGlzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3BncHUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdSA9IG5ldyBncGdwdV9jb250ZXh0XzEuR1BHUFVDb250ZXh0KCk7XG4gICAgICAgICAgICB0aGlzLmdwZ3B1Q3JlYXRlZExvY2FsbHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncGdwdUNyZWF0ZWRMb2NhbGx5ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlciA9IG5ldyB0ZXh0dXJlX21hbmFnZXJfMS5UZXh0dXJlTWFuYWdlcih0aGlzLmdwZ3B1KTtcbiAgICB9XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoZGF0YUlkLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdEYXRhIGJ1ZmZlciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleERhdGEuc2V0KGRhdGFJZCwge1xuICAgICAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICAgICAgZHR5cGU6IGR0eXBlLFxuICAgICAgICAgICAgdmFsdWVzOiBudWxsLFxuICAgICAgICAgICAgdGV4dHVyZTogbnVsbCxcbiAgICAgICAgICAgIHRleFNoYXBlOiBudWxsLFxuICAgICAgICAgICAgdGV4VHlwZTogdGV4X3V0aWxfMS5UZXh0dXJlVHlwZS5GTE9BVFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmZyb21QaXhlbHMgPSBmdW5jdGlvbiAocGl4ZWxzLCBudW1DaGFubmVscykge1xuICAgICAgICBpZiAocGl4ZWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWF0aEJhY2tlbmRXZWJHTC53cml0ZVBpeGVscygpOiBwaXhlbHMgY2FuIG5vdCBiZSBudWxsJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleFNoYXBlID0gW3BpeGVscy5oZWlnaHQsIHBpeGVscy53aWR0aF07XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IFtwaXhlbHMuaGVpZ2h0LCBwaXhlbHMud2lkdGgsIG51bUNoYW5uZWxzXTtcbiAgICAgICAgaWYgKHBpeGVscyBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IHJlYWQgcGl4ZWxzIGZyb20gSFRNTEltYWdlRWxlbWVudCBvdXRzaWRlICcgK1xuICAgICAgICAgICAgICAgICAgICAndGhlIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHBpeGVscy53aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHBpeGVscy5oZWlnaHQ7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLmRyYXdJbWFnZShwaXhlbHMsIDAsIDAsIHBpeGVscy53aWR0aCwgcGl4ZWxzLmhlaWdodCk7XG4gICAgICAgICAgICBwaXhlbHMgPSB0aGlzLmNhbnZhcztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGVtcFBpeGVsQXJyYXkgPSB0ZW5zb3JfMS5UZW5zb3IubWFrZSh0ZXhTaGFwZSwge30sICdpbnQzMicpO1xuICAgICAgICB0aGlzLnRleERhdGEuZ2V0KHRlbXBQaXhlbEFycmF5LmRhdGFJZCkudGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuVU5TSUdORURfQllURTtcbiAgICAgICAgdGhpcy5ncGdwdS51cGxvYWRQaXhlbERhdGFUb1RleHR1cmUodGhpcy5nZXRUZXh0dXJlKHRlbXBQaXhlbEFycmF5LmRhdGFJZCksIHBpeGVscyk7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGZyb21fcGl4ZWxzX2dwdV8xLkZyb21QaXhlbHNQcm9ncmFtKG91dFNoYXBlKTtcbiAgICAgICAgdmFyIHJlcyA9IHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbdGVtcFBpeGVsQXJyYXldKTtcbiAgICAgICAgdGVtcFBpeGVsQXJyYXkuZGlzcG9zZSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoZGF0YUlkLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbHVlcyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hdGhCYWNrZW5kV2ViR0wud3JpdGUoKTogdmFsdWVzIGNhbiBub3QgYmUgbnVsbCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGhyb3dJZk5vRGF0YShkYXRhSWQpO1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZSwgdGV4VHlwZSA9IHRleERhdGEudGV4VHlwZTtcbiAgICAgICAgaWYgKHRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgICAgICB0ZXhEYXRhLnRleHR1cmUgPSBudWxsO1xuICAgICAgICAgICAgdGV4RGF0YS50ZXhTaGFwZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGV4RGF0YS52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIGlmICghdGhpcy5kZWxheWVkU3RvcmFnZSkge1xuICAgICAgICAgICAgdGhpcy51cGxvYWRUb0dQVShkYXRhSWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWFkU3luYyA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICB2YXIgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgdmFsdWVzID0gdGV4RGF0YS52YWx1ZXMsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNhY2hlT25DUFUoZGF0YUlkKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFRpbWVQcm9ncmFtID0gdGhpcy5hY3RpdmVUaW1lcnMgIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZsb2F0MzJWYWx1ZXMgPSB0aGlzLmdwZ3B1LmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUodGV4dHVyZSwgdGV4U2hhcGVbMF0sIHRleFNoYXBlWzFdKTtcbiAgICAgICAgaWYgKHNob3VsZFRpbWVQcm9ncmFtKSB7XG4gICAgICAgICAgICB0aGlzLmRvd25sb2FkV2FpdE1zICs9IHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCwgZmxvYXQzMlZhbHVlcyk7XG4gICAgICAgIHJldHVybiB0ZXhEYXRhLnZhbHVlcztcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0ZXhEYXRhLCB0ZXh0dXJlLCB2YWx1ZXMsIHRleFNoYXBlLCBmbG9hdDMyVmFsdWVzO1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgdmFsdWVzID0gdGV4RGF0YS52YWx1ZXMsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FjaGVPbkNQVShkYXRhSWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9HRVRfQlVGRkVSX1NVQl9EQVRBX0FTWU5DX0VYVEVOU0lPTl9FTkFCTEVEJykpIHJldHVybiBbMywgMl07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZ3BncHUuZG93bmxvYWRNYXRyaXhGcm9tVGV4dHVyZUFzeW5jKHRleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBmbG9hdDMyVmFsdWVzID0gX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWNoZU9uQ1BVKGRhdGFJZCwgZmxvYXQzMlZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRleERhdGEudmFsdWVzXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGhpcy5yZWFkU3luYyhkYXRhSWQpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgdGhpcy5ncGdwdS5ydW5RdWVyeShmdW5jdGlvbiAoKSB7IH0pXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLnJlYWRTeW5jKGRhdGFJZCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb2xkQWN0aXZlVGltZXJzLCBuZXdBY3RpdmVUaW1lcnMsIG91dGVyTW9zdFRpbWUsIGZsYXR0ZW5lZEFjdGl2ZVRpbWVycywga2VybmVsTXMsIHJlcztcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIG9sZEFjdGl2ZVRpbWVycyA9IHRoaXMuYWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3QWN0aXZlVGltZXJzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXRlck1vc3RUaW1lID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9ncmFtVGltZXJzU3RhY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID0gbmV3QWN0aXZlVGltZXJzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dGVyTW9zdFRpbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUaW1lcnMucHVzaChuZXdBY3RpdmVUaW1lcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUaW1lcnMgPSBuZXdBY3RpdmVUaW1lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBmKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmbGF0dGVuZWRBY3RpdmVUaW1lcnMgPSB1dGlsLmZsYXR0ZW4odGhpcy5hY3RpdmVUaW1lcnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hY3RpdmVUaW1lcnMgPSBvbGRBY3RpdmVUaW1lcnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0ZXJNb3N0VGltZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvZ3JhbVRpbWVyc1N0YWNrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwoZmxhdHRlbmVkQWN0aXZlVGltZXJzKS50aGVuKGZ1bmN0aW9uIChyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gc3VtICs9IHJlc3VsdDsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdW07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXJuZWxNcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGxvYWRXYWl0TXM6IHRoaXMudXBsb2FkV2FpdE1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkV2FpdE1zOiB0aGlzLmRvd25sb2FkV2FpdE1zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtlcm5lbE1zOiBrZXJuZWxNcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsTXM6IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFdhaXRNcyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkV2FpdE1zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tZW1vcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB7IHVucmVsaWFibGU6IGZhbHNlIH07XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdGFydFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHUuYmVnaW5RdWVyeSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXJ0TXM6IHBlcmZvcm1hbmNlLm5vdygpLCBlbmRNczogbnVsbCB9O1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZW5kVGltZXIgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUuZW5kUXVlcnkoKTtcbiAgICAgICAgICAgIHJldHVybiBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBxdWVyeS5lbmRNcyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICByZXR1cm4gcXVlcnk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5nZXRRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHRpbWVyUXVlcnk7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdwZ3B1LnBvbGxRdWVyeVRpbWUocXVlcnkpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZXJRdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgICAgIHJldHVybiBbMiwgdGltZXJRdWVyeS5lbmRNcyAtIHRpbWVyUXVlcnkuc3RhcnRNc107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kaXNwb3NlRGF0YSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgaWYgKHRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdmFyIF9hID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpLCB0ZXh0dXJlID0gX2EudGV4dHVyZSwgdGV4U2hhcGUgPSBfYS50ZXhTaGFwZSwgdGV4VHlwZSA9IF9hLnRleFR5cGU7XG4gICAgICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0dXJlTWFuYWdlci5yZWxlYXNlVGV4dHVyZSh0ZXh0dXJlLCB0ZXhTaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRleERhdGEuZGVsZXRlKGRhdGFJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldFRleHR1cmUgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUoZGF0YUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKS50ZXh0dXJlO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0VGV4dHVyZURhdGEgPSBmdW5jdGlvbiAoZGF0YUlkKSB7XG4gICAgICAgIHRoaXMudXBsb2FkVG9HUFUoZGF0YUlkKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEdQR1BVQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3BncHU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBzbGljZV9ncHVfMS5TbGljZVByb2dyYW0oc2l6ZSk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKGJlZ2luKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG51bGwsIGN1c3RvbVNldHVwKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnJldmVyc2UgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZXZlcnNlX2dwdV8xLlJldmVyc2VQcm9ncmFtKHguc2hhcGUsIGF4aXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb25jYXRfZ3B1XzEuQ29uY2F0UHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5ORUcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBtdWxtYXRfZ3B1XzEuTWF0TXVsUHJvZ3JhbShhLnNoYXBlLCBiLnNoYXBlLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk1VTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB0eXBlcy51cGNhc3RUeXBlKGEuZHR5cGUsIGIuZHR5cGUpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5iYXRjaE5vcm1hbGl6YXRpb240RCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBpbnB1dHMgPSBbeCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICB2YXIgb2Zmc2V0U2hhcGUgPSBudWxsO1xuICAgICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIG9mZnNldFNoYXBlID0gb2Zmc2V0LnNoYXBlO1xuICAgICAgICAgICAgaW5wdXRzLnB1c2gob2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTaGFwZSA9IG51bGw7XG4gICAgICAgIGlmIChzY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzY2FsZVNoYXBlID0gc2NhbGUuc2hhcGU7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChzY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmF0Y2hub3JtX2dwdV8xLkJhdGNoTm9ybVByb2dyYW0oeC5zaGFwZSwgbWVhbi5zaGFwZSwgdmFyaWFuY2Uuc2hhcGUsIG9mZnNldFNoYXBlLCBzY2FsZVNoYXBlLCB2YXJpYW5jZUVwc2lsb24pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIGlucHV0cyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREID0gZnVuY3Rpb24gKHgsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEsIG5vcm1SZWdpb24pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbHJuX2dwdV8xLkxSTlByb2dyYW0oeC5zaGFwZSwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRpbGUgPSBmdW5jdGlvbiAoeCwgcmVwcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB0aWxlX2dwdV8xLlRpbGVQcm9ncmFtKHguc2hhcGUsIHJlcHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcGFkX2dwdV8xLlBhZFByb2dyYW0oeC5zaGFwZSwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50cmFuc3Bvc2UgPSBmdW5jdGlvbiAoeCwgcGVybSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB0cmFuc3Bvc2VfZ3B1XzEuVHJhbnNwb3NlUHJvZ3JhbSh4LnNoYXBlLCBwZXJtKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2F0aGVyID0gZnVuY3Rpb24gKHgsIGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgZ2F0aGVyX2dwdV8xLkdhdGhlclByb2dyYW0oeC5zaGFwZSwgaW5kaWNlcy5zaXplLCBheGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgaW5kaWNlc10pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKHgsIHJlZHVjZVR5cGUsIGR0eXBlKSB7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSB4LnNoYXBlWzBdO1xuICAgICAgICB2YXIgaW5TaXplID0geC5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKTtcbiAgICAgICAgdmFyIHJlZHVjZUluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSB9O1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyByZWR1Y2VfZ3B1XzEuUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKTtcbiAgICAgICAgdmFyIF9hID0gcHJvZ3JhbS5vdXRwdXRTaGFwZSwgcm93cyA9IF9hWzBdLCBjb2xzID0gX2FbMV07XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShbcm93cywgY29sc10sIGR0eXBlKTtcbiAgICAgICAgdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSwgb3V0cHV0KTtcbiAgICAgICAgaWYgKG91dHB1dC5zaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWR1Y2Uob3V0cHV0LCByZWR1Y2VUeXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hcmdSZWR1Y2UgPSBmdW5jdGlvbiAoeCwgcmVkdWNlVHlwZSwgYmVzdEluZGljZXNBKSB7XG4gICAgICAgIGlmIChiZXN0SW5kaWNlc0EgPT09IHZvaWQgMCkgeyBiZXN0SW5kaWNlc0EgPSBudWxsOyB9XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSB4LnNoYXBlWzBdO1xuICAgICAgICB2YXIgaW5TaXplID0geC5zaGFwZVsxXTtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSAhPSBudWxsKSB7XG4gICAgICAgICAgICBiYXRjaFNpemUgPSBiZXN0SW5kaWNlc0Euc2hhcGVbMF07XG4gICAgICAgICAgICBpblNpemUgPSBiZXN0SW5kaWNlc0Euc2hhcGVbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHdpbmRvd1NpemUgPSByZWR1Y2VfdXRpbC5jb21wdXRlT3B0aW1hbFdpbmRvd1NpemUoaW5TaXplKTtcbiAgICAgICAgdmFyIHJlZHVjZUluZm8gPSB7IHdpbmRvd1NpemU6IHdpbmRvd1NpemUsIGluU2l6ZTogaW5TaXplLCBiYXRjaFNpemU6IGJhdGNoU2l6ZSB9O1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBhcmdtaW5tYXhfZ3B1XzEuQXJnTWluTWF4UHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlLCBiZXN0SW5kaWNlc0EgPT0gbnVsbCk7XG4gICAgICAgIHZhciBfYSA9IHByb2dyYW0ub3V0cHV0U2hhcGUsIHJvd3MgPSBfYVswXSwgY29scyA9IF9hWzFdO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkoW3Jvd3MsIGNvbHNdLCAnaW50MzInKTtcbiAgICAgICAgdmFyIGlucHV0cyA9IFt4XTtcbiAgICAgICAgaWYgKGJlc3RJbmRpY2VzQSAhPSBudWxsKSB7XG4gICAgICAgICAgICBpbnB1dHMucHVzaChiZXN0SW5kaWNlc0EpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCk7XG4gICAgICAgIGlmIChvdXRwdXQuc2hhcGVbMV0gPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKHgsIHJlZHVjZVR5cGUsIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zdW0gPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ3N1bScsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgdmFyIG91dHB1dERUeXBlID0gdHlwZXMuc3VtT3V0VHlwZSh4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ3N1bScsIG91dHB1dERUeXBlKS5yZXNoYXBlKG91dFNoYXBlKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFyZ01pbiA9IGZ1bmN0aW9uICh4LCBheGVzKSB7XG4gICAgICAgIGF4aXNfdXRpbC5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcygnYXJnTWluJywgYXhlcywgeC5yYW5rKTtcbiAgICAgICAgdmFyIF9hID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyksIG91dFNoYXBlID0gX2FbMF0sIHJlZHVjZVNoYXBlID0gX2FbMV07XG4gICAgICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgYTJEID0geC5hczJEKC0xLCBpblNpemUpO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdSZWR1Y2UoYTJELCAnbWluJykucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hcmdNYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ2FyZ01heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJnUmVkdWNlKGEyRCwgJ21heCcpLnJlc2hhcGUob3V0U2hhcGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkVRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubm90RXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1Lk5PVF9FUVVBTCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxlc3MgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxFU1MsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sZXNzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxFU1NfRVFVQUwsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2Jvb2wnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5ncmVhdGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5HUkVBVEVSLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ3JlYXRlckVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5HUkVBVEVSX0VRVUFMLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9naWNhbE5vdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTE9HSUNBTF9OT1QpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5sb2dpY2FsQW5kID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5MT0dJQ0FMX0FORCwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuTE9HSUNBTF9PUiwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnYm9vbCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmxvZ2ljYWxYb3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkxPR0lDQUxfWE9SLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdib29sJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUud2hlcmUgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBsb2dpY2FsX2dwdV8xLldoZXJlUHJvZ3JhbShjb25kaXRpb24ucmFuaywgYS5zaGFwZSwgYS5yYW5rKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIGR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbY29uZGl0aW9uLCBhLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRvcEtWYWx1ZXMgPSBmdW5jdGlvbiAoeCwgaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3RvcEtWYWx1ZXMgR1BVIG5vdCB5ZXQgaW1wbGVtZW50ZWQhJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50b3BLSW5kaWNlcyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndG9wS0luZGljZXMgR1BVIG5vdCB5ZXQgaW1wbGVtZW50ZWQhJyk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5taW4gPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21pbicsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ21pbicsIGEyRC5kdHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5taW5pbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NSU4sIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoeCwgYXhlcykge1xuICAgICAgICBheGlzX3V0aWwuYXNzZXJ0QXhlc0FyZUlubmVyTW9zdERpbXMoJ21heCcsIGF4ZXMsIHgucmFuayk7XG4gICAgICAgIHZhciBfYSA9IGF4aXNfdXRpbC5jb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzKHguc2hhcGUsIGF4ZXMpLCBvdXRTaGFwZSA9IF9hWzBdLCByZWR1Y2VTaGFwZSA9IF9hWzFdO1xuICAgICAgICB2YXIgaW5TaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHJlZHVjZVNoYXBlKTtcbiAgICAgICAgdmFyIGEyRCA9IHguYXMyRCgtMSwgaW5TaXplKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVkdWNlKGEyRCwgJ21heCcsIGEyRC5kdHlwZSkucmVzaGFwZShvdXRTaGFwZSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5tYXhpbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5NQVgsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5kaXZpZGUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBiaW5hcnlvcF9ncHVfMS5CaW5hcnlPcFByb2dyYW0oYmluYXJ5b3BfZ3B1LkRJViwgYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCAnZmxvYXQzMicpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuQURELCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsIHR5cGVzLnVwY2FzdFR5cGUoYS5kdHlwZSwgYi5kdHlwZSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSwgb3V0cHV0KTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnN1YnRyYWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5TVUIsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgYmluYXJ5b3BfZ3B1XzEuQmluYXJ5T3BQcm9ncmFtKGJpbmFyeW9wX2dwdS5QT1csIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2EsIGJdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2VpbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQ0VJTCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5GTE9PUik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmV4cCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuRVhQKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5MT0cpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TUVJUKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3F1YXJlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TUVVBUkUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5SRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5FTFUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5lbHVEZXIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkVMVV9ERVIpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TRUxVKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubGVha3lSZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuTEVBS1lfUkVMVShhbHBoYSkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5wcmVsdSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuUFJFTFUsIGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFthLCBiXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5wcmVsdURlciA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGJpbmFyeW9wX2dwdV8xLkJpbmFyeU9wUHJvZ3JhbShiaW5hcnlvcF9ncHUuUFJFTFVfREVSLCBhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbYSwgYl0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuaW50ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5UT19JTlQpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY2xpcCA9IGZ1bmN0aW9uICh4LCBtaW4sIG1heCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjbGlwX2dwdV8xLkNsaXBQcm9ncmFtKHguc2hhcGUsIG1pbiwgbWF4KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BQlMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5zaWdtb2lkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSUdNT0lEKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5TSU4pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNPUyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLnRhbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuQVNJTik7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmFjb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkFDT1MpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdGFuID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5BVEFOKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHVuYXJ5b3BfZ3B1XzEuVW5hcnlPcFByb2dyYW0oeC5zaGFwZSwgdW5hcnlfb3AuU0lOSCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvc2ggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLkNPU0gpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4XSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50YW5oID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgdW5hcnlvcF9ncHVfMS5VbmFyeU9wUHJvZ3JhbSh4LnNoYXBlLCB1bmFyeV9vcC5UQU5IKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uICh4LCBhbHBoYSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyB1bmFyeW9wX2dwdV8xLlVuYXJ5T3BQcm9ncmFtKHguc2hhcGUsIHVuYXJ5X29wLlNURVAoYWxwaGEpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29udjJkID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9ncHVfMS5Db252MkRQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgZmlsdGVyXSk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jb252MmREZXJJbnB1dCA9IGZ1bmN0aW9uIChkeSwgZmlsdGVyLCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBjb252X2JhY2twcm9wX2dwdV8xLkNvbnYyRERlcklucHV0UHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2R5LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmNvbnYyZERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgY29udl9iYWNrcHJvcF9ncHVfMS5Db252MkREZXJGaWx0ZXJQcm9ncmFtKGNvbnZJbmZvKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeCwgZHldKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmRlcHRod2lzZUNvbnYyRCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IGNvbnZfZ3B1X2RlcHRod2lzZV8xLkRlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFt4LCBmaWx0ZXJdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgY29udkluZm8pIHtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgcG9vbF9ncHVfMS5Qb29sMkRQcm9ncmFtKGNvbnZJbmZvLCAnbWF4JywgZmFsc2UpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWluUG9vbCA9IGZ1bmN0aW9uICh4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBwb29sX2dwdV8xLlBvb2wyRFByb2dyYW0oY29udkluZm8sICdtaW4nLCBmYWxzZSk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0sIG91dHB1dCk7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sID0gZnVuY3Rpb24gKHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ2F2ZycsIGZhbHNlKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRoaXMubWFrZU91dHB1dEFycmF5KHByb2dyYW0ub3V0cHV0U2hhcGUsICdmbG9hdDMyJyk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW3hdLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubWF4UG9vbEJhY2twcm9wID0gZnVuY3Rpb24gKGR5LCB4LCBjb252SW5mbykge1xuICAgICAgICB2YXIgZ2V0UG9zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgdmFyIG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtID0gbmV3IHBvb2xfZ3B1XzEuUG9vbDJEUHJvZ3JhbShjb252SW5mbywgJ21heCcsIGdldFBvc2l0aW9ucyk7XG4gICAgICAgIHZhciBtYXhQb29sUG9zaXRpb25zID0gdGhpcy5jb21waWxlQW5kUnVuKG1heFBvb2xQb3NpdGlvbnNQcm9ncmFtLCBbeF0pO1xuICAgICAgICB2YXIgbWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSA9IG5ldyBtYXhfcG9vbF9iYWNrcHJvcF9ncHVfMS5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkobWF4UG9vbEJhY2tQcm9wUHJvZ3JhbS5vdXRwdXRTaGFwZSwgeC5kdHlwZSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmNvbXBpbGVBbmRSdW4obWF4UG9vbEJhY2tQcm9wUHJvZ3JhbSwgW2R5LCBtYXhQb29sUG9zaXRpb25zXSwgb3V0cHV0KTtcbiAgICAgICAgbWF4UG9vbFBvc2l0aW9ucy5kaXNwb3NlKCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIHgsIGNvbnZJbmZvKSB7XG4gICAgICAgIHZhciBhdmdQb29sQmFja3Byb3BQcm9ncmFtID0gbmV3IGF2Z19wb29sX2JhY2twcm9wX2dwdV8xLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbyk7XG4gICAgICAgIHZhciBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShhdmdQb29sQmFja3Byb3BQcm9ncmFtLm91dHB1dFNoYXBlLCB4LmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihhdmdQb29sQmFja3Byb3BQcm9ncmFtLCBbZHldLCBvdXRwdXQpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUucmVzaXplQmlsaW5lYXIgPSBmdW5jdGlvbiAoeCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gbmV3IHJlc2l6ZV9iaWxpbmVhcl9ncHVfMS5SZXNpemVCaWxpbmVhclByb2dyYW0oeC5zaGFwZSwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgYWxpZ25Db3JuZXJzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGlsZUFuZFJ1bihwcm9ncmFtLCBbeF0pO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUubXVsdGlub21pYWwgPSBmdW5jdGlvbiAocHJvYnMsIG51bVNhbXBsZXMsIHNlZWQpIHtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHByb2JzLnNoYXBlWzBdO1xuICAgICAgICB2YXIgbnVtT3V0Y29tZXMgPSBwcm9icy5zaGFwZVsxXTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSBuZXcgbXVsdGlub21pYWxfZ3B1XzEuTXVsdGlub21pYWxQcm9ncmFtKGJhdGNoU2l6ZSwgbnVtT3V0Y29tZXMsIG51bVNhbXBsZXMpO1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5tYWtlT3V0cHV0QXJyYXkocHJvZ3JhbS5vdXRwdXRTaGFwZSwgJ2ludDMyJyk7XG4gICAgICAgIHZhciBjdXN0b21TZXR1cCA9IHByb2dyYW0uZ2V0Q3VzdG9tU2V0dXBGdW5jKHNlZWQpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb21waWxlQW5kUnVuKHByb2dyYW0sIFtwcm9ic10sIG91dHB1dCwgY3VzdG9tU2V0dXApO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUub25lSG90ID0gZnVuY3Rpb24gKGluZGljZXMsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSkge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IG5ldyBvbmVob3RfZ3B1XzEuT25lSG90UHJvZ3JhbShpbmRpY2VzLnNpemUsIGRlcHRoLCBvblZhbHVlLCBvZmZWYWx1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVBbmRSdW4ocHJvZ3JhbSwgW2luZGljZXNdKTtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLm1ha2VPdXRwdXRBcnJheSA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5tYWtlKHNoYXBlLCB7fSwgZHR5cGUpO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuY29tcGlsZUFuZFJ1biA9IGZ1bmN0aW9uIChwcm9ncmFtLCBpbnB1dHMsIG91dHB1dCwgY3VzdG9tU2V0dXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKG91dHB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0aGlzLm1ha2VPdXRwdXRBcnJheShwcm9ncmFtLm91dHB1dFNoYXBlLCBpbnB1dHNbMF0uZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dHNEYXRhID0gaW5wdXRzLm1hcChmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICAgICAgICAgIF90aGlzLnVwbG9hZFRvR1BVKGlucHV0LmRhdGFJZCk7XG4gICAgICAgICAgICByZXR1cm4geyB0ZW5zb3I6IGlucHV0LCB0ZXhEYXRhOiBfdGhpcy50ZXhEYXRhLmdldChpbnB1dC5kYXRhSWQpIH07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnVwbG9hZFRvR1BVKG91dHB1dC5kYXRhSWQpO1xuICAgICAgICB2YXIgb3V0cHV0RGF0YSA9IHtcbiAgICAgICAgICAgIHRlbnNvcjogb3V0cHV0LFxuICAgICAgICAgICAgdGV4RGF0YTogdGhpcy50ZXhEYXRhLmdldChvdXRwdXQuZGF0YUlkKVxuICAgICAgICB9O1xuICAgICAgICB2YXIga2V5ID0gZ3BncHVfbWF0aC5tYWtlU2hhZGVyS2V5KHByb2dyYW0sIGlucHV0c0RhdGEsIG91dHB1dERhdGEpO1xuICAgICAgICB2YXIgYmluYXJ5ID0gdGhpcy5nZXRBbmRTYXZlQmluYXJ5KGtleSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIGdwZ3B1X21hdGguY29tcGlsZVByb2dyYW0oX3RoaXMuZ3BncHUsIHByb2dyYW0sIGlucHV0c0RhdGEsIG91dHB1dERhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHNob3VsZFRpbWVQcm9ncmFtID0gdGhpcy5hY3RpdmVUaW1lcnMgIT0gbnVsbDtcbiAgICAgICAgdmFyIHF1ZXJ5O1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5zdGFydFRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ3BncHVfbWF0aC5ydW5Qcm9ncmFtKGJpbmFyeSwgaW5wdXRzRGF0YSwgb3V0cHV0RGF0YSwgY3VzdG9tU2V0dXApO1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHF1ZXJ5ID0gdGhpcy5lbmRUaW1lcihxdWVyeSk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRpbWVycy5wdXNoKHRoaXMuZ2V0UXVlcnlUaW1lKHF1ZXJ5KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xuICAgIE1hdGhCYWNrZW5kV2ViR0wucHJvdG90eXBlLmdldEFuZFNhdmVCaW5hcnkgPSBmdW5jdGlvbiAoa2V5LCBnZXRCaW5hcnkpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMuYmluYXJ5Q2FjaGUpKSB7XG4gICAgICAgICAgICB0aGlzLmJpbmFyeUNhY2hlW2tleV0gPSBnZXRCaW5hcnkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iaW5hcnlDYWNoZVtrZXldO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZ2V0VGV4dHVyZU1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHR1cmVNYW5hZ2VyO1xuICAgIH07XG4gICAgTWF0aEJhY2tlbmRXZWJHTC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5iaW5hcnlDYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kZWxldGVQcm9ncmFtKHRoaXMuYmluYXJ5Q2FjaGVba2V5XS53ZWJHTFByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGV4dHVyZU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgaWYgKHRoaXMuZ3BncHVDcmVhdGVkTG9jYWxseSkge1xuICAgICAgICAgICAgdGhpcy5ncGdwdS5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS50aHJvd0lmTm9EYXRhID0gZnVuY3Rpb24gKGRhdGFJZCkge1xuICAgICAgICBpZiAoIXRoaXMudGV4RGF0YS5oYXMoZGF0YUlkKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogTm8gZGF0YSBmb3VuZCBmb3IgdGhpcyB0ZW5zb3IuIFwiICtcbiAgICAgICAgICAgICAgICBcIkRpZCB5b3UgY2hhbmdlIHlvdXIgYmFja2VuZCBpbiB0aGUgbWlkZGxlIG9mIHRoZSBwcm9ncmFtPyBcIiArXG4gICAgICAgICAgICAgICAgXCJOZXcgYmFja2VuZHMgY2FuJ3QgdXNlIFRlbnNvcnMgY3JlYXRlZCB3aXRoIHByZXZpb3VzIGJhY2tlbmRzXCIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS51cGxvYWRUb0dQVSA9IGZ1bmN0aW9uIChkYXRhSWQpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmTm9EYXRhKGRhdGFJZCk7XG4gICAgICAgIHZhciB0ZXhEYXRhID0gdGhpcy50ZXhEYXRhLmdldChkYXRhSWQpO1xuICAgICAgICB2YXIgc2hhcGUgPSB0ZXhEYXRhLnNoYXBlLCB2YWx1ZXMgPSB0ZXhEYXRhLnZhbHVlcywgdGV4dHVyZSA9IHRleERhdGEudGV4dHVyZSwgZHR5cGUgPSB0ZXhEYXRhLmR0eXBlLCB0ZXhUeXBlID0gdGV4RGF0YS50ZXhUeXBlO1xuICAgICAgICBpZiAodGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNob3VsZFRpbWVQcm9ncmFtID0gdGhpcy5hY3RpdmVUaW1lcnMgIT0gbnVsbDtcbiAgICAgICAgdmFyIHN0YXJ0O1xuICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRleFNoYXBlID0gd2ViZ2xfdXRpbC5nZXRUZXh0dXJlU2hhcGVGcm9tTG9naWNhbFNoYXBlKHRoaXMuZ3BncHUuZ2wsIHNoYXBlKTtcbiAgICAgICAgdGV4RGF0YS50ZXhTaGFwZSA9IHRleFNoYXBlO1xuICAgICAgICB2YXIgbmV3VGV4dHVyZSA9IHRoaXMudGV4dHVyZU1hbmFnZXIuYWNxdWlyZVRleHR1cmUodGV4U2hhcGUsIHRleFR5cGUpO1xuICAgICAgICB0ZXhEYXRhLnRleHR1cmUgPSBuZXdUZXh0dXJlO1xuICAgICAgICBpZiAodmFsdWVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZ3BncHUudXBsb2FkTWF0cml4VG9UZXh0dXJlKG5ld1RleHR1cmUsIHRleFNoYXBlWzBdLCB0ZXhTaGFwZVsxXSwgdHlwZWRBcnJheVRvRmxvYXQzMih2YWx1ZXMsIGR0eXBlKSk7XG4gICAgICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoc2hvdWxkVGltZVByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwbG9hZFdhaXRNcyArPSBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNYXRoQmFja2VuZFdlYkdMLnByb3RvdHlwZS5jYWNoZU9uQ1BVID0gZnVuY3Rpb24gKGRhdGFJZCwgZmxvYXQzMlZhbHVlcykge1xuICAgICAgICB2YXIgZG9udEtlZXBDb3B5T25HUFUgPSB0aGlzLmRlbGF5ZWRTdG9yYWdlO1xuICAgICAgICB2YXIgdGV4RGF0YSA9IHRoaXMudGV4RGF0YS5nZXQoZGF0YUlkKTtcbiAgICAgICAgdmFyIHRleHR1cmUgPSB0ZXhEYXRhLnRleHR1cmUsIHRleFNoYXBlID0gdGV4RGF0YS50ZXhTaGFwZSwgZHR5cGUgPSB0ZXhEYXRhLmR0eXBlLCB0ZXhUeXBlID0gdGV4RGF0YS50ZXhUeXBlO1xuICAgICAgICBpZiAoZG9udEtlZXBDb3B5T25HUFUgJiYgdGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVNYW5hZ2VyLnJlbGVhc2VUZXh0dXJlKHRleHR1cmUsIHRleFNoYXBlLCB0ZXhUeXBlKTtcbiAgICAgICAgICAgIHRleERhdGEudGV4dHVyZSA9IG51bGw7XG4gICAgICAgICAgICB0ZXhEYXRhLnRleFNoYXBlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxvYXQzMlZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0ZXhEYXRhLnZhbHVlcyA9IGZsb2F0MzJUb1R5cGVkQXJyYXkoZmxvYXQzMlZhbHVlcywgZHR5cGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gTWF0aEJhY2tlbmRXZWJHTDtcbn0oKSk7XG5leHBvcnRzLk1hdGhCYWNrZW5kV2ViR0wgPSBNYXRoQmFja2VuZFdlYkdMO1xuZW52aXJvbm1lbnRfMS5FTlYucmVnaXN0ZXJCYWNrZW5kKCd3ZWJnbCcsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5ldyBNYXRoQmFja2VuZFdlYkdMKCk7IH0pO1xudmFyIE5EQXJyYXlNYXRoR1BVID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTkRBcnJheU1hdGhHUFUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTkRBcnJheU1hdGhHUFUoZ3BncHUsIHNhZmVNb2RlKSB7XG4gICAgICAgIGlmIChzYWZlTW9kZSA9PT0gdm9pZCAwKSB7IHNhZmVNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgY29uc29sZS53YXJuKCduZXcgTkRBcnJheU1hdGhHUFUoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgK1xuICAgICAgICAgICAgJ2RsLnNldEJhY2tlbmQoXFwnd2ViZ2xcXCcpLicpO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG5ldyBNYXRoQmFja2VuZFdlYkdMKGdwZ3B1KSwgc2FmZU1vZGUpIHx8IHRoaXM7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoR1BVO1xufShtYXRoXzEuTkRBcnJheU1hdGgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGhHUFUgPSBOREFycmF5TWF0aEdQVTtcbmZ1bmN0aW9uIGZsb2F0MzJUb1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicgfHwgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gKGR0eXBlID09PSAnaW50MzInKSA/IG5ldyBJbnQzMkFycmF5KGEubGVuZ3RoKSA6XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB2YXIgdmFsID0gYVtpXTtcbiAgICAgICAgICAgIHZhbCA9IGlzTmFOKHZhbCkgPyB1dGlsLmdldE5hTihkdHlwZSkgOiBNYXRoLnJvdW5kKHZhbCk7XG4gICAgICAgICAgICByZXN1bHRbaV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHlwZWRBcnJheVRvRmxvYXQzMihhLCBkdHlwZSkge1xuICAgIGlmIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5KSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBGbG9hdDMyQXJyYXkoYS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHZhbCA9IGFbaV07XG4gICAgICAgICAgICByZXNbaV0gPSB1dGlsLmlzVmFsTmFOKHZhbCwgZHR5cGUpID8gTmFOIDogdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQXJnTWluTWF4UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJnTWluTWF4UHJvZ3JhbShyZWR1Y2VJbmZvLCBvcCwgZmlyc3RQYXNzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplO1xuICAgICAgICB2YXIgaW5TaXplID0gcmVkdWNlSW5mby5pblNpemU7XG4gICAgICAgIHZhciBvdXRTaXplID0gTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpO1xuICAgICAgICBpZiAoIWZpcnN0UGFzcykge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ2Jlc3RJbmRpY2VzQScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRTaXplXTtcbiAgICAgICAgdmFyIGNvbXBPcCA9IChvcCA9PT0gJ21heCcpID8gJz4nIDogJzwnO1xuICAgICAgICB2YXIgaW5kZXhTbmlwcGV0ID0gZmlyc3RQYXNzID9cbiAgICAgICAgICAgICdpbk9mZnNldCArIGk7JyA6XG4gICAgICAgICAgICAncm91bmQoZ2V0QmVzdEluZGljZXNBKGJhdGNoLCBpbk9mZnNldCArIGkpKTsnO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjMiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBvdXRJZHggPSBjb29yZHNbMV07XFxuICAgICAgICBpbnQgaW5PZmZzZXQgPSBvdXRJZHggKiBcIiArIHdpbmRvd1NpemUgKyBcIjtcXG5cXG4gICAgICAgIGludCBiZXN0SW5kZXggPSAwO1xcbiAgICAgICAgZmxvYXQgYmVzdFZhbHVlID0gZ2V0QShiYXRjaCwgaW5PZmZzZXQpO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIHdpbmRvd1NpemUgKyBcIjsgaSsrKSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IFwiICsgaW5kZXhTbmlwcGV0ICsgXCI7XFxuICAgICAgICAgIGZsb2F0IGNhbmRpZGF0ZSA9IGdldEEoYmF0Y2gsIGluSWR4KTtcXG4gICAgICAgICAgaWYgKGlzTmFOKGNhbmRpZGF0ZSkpIHtcXG4gICAgICAgICAgICBzZXRPdXRwdXQoY2FuZGlkYXRlKTtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKGNhbmRpZGF0ZSBcIiArIGNvbXBPcCArIFwiIGJlc3RWYWx1ZSkge1xcbiAgICAgICAgICAgIGJlc3RWYWx1ZSA9IGNhbmRpZGF0ZTtcXG4gICAgICAgICAgICBiZXN0SW5kZXggPSBpbklkeDtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGZsb2F0KGJlc3RJbmRleCkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBBcmdNaW5NYXhQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQXJnTWluTWF4UHJvZ3JhbSA9IEFyZ01pbk1heFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBBdmdQb29sMkRCYWNrcHJvcFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ2R5J107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5pblNoYXBlO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBmaWx0ZXJIZWlnaHQgLSAxIC0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gZmlsdGVyV2lkdGggLSAxIC0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB2YXIgYXZnTXVsdGlwbGllciA9IDEgLyAoZmlsdGVySGVpZ2h0ICogZmlsdGVyV2lkdGgpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcbiAgICAgIGNvbnN0IGZsb2F0IGF2Z011bHRpcGxpZXIgPSBmbG9hdChcIiArIGF2Z011bHRpcGxpZXIgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG5cXG4gICAgICAgICAgICBkb3RQcm9kICs9IGR5VmFsdWUgKiBhdmdNdWx0aXBsaWVyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbSA9IEF2Z1Bvb2wyREJhY2twcm9wUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL29wcy9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBCYXRjaE5vcm1Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1Qcm9ncmFtKHhTaGFwZSwgbWVhblNoYXBlLCB2YXJpYW5jZVNoYXBlLCBvZmZzZXRTaGFwZSwgc2NhbGVTaGFwZSwgdmFyaWFuY2VFcHNpbG9uKSB7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBbXTtcbiAgICAgICAgdGhpcy5zdXBwb3J0c0Jyb2FkY2FzdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdtZWFuJywgJ3ZhcmlhbmNlJ107XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgbWVhblNoYXBlKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoeFNoYXBlLCB2YXJpYW5jZVNoYXBlKTtcbiAgICAgICAgdmFyIG9mZnNldFNuaXBwZXQgPSAnMC4wJztcbiAgICAgICAgaWYgKG9mZnNldFNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgb2Zmc2V0U2hhcGUpO1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzLnB1c2goJ29mZnNldCcpO1xuICAgICAgICAgICAgb2Zmc2V0U25pcHBldCA9ICdnZXRPZmZzZXRBdE91dENvb3JkcygpJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NhbGVTbmlwcGV0ID0gJzEuMCc7XG4gICAgICAgIGlmIChzY2FsZVNoYXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKHhTaGFwZSwgc2NhbGVTaGFwZSk7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMucHVzaCgnc2NhbGUnKTtcbiAgICAgICAgICAgIHNjYWxlU25pcHBldCA9ICdnZXRTY2FsZUF0T3V0Q29vcmRzKCknO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSB4U2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGZsb2F0IHggPSBnZXRYQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IG1lYW4gPSBnZXRNZWFuQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IHZhcmlhbmNlID0gZ2V0VmFyaWFuY2VBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgb2Zmc2V0ID0gXCIgKyBvZmZzZXRTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBzY2FsZSA9IFwiICsgc2NhbGVTbmlwcGV0ICsgXCI7XFxuICAgICAgICBmbG9hdCBpbnYgPSBzY2FsZSAvIHNxcnQodmFyaWFuY2UgKyBmbG9hdChcIiArIHZhcmlhbmNlRXBzaWxvbiArIFwiKSk7XFxuICAgICAgICBzZXRPdXRwdXQoKHggLSBtZWFuKSAqIGludiArIG9mZnNldCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJhdGNoTm9ybVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5CYXRjaE5vcm1Qcm9ncmFtID0gQmF0Y2hOb3JtUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4uLy4uL29wcy9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBDSEVDS19OQU5fU05JUFBFVCA9IFwiXFxuICBpZiAoaXNOYU4oYSkpIHJldHVybiBhO1xcbiAgaWYgKGlzTmFOKGIpKSByZXR1cm4gYjtcXG5cIjtcbmV4cG9ydHMuQUREID0gJ3JldHVybiBhICsgYjsnO1xuZXhwb3J0cy5TVUIgPSAncmV0dXJuIGEgLSBiOyc7XG5leHBvcnRzLk1VTCA9ICdyZXR1cm4gYSAqIGI7JztcbmV4cG9ydHMuRElWID0gJ3JldHVybiBhIC8gYjsnO1xuZXhwb3J0cy5QT1cgPSBcIlxcbiAgcmV0dXJuIChyb3VuZChtb2QoYiwgMi4wKSkgPT0gMCB8fCByb3VuZChtb2QoYiwgMi4wKSkgPT0gMikgP1xcbiAgICAgIHBvdyhhYnMoYSksIGIpIDogc2lnbihhKSAqIHBvdyhhYnMoYSksIGIpO1xcblwiO1xuZXhwb3J0cy5FUVVBTCA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBmbG9hdChhID09IGIpO1xcblwiO1xuZXhwb3J0cy5OT1RfRVFVQUwgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSAhPSBiKTtcXG5cIjtcbmV4cG9ydHMuTEVTUyA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBmbG9hdChhIDwgYik7XFxuXCI7XG5leHBvcnRzLkxFU1NfRVFVQUwgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA8PSBiKTtcXG5cIjtcbmV4cG9ydHMuR1JFQVRFUiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBmbG9hdChhID4gYik7XFxuXCI7XG5leHBvcnRzLkdSRUFURVJfRVFVQUwgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA+PSBiKTtcXG5cIjtcbmV4cG9ydHMuTE9HSUNBTF9BTkQgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA+PSAxLjAgJiYgYiA+PSAxLjApO1xcblwiO1xuZXhwb3J0cy5MT0dJQ0FMX09SID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KGEgPj0gMS4wIHx8IGIgPj0gMS4wKTtcXG5cIjtcbmV4cG9ydHMuTE9HSUNBTF9YT1IgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gZmxvYXQoYSA+PSAxLjAgXl4gYiA+PSAxLjApO1xcblwiO1xuZXhwb3J0cy5QUkVMVSA9IFwiXFxuICByZXR1cm4gKGEgPj0gMC4wKSA/IGEgOiBiICogYTtcXG5cIjtcbmV4cG9ydHMuUFJFTFVfREVSID0gXCJcXG4gIHJldHVybiAoYSA+IDAuMCkgPyAxLjAgOiAoKGEgPCAwLjApID8gYiA6IGEpO1xcblwiO1xuZXhwb3J0cy5NQVggPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gbWF4KGEsIGIpO1xcblwiO1xuZXhwb3J0cy5NSU4gPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gbWluKGEsIGIpO1xcblwiO1xudmFyIEJpbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BQcm9ncmFtKG9wLCBhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLnN1cHBvcnRzQnJvYWRjYXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9XG4gICAgICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhU2hhcGUsIGJTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IGJpbmFyeU9wZXJhdGlvbihmbG9hdCBhLCBmbG9hdCBiKSB7XFxuICAgICAgICBcIiArIG9wICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgYSA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgYiA9IGdldEJBdE91dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGJpbmFyeU9wZXJhdGlvbihhLCBiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIEJpbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkJpbmFyeU9wUHJvZ3JhbSA9IEJpbmFyeU9wUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIENsaXBQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDbGlwUHJvZ3JhbShhU2hhcGUsIG1pbiwgbWF4KSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gYVNoYXBlO1xuICAgICAgICB2YXIgbWluRml4ZWQgPSBtaW4udG9GaXhlZCgyMCk7XG4gICAgICAgIHZhciBtYXhGaXhlZCA9IG1heC50b0ZpeGVkKDIwKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgdmFsdWUgPSBnZXRBQXRPdXRDb29yZHMoKTtcXG4gICAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbHVlKTtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc2V0T3V0cHV0KGNsYW1wKHZhbHVlLCBcIiArIG1pbkZpeGVkICsgXCIsIFwiICsgbWF4Rml4ZWQgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDbGlwUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNsaXBQcm9ncmFtID0gQ2xpcFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBjb25jYXRfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvY29uY2F0X3V0aWxcIik7XG52YXIgQ29uY2F0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uY2F0UHJvZ3JhbShhU2hhcGUsIGJTaGFwZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnQiddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPVxuICAgICAgICAgICAgY29uY2F0X3V0aWwuY29tcHV0ZU91dFNoYXBlKGFTaGFwZSwgYlNoYXBlLCAxKTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgeVIgPSBjb29yZHMueDtcXG4gICAgICAgIGludCB5QyA9IGNvb3Jkcy55O1xcblxcbiAgICAgICAgZmxvYXQgdmFsdWUgPSAwLjA7XFxuICAgICAgICBpZiAoeUMgPCBcIiArIGFTaGFwZVsxXSArIFwiKSB7XFxuICAgICAgICAgIHZhbHVlID0gZ2V0QSh5UiwgeUMpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgeUMgLT0gXCIgKyBhU2hhcGVbMV0gKyBcIjtcXG4gICAgICAgICAgdmFsdWUgPSBnZXRCKHlSLCB5Qyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQodmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBDb25jYXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29uY2F0UHJvZ3JhbSA9IENvbmNhdFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDb252MkREZXJGaWx0ZXJQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252MkREZXJGaWx0ZXJQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCcsICdkeSddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uZmlsdGVyU2hhcGU7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gY29udkluZm8ucGFkSW5mby50b3A7XG4gICAgICAgIHZhciBwYWRMZWZ0ID0gY29udkluZm8ucGFkSW5mby5sZWZ0O1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCB3UiA9IGNvb3Jkcy54O1xcbiAgICAgICAgaW50IHdDID0gY29vcmRzLnk7XFxuICAgICAgICBpbnQgZDEgPSBjb29yZHMuejtcXG4gICAgICAgIGludCBkMiA9IGNvb3Jkcy53O1xcblxcbiAgICAgICAgLy8gQ29udm9sdmUgeCg/LCA/LCBkMSkgd2l0aCBkeSg6LCA6LCBkMikgdG8gZ2V0IGR3KHdSLCB3QywgZDEsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGIgPSAwOyBiIDwgXCIgKyBjb252SW5mby5iYXRjaFNpemUgKyBcIjsgYisrKSB7XFxuICAgICAgICAgIGZvciAoaW50IHlSID0gMDsgeVIgPCBcIiArIGNvbnZJbmZvLm91dEhlaWdodCArIFwiOyB5UisrKSB7XFxuICAgICAgICAgICAgaW50IHhSID0gd1IgKyB5UiAqIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIgLSBcIiArIHBhZFRvcCArIFwiO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgeUMgPSAwOyB5QyA8IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIjsgeUMrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0gd0MgKyB5QyAqIFwiICsgc3RyaWRlV2lkdGggKyBcIiAtIFwiICsgcGFkTGVmdCArIFwiO1xcblxcbiAgICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCB5UiwgeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHhWYWx1ZSA9IGdldFgoYiwgeFIsIHhDLCBkMSk7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9ICh4VmFsdWUgKiBkeVZhbHVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVyRmlsdGVyUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkNvbnYyRERlckZpbHRlclByb2dyYW0gPSBDb252MkREZXJGaWx0ZXJQcm9ncmFtO1xudmFyIENvbnYyRERlcklucHV0UHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJERGVySW5wdXRQcm9ncmFtKGNvbnZJbmZvKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnZHknLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8uaW5TaGFwZTtcbiAgICAgICAgdmFyIGZpbHRlckhlaWdodCA9IGNvbnZJbmZvLmZpbHRlckhlaWdodDtcbiAgICAgICAgdmFyIGZpbHRlcldpZHRoID0gY29udkluZm8uZmlsdGVyV2lkdGg7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgcGFkVG9wID0gZmlsdGVySGVpZ2h0IC0gMSAtIGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGZpbHRlcldpZHRoIC0gMSAtIGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkMSA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgIGl2ZWMyIGR5Q29ybmVyID0gY29vcmRzLnl6IC0gcGFkcztcXG4gICAgICAgIGludCBkeVJDb3JuZXIgPSBkeUNvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5Q29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSBkeSg/LCA/LCBkMikgd2l0aCB3KDosIDosIGQxLCBkMikgdG8gY29tcHV0ZSBkeCh4UiwgeEMsIGQxKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGZsb2F0IGR5UiA9IGZsb2F0KGR5UkNvcm5lciArIHdSKSAvIFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIuMDtcXG5cXG4gICAgICAgICAgaWYgKGR5UiA8IDAuMCB8fCBkeVIgPj0gXCIgKyBjb252SW5mby5vdXRIZWlnaHQgKyBcIi4wIHx8IGZyYWN0KGR5UikgPiAwLjApIHtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBpbnQgaWR5UiA9IGludChkeVIpO1xcblxcbiAgICAgICAgICBpbnQgd1JQZXJtID0gXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIiAtIDEgLSB3UjtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGludCB3Q1Blcm0gPSBcIiArIGZpbHRlcldpZHRoICsgXCIgLSAxIC0gd0M7XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgZDIgPSAwOyBkMiA8IFwiICsgY29udkluZm8ub3V0Q2hhbm5lbHMgKyBcIjsgZDIrKykge1xcbiAgICAgICAgICAgICAgZmxvYXQgeFZhbHVlID0gZ2V0RHkoYmF0Y2gsIGlkeVIsIGlkeUMsIGQyKTtcXG4gICAgICAgICAgICAgIGZsb2F0IHdWYWx1ZSA9IGdldFcod1JQZXJtLCB3Q1Blcm0sIGQxLCBkMik7XFxuICAgICAgICAgICAgICBkb3RQcm9kICs9IHhWYWx1ZSAqIHdWYWx1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gQ29udjJERGVySW5wdXRQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuQ29udjJERGVySW5wdXRQcm9ncmFtID0gQ29udjJERGVySW5wdXRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29udjJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29udjJEUHJvZ3JhbShjb252SW5mbykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnLCAnVyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gY29udkluZm8ub3V0U2hhcGU7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBzdHJpZGVIZWlnaHQgPSBjb252SW5mby5zdHJpZGVIZWlnaHQ7XG4gICAgICAgIHZhciBzdHJpZGVXaWR0aCA9IGNvbnZJbmZvLnN0cmlkZVdpZHRoO1xuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIGlucHV0RGVwdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoY29udkluZm8uaW5DaGFubmVscyAvIDQpICogNDtcbiAgICAgICAgdmFyIGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID0gY29udkluZm8uaW5DaGFubmVscyAlIDQ7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHNbM107XFxuXFxuICAgICAgICBpdmVjMiB4UkNDb3JuZXIgPSBjb29yZHMueXogKiBzdHJpZGVzIC0gcGFkcztcXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIGQyKSB0byBnZXQgeSh5UiwgeUMsIGQyKS5cXG4gICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkLiA6ID0gYWNyb3NzIGFsbCB2YWx1ZXMgaW4gdGhhdCBheGlzLlxcbiAgICAgICAgZmxvYXQgZG90UHJvZCA9IDAuMDtcXG4gICAgICAgIGZvciAoaW50IHdSID0gMDsgd1IgPCBcIiArIGZpbHRlckhlaWdodCArIFwiOyB3UisrKSB7XFxuICAgICAgICAgIGludCB4UiA9IHhSQ29ybmVyICsgd1I7XFxuXFxuICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGZvciAoaW50IGQxID0gMDsgZDEgPCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiOyBkMSArPSA0KSB7XFxuICAgICAgICAgICAgICB2ZWM0IHhWYWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBkMSArIDEpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIGQxICsgMiksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgZDEgKyAzKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzQgd1ZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSwgZDIpLFxcbiAgICAgICAgICAgICAgICBnZXRXKHdSLCB3QywgZDEgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBkMSArIDIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIGQxICsgMywgZDIpXFxuICAgICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPVxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpICpcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKTtcXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGlucHV0RGVwdGhWZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICAgICAgICB2ZWMyIHhWYWx1ZXMgPSB2ZWMyKFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIpLFxcbiAgICAgICAgICAgICAgICBnZXRYKGJhdGNoLCB4UiwgeEMsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxKVxcbiAgICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICAgIHZlYzIgd1ZhbHVlcyA9IHZlYzIoXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcIiArIChpbnB1dERlcHRoVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgICAgICAgdmVjMyB4VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiKSxcXG4gICAgICAgICAgICAgICAgZ2V0WChiYXRjaCwgeFIsIHhDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMSksXFxuICAgICAgICAgICAgICAgIGdldFgoYmF0Y2gsIHhSLCB4QywgXCIgKyBpbnB1dERlcHRoTmVhcmVzdFZlYzQgKyBcIiArIDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgdmVjMyB3VmFsdWVzID0gdmVjMyhcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIsIGQyKSxcXG4gICAgICAgICAgICAgICAgZ2V0Vyh3Uiwgd0MsIFwiICsgaW5wdXREZXB0aE5lYXJlc3RWZWM0ICsgXCIgKyAxLCBkMiksXFxuICAgICAgICAgICAgICAgIGdldFcod1IsIHdDLCBcIiArIGlucHV0RGVwdGhOZWFyZXN0VmVjNCArIFwiICsgMiwgZDIpXFxuICAgICAgICAgICAgICApO1xcbiAgICAgICAgICAgICAgZG90UHJvZCArPSBkb3QoeFZhbHVlcywgd1ZhbHVlcyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoZG90UHJvZCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIENvbnYyRFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5Db252MkRQcm9ncmFtID0gQ29udjJEUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIERlcHRod2lzZUNvbnYyRFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlcHRod2lzZUNvbnYyRFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4JywgJ1cnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLm91dFNoYXBlO1xuICAgICAgICB2YXIgeE51bVJvd3MgPSBjb252SW5mby5pbkhlaWdodDtcbiAgICAgICAgdmFyIHhOdW1Db2xzID0gY29udkluZm8uaW5XaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGNvbnZJbmZvLnBhZEluZm8udG9wO1xuICAgICAgICB2YXIgcGFkTGVmdCA9IGNvbnZJbmZvLnBhZEluZm8ubGVmdDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgY2hhbm5lbE11bCA9IGNvbnZJbmZvLm91dENoYW5uZWxzIC8gY29udkluZm8uaW5DaGFubmVscztcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgY29uc3QgaXZlYzIgcGFkcyA9IGl2ZWMyKFwiICsgcGFkVG9wICsgXCIsIFwiICsgcGFkTGVmdCArIFwiKTtcXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkcy54O1xcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgZDIgPSBjb29yZHMudztcXG4gICAgICAgIGludCBkMSA9IGQyIC8gXCIgKyBjaGFubmVsTXVsICsgXCI7XFxuICAgICAgICBpbnQgcSA9IGQyIC0gZDEgKiBcIiArIGNoYW5uZWxNdWwgKyBcIjtcXG5cXG4gICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IHhDQ29ybmVyID0geFJDQ29ybmVyLnk7XFxuXFxuICAgICAgICAvLyBDb252b2x2ZSB4KD8sID8sIGQxKSB3aXRoIHcoOiwgOiwgZDEsIHEpIHRvIGdldCB5KHlSLCB5QywgZDIpLlxcbiAgICAgICAgLy8gPyA9IHRvIGJlIGRldGVybWluZWQuIDogPSBhY3Jvc3MgYWxsIHZhbHVlcyBpbiB0aGF0IGF4aXMuXFxuICAgICAgICBmbG9hdCBkb3RQcm9kID0gMC4wO1xcbiAgICAgICAgLy8gVE9ETyhkc21pbGtvdik6IEZsYXR0ZW4gdGhlIHR3byBmb3IgbG9vcHMgYW5kIHZlYzQgdGhlIG9wZXJhdGlvbnMuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgeE51bVJvd3MgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoICsgXCI7IHdDKyspIHtcXG4gICAgICAgICAgICBpbnQgeEMgPSB4Q0Nvcm5lciArIHdDO1xcblxcbiAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyB4TnVtQ29scyArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZmxvYXQgeFZhbCA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZDEpO1xcbiAgICAgICAgICAgIGZsb2F0IHdWYWwgPSBnZXRXKHdSLCB3QywgZDEsIHEpO1xcbiAgICAgICAgICAgIGRvdFByb2QgKz0geFZhbCAqIHdWYWw7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHNldE91dHB1dChkb3RQcm9kKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gRGVwdGh3aXNlQ29udjJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkRlcHRod2lzZUNvbnYyRFByb2dyYW0gPSBEZXB0aHdpc2VDb252MkRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRnJvbVBpeGVsc1Byb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEZyb21QaXhlbHNQcm9ncmFtKG91dHB1dFNoYXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnQSddO1xuICAgICAgICB2YXIgaGVpZ2h0ID0gb3V0cHV0U2hhcGVbMF0sIHdpZHRoID0gb3V0cHV0U2hhcGVbMV07XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzMgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgdGV4UiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCB0ZXhDID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGRlcHRoID0gY29vcmRzWzJdO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIoXCIgKyB3aWR0aCArIFwiLjAsIFwiICsgaGVpZ2h0ICsgXCIuMCk7XFxuXFxuICAgICAgICB2ZWM0IHZhbHVlcyA9IHRleHR1cmUyRChBLCB1dik7XFxuICAgICAgICBmbG9hdCB2YWx1ZTtcXG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLnI7XFxuICAgICAgICB9IGVsc2UgaWYgKGRlcHRoID09IDEpIHtcXG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZXMuZztcXG4gICAgICAgIH0gZWxzZSBpZiAoZGVwdGggPT0gMikge1xcbiAgICAgICAgICB2YWx1ZSA9IHZhbHVlcy5iO1xcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA9PSAzKSB7XFxuICAgICAgICAgIHZhbHVlID0gdmFsdWVzLmE7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRPdXRwdXQoZmxvb3IodmFsdWUgKiAyNTUuMCArIDAuNSkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBGcm9tUGl4ZWxzUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkZyb21QaXhlbHNQcm9ncmFtID0gRnJvbVBpeGVsc1Byb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBHYXRoZXJQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBHYXRoZXJQcm9ncmFtKGFTaGFwZSwgaW5kaWNlc0xlbmd0aCwgYXhpcykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnLCAnaW5kaWNlcyddO1xuICAgICAgICB2YXIgb3V0cHV0U2hhcGUgPSBhU2hhcGUuc2xpY2UoKTtcbiAgICAgICAgb3V0cHV0U2hhcGVbYXhpc10gPSBpbmRpY2VzTGVuZ3RoO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgICAgIHRoaXMucmFuayA9IG91dHB1dFNoYXBlLmxlbmd0aDtcbiAgICAgICAgdmFyIGR0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUodGhpcy5yYW5rKTtcbiAgICAgICAgdmFyIHNvdXJjZUNvb3JkcyA9IGdldFNvdXJjZUNvb3JkcyhhU2hhcGUsIGF4aXMpO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc291cmNlQ29vcmRzICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gR2F0aGVyUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkdhdGhlclByb2dyYW0gPSBHYXRoZXJQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSwgYXhpcykge1xuICAgIHZhciByYW5rID0gYVNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJHYXRoZXIgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcImludChnZXRJbmRpY2VzKHJlc1JDKSlcIjtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRDb29yZHMgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICB2YXIgc291cmNlQ29vcmRzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhU2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGkgPT09IGF4aXMpIHtcbiAgICAgICAgICAgIHNvdXJjZUNvb3Jkcy5wdXNoKFwiaW50KGdldEluZGljZXMoXCIgKyBjdXJyZW50Q29vcmRzW2ldICsgXCIpKVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNvdXJjZUNvb3Jkcy5wdXNoKFwiXCIgKyBjdXJyZW50Q29vcmRzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc291cmNlQ29vcmRzLmpvaW4oKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgZ3BncHVfdXRpbCA9IHJlcXVpcmUoXCIuL2dwZ3B1X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbnZhciBHUEdQVUNvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdQR1BVQ29udGV4dChnbCkge1xuICAgICAgICB0aGlzLm91dHB1dFRleHR1cmUgPSBudWxsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5maXJzdFByb2dyYW0gPSB0cnVlO1xuICAgICAgICBpZiAoZ2wgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nbCA9IGdwZ3B1X3V0aWwuY3JlYXRlV2ViR0xDb250ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnRleHR1cmVGbG9hdEV4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdPRVNfdGV4dHVyZV9mbG9hdCcpO1xuICAgICAgICAgICAgdGhpcy5jb2xvckJ1ZmZlckZsb2F0RXh0ZW5zaW9uID1cbiAgICAgICAgICAgICAgICB0aGlzLmdsLmdldEV4dGVuc2lvbignV0VCR0xfY29sb3JfYnVmZmVyX2Zsb2F0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbG9yQnVmZmVyRmxvYXRFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCAnRVhUX2NvbG9yX2J1ZmZlcl9mbG9hdCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24gPVxuICAgICAgICAgICAgd2ViZ2xfdXRpbC5nZXRFeHRlbnNpb25PclRocm93KHRoaXMuZ2wsICdXRUJHTF9sb3NlX2NvbnRleHQnKTtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfR0VUX0JVRkZFUl9TVUJfREFUQV9BU1lOQ19FWFRFTlNJT05fRU5BQkxFRCcpKSB7XG4gICAgICAgICAgICB0aGlzLmdldEJ1ZmZlclN1YkRhdGFBc3luY0V4dGVuc2lvbiA9XG4gICAgICAgICAgICAgICAgdGhpcy5nbC5nZXRFeHRlbnNpb24oJ1dFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IGdwZ3B1X3V0aWwuY3JlYXRlVmVydGV4QnVmZmVyKHRoaXMuZ2wpO1xuICAgICAgICB0aGlzLmluZGV4QnVmZmVyID0gZ3BncHVfdXRpbC5jcmVhdGVJbmRleEJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgdGhpcy5mcmFtZWJ1ZmZlciA9IHdlYmdsX3V0aWwuY3JlYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgfVxuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRGlzcG9zaW5nIGEgR1BHUFVDb250ZXh0IHRoYXQgc3RpbGwgaGFzIGEgYm91bmQgV2ViR0xQcm9ncmFtLicgK1xuICAgICAgICAgICAgICAgICcgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgcHJvZ3JhbSB3aXRoICcgK1xuICAgICAgICAgICAgICAgICdHUEdQVUNvbnRleHQuZGVsZXRlUHJvZ3JhbSBiZWZvcmUgZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNwb3NpbmcgYSBHUEdQVUNvbnRleHQgdGhhdCBzdGlsbCBoYXMgYSBib3VuZCBvdXRwdXQgbWF0cml4ICcgK1xuICAgICAgICAgICAgICAgICd0ZXh0dXJlLiAgVGhpcyBpcyBwcm9iYWJseSBhIHJlc291cmNlIGxlYWssIGRlbGV0ZSB0aGUgb3V0cHV0ICcgK1xuICAgICAgICAgICAgICAgICdtYXRyaXggdGV4dHVyZSB3aXRoIEdQR1BVQ29udGV4dC5kZWxldGVNYXRyaXhUZXh0dXJlIGJlZm9yZSAnICtcbiAgICAgICAgICAgICAgICAnZGlzcG9zaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5maW5pc2goKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRlbGV0ZUZyYW1lYnVmZmVyKF90aGlzLmZyYW1lYnVmZmVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kQnVmZmVyKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLnZlcnRleEJ1ZmZlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgbnVsbCk7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZGVsZXRlQnVmZmVyKF90aGlzLmluZGV4QnVmZmVyKTsgfSk7XG4gICAgICAgIHRoaXMubG9zZUNvbnRleHRFeHRlbnNpb24ubG9zZUNvbnRleHQoKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlZCA9IHRydWU7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmVuYWJsZUF1dG9tYXRpY0RlYnVnVmFsaWRhdGlvbiA9IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUgPSBlbmFibGVkO1xuICAgICAgICB3ZWJnbF91dGlsLmVuYWJsZURlYnVnV2ViR0xFcnJvckNoZWNraW5nKGVuYWJsZWQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHBpeGVscykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBncGdwdV91dGlsLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSh0aGlzLmdsLCB0ZXh0dXJlLCBwaXhlbHMpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSh0aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlTWF0cml4VGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLm91dHB1dFRleHR1cmUgPT09IHRleHR1cmUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5vdXRwdXRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRleHR1cmUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUudXBsb2FkTWF0cml4VG9UZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB2YXIgbnVtQ2hhbm5lbHMgPSAxO1xuICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC51cGxvYWRNYXRyaXhUb1RleHR1cmUodGhpcy5nbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4LCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zLCBtYXRyaXgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIGdwZ3B1X3V0aWwudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlKHRoaXMuZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmUgPSBmdW5jdGlvbiAodGV4dHVyZSwgcm93cywgY29sdW1ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZE1hdHJpeERyaXZlcih0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ3BncHVfdXRpbC5kb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlKF90aGlzLmdsLCByb3dzLCBjb2x1bW5zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RnJvbVRleHR1cmVBc3luYyA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGRvd25sb2FkIG1hdHJpeCBmcm9tIG91dHB1dCB0ZXh0dXJlIGFzeW5jaHJvbm91c2x5LCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIldFQkdMX2dldF9idWZmZXJfc3ViX2RhdGFfYXN5bmMgaXMgbm90IGVuYWJsZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJBc3luYyh0ZXh0dXJlLCBmdW5jdGlvbiAoKSB7IHJldHVybiBncGdwdV91dGlsLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyhfdGhpcy5nbCwgX3RoaXMuZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLCByb3dzLCBjb2x1bW5zKTsgfSldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeEZyb21SR0JBQ29sb3JUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkVGV4dHVyZSA9IGZ1bmN0aW9uICh0ZXh0dXJlLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyKHRleHR1cmUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdwZ3B1X3V0aWwuZG93bmxvYWRNYXRyaXhGcm9tUGFja2VkT3V0cHV0VGV4dHVyZShfdGhpcy5nbCwgcm93cywgY29sdW1ucyk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5jcmVhdGVQcm9ncmFtID0gZnVuY3Rpb24gKGZyYWdtZW50U2hhZGVyU291cmNlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHdlYmdsX3V0aWwuY3JlYXRlRnJhZ21lbnRTaGFkZXIoZ2wsIGZyYWdtZW50U2hhZGVyU291cmNlKTtcbiAgICAgICAgdmFyIHZlcnRleFNoYWRlciA9IGdwZ3B1X3V0aWwuY3JlYXRlVmVydGV4U2hhZGVyKGdsKTtcbiAgICAgICAgdmFyIHByb2dyYW0gPSB3ZWJnbF91dGlsLmNyZWF0ZVByb2dyYW0oZ2wpO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHZlcnRleFNoYWRlcik7IH0pO1xuICAgICAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIGZyYWdtZW50U2hhZGVyKTsgfSk7XG4gICAgICAgIHdlYmdsX3V0aWwubGlua1Byb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVByb2dyYW0oZ2wsIHByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpcnN0UHJvZ3JhbSkge1xuICAgICAgICAgICAgdGhpcy5maXJzdFByb2dyYW0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgICAgIGdwZ3B1X3V0aWwuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zKGdsLCB0aGlzLnByb2dyYW0sIHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVsZXRlUHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChwcm9ncmFtID09PSB0aGlzLnByb2dyYW0pIHtcbiAgICAgICAgICAgIHRoaXMucHJvZ3JhbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuc2V0UHJvZ3JhbSA9IGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIGlmICgodGhpcy5wcm9ncmFtICE9IG51bGwpICYmIHRoaXMuYXV0b0RlYnVnVmFsaWRhdGUpIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVQcm9ncmFtKHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFVuaWZvcm1Mb2NhdGlvbiA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSwgc2hvdWxkVGhyb3cpIHtcbiAgICAgICAgaWYgKHNob3VsZFRocm93ID09PSB2b2lkIDApIHsgc2hvdWxkVGhyb3cgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmIChzaG91bGRUaHJvdykge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3codGhpcy5nbCwgcHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHdlYmdsX3V0aWwuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbih0aGlzLmdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTG9jYXRpb24gPSBmdW5jdGlvbiAocHJvZ3JhbSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayh0aGlzLmdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5nbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBhdHRyaWJ1dGUpOyB9KTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyA9IGZ1bmN0aW9uIChwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdW5pZm9ybU5hbWUpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRJbnB1dE1hdHJpeFRleHR1cmUgPSBmdW5jdGlvbiAoaW5wdXRNYXRyaXhUZXh0dXJlLCB1bmlmb3JtTG9jYXRpb24sIHRleHR1cmVVbml0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB3ZWJnbF91dGlsLmJpbmRUZXh0dXJlVG9Qcm9ncmFtVW5pZm9ybVNhbXBsZXIodGhpcy5nbCwgdGhpcy5wcm9ncmFtLCBpbnB1dE1hdHJpeFRleHR1cmUsIHVuaWZvcm1Mb2NhdGlvbiwgdGV4dHVyZVVuaXQpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy5zZXRPdXRwdXRNYXRyaXhUZXh0dXJlRHJpdmVyKG91dHB1dE1hdHJpeFRleHR1cmUsIGNvbHVtbnMsIHJvd3MpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRQYWNrZWRNYXRyaXhUZXh0dXJlID0gZnVuY3Rpb24gKG91dHB1dFBhY2tlZE1hdHJpeFRleHR1cmUsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIob3V0cHV0UGFja2VkTWF0cml4VGV4dHVyZSwgd2lkdGgsIGhlaWdodCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aGlzLnNldE91dHB1dE1hdHJpeFdyaXRlUmVnaW9uRHJpdmVyKHN0YXJ0Q29sdW1uLCBzdGFydFJvdywgbnVtQ29sdW1ucywgbnVtUm93cyk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uID0gZnVuY3Rpb24gKHN0YXJ0Um93LCBudW1Sb3dzLCBzdGFydENvbHVtbiwgbnVtQ29sdW1ucykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldE91dHB1dFBhY2tlZE1hdHJpeFdyaXRlUmVnaW9uIG5vdCBpbXBsZW1lbnRlZC4nKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZGVidWdWYWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlUHJvZ3JhbSh0aGlzLmdsLCB0aGlzLnByb2dyYW0pO1xuICAgICAgICB9XG4gICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZXhlY3V0ZVByb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMudGhyb3dJZk5vUHJvZ3JhbSgpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmdsO1xuICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWJ1Z1ZhbGlkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRyYXdFbGVtZW50cyhnbC5UUklBTkdMRVMsIDYsIGdsLlVOU0lHTkVEX1NIT1JULCAwKTsgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmJsb2NrVW50aWxBbGxQcm9ncmFtc0NvbXBsZXRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2sodGhpcy5nbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZ2wuZmluaXNoKCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5kaXNqb2ludFF1ZXJ5VGltZXJFeHRlbnNpb24gPVxuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuZ2V0RXh0ZW5zaW9uT3JUaHJvdyh0aGlzLmdsLCBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0RJU0pPSU5UX1FVRVJZX1RJTUVSX0VYVEVOU0lPTl9WRVJTSU9OJykgPT09IDIgP1xuICAgICAgICAgICAgICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5X3dlYmdsMicgOlxuICAgICAgICAgICAgICAgICAgICAnRVhUX2Rpc2pvaW50X3RpbWVyX3F1ZXJ5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzam9pbnRRdWVyeVRpbWVyRXh0ZW5zaW9uO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uKCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb24oKTtcbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUucnVuUXVlcnkgPSBmdW5jdGlvbiAocXVlcnlGbikge1xuICAgICAgICB2YXIgcXVlcnkgPSB0aGlzLmJlZ2luUXVlcnkoKTtcbiAgICAgICAgcXVlcnlGbigpO1xuICAgICAgICB0aGlzLmVuZFF1ZXJ5KCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBvbGxRdWVyeVRpbWUocXVlcnkpO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5iZWdpblF1ZXJ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHRfMSA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMigpO1xuICAgICAgICAgICAgdmFyIHF1ZXJ5XzEgPSBnbDIuY3JlYXRlUXVlcnkoKTtcbiAgICAgICAgICAgIGdsMi5iZWdpblF1ZXJ5KGV4dF8xLlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5XzEpO1xuICAgICAgICAgICAgcmV0dXJuIHF1ZXJ5XzE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICB2YXIgcXVlcnkgPSBleHQuY3JlYXRlUXVlcnlFWFQoKTtcbiAgICAgICAgZXh0LmJlZ2luUXVlcnlFWFQoZXh0LlRJTUVfRUxBUFNFRF9FWFQsIHF1ZXJ5KTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5lbmRRdWVyeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRElTSk9JTlRfUVVFUllfVElNRVJfRVhURU5TSU9OX1ZFUlNJT04nKSA9PT0gMikge1xuICAgICAgICAgICAgdmFyIGdsMiA9IHRoaXMuZ2w7XG4gICAgICAgICAgICB2YXIgZXh0XzIgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtcbiAgICAgICAgICAgIGdsMi5lbmRRdWVyeShleHRfMi5USU1FX0VMQVBTRURfRVhUKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXh0ID0gdGhpcy5nZXRRdWVyeVRpbWVyRXh0ZW5zaW9uV2ViR0wxKCk7XG4gICAgICAgIGV4dC5lbmRRdWVyeUVYVChleHQuVElNRV9FTEFQU0VEX0VYVCk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmlzUXVlcnlBdmFpbGFibGUgPSBmdW5jdGlvbiAocXVlcnksIHF1ZXJ5VGltZXJWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeVRpbWVyVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDIoKTtcbiAgICAgICAgICAgIHZhciBhdmFpbGFibGUgPSBnbDIuZ2V0UXVlcnlQYXJhbWV0ZXIocXVlcnksIGdsMi5RVUVSWV9SRVNVTFRfQVZBSUxBQkxFKTtcbiAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2V0UXVlcnlUaW1lckV4dGVuc2lvbldlYkdMMSgpO1xuICAgICAgICAgICAgdmFyIGF2YWlsYWJsZSA9IGV4dC5nZXRRdWVyeU9iamVjdEVYVChxdWVyeSwgZXh0LlFVRVJZX1JFU1VMVF9BVkFJTEFCTEVfRVhUKTtcbiAgICAgICAgICAgIHZhciBkaXNqb2ludCA9IHRoaXMuZ2wuZ2V0UGFyYW1ldGVyKGV4dC5HUFVfRElTSk9JTlRfRVhUKTtcbiAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGUgJiYgIWRpc2pvaW50O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnBvbGxRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnkpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIHZhciByZXNvbHZlV2l0aFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdEaXNqb2ludCBxdWVyeSB0aW1lciBuZXZlciBhdmFpbGFibGUuJyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgtMSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHF1ZXJ5VGltZXJWZXJzaW9uID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9ESVNKT0lOVF9RVUVSWV9USU1FUl9FWFRFTlNJT05fVkVSU0lPTicpO1xuICAgICAgICAgICAgdXRpbC5yZXBlYXRlZFRyeShmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5pc1F1ZXJ5QXZhaWxhYmxlKHF1ZXJ5LCBxdWVyeVRpbWVyVmVyc2lvbik7IH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oZnVuY3Rpb24gKCkgeyByZXR1cm4gcmVzb2x2ZShfdGhpcy5nZXRRdWVyeVRpbWUocXVlcnksIHF1ZXJ5VGltZXJWZXJzaW9uKSk7IH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlc29sdmVXaXRoV2FybmluZyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5nZXRRdWVyeVRpbWUgPSBmdW5jdGlvbiAocXVlcnksIHF1ZXJ5VGltZXJWZXJzaW9uKSB7XG4gICAgICAgIGlmIChxdWVyeVRpbWVyVmVyc2lvbiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHF1ZXJ5VGltZXJWZXJzaW9uID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZ2wyID0gdGhpcy5nbDtcbiAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gZ2wyLmdldFF1ZXJ5UGFyYW1ldGVyKHF1ZXJ5LCBnbDIuUVVFUllfUkVTVUxUKTtcbiAgICAgICAgICAgIHJldHVybiB0aW1lRWxhcHNlZE5hbm9zIC8gMTAwMDAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBleHQgPSB0aGlzLmdldFF1ZXJ5VGltZXJFeHRlbnNpb25XZWJHTDEoKTtcbiAgICAgICAgICAgIHZhciB0aW1lRWxhcHNlZE5hbm9zID0gZXh0LmdldFF1ZXJ5T2JqZWN0RVhUKHF1ZXJ5LCBleHQuUVVFUllfUkVTVUxUX0VYVCk7XG4gICAgICAgICAgICByZXR1cm4gdGltZUVsYXBzZWROYW5vcyAvIDEwMDAwMDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCA9IGZ1bmN0aW9uICh0ZXh0dXJlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIodGhpcy5nbCwgdGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIodGhpcy5nbCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEdQR1BVQ29udGV4dC5wcm90b3R5cGUuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93biA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0VGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMub3V0cHV0VGV4dHVyZSwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICBpZiAodGhpcy5hdXRvRGVidWdWYWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwudmFsaWRhdGVGcmFtZWJ1ZmZlcih0aGlzLmdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlYmdsX3V0aWwudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyKHRoaXMuZ2wsIHRoaXMuZnJhbWVidWZmZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLmRvd25sb2FkTWF0cml4RHJpdmVyID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJTZXR1cCh0ZXh0dXJlKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGRvd25sb2FkQW5kRGVjb2RlKCk7XG4gICAgICAgIHRoaXMuZG93bmxvYWRNYXRyaXhEcml2ZXJUZWFyZG93bigpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5kb3dubG9hZE1hdHJpeERyaXZlckFzeW5jID0gZnVuY3Rpb24gKHRleHR1cmUsIGRvd25sb2FkQW5kRGVjb2RlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyU2V0dXAodGV4dHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGRvd25sb2FkQW5kRGVjb2RlKCldO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRvd25sb2FkTWF0cml4RHJpdmVyVGVhcmRvd24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgcmVzdWx0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnNldE91dHB1dE1hdHJpeFRleHR1cmVEcml2ZXIgPSBmdW5jdGlvbiAob3V0cHV0TWF0cml4VGV4dHVyZU1heWJlUGFja2VkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuZ2w7XG4gICAgICAgIHdlYmdsX3V0aWwuYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXIoZ2wsIG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZCwgdGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIGlmICh0aGlzLmF1dG9EZWJ1Z1ZhbGlkYXRlKSB7XG4gICAgICAgICAgICB3ZWJnbF91dGlsLnZhbGlkYXRlRnJhbWVidWZmZXIoZ2wpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0VGV4dHVyZSA9IG91dHB1dE1hdHJpeFRleHR1cmVNYXliZVBhY2tlZDtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIHdpZHRoLCBoZWlnaHQpOyB9KTtcbiAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNjaXNzb3IoMCwgMCwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS5zZXRPdXRwdXRNYXRyaXhXcml0ZVJlZ2lvbkRyaXZlciA9IGZ1bmN0aW9uICh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKHRoaXMuZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmdsLnNjaXNzb3IoeCwgeSwgd2lkdGgsIGhlaWdodCk7IH0pO1xuICAgIH07XG4gICAgR1BHUFVDb250ZXh0LnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0F0dGVtcHRlZCB0byB1c2UgZGlzcG9zZWQgR1BHUFVDb250ZXh0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBHUEdQVUNvbnRleHQucHJvdG90eXBlLnRocm93SWZOb1Byb2dyYW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBHUFUgcHJvZ3JhbSBpcyBjdXJyZW50bHkgc2V0LicpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gR1BHUFVDb250ZXh0O1xufSgpKTtcbmV4cG9ydHMuR1BHUFVDb250ZXh0ID0gR1BHUFVDb250ZXh0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uLy4uL3V0aWxcIik7XG52YXIgc2hhZGVyX2NvbXBpbGVyID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIE5BTl9VTklGT1JNX05BTUUgPSAnTmFOJztcbmZ1bmN0aW9uIHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSB7XG4gICAgcmV0dXJuICFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xufVxuZnVuY3Rpb24gY29tcGlsZVByb2dyYW0oZ3BncHUsIHByb2dyYW0sIGlucHV0cywgb3V0cHV0KSB7XG4gICAgdmFyIHVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIgaW5wdXRJbmZvcyA9IGlucHV0cy5tYXAoZnVuY3Rpb24gKGlucHV0LCBpKSB7XG4gICAgICAgIHZhciBzaGFwZUluZm8gPSB7XG4gICAgICAgICAgICBsb2dpY2FsU2hhcGU6IGlucHV0LnRlbnNvci5zaGFwZSxcbiAgICAgICAgICAgIHRleFNoYXBlOiBpbnB1dC50ZXhEYXRhLnRleFNoYXBlXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IG5hbWU6IHByb2dyYW0udmFyaWFibGVOYW1lc1tpXSwgc2hhcGVJbmZvOiBzaGFwZUluZm8gfTtcbiAgICB9KTtcbiAgICB2YXIgaW5TaGFwZUluZm9zID0gaW5wdXRJbmZvcy5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHguc2hhcGVJbmZvOyB9KTtcbiAgICB2YXIgb3V0U2hhcGVJbmZvID0ge1xuICAgICAgICBsb2dpY2FsU2hhcGU6IG91dHB1dC50ZW5zb3Iuc2hhcGUsXG4gICAgICAgIHRleFNoYXBlOiBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZVxuICAgIH07XG4gICAgdmFyIHNvdXJjZSA9IHNoYWRlcl9jb21waWxlci5tYWtlU2hhZGVyKGlucHV0SW5mb3MsIG91dFNoYXBlSW5mbywgdXNlckNvZGUsIHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpO1xuICAgIHZhciB3ZWJHTFByb2dyYW0gPSBncGdwdS5jcmVhdGVQcm9ncmFtKHNvdXJjZSk7XG4gICAgdmFyIHVuaWZvcm1Mb2NhdGlvbnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2dyYW0udmFyaWFibGVOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdW5pZm9ybU5hbWUgPSBwcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnNbdW5pZm9ybU5hbWVdID1cbiAgICAgICAgICAgIGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIHVuaWZvcm1OYW1lKTtcbiAgICB9XG4gICAgaWYgKHNob3VsZFVwbG9hZE5hTlVuaWZvcm0oKSkge1xuICAgICAgICB2YXIgdGhyb3dJZk5hTlVuaWZvcm1Jc05vdFVzZWQgPSBmYWxzZTtcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSA9IGdwZ3B1LmdldFVuaWZvcm1Mb2NhdGlvbih3ZWJHTFByb2dyYW0sIE5BTl9VTklGT1JNX05BTUUsIHRocm93SWZOYU5Vbmlmb3JtSXNOb3RVc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbTogcHJvZ3JhbSxcbiAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgIHdlYkdMUHJvZ3JhbTogd2ViR0xQcm9ncmFtLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zOiB1bmlmb3JtTG9jYXRpb25zLFxuICAgICAgICBncGdwdTogZ3BncHUsXG4gICAgICAgIGluU2hhcGVJbmZvczogaW5TaGFwZUluZm9zLFxuICAgICAgICBvdXRTaGFwZUluZm86IG91dFNoYXBlSW5mb1xuICAgIH07XG59XG5leHBvcnRzLmNvbXBpbGVQcm9ncmFtID0gY29tcGlsZVByb2dyYW07XG5mdW5jdGlvbiB2YWxpZGF0ZUJpbmFyeUFuZFByb2dyYW0oc2hhcGVJbmZvcywgaW5wdXRzKSB7XG4gICAgaWYgKHNoYXBlSW5mb3MubGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiQmluYXJ5IHdhcyBjb21waWxlZCB3aXRoIFwiICsgc2hhcGVJbmZvcy5sZW5ndGggKyBcIiBpbnB1dHMsIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJ3YXMgZXhlY3V0ZWQgd2l0aCBcIiArIGlucHV0cy5sZW5ndGggKyBcIiBpbnB1dHNcIikpO1xuICAgIH1cbiAgICBzaGFwZUluZm9zLmZvckVhY2goZnVuY3Rpb24gKHMsIGkpIHtcbiAgICAgICAgdmFyIHNoYXBlQSA9IHMubG9naWNhbFNoYXBlO1xuICAgICAgICB2YXIgdGV4U2hhcGVBID0gcy50ZXhTaGFwZTtcbiAgICAgICAgdmFyIHNoYXBlQiA9IGlucHV0c1tpXS50ZW5zb3Iuc2hhcGU7XG4gICAgICAgIHZhciB0ZXhTaGFwZUIgPSBpbnB1dHNbaV0udGV4RGF0YS50ZXhTaGFwZTtcbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKHNoYXBlQSwgc2hhcGVCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJCaW5hcnkgd2FzIGNvbXBpbGVkIHdpdGggZGlmZmVyZW50IHNoYXBlcyB0aGFuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ0aGUgY3VycmVudCBhcmdzLiBTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwodGV4U2hhcGVBLCB0ZXhTaGFwZUIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkJpbmFyeSB3YXMgY29tcGlsZWQgd2l0aCBkaWZmZXJlbnQgdGV4dHVyZSBzaGFwZXMgdGhhbiB0aGVcIiArXG4gICAgICAgICAgICAgICAgKFwiIGN1cnJlbnQgYXJncy4gU2hhcGUgXCIgKyB0ZXhTaGFwZUEgKyBcIiBhbmQgXCIgKyB0ZXhTaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gcnVuUHJvZ3JhbShiaW5hcnksIGlucHV0cywgb3V0cHV0LCBjdXN0b21TZXR1cCkge1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShiaW5hcnkuaW5TaGFwZUluZm9zLCBpbnB1dHMpO1xuICAgIHZhbGlkYXRlQmluYXJ5QW5kUHJvZ3JhbShbYmluYXJ5Lm91dFNoYXBlSW5mb10sIFtvdXRwdXRdKTtcbiAgICB2YXIgb3V0VGV4ID0gb3V0cHV0LnRleERhdGEudGV4dHVyZTtcbiAgICB2YXIgb3V0VGV4U2hhcGUgPSBvdXRwdXQudGV4RGF0YS50ZXhTaGFwZTtcbiAgICB2YXIgZ3BncHUgPSBiaW5hcnkuZ3BncHU7XG4gICAgZ3BncHUuc2V0T3V0cHV0TWF0cml4VGV4dHVyZShvdXRUZXgsIG91dFRleFNoYXBlWzBdLCBvdXRUZXhTaGFwZVsxXSk7XG4gICAgZ3BncHUuc2V0UHJvZ3JhbShiaW5hcnkud2ViR0xQcm9ncmFtKTtcbiAgICBpbnB1dHMuZm9yRWFjaChmdW5jdGlvbiAoaW5wdXQsIGkpIHtcbiAgICAgICAgdmFyIHRleCA9IGlucHV0LnRleERhdGEudGV4dHVyZTtcbiAgICAgICAgdmFyIHZhcmlhYmxlTmFtZSA9IGJpbmFyeS5wcm9ncmFtLnZhcmlhYmxlTmFtZXNbaV07XG4gICAgICAgIHZhciB2YXJpYWJsZVVuaWZvcm1Mb2NhdGlvbiA9IGJpbmFyeS51bmlmb3JtTG9jYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgIGdwZ3B1LnNldElucHV0TWF0cml4VGV4dHVyZSh0ZXgsIHZhcmlhYmxlVW5pZm9ybUxvY2F0aW9uLCBpKTtcbiAgICB9KTtcbiAgICBpZiAoc2hvdWxkVXBsb2FkTmFOVW5pZm9ybSgpKSB7XG4gICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xZihiaW5hcnkudW5pZm9ybUxvY2F0aW9uc1tOQU5fVU5JRk9STV9OQU1FXSwgTmFOKTtcbiAgICB9XG4gICAgaWYgKGN1c3RvbVNldHVwICE9IG51bGwpIHtcbiAgICAgICAgY3VzdG9tU2V0dXAoZ3BncHUsIGJpbmFyeS53ZWJHTFByb2dyYW0pO1xuICAgIH1cbiAgICBncGdwdS5leGVjdXRlUHJvZ3JhbSgpO1xufVxuZXhwb3J0cy5ydW5Qcm9ncmFtID0gcnVuUHJvZ3JhbTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXJLZXkocHJvZ3JhbSwgaW5wdXRzLCBvdXRwdXQpIHtcbiAgICB2YXIga2V5SW5wdXRzID0gJyc7XG4gICAgaW5wdXRzLmNvbmNhdChvdXRwdXQpLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAga2V5SW5wdXRzICs9IHgudGVuc29yLnNoYXBlICsgXCJfXCIgKyB4LnRleERhdGEudGV4U2hhcGU7XG4gICAgfSk7XG4gICAgdmFyIGtleVVzZXJDb2RlID0gcHJvZ3JhbS51c2VyQ29kZTtcbiAgICB2YXIga2V5QnJvYWRjYXN0ID0gKHByb2dyYW0uc3VwcG9ydHNCcm9hZGNhc3RpbmcgPT09IHRydWUpLnRvU3RyaW5nKCk7XG4gICAgdmFyIGtleSA9IHByb2dyYW0uY29uc3RydWN0b3IubmFtZTtcbiAgICBrZXkgKz0gJ18nICsga2V5QnJvYWRjYXN0ICsgJ18nICsga2V5SW5wdXRzICsgJ18nICsga2V5VXNlckNvZGU7XG4gICAgcmV0dXJuIGtleTtcbn1cbmV4cG9ydHMubWFrZVNoYWRlcktleSA9IG1ha2VTaGFkZXJLZXk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xudmFyIF9fZ2VuZXJhdG9yID0gKHRoaXMgJiYgdGhpcy5fX2dlbmVyYXRvcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcbiAgICB9XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciB3ZWJnbF91dGlsID0gcmVxdWlyZShcIi4vd2ViZ2xfdXRpbFwiKTtcbmZ1bmN0aW9uIGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWxwaGE6IGZhbHNlLFxuICAgICAgICBhbnRpYWxpYXM6IGZhbHNlLFxuICAgICAgICBwcmVtdWx0aXBsaWVkQWxwaGE6IGZhbHNlLFxuICAgICAgICBwcmVzZXJ2ZURyYXdpbmdCdWZmZXI6IGZhbHNlLFxuICAgICAgICBkZXB0aDogZmFsc2UsXG4gICAgICAgIHN0ZW5jaWw6IGZhbHNlLFxuICAgICAgICBmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiB0cnVlXG4gICAgfTtcbn1cbmV4cG9ydHMuZ2V0V2ViR0xDb250ZXh0QXR0cmlidXRlcyA9IGdldFdlYkdMQ29udGV4dEF0dHJpYnV0ZXM7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoY2FudmFzKSB7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBnZXRXZWJHTENvbnRleHRBdHRyaWJ1dGVzKCk7XG4gICAgdmFyIGdsO1xuICAgIGlmIChjYW52YXMgIT0gbnVsbCkge1xuICAgICAgICBnbCA9IHdlYmdsX3V0aWwuY3JlYXRlV2ViR0xSZW5kZXJpbmdDb250ZXh0RnJvbUNhbnZhcyhjYW52YXMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ2wgPSB3ZWJnbF91dGlsLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dChhdHRyaWJ1dGVzKTtcbiAgICB9XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuREVQVEhfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlNURU5DSUxfVEVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLkJMRU5EKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuRElUSEVSKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmRpc2FibGUoZ2wuUE9MWUdPTl9PRkZTRVRfRklMTCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5kaXNhYmxlKGdsLlNBTVBMRV9DT1ZFUkFHRSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5lbmFibGUoZ2wuU0NJU1NPUl9URVNUKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmVuYWJsZShnbC5DVUxMX0ZBQ0UpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY3VsbEZhY2UoZ2wuQkFDSyk7IH0pO1xuICAgIHJldHVybiBnbDtcbn1cbmV4cG9ydHMuY3JlYXRlV2ViR0xDb250ZXh0ID0gY3JlYXRlV2ViR0xDb250ZXh0O1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4U2hhZGVyKGdsKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlclNvdXJjZSA9IFwiXFxuICAgIHByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG4gICAgYXR0cmlidXRlIHZlYzMgY2xpcFNwYWNlUG9zO1xcbiAgICBhdHRyaWJ1dGUgdmVjMiB1djtcXG4gICAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcblxcbiAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgZ2xfUG9zaXRpb24gPSB2ZWM0KGNsaXBTcGFjZVBvcywgMSk7XFxuICAgICAgcmVzdWx0VVYgPSB1djtcXG4gICAgfVwiO1xuICAgIHJldHVybiB3ZWJnbF91dGlsLmNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKTtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4U2hhZGVyID0gY3JlYXRlVmVydGV4U2hhZGVyO1xuZnVuY3Rpb24gY3JlYXRlVmVydGV4QnVmZmVyKGdsKSB7XG4gICAgdmFyIHZlcnRleEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShbLTEsIDEsIDAsIDAsIDEsIC0xLCAtMSwgMCwgMCwgMCwgMSwgMSwgMCwgMSwgMSwgMSwgLTEsIDAsIDEsIDBdKTtcbiAgICByZXR1cm4gd2ViZ2xfdXRpbC5jcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIHZlcnRleEFycmF5KTtcbn1cbmV4cG9ydHMuY3JlYXRlVmVydGV4QnVmZmVyID0gY3JlYXRlVmVydGV4QnVmZmVyO1xuZnVuY3Rpb24gY3JlYXRlSW5kZXhCdWZmZXIoZ2wpIHtcbiAgICB2YXIgdHJpYW5nbGVWZXJ0ZXhJbmRpY2VzID0gbmV3IFVpbnQxNkFycmF5KFswLCAxLCAyLCAyLCAxLCAzXSk7XG4gICAgcmV0dXJuIHdlYmdsX3V0aWwuY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIHRyaWFuZ2xlVmVydGV4SW5kaWNlcyk7XG59XG5leHBvcnRzLmNyZWF0ZUluZGV4QnVmZmVyID0gY3JlYXRlSW5kZXhCdWZmZXI7XG5mdW5jdGlvbiBnZXRUZXh0dXJlSW50ZXJuYWxGb3JtYXQoZ2wsIG51bUNoYW5uZWxzKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiBnbC5SR0JBO1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSA0KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2wuUkdCQTMyRjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2wuUjMyRjtcbiAgICB9XG4gICAgcmV0dXJuIGdsLlJHQkE7XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscykge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuUkdCQTtcbiAgICB9XG4gICAgaWYgKGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfVkVSU0lPTicpID09PSAyKSB7XG4gICAgICAgIGlmIChudW1DaGFubmVscyA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIGdsLlJHQkE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsLlJFRDtcbiAgICB9XG4gICAgcmV0dXJuIGdsLlJHQkE7XG59XG5mdW5jdGlvbiBnZXRUZXh0dXJlVHlwZShnbCkge1xuICAgIGlmICghZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICByZXR1cm4gZ2wuVU5TSUdORURfQllURTtcbiAgICB9XG4gICAgcmV0dXJuIGdsLkZMT0FUO1xufVxuZnVuY3Rpb24gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpIHtcbiAgICB3ZWJnbF91dGlsLnZhbGlkYXRlVGV4dHVyZVNpemUoZ2wsIHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciB0ZXh0dXJlID0gd2ViZ2xfdXRpbC5jcmVhdGVUZXh0dXJlKGdsKTtcbiAgICB2YXIgdGV4MmQgPSBnbC5URVhUVVJFXzJEO1xuICAgIHZhciBpbnRlcm5hbEZvcm1hdCA9IGdldFRleHR1cmVJbnRlcm5hbEZvcm1hdChnbCwgbnVtQ2hhbm5lbHMpO1xuICAgIHZhciBmb3JtYXQgPSBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKHRleDJkLCB0ZXh0dXJlKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnRleFBhcmFtZXRlcmkodGV4MmQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhQYXJhbWV0ZXJpKHRleDJkLCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpOyB9KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudGV4SW1hZ2UyRCh0ZXgyZCwgMCwgaW50ZXJuYWxGb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCBudWxsKTsgfSk7XG4gICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU1hdHJpeFRleHR1cmUoZ2wsIHJvd3MsIGNvbHVtbnMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3aWR0aCA9IF9hWzBdLCBoZWlnaHQgPSBfYVsxXTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSAxO1xuICAgIHJldHVybiBjcmVhdGVBbmRDb25maWd1cmVUZXh0dXJlKGdsLCB3aWR0aCwgaGVpZ2h0LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLmNyZWF0ZU1hdHJpeFRleHR1cmUgPSBjcmVhdGVNYXRyaXhUZXh0dXJlO1xuZnVuY3Rpb24gY3JlYXRlQ29sb3JNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSwgd2lkdGggPSBfYVswXSwgaGVpZ2h0ID0gX2FbMV07XG4gICAgdmFyIG51bUNoYW5uZWxzID0gNDtcbiAgICByZXR1cm4gY3JlYXRlQW5kQ29uZmlndXJlVGV4dHVyZShnbCwgd2lkdGgsIGhlaWdodCwgbnVtQ2hhbm5lbHMpO1xufVxuZXhwb3J0cy5jcmVhdGVDb2xvck1hdHJpeFRleHR1cmUgPSBjcmVhdGVDb2xvck1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVQYWNrZWRNYXRyaXhUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHdpZHRoID0gX2FbMF0sIGhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBudW1DaGFubmVscyA9IDQ7XG4gICAgcmV0dXJuIGNyZWF0ZUFuZENvbmZpZ3VyZVRleHR1cmUoZ2wsIHdpZHRoLCBoZWlnaHQsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMuY3JlYXRlUGFja2VkTWF0cml4VGV4dHVyZSA9IGNyZWF0ZVBhY2tlZE1hdHJpeFRleHR1cmU7XG5mdW5jdGlvbiBiaW5kVmVydGV4UHJvZ3JhbUF0dHJpYnV0ZVN0cmVhbXMoZ2wsIHByb2dyYW0sIHZlcnRleEJ1ZmZlcikge1xuICAgIHZhciBwb3NPZmZzZXQgPSAwO1xuICAgIHZhciB1dk9mZnNldCA9IDMgKiA0O1xuICAgIHZhciBzdHJpZGUgPSAoMyAqIDQpICsgKDIgKiA0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHZlcnRleEJ1ZmZlcik7IH0pO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ2NsaXBTcGFjZVBvcycsIHZlcnRleEJ1ZmZlciwgMywgc3RyaWRlLCBwb3NPZmZzZXQpO1xuICAgIHdlYmdsX3V0aWwuYmluZFZlcnRleEJ1ZmZlclRvUHJvZ3JhbUF0dHJpYnV0ZShnbCwgcHJvZ3JhbSwgJ3V2JywgdmVydGV4QnVmZmVyLCAyLCBzdHJpZGUsIHV2T2Zmc2V0KTtcbn1cbmV4cG9ydHMuYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zID0gYmluZFZlcnRleFByb2dyYW1BdHRyaWJ1dGVTdHJlYW1zO1xuZnVuY3Rpb24gdXBsb2FkUGl4ZWxEYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCBwaXhlbHMpIHtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHBpeGVscyk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5leHBvcnRzLnVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZSA9IHVwbG9hZFBpeGVsRGF0YVRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHdpZHRoLCBoZWlnaHQsIGRhdGEsIG51bUNoYW5uZWxzKSB7XG4gICAgdmFyIHRleHR1cmVGb3JtYXQgPSBnZXRUZXh0dXJlRm9ybWF0KGdsLCBudW1DaGFubmVscyk7XG4gICAgd2ViZ2xfdXRpbC52YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIDAsIDAsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVGb3JtYXQsIGdldFRleHR1cmVUeXBlKGdsKSwgZGF0YSk7IH0pO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTsgfSk7XG59XG5mdW5jdGlvbiB1cGxvYWRNYXRyaXhUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCwgbnVtQ2hhbm5lbHMpIHtcbiAgICB2YXIgX2EgPSB0ZXhfdXRpbC5nZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICB2YXIgdW5wYWNrZWRBcnJheTtcbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSkge1xuICAgICAgICB2YXIgY2hhbm5lbHNQZXJUZXh0dXJlID0gbnVtQ2hhbm5lbHMgPT09IDEgPyB3ZWJnbF91dGlsLmdldENoYW5uZWxzUGVyVGV4dHVyZSgpIDogbnVtQ2hhbm5lbHM7XG4gICAgICAgIGlmIChjaGFubmVsc1BlclRleHR1cmUgPT09IDEpIHtcbiAgICAgICAgICAgIHVucGFja2VkQXJyYXkgPSBtYXRyaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1bnBhY2tlZEFycmF5ID1cbiAgICAgICAgICAgICAgICBuZXcgRmxvYXQzMkFycmF5KHRleF91dGlsLmdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemUobWF0cml4Lmxlbmd0aCwgY2hhbm5lbHNQZXJUZXh0dXJlKSk7XG4gICAgICAgICAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkobWF0cml4LCB1bnBhY2tlZEFycmF5LCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB1bnBhY2tlZEFycmF5ID0gdGV4X3V0aWwuZW5jb2RlRmxvYXRBcnJheShtYXRyaXgpO1xuICAgIH1cbiAgICB1cGxvYWREYXRhVG9UZXh0dXJlKGdsLCB0ZXh0dXJlLCB3LCBoLCB1bnBhY2tlZEFycmF5LCBudW1DaGFubmVscyk7XG59XG5leHBvcnRzLnVwbG9hZE1hdHJpeFRvVGV4dHVyZSA9IHVwbG9hZE1hdHJpeFRvVGV4dHVyZTtcbmZ1bmN0aW9uIHVwbG9hZE1hdHJpeFRvUGFja2VkVGV4dHVyZShnbCwgdGV4dHVyZSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB0ZXhfdXRpbC5lbmNvZGVNYXRyaXhUb1BhY2tlZFJHQkEobWF0cml4LCByb3dzLCBjb2x1bW5zLCBwYWNrZWRSR0JBKTtcbiAgICB2YXIgbnVtQ2hhbm5lbHMgPSA0O1xuICAgIHVwbG9hZERhdGFUb1RleHR1cmUoZ2wsIHRleHR1cmUsIHcsIGgsIHBhY2tlZFJHQkEsIG51bUNoYW5uZWxzKTtcbn1cbmV4cG9ydHMudXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlID0gdXBsb2FkTWF0cml4VG9QYWNrZWRUZXh0dXJlO1xuZnVuY3Rpb24gZ2V0RG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihyb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICB2YXIgaXNGbG9hdFRleHR1cmUgPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpO1xuICAgIHZhciBkb3dubG9hZFRhcmdldDtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgZG93bmxvYWRUYXJnZXQgPVxuICAgICAgICAgICAgbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKHJvd3MgKiBjb2x1bW5zLCBjaGFubmVsc1BlclRleHR1cmUpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRvd25sb2FkVGFyZ2V0ID0gbmV3IFVpbnQ4QXJyYXkocm93cyAqIGNvbHVtbnMgKiBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIH1cbiAgICByZXR1cm4gZG93bmxvYWRUYXJnZXQ7XG59XG5mdW5jdGlvbiBkZWNvZGVEb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKGRvd25sb2FkVGFyZ2V0LCByb3dzLCBjb2x1bW5zLCBjaGFubmVsc1BlclBpeGVsKSB7XG4gICAgdmFyIGlzRmxvYXRUZXh0dXJlID0gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKTtcbiAgICBpZiAoaXNGbG9hdFRleHR1cmUpIHtcbiAgICAgICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMpO1xuICAgICAgICB0ZXhfdXRpbC5kZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheShkb3dubG9hZFRhcmdldCwgbWF0cml4LCBjaGFubmVsc1BlclBpeGVsKTtcbiAgICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZXhfdXRpbC5kZWNvZGVUb0Zsb2F0QXJyYXkoZG93bmxvYWRUYXJnZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmVBc3luYyhnbCwgZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZ2wyLCBjaGFubmVsc1BlclBpeGVsLCBkb3dubG9hZFRhcmdldCwgYnVmZmVyU2l6ZUJ5dGVzLCBidWZmZXI7XG4gICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIGdsMiA9IGdsO1xuICAgICAgICAgICAgICAgICAgICBjaGFubmVsc1BlclBpeGVsID0gNDtcbiAgICAgICAgICAgICAgICAgICAgZG93bmxvYWRUYXJnZXQgPSBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJTaXplQnl0ZXMgPSBkb3dubG9hZFRhcmdldCBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSA/XG4gICAgICAgICAgICAgICAgICAgICAgICBkb3dubG9hZFRhcmdldC5sZW5ndGggKiA0IDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvd25sb2FkVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBnbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgd2ViZ2xfdXRpbC5jYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJ1ZmZlckRhdGEoZ2wyLlBJWEVMX1BBQ0tfQlVGRkVSLCBidWZmZXJTaXplQnl0ZXMsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2wyLnJlYWRQaXhlbHMoMCwgMCwgY29sdW1ucywgcm93cywgZ2wuUkdCQSwgZ2V0VGV4dHVyZVR5cGUoZ2wpLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgZ2V0QnVmZmVyU3ViRGF0YUFzeW5jRXh0ZW5zaW9uLmdldEJ1ZmZlclN1YkRhdGFBc3luYyhnbDIuUElYRUxfUEFDS19CVUZGRVIsIDAsIGRvd25sb2FkVGFyZ2V0KV07XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiwgZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jID0gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZUFzeW5jO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tT3V0cHV0VGV4dHVyZShnbCwgcm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IHRleF91dGlsLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBjaGFubmVsc1BlclBpeGVsID0gNDtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQgPSBnZXREb3dubG9hZFRhcmdldEFycmF5QnVmZmVyKHJvd3MsIGNvbHVtbnMsIGNoYW5uZWxzUGVyUGl4ZWwpO1xuICAgIHdlYmdsX3V0aWwuY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5yZWFkUGl4ZWxzKDAsIDAsIHcsIGgsIGdsLlJHQkEsIGdldFRleHR1cmVUeXBlKGdsKSwgZG93bmxvYWRUYXJnZXQpOyB9KTtcbiAgICByZXR1cm4gZGVjb2RlRG93bmxvYWRUYXJnZXRBcnJheUJ1ZmZlcihkb3dubG9hZFRhcmdldCwgcm93cywgY29sdW1ucywgY2hhbm5lbHNQZXJQaXhlbCk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbU91dHB1dFRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21PdXRwdXRUZXh0dXJlO1xuZnVuY3Rpb24gZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZShnbCwgcm93cywgY29sdW1ucywgY2hhbm5lbHMpIHtcbiAgICB2YXIgc2l6ZSA9IHJvd3MgKiBjb2x1bW5zICogNDtcbiAgICB2YXIgZG93bmxvYWRUYXJnZXQgPSBuZXcgVWludDhBcnJheShzaXplKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCBjb2x1bW5zLCByb3dzLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkb3dubG9hZFRhcmdldCk7IH0pO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheShzaXplKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRvd25sb2FkVGFyZ2V0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBhY2tlZFJHQkFbaV0gPSBkb3dubG9hZFRhcmdldFtpXTtcbiAgICB9XG4gICAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkocm93cyAqIGNvbHVtbnMgKiBjaGFubmVscyk7XG4gICAgdGV4X3V0aWwuZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXkocGFja2VkUkdCQSwgbWF0cml4LCBjaGFubmVscyk7XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMuZG93bmxvYWRNYXRyaXhGcm9tUkdCQUNvbG9yVGV4dHVyZSA9IGRvd25sb2FkTWF0cml4RnJvbVJHQkFDb2xvclRleHR1cmU7XG5mdW5jdGlvbiBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlKGdsLCByb3dzLCBjb2x1bW5zKSB7XG4gICAgdmFyIF9hID0gdGV4X3V0aWwuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHcgPSBfYVswXSwgaCA9IF9hWzFdO1xuICAgIHZhciBwYWNrZWRSR0JBID0gbmV3IEZsb2F0MzJBcnJheSh0ZXhfdXRpbC5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlKHJvd3MsIGNvbHVtbnMpKTtcbiAgICB3ZWJnbF91dGlsLmNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wucmVhZFBpeGVscygwLCAwLCB3LCBoLCBnbC5SR0JBLCBnZXRUZXh0dXJlVHlwZShnbCksIHBhY2tlZFJHQkEpOyB9KTtcbiAgICB2YXIgbWF0cml4ID0gbmV3IEZsb2F0MzJBcnJheShyb3dzICogY29sdW1ucyk7XG4gICAgcmV0dXJuIHRleF91dGlsLmRlY29kZU1hdHJpeEZyb21QYWNrZWRSR0JBKHBhY2tlZFJHQkEsIHJvd3MsIGNvbHVtbnMsIG1hdHJpeCk7XG59XG5leHBvcnRzLmRvd25sb2FkTWF0cml4RnJvbVBhY2tlZE91dHB1dFRleHR1cmUgPSBkb3dubG9hZE1hdHJpeEZyb21QYWNrZWRPdXRwdXRUZXh0dXJlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgV2hlcmVQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaGVyZVByb2dyYW0oY1JhbmssIHNoYXBlLCByYW5rKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnYycsICdhJywgJ2InXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHNoYXBlO1xuICAgICAgICB2YXIgY0Nvb3JkcztcbiAgICAgICAgdmFyIGFiQ29vcmRzO1xuICAgICAgICBpZiAocmFuayA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiV2hlcmUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gXCJyZXNSQ1wiO1xuICAgICAgICAgICAgY0Nvb3JkcyA9IFwicmVzUkNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgICAgICAgICB2YXIgY0Nvb3JkVmFycyA9IFtdO1xuICAgICAgICAgICAgdmFyIGFiQ29vcmRWYXJzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYWJDb29yZFZhcnMucHVzaChcIlwiICsgY3VycmVudENvb3Jkc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGkgPCBjUmFuaykge1xuICAgICAgICAgICAgICAgICAgICBjQ29vcmRWYXJzLnB1c2goXCJcIiArIGN1cnJlbnRDb29yZHNbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNDb29yZHMgPSBjQ29vcmRWYXJzLmpvaW4oKTtcbiAgICAgICAgICAgIGFiQ29vcmRzID0gYWJDb29yZFZhcnMuam9pbigpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIGR0eXBlICsgXCIgcmVzUkMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGZsb2F0IGNWYWwgPSBnZXRDKFwiICsgY0Nvb3JkcyArIFwiKTtcXG4gICAgICAgIGlmIChjVmFsID49IDEuMCkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0QShcIiArIGFiQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHNldE91dHB1dChnZXRCKFwiICsgYWJDb29yZHMgKyBcIikpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBXaGVyZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5XaGVyZVByb2dyYW0gPSBXaGVyZVByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBMUk5Qcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMUk5Qcm9ncmFtKHhTaGFwZSwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbikge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgcmFkID0gcmFkaXVzO1xuICAgICAgICB2YXIgbWF4VyA9IHhTaGFwZVsxXSAtIDE7XG4gICAgICAgIHZhciBtYXhIID0geFNoYXBlWzJdIC0gMTtcbiAgICAgICAgdmFyIG1heEQgPSB4U2hhcGVbM10gLSAxO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICB2YXIgcG93T3BlcmF0b3I7XG4gICAgICAgIHZhciBiYXNpcyA9IFwiZmxvYXQoXCIgKyBiaWFzICsgXCIpICsgZmxvYXQoXCIgKyBhbHBoYSArIFwiKSAqIHN1bVwiO1xuICAgICAgICBpZiAoYmV0YSA9PT0gMC41KSB7XG4gICAgICAgICAgICBwb3dPcGVyYXRvciA9IFwiaW52ZXJzZXNxcnQoXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJldGEgPT09IDEuMCkge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcIjEuMC8oXCIgKyBiYXNpcyArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG93T3BlcmF0b3IgPSBcImV4cChsb2coXCIgKyBiYXNpcyArIFwiKSAqIGZsb2F0KC1cIiArIGJldGEgKyBcIikpO1wiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub3JtUmVnaW9uID09PSAnd2l0aGluQ2hhbm5lbCcpIHtcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICAgIGludCByID0gY29vcmRzWzFdO1xcbiAgICAgICAgICBpbnQgYyA9IGNvb3Jkc1syXTtcXG4gICAgICAgICAgaW50IGQgPSBjb29yZHNbM107XFxuICAgICAgICAgIGZsb2F0IHggPSBnZXRYKGIsIHIsIGMsIGQpO1xcbiAgICAgICAgICBmbG9hdCBzdW0gPSAwLjA7XFxuICAgICAgICAgIGZvciAoaW50IHUgPSAtXCIgKyByYWQgKyBcIjsgdSA8PSBcIiArIHJhZCArIFwiOyB1KyspIHtcXG4gICAgICAgICAgICBmb3IgKGludCB2ID0gLVwiICsgcmFkICsgXCI7IHYgPD0gXCIgKyByYWQgKyBcIjsgdisrKSB7XFxuICAgICAgICAgICAgICBpbnQgaWR4ID0gciArIHU7XFxuICAgICAgICAgICAgICBpbnQgaWR5ID0gYyArIHY7XFxuICAgICAgICAgICAgICBpZiAoaWR4ID49IDAgJiYgaWR4IDw9IFwiICsgbWF4VyArIFwiICYmIGlkeSA+PSAwICYmIGlkeSA8PSBcIiArIG1heEggKyBcIikge1xcbiAgICAgICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCBpZHgsIGlkeSwgZCk7XFxuICAgICAgICAgICAgICAgIHN1bSArPSB6ICogejtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZmxvYXQgdmFsID0geCAqIFwiICsgcG93T3BlcmF0b3IgKyBcIjtcXG4gICAgICAgICAgc2V0T3V0cHV0KHZhbCk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICAgIGludCBiID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgciA9IGNvb3Jkc1sxXTtcXG4gICAgICAgICAgaW50IGMgPSBjb29yZHNbMl07XFxuICAgICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcbiAgICAgICAgICBmbG9hdCB4ID0gZ2V0WChiLCByLCBjLCBkKTtcXG4gICAgICAgICAgZmxvYXQgc3VtID0gMC4wO1xcbiAgICAgICAgICBmb3IgKGludCBqID0gLVwiICsgcmFkICsgXCI7IGogPD0gXCIgKyByYWQgKyBcIjsgaisrKSB7XFxuICAgICAgICAgICAgaW50IGlkeCA9IGQgKyBqO1xcbiAgICAgICAgICAgIGlmIChpZHggPj0gMCAmJiBpZHggPD0gIFwiICsgbWF4RCArIFwiKSB7XFxuICAgICAgICAgICAgICBmbG9hdCB6ID0gZ2V0WChiLCByLCBjLCBpZHgpO1xcbiAgICAgICAgICAgICAgc3VtICs9IHogKiB6O1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBmbG9hdCB2YWwgPSB4ICogXCIgKyBwb3dPcGVyYXRvciArIFwiO1xcbiAgICAgICAgICBzZXRPdXRwdXQodmFsKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gTFJOUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLkxSTlByb2dyYW0gPSBMUk5Qcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTWF4UG9vbDJEQmFja3Byb3BQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW0oY29udkluZm8pIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydkeScsICdtYXhQb3MnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IGNvbnZJbmZvLmluU2hhcGU7XG4gICAgICAgIHZhciBmaWx0ZXJIZWlnaHQgPSBjb252SW5mby5maWx0ZXJIZWlnaHQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aCA9IGNvbnZJbmZvLmZpbHRlcldpZHRoO1xuICAgICAgICB2YXIgc3RyaWRlSGVpZ2h0ID0gY29udkluZm8uc3RyaWRlSGVpZ2h0O1xuICAgICAgICB2YXIgc3RyaWRlV2lkdGggPSBjb252SW5mby5zdHJpZGVXaWR0aDtcbiAgICAgICAgdmFyIHBhZFRvcCA9IGZpbHRlckhlaWdodCAtIDEgLSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBmaWx0ZXJXaWR0aCAtIDEgLSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCAtIDE7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzQgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYiA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgZHlSQ0Nvcm5lciA9IGNvb3Jkcy55eiAtIHBhZHM7XFxuICAgICAgICBpbnQgZHlSQ29ybmVyID0gZHlSQ0Nvcm5lci54O1xcbiAgICAgICAgaW50IGR5Q0Nvcm5lciA9IGR5UkNDb3JuZXIueTtcXG5cXG4gICAgICAgIC8vIENvbnZvbHZlIGR5KD8sID8sIGQpIHdpdGggcG9zIG1hc2soOiwgOiwgZCkgdG8gZ2V0IGR4KHhSLCB4QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZC4gOiA9IGFjcm9zcyBhbGwgdmFsdWVzIGluIHRoYXQgYXhpcy5cXG4gICAgICAgIGZsb2F0IGRvdFByb2QgPSAwLjA7XFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBmbG9hdCBkeVIgPSBmbG9hdChkeVJDb3JuZXIgKyB3UikgLyBcIiArIHN0cmlkZUhlaWdodCArIFwiLjA7XFxuXFxuICAgICAgICAgIGlmIChkeVIgPCAwLjAgfHwgZHlSID49IFwiICsgY29udkluZm8ub3V0SGVpZ2h0ICsgXCIuMCB8fCBmcmFjdChkeVIpID4gMC4wKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaW50IGlkeVIgPSBpbnQoZHlSKTtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgIGZsb2F0IGR5QyA9IGZsb2F0KGR5Q0Nvcm5lciArIHdDKSAvIFwiICsgc3RyaWRlV2lkdGggKyBcIi4wO1xcblxcbiAgICAgICAgICAgIGlmIChkeUMgPCAwLjAgfHwgZHlDID49IFwiICsgY29udkluZm8ub3V0V2lkdGggKyBcIi4wIHx8XFxuICAgICAgICAgICAgICAgIGZyYWN0KGR5QykgPiAwLjApIHtcXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpbnQgaWR5QyA9IGludChkeUMpO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGR5VmFsdWUgPSBnZXREeShiLCBpZHlSLCBpZHlDLCBkKTtcXG4gICAgICAgICAgICBpbnQgbWF4UG9zVmFsdWUgPSBcIiArIGxhc3RJbmRleCArIFwiIC0gaW50KGdldE1heFBvcyhiLCBpZHlSLCBpZHlDLCBkKSk7XFxuXFxuICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHZhbHVlLCBjaGVjayBpdCBhZ2FpbnN0IHRoZSB2YWx1ZSBmcm9tIHRoZVxcbiAgICAgICAgICAgIC8vIHBvc2l0aW9uIG1hdHJpeC5cXG4gICAgICAgICAgICBpbnQgY3VyUG9zVmFsdWUgPSB3UiAqIFwiICsgZmlsdGVyV2lkdGggKyBcIiArIHdDO1xcbiAgICAgICAgICAgIGZsb2F0IG1hc2sgPSBmbG9hdChtYXhQb3NWYWx1ZSA9PSBjdXJQb3NWYWx1ZSA/IDEuMCA6IDAuMCk7XFxuXFxuICAgICAgICAgICAgZG90UHJvZCArPSBkeVZhbHVlICogbWFzaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KGRvdFByb2QpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5NYXhQb29sMkRCYWNrcHJvcFByb2dyYW0gPSBNYXhQb29sMkRCYWNrcHJvcFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNYXRNdWxQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXRNdWxQcm9ncmFtKGFTaGFwZSwgYlNoYXBlLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKSB7XG4gICAgICAgIGlmICh0cmFuc3Bvc2VBID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0cmFuc3Bvc2VCID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQiA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnbWF0cml4QScsICdtYXRyaXhCJ107XG4gICAgICAgIHZhciBvdXRlclNoYXBlQSA9IHRyYW5zcG9zZUEgPyBhU2hhcGVbMV0gOiBhU2hhcGVbMF07XG4gICAgICAgIHZhciBvdXRlclNoYXBlQiA9IHRyYW5zcG9zZUIgPyBiU2hhcGVbMF0gOiBiU2hhcGVbMV07XG4gICAgICAgIHZhciBzaGFyZWREaW0gPSB0cmFuc3Bvc2VBID8gYVNoYXBlWzBdIDogYVNoYXBlWzFdO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW291dGVyU2hhcGVBLCBvdXRlclNoYXBlQl07XG4gICAgICAgIHZhciBhU25pcHBldEZyb21PZmZzZXQgPSBmdW5jdGlvbiAodmVjNE9mZnNldCwgaW5kZXhWYXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc3Bvc2VBID8gaW5kZXhWYXIgKyBcIiArIFwiICsgdmVjNE9mZnNldCArIFwiLCBhUm93XCIgOlxuICAgICAgICAgICAgICAgIFwiYVJvdywgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgYlNuaXBwZXRGcm9tT2Zmc2V0ID0gZnVuY3Rpb24gKHZlYzRPZmZzZXQsIGluZGV4VmFyKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNwb3NlQiA/IFwiYkNvbCwgXCIgKyBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0IDpcbiAgICAgICAgICAgICAgICBpbmRleFZhciArIFwiICsgXCIgKyB2ZWM0T2Zmc2V0ICsgXCIsIGJDb2xcIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHNoYXJlZERpbU5lYXJlc3RWZWM0ID0gTWF0aC5mbG9vcihzaGFyZWREaW0gLyA0KSAqIDQ7XG4gICAgICAgIHZhciBzaGFyZWREaW1WZWM0UmVtYWluZGVyID0gc2hhcmVkRGltICUgNDtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiIGZsb2F0IGRvdEFSb3dCQ29sKGludCBhUm93LCBpbnQgYkNvbCkge1xcbiAgICAgIGZsb2F0IHJlc3VsdCA9IDAuMDtcXG4gICAgICBmb3IgKGludCBpID0gMDsgaSA8IFwiICsgc2hhcmVkRGltTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICB2ZWM0IGEgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWM0IGIgPSB2ZWM0KFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsICdpJykgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMSwgJ2knKSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCAnaScpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDMsICdpJykgKyBcIilcXG4gICAgICAgICk7XFxuXFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgcmVzdWx0ICs9IGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpICpcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIik7XFxuICAgICAgfSBlbHNlIGlmIChcIiArIChzaGFyZWREaW1WZWM0UmVtYWluZGVyID09PSAyKSArIFwiKSB7XFxuICAgICAgICB2ZWMyIGEgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICB2ZWMyIGIgPSB2ZWMyKFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDAsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgxLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH0gZWxzZSBpZiAoXCIgKyAoc2hhcmVkRGltVmVjNFJlbWFpbmRlciA9PT0gMykgKyBcIikge1xcbiAgICAgICAgdmVjMyBhID0gdmVjMyhcXG4gICAgICAgICAgZ2V0TWF0cml4QShcIiArIGFTbmlwcGV0RnJvbU9mZnNldCgwLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIiksXFxuICAgICAgICAgIGdldE1hdHJpeEEoXCIgKyBhU25pcHBldEZyb21PZmZzZXQoMSwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhBKFwiICsgYVNuaXBwZXRGcm9tT2Zmc2V0KDIsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKVxcbiAgICAgICAgKTtcXG4gICAgICAgIHZlYzMgYiA9IHZlYzMoXFxuICAgICAgICAgIGdldE1hdHJpeEIoXCIgKyBiU25pcHBldEZyb21PZmZzZXQoMCwgc2hhcmVkRGltTmVhcmVzdFZlYzQpICsgXCIpLFxcbiAgICAgICAgICBnZXRNYXRyaXhCKFwiICsgYlNuaXBwZXRGcm9tT2Zmc2V0KDEsIHNoYXJlZERpbU5lYXJlc3RWZWM0KSArIFwiKSxcXG4gICAgICAgICAgZ2V0TWF0cml4QihcIiArIGJTbmlwcGV0RnJvbU9mZnNldCgyLCBzaGFyZWREaW1OZWFyZXN0VmVjNCkgKyBcIilcXG4gICAgICAgICk7XFxuICAgICAgICByZXN1bHQgKz0gZG90KGEsIGIpO1xcbiAgICAgIH1cXG5cXG4gICAgICByZXR1cm4gcmVzdWx0O1xcbiAgICB9XFxuXFxuICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICBpdmVjMiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChkb3RBUm93QkNvbChyZXNSQy54LCByZXNSQy55KSk7XFxuICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBNYXRNdWxQcm9ncmFtO1xufSgpKTtcbmV4cG9ydHMuTWF0TXVsUHJvZ3JhbSA9IE1hdE11bFByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBNdWx0aW5vbWlhbFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE11bHRpbm9taWFsUHJvZ3JhbShiYXRjaFNpemUsIG51bU91dGNvbWVzLCBudW1TYW1wbGVzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsncHJvYnMnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bVNhbXBsZXNdO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB1bmlmb3JtIGZsb2F0IHNlZWQ7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuXFxuICAgICAgICBmbG9hdCByID0gcmFuZG9tKHNlZWQpO1xcbiAgICAgICAgZmxvYXQgY2RmID0gMC4wO1xcblxcbiAgICAgICAgZm9yIChpbnQgaSA9IDA7IGkgPCBcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCI7IGkrKykge1xcbiAgICAgICAgICBjZGYgKz0gZ2V0UHJvYnMoYmF0Y2gsIGkpO1xcblxcbiAgICAgICAgICBpZiAociA8IGNkZikge1xcbiAgICAgICAgICAgIHNldE91dHB1dChmbG9hdChpKSk7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBJZiBubyBvdGhlciBldmVudCBoYXBwZW5lZCwgbGFzdCBldmVudCBoYXBwZW5lZC5cXG4gICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIChudW1PdXRjb21lcyAtIDEpICsgXCIpKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBNdWx0aW5vbWlhbFByb2dyYW0ucHJvdG90eXBlLmdldEN1c3RvbVNldHVwRnVuYyA9IGZ1bmN0aW9uIChzZWVkKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZ3BncHUsIHdlYkdMUHJvZ3JhbSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnNlZWRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnNlZWRMb2MgPSBncGdwdS5nZXRVbmlmb3JtTG9jYXRpb24od2ViR0xQcm9ncmFtLCAnc2VlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ3BncHUuZ2wudW5pZm9ybTFmKF90aGlzLnNlZWRMb2MsIHNlZWQpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIE11bHRpbm9taWFsUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLk11bHRpbm9taWFsUHJvZ3JhbSA9IE11bHRpbm9taWFsUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE9uZUhvdFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9uZUhvdFByb2dyYW0obnVtSW5kaWNlcywgZGVwdGgsIG9uVmFsdWUsIG9mZlZhbHVlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnaW5kaWNlcyddO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW251bUluZGljZXMsIGRlcHRoXTtcbiAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgaW5kZXggPSByb3VuZChnZXRJbmRpY2VzKGNvb3Jkcy54KSk7XFxuICAgICAgICBzZXRPdXRwdXQobWl4KGZsb2F0KFwiICsgb2ZmVmFsdWUgKyBcIiksIGZsb2F0KFwiICsgb25WYWx1ZSArIFwiKSxcXG4gICAgICAgICAgICAgICAgICAgICAgZmxvYXQoaW5kZXggPT0gY29vcmRzLnkpKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIE9uZUhvdFByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5PbmVIb3RQcm9ncmFtID0gT25lSG90UHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFBhZFByb2dyYW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhZFByb2dyYW0oeFNoYXBlLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ3gnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCwgaSkgeyByZXR1cm4gcFswXSArIHhTaGFwZVtpXSArIHBbMV07IH0pO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIHZhciB0eXBlID0gc2hhZGVyX2NvbXBpbGVyXzEuZ2V0Q29vcmRzRGF0YVR5cGUocmFuayk7XG4gICAgICAgIHZhciBzdGFydCA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgZW5kID0gcGFkZGluZ3MubWFwKGZ1bmN0aW9uIChwLCBpKSB7IHJldHVybiBwWzBdICsgeFNoYXBlW2ldOyB9KS5qb2luKCcsJyk7XG4gICAgICAgIHZhciB1bnBhY2tlZENvb3JkcyA9IFsnY29vcmRzWzBdJywgJ2Nvb3Jkc1sxXScsICdjb29yZHNbMl0nLCAnY29vcmRzWzNdJ10uc2xpY2UoMCwgcmFuayk7XG4gICAgICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICAgIGludCBzdGFydCA9IFwiICsgc3RhcnQgKyBcIjtcXG4gICAgICAgIGludCBlbmQgPSBcIiArIGVuZCArIFwiO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpbnQgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBpZiAob3V0QyA8IHN0YXJ0IHx8IG91dEMgPj0gZW5kKSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGZsb2F0KFwiICsgY29uc3RhbnRWYWx1ZSArIFwiKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc2V0T3V0cHV0KGdldFgob3V0QyAtIHN0YXJ0KSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBcIiArIHR5cGUgKyBcIiBzdGFydCA9IFwiICsgdHlwZSArIFwiKFwiICsgc3RhcnQgKyBcIik7XFxuICAgICAgXCIgKyB0eXBlICsgXCIgZW5kID0gXCIgKyB0eXBlICsgXCIoXCIgKyBlbmQgKyBcIik7XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgXCIgKyB0eXBlICsgXCIgb3V0QyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaWYgKGFueShsZXNzVGhhbihvdXRDLCBzdGFydCkpIHx8IGFueShncmVhdGVyVGhhbkVxdWFsKG91dEMsIGVuZCkpKSB7XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChcIiArIGNvbnN0YW50VmFsdWUgKyBcIikpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgXCIgKyB0eXBlICsgXCIgY29vcmRzID0gb3V0QyAtIHN0YXJ0O1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHVucGFja2VkQ29vcmRzICsgXCIpKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUGFkUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBhZFByb2dyYW0gPSBQYWRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUG9vbDJEUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUG9vbDJEUHJvZ3JhbShjb252SW5mbywgcG9vbFR5cGUsIGNvbXB1dGVQb3NpdGlvbnMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWyd4J107XG4gICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ2F2ZycgJiYgY29tcHV0ZVBvc2l0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgY29tcHV0ZSBwb3NpdGlvbnMgZm9yIGF2ZXJhZ2UgcG9vbC4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVySGVpZ2h0ID0gY29udkluZm8uZmlsdGVySGVpZ2h0O1xuICAgICAgICB2YXIgZmlsdGVyV2lkdGggPSBjb252SW5mby5maWx0ZXJXaWR0aDtcbiAgICAgICAgdmFyIHN0cmlkZUhlaWdodCA9IGNvbnZJbmZvLnN0cmlkZUhlaWdodDtcbiAgICAgICAgdmFyIHN0cmlkZVdpZHRoID0gY29udkluZm8uc3RyaWRlV2lkdGg7XG4gICAgICAgIHZhciBwYWRUb3AgPSBjb252SW5mby5wYWRJbmZvLnRvcDtcbiAgICAgICAgdmFyIHBhZExlZnQgPSBjb252SW5mby5wYWRJbmZvLmxlZnQ7XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBjb252SW5mby5vdXRTaGFwZTtcbiAgICAgICAgdmFyIGlzQXZnUG9vbCA9IHBvb2xUeXBlID09PSAnYXZnJztcbiAgICAgICAgdmFyIGluaXRpYWxpemF0aW9uVmFsdWUgPSAnMC4wJztcbiAgICAgICAgaWYgKCFpc0F2Z1Bvb2wpIHtcbiAgICAgICAgICAgIGlmIChwb29sVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wdXRlUG9zaXRpb25zKSB7XG4gICAgICAgICAgICB2YXIgY29tcGFyZU9wXzEgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnPD0nIDogJz49JztcbiAgICAgICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgICAgY29uc3QgaXZlYzIgc3RyaWRlcyA9IGl2ZWMyKFwiICsgc3RyaWRlSGVpZ2h0ICsgXCIsIFwiICsgc3RyaWRlV2lkdGggKyBcIik7XFxuICAgICAgICBjb25zdCBpdmVjMiBwYWRzID0gaXZlYzIoXCIgKyBwYWRUb3AgKyBcIiwgXCIgKyBwYWRMZWZ0ICsgXCIpO1xcblxcbiAgICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgICAgaW50IGJhdGNoID0gY29vcmRzWzBdO1xcbiAgICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG5cXG4gICAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICAgIGludCB4UkNvcm5lciA9IHhSQ0Nvcm5lci54O1xcbiAgICAgICAgICBpbnQgeENDb3JuZXIgPSB4UkNDb3JuZXIueTtcXG5cXG4gICAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAgIC8vID8gPSB0byBiZSBkZXRlcm1pbmVkXFxuICAgICAgICAgIGZsb2F0IG1pbk1heFZhbHVlID0gMC4wO1xcbiAgICAgICAgICBmbG9hdCBtaW5NYXhWYWx1ZUZvdW5kID0gMC4wO1xcbiAgICAgICAgICBpbnQgbWluTWF4UG9zaXRpb24gPSAwO1xcbiAgICAgICAgICBmbG9hdCBhdmdWYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgICAgZm9yIChpbnQgd1IgPSAwOyB3UiA8IFwiICsgZmlsdGVySGVpZ2h0ICsgXCI7IHdSKyspIHtcXG4gICAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICAgIGlmICh4UiA8IDAgfHwgeFIgPj0gXCIgKyBjb252SW5mby5pbkhlaWdodCArIFwiKSB7XFxuICAgICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgZm9yIChpbnQgd0MgPSAwOyB3QyA8IFwiICsgZmlsdGVyV2lkdGggKyBcIjsgd0MrKykge1xcbiAgICAgICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyB3QztcXG5cXG4gICAgICAgICAgICAgIGlmICh4QyA8IDAgfHwgeEMgPj0gXCIgKyBjb252SW5mby5pbldpZHRoICsgXCIpIHtcXG4gICAgICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICBmbG9hdCB2YWx1ZSA9IGdldFgoYmF0Y2gsIHhSLCB4QywgZCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHNldE91dHB1dCh2YWx1ZSk7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICAgIC8vIElmIGEgbWluIC8gbWF4IHZhbHVlIGhhcyBhbHJlYWR5IGJlZW4gZm91bmQsIHVzZSBpdC4gSWYgbm90LFxcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHZhbHVlLlxcbiAgICAgICAgICAgICAgZmxvYXQgY3Vyck1pbk1heFZhbHVlID0gbWl4KFxcbiAgICAgICAgICAgICAgICAgIHZhbHVlLCBtaW5NYXhWYWx1ZSwgbWluTWF4VmFsdWVGb3VuZCk7XFxuICAgICAgICAgICAgICBpZiAodmFsdWUgXCIgKyBjb21wYXJlT3BfMSArIFwiIGN1cnJNaW5NYXhWYWx1ZSkge1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZSA9IHZhbHVlO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhWYWx1ZUZvdW5kID0gMS4wO1xcbiAgICAgICAgICAgICAgICBtaW5NYXhQb3NpdGlvbiA9IHdSICogXCIgKyBmaWx0ZXJXaWR0aCArIFwiICsgd0M7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNldE91dHB1dChmbG9hdChtaW5NYXhQb3NpdGlvbikpO1xcbiAgICAgICAgfVxcbiAgICAgIFwiO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSBwb29sVHlwZSA9PT0gJ21pbicgPyAnbWluJyA6ICdtYXgnO1xuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSBwb29sVHlwZSArIFwiKFwiICsgcG9vbFR5cGUgKyBcIihcIiArIHBvb2xUeXBlICsgXCIoXCIgK1xuICAgICAgICAgICAgJ21pbk1heFZhbHVlWzBdLCBtaW5NYXhWYWx1ZVsxXSksIG1pbk1heFZhbHVlWzJdKSwgbWluTWF4VmFsdWVbM10pJztcbiAgICAgICAgaWYgKHBvb2xUeXBlID09PSAnYXZnJykge1xuICAgICAgICAgICAgcmV0dXJuVmFsdWUgPSBcImF2Z1ZhbHVlIC8gXCIgKyBmaWx0ZXJIZWlnaHQgKiBmaWx0ZXJXaWR0aCArIFwiLjBcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyV2lkdGhOZWFyZXN0VmVjNCA9IE1hdGguZmxvb3IoZmlsdGVyV2lkdGggLyA0KSAqIDQ7XG4gICAgICAgIHZhciBmaWx0ZXJXaWR0aFZlYzRSZW1haW5kZXIgPSBmaWx0ZXJXaWR0aCAlIDQ7XG4gICAgICAgIHZhciB1cGRhdGVTbmlwcGV0ID0gXCJcXG4gICAgICBpZiAoaGFzTmFOKHZhbHVlcykpIHtcXG4gICAgICAgIHNldE91dHB1dChnZXROYU4odmFsdWVzKSk7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcbiAgICAgIGlmIChcIiArIGlzQXZnUG9vbCArIFwiKSB7XFxuICAgICAgICBhdmdWYWx1ZSArPSBkb3QodmFsdWVzLCBvbmVzKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbWluTWF4VmFsdWUgPSBcIiArIGNvbXBhcmVPcCArIFwiKHZhbHVlcywgbWluTWF4VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IGl2ZWMyIHN0cmlkZXMgPSBpdmVjMihcIiArIHN0cmlkZUhlaWdodCArIFwiLCBcIiArIHN0cmlkZVdpZHRoICsgXCIpO1xcbiAgICAgIGNvbnN0IGl2ZWMyIHBhZHMgPSBpdmVjMihcIiArIHBhZFRvcCArIFwiLCBcIiArIHBhZExlZnQgKyBcIik7XFxuICAgICAgY29uc3QgZmxvYXQgaW5pdGlhbGl6YXRpb25WYWx1ZSA9IFwiICsgaW5pdGlhbGl6YXRpb25WYWx1ZSArIFwiO1xcbiAgICAgIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgMS4wKTtcXG5cXG4gICAgICBmbG9hdCBnZXRWYWx1ZShpbnQgYmF0Y2gsIGludCB4UiwgaW50IHhDLCBpbnQgZCkge1xcbiAgICAgICAgaWYgKHhDIDwgMCB8fCB4QyA+PSBcIiArIGNvbnZJbmZvLmluV2lkdGggKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBnZXRYKGJhdGNoLCB4UiwgeEMsIGQpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBpdmVjNCBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIGludCBiYXRjaCA9IGNvb3Jkc1swXTtcXG4gICAgICAgIGludCBkID0gY29vcmRzWzNdO1xcblxcbiAgICAgICAgaXZlYzIgeFJDQ29ybmVyID0gY29vcmRzLnl6ICogc3RyaWRlcyAtIHBhZHM7XFxuICAgICAgICBpbnQgeFJDb3JuZXIgPSB4UkNDb3JuZXIueDtcXG4gICAgICAgIGludCB4Q0Nvcm5lciA9IHhSQ0Nvcm5lci55O1xcblxcbiAgICAgICAgLy8gbWF4L21pbiB4KD8sID8sIGQpIHRvIGdldCB5KHlSLCB5QywgZCkuXFxuICAgICAgICAvLyA/ID0gdG8gYmUgZGV0ZXJtaW5lZFxcbiAgICAgICAgdmVjNCBtaW5NYXhWYWx1ZSA9IHZlYzQoXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCIpO1xcbiAgICAgICAgZmxvYXQgYXZnVmFsdWUgPSAwLjA7XFxuXFxuICAgICAgICBmb3IgKGludCB3UiA9IDA7IHdSIDwgXCIgKyBmaWx0ZXJIZWlnaHQgKyBcIjsgd1IrKykge1xcbiAgICAgICAgICBpbnQgeFIgPSB4UkNvcm5lciArIHdSO1xcblxcbiAgICAgICAgICBpZiAoeFIgPCAwIHx8IHhSID49IFwiICsgY29udkluZm8uaW5IZWlnaHQgKyBcIikge1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGZvciAoaW50IHdDID0gMDsgd0MgPCBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjsgd0MgKz0gNCkge1xcbiAgICAgICAgICAgIGludCB4QyA9IHhDQ29ybmVyICsgd0M7XFxuXFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMywgZClcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaW50IHhDID0geENDb3JuZXIgKyBcIiArIGZpbHRlcldpZHRoTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgICAgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9IGVsc2UgaWYgKFwiICsgKGZpbHRlcldpZHRoVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICAgIHZlYzQgdmFsdWVzID0gdmVjNChcXG4gICAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCB4UiwgeEMsIGQpLFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QyArIDEsIGQpLFxcbiAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZSxcXG4gICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgICApO1xcblxcbiAgICAgICAgICAgIFwiICsgdXBkYXRlU25pcHBldCArIFwiXFxuICAgICAgICAgIH0gZWxzZSBpZiAoXCIgKyAoZmlsdGVyV2lkdGhWZWM0UmVtYWluZGVyID09PSAzKSArIFwiKSB7XFxuICAgICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIHhSLCB4QywgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMSwgZCksXFxuICAgICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgeFIsIHhDICsgMiwgZCksXFxuICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlXFxuICAgICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBzZXRPdXRwdXQoXCIgKyByZXR1cm5WYWx1ZSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gUG9vbDJEUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlBvb2wyRFByb2dyYW0gPSBQb29sMkRQcm9ncmFtO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUmVkdWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVkdWNlUHJvZ3JhbShyZWR1Y2VJbmZvLCByZWR1Y2VUeXBlKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgd2luZG93U2l6ZSA9IHJlZHVjZUluZm8ud2luZG93U2l6ZTtcbiAgICAgICAgdmFyIGJhdGNoU2l6ZSA9IHJlZHVjZUluZm8uYmF0Y2hTaXplO1xuICAgICAgICB2YXIgaW5TaXplID0gcmVkdWNlSW5mby5pblNpemU7XG4gICAgICAgIHZhciBvdXRTaXplID0gTWF0aC5jZWlsKGluU2l6ZSAvIHdpbmRvd1NpemUpO1xuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0U2l6ZV07XG4gICAgICAgIHZhciBpc1JlZHVjZVN1bSA9IHJlZHVjZVR5cGUgPT09ICdzdW0nO1xuICAgICAgICB2YXIgaW5pdGlhbGl6YXRpb25WYWx1ZSA9ICcwLjAnO1xuICAgICAgICBpZiAoIWlzUmVkdWNlU3VtKSB7XG4gICAgICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ21pbicpIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJzEuMCAvIDAuMCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlID0gJy0xLjAgLyAwLjAnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBjb21wYXJlT3AgPSByZWR1Y2VUeXBlID09PSAnbWluJyA/ICdtaW4nIDogJ21heCc7XG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArIHJlZHVjZVR5cGUgKyBcIihcIiArXG4gICAgICAgICAgICAnbWluTWF4VmFsdWVbMF0sIG1pbk1heFZhbHVlWzFdKSwgbWluTWF4VmFsdWVbMl0pLCBtaW5NYXhWYWx1ZVszXSknO1xuICAgICAgICBpZiAocmVkdWNlVHlwZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgICAgIHJldHVyblZhbHVlID0gXCJzdW1WYWx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciB3aW5kb3dTaXplTmVhcmVzdFZlYzQgPSBNYXRoLmZsb29yKHdpbmRvd1NpemUgLyA0KSAqIDQ7XG4gICAgICAgIHZhciB3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9IHdpbmRvd1NpemUgJSA0O1xuICAgICAgICB2YXIgdXBkYXRlU25pcHBldCA9IFwiXFxuICAgICAgaWYgKFwiICsgaXNSZWR1Y2VTdW0gKyBcIikge1xcbiAgICAgICAgc3VtVmFsdWUgKz0gZG90KHZhbHVlcywgb25lcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChoYXNOYU4odmFsdWVzKSkge1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0TmFOKHZhbHVlcykpO1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICBtaW5NYXhWYWx1ZSA9IFwiICsgY29tcGFyZU9wICsgXCIodmFsdWVzLCBtaW5NYXhWYWx1ZSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICAgICAgdmFyIGNoZWNrT3V0T2ZCb3VuZHMgPSAnJztcbiAgICAgICAgaWYgKGluU2l6ZSAlIHdpbmRvd1NpemUgPiAwKSB7XG4gICAgICAgICAgICBjaGVja091dE9mQm91bmRzID0gXCJcXG4gICAgICAgIGlmIChpbklkeCA8IDAgfHwgaW5JZHggPj0gXCIgKyBpblNpemUgKyBcIikge1xcbiAgICAgICAgICByZXR1cm4gaW5pdGlhbGl6YXRpb25WYWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICBjb25zdCBmbG9hdCBpbml0aWFsaXphdGlvblZhbHVlID0gXCIgKyBpbml0aWFsaXphdGlvblZhbHVlICsgXCI7XFxuICAgICAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAxLjApO1xcblxcbiAgICAgIGZsb2F0IGdldFZhbHVlKGludCBiYXRjaCwgaW50IGluSWR4KSB7XFxuICAgICAgICBcIiArIGNoZWNrT3V0T2ZCb3VuZHMgKyBcIlxcbiAgICAgICAgcmV0dXJuIGdldFgoYmF0Y2gsIGluSWR4KTtcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgaXZlYzIgY29vcmRzID0gZ2V0T3V0cHV0Q29vcmRzKCk7XFxuICAgICAgICBpbnQgYmF0Y2ggPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgb3V0SWR4ID0gY29vcmRzWzFdO1xcbiAgICAgICAgaW50IGluT2Zmc2V0ID0gb3V0SWR4ICogXCIgKyB3aW5kb3dTaXplICsgXCI7XFxuXFxuICAgICAgICB2ZWM0IG1pbk1heFZhbHVlID0gdmVjNChcIiArIGluaXRpYWxpemF0aW9uVmFsdWUgKyBcIik7XFxuICAgICAgICBmbG9hdCBzdW1WYWx1ZSA9IDAuMDtcXG5cXG4gICAgICAgIGZvciAoaW50IGkgPSAwOyBpIDwgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjsgaSArPSA0KSB7XFxuICAgICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgaTtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMylcXG4gICAgICAgICAgKTtcXG5cXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGludCBpbklkeCA9IGluT2Zmc2V0ICsgXCIgKyB3aW5kb3dTaXplTmVhcmVzdFZlYzQgKyBcIjtcXG4gICAgICAgIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMSkgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWUsXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfSBlbHNlIGlmIChcIiArICh3aW5kb3dTaXplVmVjNFJlbWFpbmRlciA9PT0gMikgKyBcIikge1xcbiAgICAgICAgICB2ZWM0IHZhbHVlcyA9IHZlYzQoXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4KSxcXG4gICAgICAgICAgICBnZXRWYWx1ZShiYXRjaCwgaW5JZHggKyAxKSxcXG4gICAgICAgICAgICBpbml0aWFsaXphdGlvblZhbHVlLFxcbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uVmFsdWVcXG4gICAgICAgICAgKTtcXG4gICAgICAgICAgXCIgKyB1cGRhdGVTbmlwcGV0ICsgXCJcXG4gICAgICAgIH0gZWxzZSBpZiAoXCIgKyAod2luZG93U2l6ZVZlYzRSZW1haW5kZXIgPT09IDMpICsgXCIpIHtcXG4gICAgICAgICAgdmVjNCB2YWx1ZXMgPSB2ZWM0KFxcbiAgICAgICAgICAgIGdldFZhbHVlKGJhdGNoLCBpbklkeCksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMSksXFxuICAgICAgICAgICAgZ2V0VmFsdWUoYmF0Y2gsIGluSWR4ICsgMiksXFxuICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25WYWx1ZVxcbiAgICAgICAgICApO1xcbiAgICAgICAgICBcIiArIHVwZGF0ZVNuaXBwZXQgKyBcIlxcbiAgICAgICAgfVxcbiAgICAgICAgc2V0T3V0cHV0KFwiICsgcmV0dXJuVmFsdWUgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFJlZHVjZVByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZWR1Y2VQcm9ncmFtID0gUmVkdWNlUHJvZ3JhbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFJlc2l6ZUJpbGluZWFyUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmVzaXplQmlsaW5lYXJQcm9ncmFtKGlucHV0U2hhcGUsIG5ld0hlaWdodCwgbmV3V2lkdGgsIGFsaWduQ29ybmVycykge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtdO1xuICAgICAgICB2YXIgYmF0Y2ggPSBpbnB1dFNoYXBlWzBdLCBvbGRIZWlnaHQgPSBpbnB1dFNoYXBlWzFdLCBvbGRXaWR0aCA9IGlucHV0U2hhcGVbMl0sIGRlcHRoID0gaW5wdXRTaGFwZVszXTtcbiAgICAgICAgdGhpcy5vdXRwdXRTaGFwZSA9IFtiYXRjaCwgbmV3SGVpZ2h0LCBuZXdXaWR0aCwgZGVwdGhdO1xuICAgICAgICB2YXIgZWZmZWN0aXZlSW5TaXplID0gYWxpZ25Db3JuZXJzID8gW29sZEhlaWdodCAtIDEsIG9sZFdpZHRoIC0gMV0gOiBbb2xkSGVpZ2h0LCBvbGRXaWR0aF07XG4gICAgICAgIHZhciBlZmZlY3RpdmVPdXRTaXplID0gYWxpZ25Db3JuZXJzID8gW25ld0hlaWdodCAtIDEsIG5ld1dpZHRoIC0gMV0gOiBbbmV3SGVpZ2h0LCBuZXdXaWR0aF07XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGNvbnN0IHZlYzIgZWZmZWN0aXZlSW5wdXRPdmVyT3V0cHV0UmF0aW9SQyA9IHZlYzIoXFxuICAgICAgICAgIFwiICsgZWZmZWN0aXZlSW5TaXplWzBdIC8gZWZmZWN0aXZlT3V0U2l6ZVswXSArIFwiLFxcbiAgICAgICAgICBcIiArIGVmZmVjdGl2ZUluU2l6ZVsxXSAvIGVmZmVjdGl2ZU91dFNpemVbMV0gKyBcIik7XFxuICAgICAgY29uc3QgdmVjMiBpbnB1dFNoYXBlUkMgPSB2ZWMyKFwiICsgb2xkSGVpZ2h0ICsgXCIuMCwgXCIgKyBvbGRXaWR0aCArIFwiLjApO1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIGl2ZWM0IGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgaW50IGIgPSBjb29yZHNbMF07XFxuICAgICAgICBpbnQgZCA9IGNvb3Jkc1szXTtcXG4gICAgICAgIGl2ZWMyIHlSQyA9IGNvb3Jkcy55ejtcXG5cXG4gICAgICAgIC8vIEZyYWN0aW9uYWwgc291cmNlIGluZGV4LlxcbiAgICAgICAgdmVjMiBzb3VyY2VGcmFjSW5kZXhSQyA9IHZlYzIoeVJDKSAqIGVmZmVjdGl2ZUlucHV0T3Zlck91dHB1dFJhdGlvUkM7XFxuXFxuICAgICAgICAvLyBDb21wdXRlIHRoZSBmb3VyIGludGVnZXIgaW5kaWNlcy5cXG4gICAgICAgIGl2ZWMyIHNvdXJjZUZsb29yUkMgPSBpdmVjMihzb3VyY2VGcmFjSW5kZXhSQyk7XFxuICAgICAgICBpdmVjMiBzb3VyY2VDZWlsUkMgPSBpdmVjMihcXG4gICAgICAgICAgbWluKGlucHV0U2hhcGVSQyAtIDEuMCwgY2VpbChzb3VyY2VGcmFjSW5kZXhSQykpKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcExlZnQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlRmxvb3JSQy55LCBkKTtcXG4gICAgICAgIGZsb2F0IGJvdHRvbUxlZnQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VGbG9vclJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgdG9wUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUZsb29yUkMueCwgc291cmNlQ2VpbFJDLnksIGQpO1xcbiAgICAgICAgZmxvYXQgYm90dG9tUmlnaHQgPSBnZXRBKGIsIHNvdXJjZUNlaWxSQy54LCBzb3VyY2VDZWlsUkMueSwgZCk7XFxuXFxuICAgICAgICB2ZWMyIGZyYWNSQyA9IHNvdXJjZUZyYWNJbmRleFJDIC0gdmVjMihzb3VyY2VGbG9vclJDKTtcXG5cXG4gICAgICAgIGZsb2F0IHRvcCA9IHRvcExlZnQgKyAodG9wUmlnaHQgLSB0b3BMZWZ0KSAqIGZyYWNSQy55O1xcbiAgICAgICAgZmxvYXQgYm90dG9tID0gYm90dG9tTGVmdCArIChib3R0b21SaWdodCAtIGJvdHRvbUxlZnQpICogZnJhY1JDLnk7XFxuICAgICAgICBmbG9hdCBuZXdWYWx1ZSA9IHRvcCArIChib3R0b20gLSB0b3ApICogZnJhY1JDLng7XFxuXFxuICAgICAgICBzZXRPdXRwdXQobmV3VmFsdWUpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXNpemVCaWxpbmVhclByb2dyYW07XG59KCkpO1xuZXhwb3J0cy5SZXNpemVCaWxpbmVhclByb2dyYW0gPSBSZXNpemVCaWxpbmVhclByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzaGFkZXJfY29tcGlsZXJfMSA9IHJlcXVpcmUoXCIuL3NoYWRlcl9jb21waWxlclwiKTtcbnZhciBSZXZlcnNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZVByb2dyYW0oeFNoYXBlLCBheGlzKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsneCddO1xuICAgICAgICB2YXIgcmFuayA9IHhTaGFwZS5sZW5ndGg7XG4gICAgICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2ViR0wgYmFja2VuZDogUmV2ZXJzZSBvZiByYW5rLVwiICsgcmFuayArIFwiIHRlbnNvciBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm91dHB1dFNoYXBlID0geFNoYXBlO1xuICAgICAgICBpZiAocmFuayA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy51c2VyQ29kZSA9IFwiXFxuICAgICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICAgIGludCBjb29yZCA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgICBzZXRPdXRwdXQoZ2V0WChcIiArIHhTaGFwZVswXSArIFwiIC0gY29vcmQgLSAxKSk7XFxuICAgICAgICB9XFxuICAgICAgXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGdldEluQ29vcmQgPSBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGF4aXMuaW5kZXhPZihpKSAhPT0gLTEgJiYgeFNoYXBlW2ldICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhTaGFwZVtpXSArIFwiIC0gY29vcmRzW1wiICsgaSArIFwiXSAtIDFcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcImNvb3Jkc1tcIiArIGkgKyBcIl1cIjtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGluQ29vcmRzID0geFNoYXBlLm1hcChmdW5jdGlvbiAoXywgaSkgeyByZXR1cm4gZ2V0SW5Db29yZChpKTsgfSkuam9pbignLCcpO1xuICAgICAgICB2YXIgdHlwZSA9IHNoYWRlcl9jb21waWxlcl8xLmdldENvb3Jkc0RhdGFUeXBlKHJhbmspO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgICB2b2lkIG1haW4oKSB7XFxuICAgICAgICBcIiArIHR5cGUgKyBcIiBjb29yZHMgPSBnZXRPdXRwdXRDb29yZHMoKTtcXG4gICAgICAgIHNldE91dHB1dChnZXRYKFwiICsgaW5Db29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBSZXZlcnNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlJldmVyc2VQcm9ncmFtID0gUmV2ZXJzZVByb2dyYW07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uLy4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi9vcHMvYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgdGV4X3V0aWwgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbmZ1bmN0aW9uIG1ha2VTaGFkZXIoaW5wdXRzSW5mbywgb3V0cHV0U2hhcGUsIHVzZXJDb2RlLCBicm9hZGNhc3QpIHtcbiAgICB2YXIgc2FtcGxlU25pcHBldCA9IGdldFNhbXBsZVNuaXBwZXQoKTtcbiAgICB2YXIgc2V0T3V0cHV0U25pcHBldCA9IGdldFNldE91dHB1dFNuaXBwZXQoKTtcbiAgICB2YXIgaW5wdXRQcmVmaXhTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIFwidW5pZm9ybSBzYW1wbGVyMkQgXCIgKyB4Lm5hbWUgKyBcIjtcIjsgfSkuam9pbignXFxuJyk7XG4gICAgdmFyIGlucHV0U2FtcGxpbmdTbmlwcGV0ID0gaW5wdXRzSW5mby5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIGdldElucHV0U2FtcGxpbmdTbmlwcGV0KHgsIG91dHB1dFNoYXBlLCBicm9hZGNhc3QpOyB9KVxuICAgICAgICAuam9pbignXFxuJyk7XG4gICAgdmFyIG91dFRleFNoYXBlID0gb3V0cHV0U2hhcGUudGV4U2hhcGU7XG4gICAgdmFyIG91dHB1dFNhbXBsaW5nU25pcHBldCA9IGdldE91dHB1dFNhbXBsaW5nU25pcHBldChvdXRwdXRTaGFwZS5sb2dpY2FsU2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICB2YXIgc291cmNlID0gW1xuICAgICAgICBTSEFERVJfUFJFRklYLCBzYW1wbGVTbmlwcGV0LCBzZXRPdXRwdXRTbmlwcGV0LCBpbnB1dFByZWZpeFNuaXBwZXQsXG4gICAgICAgIG91dHB1dFNhbXBsaW5nU25pcHBldCwgaW5wdXRTYW1wbGluZ1NuaXBwZXQsIHVzZXJDb2RlXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgICByZXR1cm4gc291cmNlO1xufVxuZXhwb3J0cy5tYWtlU2hhZGVyID0gbWFrZVNoYWRlcjtcbmZ1bmN0aW9uIGdldFNhbXBsZVNuaXBwZXQoKSB7XG4gICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmdldCgnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJykgP1xuICAgICAgICBGTE9BVF9URVhUVVJFX1NBTVBMRV9TTklQUEVUIDpcbiAgICAgICAgVU5TSUdORURfQllURV9URVhUVVJFX1NBTVBMRV9TTklQUEVUO1xufVxuZnVuY3Rpb24gZ2V0U2V0T3V0cHV0U25pcHBldCgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnKSA/XG4gICAgICAgIEZMT0FUX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQgOlxuICAgICAgICBVTlNJR05FRF9CWVRFX1RFWFRVUkVfU0VUT1VUUFVUX1NOSVBQRVQ7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyRnJvbUluSW5mbyhpbkluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbkluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICBzd2l0Y2ggKHNoYXBlLmxlbmd0aCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlclNjYWxhcihpbkluZm8pO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjFEKGluSW5mbyk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRTYW1wbGVyMkQoaW5JbmZvKTtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgcmV0dXJuIGdldFNhbXBsZXIzRChpbkluZm8pO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICByZXR1cm4gZ2V0U2FtcGxlcjREKGluSW5mbyk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc2hhcGUubGVuZ3RoICsgXCItRCBpbnB1dCBzYW1wbGluZ1wiICtcbiAgICAgICAgICAgICAgICBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRJbnB1dFNhbXBsaW5nU25pcHBldChpbkluZm8sIG91dFNoYXBlSW5mbywgYnJvYWRjYXN0KSB7XG4gICAgdmFyIHJlcyA9IGdldFNhbXBsZXJGbGF0KGluSW5mbyk7XG4gICAgcmVzICs9IGdldFNhbXBsZXJGcm9tSW5JbmZvKGluSW5mbyk7XG4gICAgaWYgKGJyb2FkY2FzdCB8fFxuICAgICAgICB1dGlsLmFycmF5c0VxdWFsKGluSW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKSkge1xuICAgICAgICByZXMgKz0gZ2V0U2FtcGxlckF0T3V0cHV0Q29vcmRzKGluSW5mbywgb3V0U2hhcGVJbmZvLCBicm9hZGNhc3QpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0U2FtcGxpbmdTbmlwcGV0KG91dFNoYXBlLCBvdXRUZXhTaGFwZSkge1xuICAgIHN3aXRjaCAob3V0U2hhcGUubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXRTY2FsYXJDb29yZHMoKTtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDFEQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBnZXRPdXRwdXQyRENvb3JkcyhvdXRTaGFwZSwgb3V0VGV4U2hhcGUpO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gZ2V0T3V0cHV0M0RDb29yZHMob3V0U2hhcGUsIG91dFRleFNoYXBlKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgcmV0dXJuIGdldE91dHB1dDREQ29vcmRzKG91dFNoYXBlLCBvdXRUZXhTaGFwZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Iob3V0U2hhcGUubGVuZ3RoICsgXCItRCBvdXRwdXQgc2FtcGxpbmcgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxufVxudmFyIFNBTVBMRV8xRF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTFEKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IGluZGV4KSB7XFxuICBpbnQgdGV4UiA9IGluZGV4IC8gdGV4TnVtQztcXG4gIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogdGV4TnVtQztcXG4gIHJldHVybiAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKHRleE51bUMsIHRleE51bVIpO1xcbn1cXG5cIjtcbnZhciBTQU1QTEVfMkRfU05JUFBFVCA9IFwiXFxudmVjMiBVVmZyb20yRChpbnQgdGV4TnVtUiwgaW50IHRleE51bUMsIGludCBudW1DLCBpbnQgcm93LCBpbnQgY29sKSB7XFxuICBpbnQgaW5kZXggPSByb3cgKiBudW1DICsgY29sO1xcbiAgaW50IHRleFIgPSBpbmRleCAvIHRleE51bUM7XFxuICBpbnQgdGV4QyA9IGluZGV4IC0gdGV4UiAqIHRleE51bUM7XFxuICByZXR1cm4gKHZlYzIodGV4QywgdGV4UikgKyBoYWxmQ1IpIC8gdmVjMih0ZXhOdW1DLCB0ZXhOdW1SKTtcXG59XFxuXCI7XG52YXIgU0FNUExFXzNEX1NOSVBQRVQgPSBcIlxcbnZlYzIgVVZmcm9tM0QoaW50IHRleE51bVIsIGludCB0ZXhOdW1DLCBpbnQgc3RyaWRlMCxcXG4gICAgaW50IHN0cmlkZTEsIGludCByb3csIGludCBjb2wsIGludCBkZXB0aCkge1xcbiAgLy8gRXhwbGljaXRseSB1c2UgaW50ZWdlciBvcGVyYXRpb25zIGFzIGRvdCgpIG9ubHkgd29ya3Mgb24gZmxvYXRzLlxcbiAgaW50IGluZGV4ID0gcm93ICogc3RyaWRlMCArIGNvbCAqIHN0cmlkZTEgKyBkZXB0aDtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFNBTVBMRV80RF9TTklQUEVUID0gXCJcXG52ZWMyIFVWZnJvbTREKGludCB0ZXhOdW1SLCBpbnQgdGV4TnVtQywgaW50IHN0cmlkZTAsXFxuICAgIGludCBzdHJpZGUxLCBpbnQgc3RyaWRlMiwgaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLFxcbiAgICBpbnQgZGVwdGgyKSB7XFxuICAvLyBFeHBsaWNpdGx5IHVzZSBpbnRlZ2VyIG9wZXJhdGlvbnMgYXMgZG90KCkgb25seSB3b3JrcyBvbiBmbG9hdHMuXFxuICBpbnQgaW5kZXggPSByb3cgKiBzdHJpZGUwICsgY29sICogc3RyaWRlMSArIGRlcHRoICogc3RyaWRlMiArIGRlcHRoMjtcXG4gIGludCB0ZXhSID0gaW5kZXggLyB0ZXhOdW1DO1xcbiAgaW50IHRleEMgPSBpbmRleCAtIHRleFIgKiB0ZXhOdW1DO1xcbiAgcmV0dXJuICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvIHZlYzIodGV4TnVtQywgdGV4TnVtUik7XFxufVxcblwiO1xudmFyIFVOU0lHTkVEX0JZVEVfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICB1bmlmb3JtIGZsb2F0IE5hTjtcXG5cXG4gIGNvbnN0IHZlYzQgZmxvYXREZWx0YXMgPSB2ZWM0KFxcbiAgICAgIDEuMCxcXG4gICAgICAxLjAgLyAyNTUuMCxcXG4gICAgICAxLjAgLyAoMjU1LjAgKiAyNTUuMCksXFxuICAgICAgMS4wIC8gKDI1NS4wICogMjU1LjAgKiAyNTUuMClcXG4gICk7XFxuICBjb25zdCBmbG9hdCBtaW5WYWx1ZSA9IFwiICsgdGV4X3V0aWwuRkxPQVRfTUlOICsgXCIuMDtcXG4gIGNvbnN0IGZsb2F0IG1heFZhbHVlID0gXCIgKyB0ZXhfdXRpbC5GTE9BVF9NQVggKyBcIi4wO1xcbiAgY29uc3QgZmxvYXQgcmFuZ2UgPSAobWF4VmFsdWUgLSBtaW5WYWx1ZSkgLyAyNTUuMDtcXG4gIGNvbnN0IHZlYzIgZG90UmFuZ2UgPSB2ZWMyKDEuMCwgcmFuZ2UpO1xcblxcbiAgZmxvYXQgc2FtcGxlKHNhbXBsZXIyRCB0ZXh0dXJlLCB2ZWMyIHV2KSB7XFxuICAgIHZlYzQgc2FtcGxlVmFsdWUgPSB0ZXh0dXJlMkQodGV4dHVyZSwgdXYpO1xcbiAgICBpZiAoYWxsKGVxdWFsKHNhbXBsZVZhbHVlLCB2ZWM0KFwiICsgdGV4X3V0aWwuQllURV9OQU5fVkFMVUUgKyBcIikpKSkge1xcbiAgICAgIHJldHVybiBOYU47XFxuICAgIH1cXG5cXG4gICAgdmVjNCBlbmNWYWx1ZSA9IGZsb29yKHNhbXBsZVZhbHVlICogMjU1LjAgKyAwLjUpO1xcbiAgICBmbG9hdCBkZWNvZGVkVmFsdWUgPSBkb3QoZW5jVmFsdWUsIGZsb2F0RGVsdGFzKTtcXG4gICAgcmV0dXJuIGRvdCh2ZWMyKG1pblZhbHVlLCBkZWNvZGVkVmFsdWUpLCBkb3RSYW5nZSk7XFxuICB9XFxuXCI7XG52YXIgVU5TSUdORURfQllURV9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIGNvbnN0IHZlYzQgZmxvYXRQb3dlcnMgPSB2ZWM0KFxcbiAgICAxLjAsXFxuICAgIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wLFxcbiAgICAyNTUuMCAqIDI1NS4wICogMjU1LjBcXG4gICk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UgPSB2ZWMyKDEuMC9yYW5nZSk7XFxuICBjb25zdCB2ZWMyIHJlY2lwUmFuZ2UyNTUgPSB2ZWMyKDEuMC8obWF4VmFsdWUgLSBtaW5WYWx1ZSkpO1xcblxcbiAgdm9pZCBzZXRPdXRwdXQoZmxvYXQgZGVjb2RlZFZhbHVlKSB7XFxuICAgIGlmIChpc05hTihkZWNvZGVkVmFsdWUpKSB7XFxuICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChcIiArIHRleF91dGlsLkJZVEVfTkFOX1ZBTFVFICsgXCIpO1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBmbG9hdCBhID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlKTtcXG4gICAgZmxvYXQgYiA9IGZyYWN0KGEpICogMjU1LjA7XFxuICAgIGZsb2F0IGMgPSBmcmFjdChiKSAqIDI1NS4wO1xcbiAgICBmbG9hdCBkID0gZnJhY3QoYykgKiAyNTUuMDtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gZmxvb3IodmVjNChhLCBiLCBjLCBkKSkgLyAyNTUuMDtcXG5cXG4gICAgLy8gVE9ETyhkc21pbGtvdik6IFZlcnNpb24gYWJvdmUgZ2V0cyBiZXR0ZXIgYWNjdXJhY3kgYnV0IHByb2JhYmx5IHNsb3dlclxcbiAgICAvLyB0aGFuIHRoZSB2ZXJzaW9uIGJlbG93LiBCZW5jaG1hcmsgdG8gZGV0ZXJtaW5lIGlmIHRoZSBhY2N1cmFjeSBpcyB3b3J0aFxcbiAgICAvLyB0aGUgY29zdC5cXG5cXG4gICAgLy8gZmxvYXQgbm9ybVZhbHVlID0gZG90KHZlYzIoZGVjb2RlZFZhbHVlLCAtbWluVmFsdWUpLCByZWNpcFJhbmdlMjU1KTtcXG4gICAgLy8gdmVjNCBmID0gbm9ybVZhbHVlICogZmxvYXRQb3dlcnM7XFxuICAgIC8vIGdsX0ZyYWdDb2xvciA9IGZsb29yKGZyYWN0KGYpICogMjU1LjApIC8gMjU1LjA7XFxuICB9XFxuXCI7XG52YXIgRkxPQVRfVEVYVFVSRV9TQU1QTEVfU05JUFBFVCA9IFwiXFxuICBmbG9hdCBzYW1wbGUoc2FtcGxlcjJEIHRleHR1cmUsIHZlYzIgdXYpIHtcXG4gICAgcmV0dXJuIHRleHR1cmUyRCh0ZXh0dXJlLCB1dikucjtcXG4gIH1cXG5cIjtcbnZhciBGTE9BVF9URVhUVVJFX1NFVE9VVFBVVF9TTklQUEVUID0gXCJcXG4gIHZvaWQgc2V0T3V0cHV0KGZsb2F0IHZhbCkge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2ZWM0KHZhbCwgMCwgMCwgMCk7XFxuICB9XFxuXCI7XG52YXIgU0hBREVSX1BSRUZJWCA9IFwiXFxuICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XFxuICBwcmVjaXNpb24gaGlnaHAgaW50O1xcbiAgdmFyeWluZyB2ZWMyIHJlc3VsdFVWO1xcbiAgY29uc3QgdmVjMiBoYWxmQ1IgPSB2ZWMyKDAuNSwgMC41KTtcXG5cXG4gIGJvb2wgaXNOYU4oZmxvYXQgdmFsKSB7XFxuICAgIGZsb2F0IHYxID0gdmFsICogdmFsO1xcbiAgICBmbG9hdCB2MiA9IHZhbCAqIHZhbDtcXG4gICAgcmV0dXJuIHYxID09IHYyID8gZmFsc2UgOiB0cnVlO1xcbiAgfVxcblxcbiAgYm9vbCBoYXNOYU4odmVjNCB2YWx1ZXMpIHtcXG4gICAgdmVjNCB2MSA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgdmVjNCB2MiA9IHZhbHVlcyAqIHZhbHVlcztcXG4gICAgcmV0dXJuIGFueShub3RFcXVhbCh2MSwgdjIpKTtcXG4gIH1cXG5cXG4gIGZsb2F0IGdldE5hTih2ZWM0IHZhbHVlcykge1xcbiAgICByZXR1cm4gZG90KHZlYzQoMSksIHZhbHVlcyk7XFxuICB9XFxuXFxuICBpbnQgcm91bmQoZmxvYXQgdmFsdWUpIHtcXG4gICAgcmV0dXJuIGludChmbG9vcih2YWx1ZSArIDAuNSkpO1xcbiAgfVxcblxcbiAgaW50IGltb2QoaW50IHgsIGludCB5KSB7XFxuICAgIHJldHVybiB4IC0geSAqICh4IC8geSk7XFxuICB9XFxuXFxuICBjb25zdCB2ZWMyIHJhbmRvbUNvbnN0ID0gdmVjMihcXG4gICAgMjMuMTQwNjkyNjMyNzc5MjYsIC8vIGVecGkgKEdlbGZvbmQncyBjb25zdGFudClcXG4gICAgIDIuNjY1MTQ0MTQyNjkwMjI1IC8vIDJec3FydCgyKSAoR2VsZm9uZFxcdTIwMTNTY2huZWlkZXIgY29uc3RhbnQpXFxuICApO1xcblxcbiAgZmxvYXQgcmFuZG9tKGZsb2F0IHNlZWQpIHtcXG4gICAgICByZXR1cm4gZnJhY3QoY29zKGRvdChyZXN1bHRVViAqIHNlZWQsIHJhbmRvbUNvbnN0KSkgKiAxMjM0NS42Nzg5KTtcXG4gIH1cXG5cXG4gIFwiICsgU0FNUExFXzFEX1NOSVBQRVQgKyBcIlxcbiAgXCIgKyBTQU1QTEVfMkRfU05JUFBFVCArIFwiXFxuICBcIiArIFNBTVBMRV8zRF9TTklQUEVUICsgXCJcXG4gIFwiICsgU0FNUExFXzREX1NOSVBQRVQgKyBcIlxcblwiO1xuZnVuY3Rpb24gZ2V0T3V0cHV0U2NhbGFyQ29vcmRzKCkge1xuICAgIHJldHVybiBcIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIHJldHVybiAwO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDFEQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIGlmICh0ZXhTaGFwZVswXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhTaGFwZVsxXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgICAgcmV0dXJuIGludChyZXN1bHRVVi55ICogXCIgKyB0ZXhTaGFwZVswXSArIFwiLjApO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICBpbnQgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIHJldHVybiByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRPdXRwdXQzRENvb3JkcyhzaGFwZSwgdGV4U2hhcGUpIHtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXTtcbiAgICByZXR1cm4gXCJcXG4gICAgaXZlYzMgZ2V0T3V0cHV0Q29vcmRzKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleFNoYXBlWzBdICsgXCIsIFwiICsgdGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIHRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIGludCByID0gaW5kZXggLyBcIiArIHN0cmlkZTAgKyBcIjtcXG4gICAgICBpbmRleCAtPSByICogXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW50IGMgPSBpbmRleCAvIFwiICsgc3RyaWRlMSArIFwiO1xcbiAgICAgIGludCBkID0gaW5kZXggLSBjICogXCIgKyBzdHJpZGUxICsgXCI7XFxuICAgICAgcmV0dXJuIGl2ZWMzKHIsIGMsIGQpO1xcbiAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldE91dHB1dDREQ29vcmRzKHNoYXBlLCB0ZXhTaGFwZSkge1xuICAgIHZhciBzdHJpZGUyID0gc2hhcGVbM107XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXSAqIHN0cmlkZTI7XG4gICAgdmFyIHN0cmlkZTAgPSBzaGFwZVsxXSAqIHN0cmlkZTE7XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWM0IGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG5cXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzdHJpZGUwICsgXCI7XFxuICAgICAgaW5kZXggLT0gciAqIFwiICsgc3RyaWRlMCArIFwiO1xcblxcbiAgICAgIGludCBjID0gaW5kZXggLyBcIiArIHN0cmlkZTEgKyBcIjtcXG4gICAgICBpbmRleCAtPSBjICogXCIgKyBzdHJpZGUxICsgXCI7XFxuXFxuICAgICAgaW50IGQgPSBpbmRleCAvIFwiICsgc3RyaWRlMiArIFwiO1xcbiAgICAgIGludCBkMiA9IGluZGV4IC0gZCAqIFwiICsgc3RyaWRlMiArIFwiO1xcblxcbiAgICAgIHJldHVybiBpdmVjNChyLCBjLCBkLCBkMik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0T3V0cHV0MkRDb29yZHMoc2hhcGUsIHRleFNoYXBlKSB7XG4gICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHRleFNoYXBlKSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICBpdmVjMiBnZXRPdXRwdXRDb29yZHMoKSB7XFxuICAgICAgICByZXR1cm4gaXZlYzIocmVzdWx0VVYueXggKiB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMihpbmRleCwgMCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHNoYXBlWzBdID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4U2hhcGVbMF0gKyBcIiwgXCIgKyB0ZXhTaGFwZVsxXSArIFwiKSk7XFxuICAgICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICAgIHJldHVybiBpdmVjMigwLCBpbmRleCk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGl2ZWMyIGdldE91dHB1dENvb3JkcygpIHtcXG4gICAgICBpdmVjMiByZXNUZXhSQyA9IGl2ZWMyKHJlc3VsdFVWLnl4ICpcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhTaGFwZVswXSArIFwiLCBcIiArIHRleFNoYXBlWzFdICsgXCIpKTtcXG4gICAgICBpbnQgaW5kZXggPSByZXNUZXhSQy54ICogXCIgKyB0ZXhTaGFwZVsxXSArIFwiICsgcmVzVGV4UkMueTtcXG4gICAgICBpbnQgciA9IGluZGV4IC8gXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCBjID0gaW5kZXggLSByICogXCIgKyBzaGFwZVsxXSArIFwiO1xcbiAgICAgIHJldHVybiBpdmVjMihyLCBjKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyU2NhbGFyKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjFEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCBpbmRleCkge1xcbiAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCJGbGF0KGluZGV4KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyMkQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleFNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICB2YXIgdGV4TmFtZSA9IGlucHV0SW5mby5uYW1lO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIHRleE51bVIgPSB0ZXhTaGFwZVswXTtcbiAgICB2YXIgdGV4TnVtQyA9IHRleFNoYXBlWzFdO1xuICAgIGlmICh1dGlsLmFycmF5c0VxdWFsKHNoYXBlLCB0ZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sKSB7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKGNvbCwgcm93KSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHZhciBfYSA9IHV0aWwuc3F1ZWV6ZVNoYXBlKHNoYXBlKSwgbmV3U2hhcGUgPSBfYS5uZXdTaGFwZSwga2VwdERpbXMgPSBfYS5rZXB0RGltcztcbiAgICB2YXIgc3F1ZWV6ZWRTaGFwZSA9IG5ld1NoYXBlO1xuICAgIGlmIChzcXVlZXplZFNoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIHNxdWVlemVkU2hhcGUpO1xuICAgICAgICB2YXIgcGFyYW1zID0gWydyb3cnLCAnY29sJ107XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICBpZiAodGV4TnVtQyA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wpIHtcXG4gICAgICBpbnQgaW5kZXggPSByb3cgKiBcIiArIHNoYXBlWzFdICsgXCIgKyBjb2w7XFxuICAgICAgdmVjMiB1diA9IHZlYzIoMC41LCAoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICAgIGludCBpbmRleCA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICB2ZWMyIHV2ID0gdmVjMigoZmxvYXQoaW5kZXgpICsgMC41KSAvIFwiICsgdGV4TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICB9XFxuICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCkge1xcbiAgICB2ZWMyIHV2ID0gVVZmcm9tMkQoXCIgKyB0ZXhOdW1SICsgXCIsIFwiICsgdGV4TnVtQyArIFwiLCBcIiArIHNoYXBlWzFdICsgXCIsIHJvdywgY29sKTtcXG4gICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgfVxcblwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlcjNEKGlucHV0SW5mbykge1xuICAgIHZhciB0ZXhTaGFwZSA9IGlucHV0SW5mby5zaGFwZUluZm8udGV4U2hhcGU7XG4gICAgdmFyIHNoYXBlID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGU7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgZnVuY05hbWUgPSAnZ2V0JyArIHRleE5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB0ZXhOYW1lLnNsaWNlKDEpO1xuICAgIHZhciB0ZXhOdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHRleE51bUMgPSB0ZXhTaGFwZVsxXTtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc2hhcGVbMl07XG4gICAgdmFyIHN0cmlkZTEgPSBzaGFwZVsyXTtcbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgdmFyIHNxdWVlemVkU2hhcGUgPSBuZXdTaGFwZTtcbiAgICBpZiAoc3F1ZWV6ZWRTaGFwZS5sZW5ndGggPCBzaGFwZS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIG5ld0lucHV0SW5mbyA9IHNxdWVlemVJbnB1dEluZm8oaW5wdXRJbmZvLCBzcXVlZXplZFNoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCddO1xuICAgICAgICByZXR1cm4gXCJcXG4gICAgICAgIFwiICsgZ2V0U2FtcGxlckZyb21JbkluZm8obmV3SW5wdXRJbmZvKSArIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIHJldHVybiBcIiArIGZ1bmNOYW1lICsgXCIoXCIgKyBnZXRTcXVlZXplZFBhcmFtcyhwYXJhbXMsIGtlcHREaW1zKSArIFwiKTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTApIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoKSB7XFxuICAgICAgICAgIGludCB0ZXhSID0gcm93O1xcbiAgICAgICAgICBpbnQgdGV4QyA9IGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICsgZGVwdGg7XFxuICAgICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICAgIHZlYzIoXCIgKyB0ZXhOdW1DICsgXCIuMCwgXCIgKyB0ZXhOdW1SICsgXCIuMCk7XFxuICAgICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICAgIH1cXG4gICAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTEpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICBpbnQgdGV4UiA9IHJvdyAqIFwiICsgc2hhcGVbMV0gKyBcIiArIGNvbDtcXG4gICAgICBpbnQgdGV4QyA9IGRlcHRoO1xcbiAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgLyB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG4gICAgfVxuICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSBVVmZyb20zRChcXG4gICAgICAgICAgICBcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIiwgcm93LCBjb2wsIGRlcHRoKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICBcIjtcbn1cbmZ1bmN0aW9uIGdldFNhbXBsZXI0RChpbnB1dEluZm8pIHtcbiAgICB2YXIgc2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhOYW1lLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgdGV4TmFtZS5zbGljZSgxKTtcbiAgICB2YXIgdGV4TnVtUiA9IHRleFNoYXBlWzBdO1xuICAgIHZhciB0ZXhOdW1DID0gdGV4U2hhcGVbMV07XG4gICAgdmFyIHN0cmlkZTIgPSBzaGFwZVszXTtcbiAgICB2YXIgc3RyaWRlMSA9IHNoYXBlWzJdICogc3RyaWRlMjtcbiAgICB2YXIgc3RyaWRlMCA9IHNoYXBlWzFdICogc3RyaWRlMTtcbiAgICB2YXIgX2EgPSB1dGlsLnNxdWVlemVTaGFwZShzaGFwZSksIG5ld1NoYXBlID0gX2EubmV3U2hhcGUsIGtlcHREaW1zID0gX2Eua2VwdERpbXM7XG4gICAgaWYgKG5ld1NoYXBlLmxlbmd0aCA8IHNoYXBlLmxlbmd0aCkge1xuICAgICAgICB2YXIgbmV3SW5wdXRJbmZvID0gc3F1ZWV6ZUlucHV0SW5mbyhpbnB1dEluZm8sIG5ld1NoYXBlKTtcbiAgICAgICAgdmFyIHBhcmFtcyA9IFsncm93JywgJ2NvbCcsICdkZXB0aCcsICdkZXB0aDInXTtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgXCIgKyBnZXRTYW1wbGVyRnJvbUluSW5mbyhuZXdJbnB1dEluZm8pICsgXCJcXG4gICAgICBmbG9hdCBcIiArIGZ1bmNOYW1lICsgXCIoaW50IHJvdywgaW50IGNvbCwgaW50IGRlcHRoLCBpbnQgZGVwdGgyKSB7XFxuICAgICAgICByZXR1cm4gXCIgKyBmdW5jTmFtZSArIFwiKFwiICsgZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykgKyBcIik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHRleE51bUMgPT09IHN0cmlkZTApIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgICAgaW50IHRleFIgPSByb3c7XFxuICAgICAgICBpbnQgdGV4QyA9IGNvbCAqIFwiICsgc3RyaWRlMSArIFwiICsgZGVwdGggKiBcIiArIHN0cmlkZTIgKyBcIiArIGRlcHRoMjtcXG4gICAgICAgIHZlYzIgdXYgPSAodmVjMih0ZXhDLCB0ZXhSKSArIGhhbGZDUikgL1xcbiAgICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgdGV4TnVtQyArIFwiLjAsIFwiICsgdGV4TnVtUiArIFwiLjApO1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgdXYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIGlmICh0ZXhOdW1DID09PSBzdHJpZGUyKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgcm93LCBpbnQgY29sLCBpbnQgZGVwdGgsIGludCBkZXB0aDIpIHtcXG4gICAgICAgIGludCB0ZXhSID0gcm93ICogXCIgKyBzaGFwZVsxXSAqIHNoYXBlWzJdICsgXCIgKyBjb2wgKiBcIiArIHNoYXBlWzJdICsgXCIgKyBkZXB0aDtcXG4gICAgICAgIGludCB0ZXhDID0gZGVwdGgyO1xcbiAgICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICAgdmVjMihcIiArIHRleE51bUMgKyBcIi4wLCBcIiArIHRleE51bVIgKyBcIi4wKTtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKGludCByb3csIGludCBjb2wsIGludCBkZXB0aCwgaW50IGRlcHRoMikge1xcbiAgICAgIHZlYzIgdXYgPSBVVmZyb200RChcIiArIHRleE51bVIgKyBcIiwgXCIgKyB0ZXhOdW1DICsgXCIsIFwiICsgc3RyaWRlMCArIFwiLCBcIiArIHN0cmlkZTEgKyBcIixcXG4gICAgICAgICAgXCIgKyBzdHJpZGUyICsgXCIsIHJvdywgY29sLCBkZXB0aCwgZGVwdGgyKTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0U2FtcGxlckZsYXQoaW5wdXRJbmZvKSB7XG4gICAgdmFyIHRleE5hbWUgPSBpbnB1dEluZm8ubmFtZTtcbiAgICB2YXIgdGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciBmdW5jTmFtZSA9ICdnZXQnICsgdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSkgKyAnRmxhdCc7XG4gICAgdmFyIHROdW1SID0gdGV4U2hhcGVbMF07XG4gICAgdmFyIHROdW1DID0gdGV4U2hhcGVbMV07XG4gICAgaWYgKHROdW1DID09PSAxICYmIHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIGhhbGZDUik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHROdW1DID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKDAuNSwgKGZsb2F0KGluZGV4KSArIDAuNSkgLyBcIiArIHROdW1SICsgXCIuMCk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgaWYgKHROdW1SID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcIlxcbiAgICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICAgIHZlYzIgdXYgPSB2ZWMyKChmbG9hdChpbmRleCkgKyAwLjUpIC8gXCIgKyB0TnVtQyArIFwiLjAsIDAuNSk7XFxuICAgICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiXFxuICAgIGZsb2F0IFwiICsgZnVuY05hbWUgKyBcIihpbnQgaW5kZXgpIHtcXG4gICAgICB2ZWMyIHV2ID0gVVZmcm9tMUQoXCIgKyB0TnVtUiArIFwiLCBcIiArIHROdW1DICsgXCIsIGluZGV4KTtcXG4gICAgICByZXR1cm4gc2FtcGxlKFwiICsgdGV4TmFtZSArIFwiLCB1dik7XFxuICAgIH1cXG4gIFwiO1xufVxuZnVuY3Rpb24gZ2V0QnJvYWRjYXN0T3V0cHV0Q29vcmRzU2FtcGxlcihpbnB1dEluZm8sIG91dFNoYXBlSW5mbywgdGV4RnVuY1NuaXBwZXQsIGZ1bmNOYW1lKSB7XG4gICAgdmFyIGluUmFuayA9IGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLmxlbmd0aDtcbiAgICB2YXIgb3V0UmFuayA9IG91dFNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciB0eXBlID0gJ2ludCc7XG4gICAgaWYgKG91dFJhbmsgPT09IDIpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPT09IDMpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKG91dFJhbmsgPT09IDQpIHtcbiAgICAgICAgdHlwZSA9ICdpdmVjNCc7XG4gICAgfVxuICAgIHZhciBicm9hZGNhc3REaW1zID0gYnJvYWRjYXN0X3V0aWwuZ2V0QnJvYWRjYXN0RGltcyhpbnB1dEluZm8uc2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSwgb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZSk7XG4gICAgdmFyIHJhbmtEaWZmID0gb3V0UmFuayAtIGluUmFuaztcbiAgICB2YXIgY29vcmRzU25pcHBldDtcbiAgICBpZiAoaW5SYW5rID09PSAwKSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPSAnJztcbiAgICB9XG4gICAgZWxzZSBpZiAob3V0UmFuayA8IDIgJiYgYnJvYWRjYXN0RGltcy5sZW5ndGggPj0gMSkge1xuICAgICAgICBjb29yZHNTbmlwcGV0ID0gJ2Nvb3JkcyA9IDA7JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvb3Jkc1NuaXBwZXQgPVxuICAgICAgICAgICAgYnJvYWRjYXN0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIFwiY29vcmRzW1wiICsgKGQgKyByYW5rRGlmZikgKyBcIl0gPSAwO1wiOyB9KS5qb2luKCdcXG4nKTtcbiAgICB9XG4gICAgdmFyIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICcnO1xuICAgIGlmIChvdXRSYW5rIDwgMiAmJiBpblJhbmsgPiAwKSB7XG4gICAgICAgIHVucGFja2VkQ29vcmRzU25pcHBldCA9ICdjb29yZHMnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdW5wYWNrZWRDb29yZHNTbmlwcGV0ID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGVcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHMsIGkpIHsgcmV0dXJuIFwiY29vcmRzW1wiICsgKGkgKyByYW5rRGlmZikgKyBcIl1cIjsgfSlcbiAgICAgICAgICAgIC5qb2luKCcsICcpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIFwiICsgdHlwZSArIFwiIGNvb3JkcyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIFwiICsgY29vcmRzU25pcHBldCArIFwiXFxuICAgICAgcmV0dXJuIGdldFwiICsgdGV4RnVuY1NuaXBwZXQgKyBcIihcIiArIHVucGFja2VkQ29vcmRzU25pcHBldCArIFwiKTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRTYW1wbGVyQXRPdXRwdXRDb29yZHMoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHN1cHBvcnRzQnJvYWRjYXN0aW5nKSB7XG4gICAgdmFyIGluVGV4U2hhcGUgPSBpbnB1dEluZm8uc2hhcGVJbmZvLnRleFNoYXBlO1xuICAgIHZhciB0ZXhOYW1lID0gaW5wdXRJbmZvLm5hbWU7XG4gICAgdmFyIHRleEZ1bmNTbmlwcGV0ID0gdGV4TmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHRleE5hbWUuc2xpY2UoMSk7XG4gICAgdmFyIGZ1bmNOYW1lID0gJ2dldCcgKyB0ZXhGdW5jU25pcHBldCArICdBdE91dENvb3Jkcyc7XG4gICAgdmFyIGJyb2FkY2FzdERpbXMgPSBicm9hZGNhc3RfdXRpbC5nZXRCcm9hZGNhc3REaW1zKGlucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlLCBvdXRTaGFwZUluZm8ubG9naWNhbFNoYXBlKTtcbiAgICB2YXIgaW5SYW5rID0gaW5wdXRJbmZvLnNoYXBlSW5mby5sb2dpY2FsU2hhcGUubGVuZ3RoO1xuICAgIHZhciBvdXRSYW5rID0gb3V0U2hhcGVJbmZvLmxvZ2ljYWxTaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRvQnJvYWRjYXN0ID0gc3VwcG9ydHNCcm9hZGNhc3RpbmcgJiYgKChvdXRSYW5rID4gaW5SYW5rKSB8fCBicm9hZGNhc3REaW1zLmxlbmd0aCA+IDApO1xuICAgIHZhciBicm9hZGNhc3RPdmVyT3V0ZXIgPSBicm9hZGNhc3RfdXRpbC5icm9hZGNhc3REaW1zQXJlT3V0ZXIoYnJvYWRjYXN0RGltcyk7XG4gICAgaWYgKGRvQnJvYWRjYXN0ICYmICFicm9hZGNhc3RPdmVyT3V0ZXIpIHtcbiAgICAgICAgcmV0dXJuIGdldEJyb2FkY2FzdE91dHB1dENvb3Jkc1NhbXBsZXIoaW5wdXRJbmZvLCBvdXRTaGFwZUluZm8sIHRleEZ1bmNTbmlwcGV0LCBmdW5jTmFtZSk7XG4gICAgfVxuICAgIHZhciBvdXRUZXhTaGFwZSA9IG91dFNoYXBlSW5mby50ZXhTaGFwZTtcbiAgICBpZiAodXRpbC5hcnJheXNFcXVhbChpblRleFNoYXBlLCBvdXRUZXhTaGFwZSkpIHtcbiAgICAgICAgcmV0dXJuIFwiXFxuICAgICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgICAgcmV0dXJuIHNhbXBsZShcIiArIHRleE5hbWUgKyBcIiwgcmVzdWx0VVYpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHZhciBpblNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoaW5UZXhTaGFwZSk7XG4gICAgdmFyIGJyb2FkY2FzdFNuaXBwZXQgPSAnJztcbiAgICBpZiAoZG9Ccm9hZGNhc3QgJiYgYnJvYWRjYXN0T3Zlck91dGVyKSB7XG4gICAgICAgIGJyb2FkY2FzdFNuaXBwZXQgPSBcIlxcbiAgICAgICAgaW50IG1haW5QYXJ0ID0gaW5kZXggLyBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgICAgaW5kZXggLT0gbWFpblBhcnQgKiBcIiArIGluU2l6ZSArIFwiO1xcbiAgICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJcXG4gICAgZmxvYXQgXCIgKyBmdW5jTmFtZSArIFwiKCkge1xcbiAgICAgIGl2ZWMyIHJlc1RleFJDID0gaXZlYzIocmVzdWx0VVYueXggKlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmVjMihcIiArIG91dFRleFNoYXBlWzBdICsgXCIsIFwiICsgb3V0VGV4U2hhcGVbMV0gKyBcIikpO1xcbiAgICAgIGludCBpbmRleCA9IHJlc1RleFJDLnggKiBcIiArIG91dFRleFNoYXBlWzFdICsgXCIgKyByZXNUZXhSQy55O1xcbiAgICAgIFwiICsgYnJvYWRjYXN0U25pcHBldCArIFwiXFxuICAgICAgaW50IHRleFIgPSBpbmRleCAvIFwiICsgaW5UZXhTaGFwZVsxXSArIFwiO1xcbiAgICAgIGludCB0ZXhDID0gaW5kZXggLSB0ZXhSICogXCIgKyBpblRleFNoYXBlWzFdICsgXCI7XFxuICAgICAgdmVjMiB1diA9ICh2ZWMyKHRleEMsIHRleFIpICsgaGFsZkNSKSAvXFxuICAgICAgICAgICAgICAgICB2ZWMyKFwiICsgaW5UZXhTaGFwZVsxXSArIFwiLjAsIFwiICsgaW5UZXhTaGFwZVswXSArIFwiLjApO1xcblxcbiAgICAgIHJldHVybiBzYW1wbGUoXCIgKyB0ZXhOYW1lICsgXCIsIHV2KTtcXG4gICAgfVxcbiAgXCI7XG59XG5mdW5jdGlvbiBnZXRDb29yZHNEYXRhVHlwZShyYW5rKSB7XG4gICAgaWYgKHJhbmsgPD0gMSkge1xuICAgICAgICByZXR1cm4gJ2ludCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDMpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjMyc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJhbmsgPT09IDQpIHtcbiAgICAgICAgcmV0dXJuICdpdmVjNCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkdQVSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmdldENvb3Jkc0RhdGFUeXBlID0gZ2V0Q29vcmRzRGF0YVR5cGU7XG5mdW5jdGlvbiBzcXVlZXplSW5wdXRJbmZvKGluSW5mbywgc3F1ZWV6ZWRTaGFwZSkge1xuICAgIHZhciBuZXdJbnB1dEluZm8gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGluSW5mbykpO1xuICAgIG5ld0lucHV0SW5mby5zaGFwZUluZm8ubG9naWNhbFNoYXBlID0gc3F1ZWV6ZWRTaGFwZTtcbiAgICByZXR1cm4gbmV3SW5wdXRJbmZvO1xufVxuZnVuY3Rpb24gZ2V0U3F1ZWV6ZWRQYXJhbXMocGFyYW1zLCBrZXB0RGltcykge1xuICAgIHJldHVybiBrZXB0RGltcy5tYXAoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIHBhcmFtc1tkXTsgfSkuam9pbignLCAnKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFNsaWNlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2xpY2VQcm9ncmFtKGRlc3RTaXplKSB7XG4gICAgICAgIHRoaXMudmFyaWFibGVOYW1lcyA9IFsnc291cmNlJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBkZXN0U2l6ZTtcbiAgICAgICAgdGhpcy5yYW5rID0gZGVzdFNpemUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0Q29vcmRzKHRoaXMucmFuayk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHVuaWZvcm0gXCIgKyBkdHlwZSArIFwiIHN0YXJ0O1xcblxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiBzb3VyY2VMb2MgPSBzdGFydCArIGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldFNvdXJjZShcIiArIHNvdXJjZUNvb3JkcyArIFwiKSk7XFxuICAgICAgfVxcbiAgICBcIjtcbiAgICB9XG4gICAgU2xpY2VQcm9ncmFtLnByb3RvdHlwZS5nZXRDdXN0b21TZXR1cEZ1bmMgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHN0YXJ0Lmxlbmd0aCAhPT0gdGhpcy5yYW5rKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSByYW5rIChcIiArIHRoaXMucmFuayArIFwiKSBvZiB0aGUgcHJvZ3JhbSBtdXN0IG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHN0YXJ0IChcIiArIHN0YXJ0Lmxlbmd0aCArIFwiKVwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChncGdwdSwgd2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRMb2MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0TG9jID0gZ3BncHUuZ2V0VW5pZm9ybUxvY2F0aW9uTm9UaHJvdyh3ZWJHTFByb2dyYW0sICdzdGFydCcpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGFydExvYyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0xaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm0yaShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKF90aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgICAgICBncGdwdS5nbC51bmlmb3JtM2koX3RoaXMuc3RhcnRMb2MsIHN0YXJ0WzBdLCBzdGFydFsxXSwgc3RhcnRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgIGdwZ3B1LmdsLnVuaWZvcm00aShfdGhpcy5zdGFydExvYywgc3RhcnRbMF0sIHN0YXJ0WzFdLCBzdGFydFsyXSwgc3RhcnRbM10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgX3RoaXMucmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG4gICAgcmV0dXJuIFNsaWNlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlNsaWNlUHJvZ3JhbSA9IFNsaWNlUHJvZ3JhbTtcbmZ1bmN0aW9uIGdldENvb3JkcyhyYW5rKSB7XG4gICAgaWYgKHJhbmsgPT09IDEpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2VMb2MnO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55JztcbiAgICB9XG4gICAgZWxzZSBpZiAocmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4gJ3NvdXJjZUxvYy54LCBzb3VyY2VMb2MueSwgc291cmNlTG9jLnonO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5rID09PSA0KSB7XG4gICAgICAgIHJldHVybiAnc291cmNlTG9jLngsIHNvdXJjZUxvYy55LCBzb3VyY2VMb2Mueiwgc291cmNlTG9jLncnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJTbGljaW5nIGZvciByYW5rIFwiICsgcmFuayArIFwiIGlzIG5vdCB5ZXQgc3VwcG9ydGVkXCIpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFRleHR1cmVUeXBlO1xuKGZ1bmN0aW9uIChUZXh0dXJlVHlwZSkge1xuICAgIFRleHR1cmVUeXBlW1RleHR1cmVUeXBlW1wiRkxPQVRcIl0gPSAwXSA9IFwiRkxPQVRcIjtcbiAgICBUZXh0dXJlVHlwZVtUZXh0dXJlVHlwZVtcIlVOU0lHTkVEX0JZVEVcIl0gPSAxXSA9IFwiVU5TSUdORURfQllURVwiO1xufSkoVGV4dHVyZVR5cGUgPSBleHBvcnRzLlRleHR1cmVUeXBlIHx8IChleHBvcnRzLlRleHR1cmVUeXBlID0ge30pKTtcbmZ1bmN0aW9uIGdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucykge1xuICAgIHJldHVybiBbY29sdW1ucywgcm93c107XG59XG5leHBvcnRzLmdldFVucGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRVbnBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0O1xuZnVuY3Rpb24gZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZShtYXRyaXhTaXplLCBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICByZXR1cm4gbWF0cml4U2l6ZSAqIGNoYW5uZWxzUGVyVGV4dHVyZTtcbn1cbmV4cG9ydHMuZ2V0VW5wYWNrZWRBcnJheVNpemVGcm9tTWF0cml4U2l6ZSA9IGdldFVucGFja2VkQXJyYXlTaXplRnJvbU1hdHJpeFNpemU7XG5mdW5jdGlvbiBnZXRDb2xvck1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpIHtcbiAgICByZXR1cm4gW2NvbHVtbnMgKiA0LCByb3dzXTtcbn1cbmV4cG9ydHMuZ2V0Q29sb3JNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodCA9IGdldENvbG9yTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQ7XG5mdW5jdGlvbiBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkU2l6ZSwgY2hhbm5lbHNQZXJUZXh0dXJlKSB7XG4gICAgaWYgKHVucGFja2VkU2l6ZSAlIGNoYW5uZWxzUGVyVGV4dHVyZSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnBhY2tlZFNpemUgKFwiICsgdW5wYWNrZWRTaXplICsgXCIpIG11c3QgYmUgYSBtdWx0aXBsZSBvZiBcIiArXG4gICAgICAgICAgICAoXCJcIiArIGNoYW5uZWxzUGVyVGV4dHVyZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdW5wYWNrZWRTaXplIC8gY2hhbm5lbHNQZXJUZXh0dXJlO1xufVxuZXhwb3J0cy5nZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplID0gZ2V0TWF0cml4U2l6ZUZyb21VbnBhY2tlZEFycmF5U2l6ZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvVW5wYWNrZWRBcnJheShtYXRyaXgsIHVucGFja2VkQXJyYXksIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRVbnBhY2tlZEFycmF5U2l6ZUZyb21NYXRyaXhTaXplKG1hdHJpeC5sZW5ndGgsIGNoYW5uZWxzUGVyVGV4dHVyZSk7XG4gICAgaWYgKHVucGFja2VkQXJyYXkubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVucGFja2VkQXJyYXkgbGVuZ3RoIChcIiArIHVucGFja2VkQXJyYXkubGVuZ3RoICsgXCIpIG11c3QgYmUgPj0gXCIgK1xuICAgICAgICAgICAgKFwiXCIgKyByZXF1aXJlZFNpemUpKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgbWF0cml4Lmxlbmd0aDsgKytzcmMpIHtcbiAgICAgICAgdW5wYWNrZWRBcnJheVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgIGRzdCArPSBjaGFubmVsc1BlclRleHR1cmU7XG4gICAgfVxufVxuZXhwb3J0cy5lbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXkgPSBlbmNvZGVNYXRyaXhUb1VucGFja2VkQXJyYXk7XG5leHBvcnRzLkZMT0FUX01BWCA9IDIwMDAwO1xuZXhwb3J0cy5GTE9BVF9NSU4gPSAtZXhwb3J0cy5GTE9BVF9NQVg7XG52YXIgRkxPQVRfUkFOR0UgPSAoZXhwb3J0cy5GTE9BVF9NQVggLSBleHBvcnRzLkZMT0FUX01JTikgLyAyNTU7XG52YXIgRkxPQVRfREVMVEFTID0gWzEsIDEgLyAyNTUsIDEgLyAoMjU1ICogMjU1KSwgMSAvICgyNTUgKiAyNTUgKiAyNTUpXTtcbnZhciBGTE9BVF9QT1dFUlMgPSBbMSwgMjU1LCAyNTUgKiAyNTVdO1xuZXhwb3J0cy5CWVRFX05BTl9WQUxVRSA9IDA7XG5mdW5jdGlvbiBlbmNvZGVGbG9hdEFycmF5KGZsb2F0QXJyYXkpIHtcbiAgICB2YXIgdWludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZmxvYXRBcnJheS5sZW5ndGggKiA0KTtcbiAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGZsb2F0QXJyYXlbaSAvIDRdO1xuICAgICAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICAgICAgICB1aW50QXJyYXlbaV0gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgdWludEFycmF5W2kgKyAxXSA9IGV4cG9ydHMuQllURV9OQU5fVkFMVUU7XG4gICAgICAgICAgICB1aW50QXJyYXlbaSArIDJdID0gZXhwb3J0cy5CWVRFX05BTl9WQUxVRTtcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBleHBvcnRzLkJZVEVfTkFOX1ZBTFVFO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbm9ybWFsaXplZFZhbHVlID0gKHZhbHVlIC0gZXhwb3J0cy5GTE9BVF9NSU4pIC8gRkxPQVRfUkFOR0U7XG4gICAgICAgIHZhciBlbmMgPSBGTE9BVF9QT1dFUlMubWFwKGZ1bmN0aW9uIChwb3cpIHsgcmV0dXJuIHBvdyAqIG5vcm1hbGl6ZWRWYWx1ZTsgfSk7XG4gICAgICAgIHZhciBidWNrZXRzID0gZW5jLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIE1hdGguZmxvb3IoKHZhbHVlICUgMSkgKiAyNTUpOyB9KTtcbiAgICAgICAgdWludEFycmF5W2ldID0gTWF0aC5mbG9vcihub3JtYWxpemVkVmFsdWUpO1xuICAgICAgICB1aW50QXJyYXlbaSArIDFdID0gYnVja2V0c1swXTtcbiAgICAgICAgdWludEFycmF5W2kgKyAyXSA9IGJ1Y2tldHNbMV07XG4gICAgICAgIHVpbnRBcnJheVtpICsgM10gPSBidWNrZXRzWzJdO1xuICAgIH07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1aW50QXJyYXkubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgX2xvb3BfMShpKTtcbiAgICB9XG4gICAgcmV0dXJuIHVpbnRBcnJheTtcbn1cbmV4cG9ydHMuZW5jb2RlRmxvYXRBcnJheSA9IGVuY29kZUZsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVUb0Zsb2F0QXJyYXkodWludEFycmF5KSB7XG4gICAgdmFyIGZsb2F0QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHVpbnRBcnJheS5sZW5ndGggLyA0KTtcbiAgICB2YXIgX2xvb3BfMiA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgIGlmICh1aW50QXJyYXlbaV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMV0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgMl0gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUgJiZcbiAgICAgICAgICAgIHVpbnRBcnJheVtpICsgM10gPT09IGV4cG9ydHMuQllURV9OQU5fVkFMVUUpIHtcbiAgICAgICAgICAgIGZsb2F0QXJyYXlbaSAvIDRdID0gTmFOO1xuICAgICAgICAgICAgcmV0dXJuIFwiY29udGludWVcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZG90ID0gMDtcbiAgICAgICAgRkxPQVRfREVMVEFTLmZvckVhY2goZnVuY3Rpb24gKGRlbHRhLCBqKSB7XG4gICAgICAgICAgICBkb3QgKz0gZGVsdGEgKiB1aW50QXJyYXlbaSArIGpdO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHZhbHVlID0gZG90ICogRkxPQVRfUkFOR0UgKyBleHBvcnRzLkZMT0FUX01JTjtcbiAgICAgICAgZmxvYXRBcnJheVtpIC8gNF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdWludEFycmF5Lmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgIF9sb29wXzIoaSk7XG4gICAgfVxuICAgIHJldHVybiBmbG9hdEFycmF5O1xufVxuZXhwb3J0cy5kZWNvZGVUb0Zsb2F0QXJyYXkgPSBkZWNvZGVUb0Zsb2F0QXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzUGVyVGV4dHVyZSkge1xuICAgIHZhciByZXF1aXJlZFNpemUgPSBnZXRNYXRyaXhTaXplRnJvbVVucGFja2VkQXJyYXlTaXplKHVucGFja2VkQXJyYXkubGVuZ3RoLCBjaGFubmVsc1BlclRleHR1cmUpO1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSBjaGFubmVsc1BlclRleHR1cmUpIHtcbiAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjXTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZEFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQXJyYXk7XG5mdW5jdGlvbiBkZWNvZGVNYXRyaXhGcm9tVW5wYWNrZWRDb2xvclJHQkFBcnJheSh1bnBhY2tlZEFycmF5LCBtYXRyaXgsIGNoYW5uZWxzKSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHVucGFja2VkQXJyYXkubGVuZ3RoICogY2hhbm5lbHMgLyA0O1xuICAgIGlmIChtYXRyaXgubGVuZ3RoIDwgcmVxdWlyZWRTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIGRzdCA9IDA7XG4gICAgZm9yICh2YXIgc3JjID0gMDsgc3JjIDwgdW5wYWNrZWRBcnJheS5sZW5ndGg7IHNyYyArPSA0KSB7XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY2hhbm5lbHM7IGMrKykge1xuICAgICAgICAgICAgbWF0cml4W2RzdCsrXSA9IHVucGFja2VkQXJyYXlbc3JjICsgY107XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlY29kZU1hdHJpeEZyb21VbnBhY2tlZENvbG9yUkdCQUFycmF5ID0gZGVjb2RlTWF0cml4RnJvbVVucGFja2VkQ29sb3JSR0JBQXJyYXk7XG5mdW5jdGlvbiBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodChyb3dzLCBjb2x1bW5zKSB7XG4gICAgcmV0dXJuIFtNYXRoLmNlaWwoY29sdW1ucyAvIDIpLCBNYXRoLmNlaWwocm93cyAvIDIpXTtcbn1cbmV4cG9ydHMuZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQgPSBnZXRQYWNrZWRNYXRyaXhUZXh0dXJlU2hhcGVXaWR0aEhlaWdodDtcbmZ1bmN0aW9uIGdldFBhY2tlZFJHQkFBcnJheVNpemVGcm9tTWF0cml4U2hhcGUocm93cywgY29sdW1ucykge1xuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB3ID0gX2FbMF0sIGggPSBfYVsxXTtcbiAgICByZXR1cm4gdyAqIGggKiA0O1xufVxuZXhwb3J0cy5nZXRQYWNrZWRSR0JBQXJyYXlTaXplRnJvbU1hdHJpeFNoYXBlID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZTtcbmZ1bmN0aW9uIGVuY29kZU1hdHJpeFRvUGFja2VkUkdCQShtYXRyaXgsIHJvd3MsIGNvbHVtbnMsIHBhY2tlZFJHQkEpIHtcbiAgICB2YXIgcmVxdWlyZWRTaXplID0gZ2V0UGFja2VkUkdCQUFycmF5U2l6ZUZyb21NYXRyaXhTaGFwZShyb3dzLCBjb2x1bW5zKTtcbiAgICBpZiAocGFja2VkUkdCQS5sZW5ndGggPCByZXF1aXJlZFNpemUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGFja2VkUkdCQSBsZW5ndGggKFwiICsgcGFja2VkUkdCQS5sZW5ndGggKyBcIikgbXVzdCBiZSA+PSBcIiArIHJlcXVpcmVkU2l6ZSk7XG4gICAgfVxuICAgIHZhciBfYSA9IGdldFBhY2tlZE1hdHJpeFRleHR1cmVTaGFwZVdpZHRoSGVpZ2h0KHJvd3MsIGNvbHVtbnMpLCB0ZXh0dXJlV2lkdGggPSBfYVswXSwgdGV4dHVyZUhlaWdodCA9IF9hWzFdO1xuICAgIHZhciBvZGRXaWR0aCA9IChjb2x1bW5zICUgMikgPT09IDE7XG4gICAgdmFyIG9kZEhlaWdodCA9IChyb3dzICUgMikgPT09IDE7XG4gICAgdmFyIHdpZHRoSW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihjb2x1bW5zIC8gMik7XG4gICAgdmFyIGhlaWdodEluRnVsbEJsb2NrcyA9IE1hdGguZmxvb3Iocm93cyAvIDIpO1xuICAgIHtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IChvZGRXaWR0aCA/IDQgOiAwKTtcbiAgICAgICAgdmFyIG9uZVJvdyA9IGNvbHVtbnM7XG4gICAgICAgIHZhciBkc3QgPSAwO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICB2YXIgbWF0cml4U3JjUm93ID0gKGJsb2NrWSAqIDIgKiBjb2x1bW5zKTtcbiAgICAgICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRyaXhTcmNDb2wgPSBibG9ja1ggKiAyO1xuICAgICAgICAgICAgICAgIHZhciBzcmMgPSBtYXRyaXhTcmNSb3cgKyBtYXRyaXhTcmNDb2w7XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3RdID0gbWF0cml4W3NyY107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAxXSA9IG1hdHJpeFtzcmMgKyAxXTtcbiAgICAgICAgICAgICAgICBwYWNrZWRSR0JBW2RzdCArIDJdID0gbWF0cml4W3NyYyArIG9uZVJvd107XG4gICAgICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAzXSA9IG1hdHJpeFtzcmMgKyBvbmVSb3cgKyAxXTtcbiAgICAgICAgICAgICAgICBkc3QgKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRzdCArPSBkc3RTdHJpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoKSB7XG4gICAgICAgIHZhciBzcmMgPSBjb2x1bW5zIC0gMTtcbiAgICAgICAgdmFyIGRzdCA9ICh0ZXh0dXJlV2lkdGggLSAxKSAqIDQ7XG4gICAgICAgIHZhciBzcmNTdHJpZGUgPSAyICogY29sdW1ucztcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWSA9IDA7IGJsb2NrWSA8IGhlaWdodEluRnVsbEJsb2NrczsgKytibG9ja1kpIHtcbiAgICAgICAgICAgIHBhY2tlZFJHQkFbZHN0XSA9IG1hdHJpeFtzcmNdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QgKyAyXSA9IG1hdHJpeFtzcmMgKyBjb2x1bW5zXTtcbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3QgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRIZWlnaHQpIHtcbiAgICAgICAgdmFyIHNyYyA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICB2YXIgZHN0ID0gKHRleHR1cmVIZWlnaHQgLSAxKSAqIHRleHR1cmVXaWR0aCAqIDQ7XG4gICAgICAgIGZvciAodmFyIGJsb2NrWCA9IDA7IGJsb2NrWCA8IHdpZHRoSW5GdWxsQmxvY2tzOyArK2Jsb2NrWCkge1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgcGFja2VkUkdCQVtkc3QrK10gPSBtYXRyaXhbc3JjKytdO1xuICAgICAgICAgICAgZHN0ICs9IDI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9kZFdpZHRoICYmIG9kZEhlaWdodCkge1xuICAgICAgICBwYWNrZWRSR0JBW3BhY2tlZFJHQkEubGVuZ3RoIC0gNF0gPSBtYXRyaXhbbWF0cml4Lmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICByZXR1cm4gcGFja2VkUkdCQTtcbn1cbmV4cG9ydHMuZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBID0gZW5jb2RlTWF0cml4VG9QYWNrZWRSR0JBO1xuZnVuY3Rpb24gZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEocGFja2VkUkdCQSwgcm93cywgY29sdW1ucywgbWF0cml4KSB7XG4gICAgdmFyIHJlcXVpcmVkU2l6ZSA9IHJvd3MgKiBjb2x1bW5zO1xuICAgIGlmIChyZXF1aXJlZFNpemUgPCBtYXRyaXgubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1hdHJpeCBsZW5ndGggKFwiICsgbWF0cml4Lmxlbmd0aCArIFwiKSBtdXN0IGJlID49IFwiICsgcmVxdWlyZWRTaXplKTtcbiAgICB9XG4gICAgdmFyIG9kZFdpZHRoID0gKGNvbHVtbnMgJSAyKSA9PT0gMTtcbiAgICB2YXIgb2RkSGVpZ2h0ID0gKHJvd3MgJSAyKSA9PT0gMTtcbiAgICB2YXIgd2lkdGhJbkZ1bGxCbG9ja3MgPSBNYXRoLmZsb29yKGNvbHVtbnMgLyAyKTtcbiAgICB2YXIgaGVpZ2h0SW5GdWxsQmxvY2tzID0gTWF0aC5mbG9vcihyb3dzIC8gMik7XG4gICAgdmFyIF9hID0gZ2V0UGFja2VkTWF0cml4VGV4dHVyZVNoYXBlV2lkdGhIZWlnaHQocm93cywgY29sdW1ucyksIHRleHR1cmVXaWR0aCA9IF9hWzBdLCB0ZXh0dXJlSGVpZ2h0ID0gX2FbMV07XG4gICAge1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gb2RkV2lkdGggPyA0IDogMDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IGNvbHVtbnMgKyAob2RkV2lkdGggPyAxIDogMCk7XG4gICAgICAgIHZhciBzcmMgPSAwO1xuICAgICAgICB2YXIgZHN0Um93MSA9IDA7XG4gICAgICAgIHZhciBkc3RSb3cyID0gY29sdW1ucztcbiAgICAgICAgZm9yICh2YXIgYmxvY2tZID0gMDsgYmxvY2tZIDwgaGVpZ2h0SW5GdWxsQmxvY2tzOyArK2Jsb2NrWSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYmxvY2tYID0gMDsgYmxvY2tYIDwgd2lkdGhJbkZ1bGxCbG9ja3M7ICsrYmxvY2tYKSB7XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzErK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgICAgICBtYXRyaXhbZHN0Um93MSsrXSA9IHBhY2tlZFJHQkFbc3JjKytdO1xuICAgICAgICAgICAgICAgIG1hdHJpeFtkc3RSb3cyKytdID0gcGFja2VkUkdCQVtzcmMrK107XG4gICAgICAgICAgICAgICAgbWF0cml4W2RzdFJvdzIrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyYyArPSBzcmNTdHJpZGU7XG4gICAgICAgICAgICBkc3RSb3cxICs9IGRzdFN0cmlkZTtcbiAgICAgICAgICAgIGRzdFJvdzIgKz0gZHN0U3RyaWRlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCkge1xuICAgICAgICB2YXIgc3JjID0gKHRleHR1cmVXaWR0aCAtIDEpICogNDtcbiAgICAgICAgdmFyIGRzdCA9IGNvbHVtbnMgLSAxO1xuICAgICAgICB2YXIgc3JjU3RyaWRlID0gdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdFN0cmlkZSA9IDIgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1kgPSAwOyBibG9ja1kgPCBoZWlnaHRJbkZ1bGxCbG9ja3M7ICsrYmxvY2tZKSB7XG4gICAgICAgICAgICBtYXRyaXhbZHN0XSA9IHBhY2tlZFJHQkFbc3JjXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QgKyBjb2x1bW5zXSA9IHBhY2tlZFJHQkFbc3JjICsgMl07XG4gICAgICAgICAgICBzcmMgKz0gc3JjU3RyaWRlO1xuICAgICAgICAgICAgZHN0ICs9IGRzdFN0cmlkZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob2RkSGVpZ2h0KSB7XG4gICAgICAgIHZhciBzcmMgPSAodGV4dHVyZUhlaWdodCAtIDEpICogdGV4dHVyZVdpZHRoICogNDtcbiAgICAgICAgdmFyIGRzdCA9IChyb3dzIC0gMSkgKiBjb2x1bW5zO1xuICAgICAgICBmb3IgKHZhciBibG9ja1ggPSAwOyBibG9ja1ggPCB3aWR0aEluRnVsbEJsb2NrczsgKytibG9ja1gpIHtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIG1hdHJpeFtkc3QrK10gPSBwYWNrZWRSR0JBW3NyYysrXTtcbiAgICAgICAgICAgIHNyYyArPSAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChvZGRXaWR0aCAmJiBvZGRIZWlnaHQpIHtcbiAgICAgICAgbWF0cml4W21hdHJpeC5sZW5ndGggLSAxXSA9IHBhY2tlZFJHQkFbcGFja2VkUkdCQS5sZW5ndGggLSA0XTtcbiAgICB9XG4gICAgcmV0dXJuIG1hdHJpeDtcbn1cbmV4cG9ydHMuZGVjb2RlTWF0cml4RnJvbVBhY2tlZFJHQkEgPSBkZWNvZGVNYXRyaXhGcm9tUGFja2VkUkdCQTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRleF91dGlsXzEgPSByZXF1aXJlKFwiLi90ZXhfdXRpbFwiKTtcbnZhciBUZXh0dXJlTWFuYWdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVGV4dHVyZU1hbmFnZXIoZ3BncHUpIHtcbiAgICAgICAgdGhpcy5ncGdwdSA9IGdwZ3B1O1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzID0gMDtcbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXMgPSB7fTtcbiAgICAgICAgdGhpcy5sb2dFbmFibGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkVGV4dHVyZXMgPSBbXTtcbiAgICAgICAgdGhpcy51c2VkVGV4dHVyZUNvdW50ID0ge307XG4gICAgfVxuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5hY3F1aXJlVGV4dHVyZSA9IGZ1bmN0aW9uIChzaGFwZVJDLCB0ZXhUeXBlKSB7XG4gICAgICAgIGlmICh0ZXhUeXBlID09PSB2b2lkIDApIHsgdGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuRkxPQVQ7IH1cbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZVJDLCB0ZXhUeXBlKTtcbiAgICAgICAgaWYgKCEoc2hhcGVLZXkgaW4gdGhpcy5mcmVlVGV4dHVyZXMpKSB7XG4gICAgICAgICAgICB0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIShzaGFwZUtleSBpbiB0aGlzLnVzZWRUZXh0dXJlQ291bnQpKSB7XG4gICAgICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnRbc2hhcGVLZXldKys7XG4gICAgICAgIGlmICh0aGlzLmZyZWVUZXh0dXJlc1tzaGFwZUtleV0ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5udW1GcmVlVGV4dHVyZXMtLTtcbiAgICAgICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgICAgICB0aGlzLmxvZygpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnJlZVRleHR1cmVzW3NoYXBlS2V5XS5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzKys7XG4gICAgICAgIHRoaXMubG9nKCk7XG4gICAgICAgIHZhciBuZXdUZXh0dXJlID0gdGhpcy5ncGdwdS5jcmVhdGVNYXRyaXhUZXh0dXJlKHNoYXBlUkNbMF0sIHNoYXBlUkNbMV0pO1xuICAgICAgICB0aGlzLmFsbG9jYXRlZFRleHR1cmVzLnB1c2gobmV3VGV4dHVyZSk7XG4gICAgICAgIHJldHVybiBuZXdUZXh0dXJlO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLnJlbGVhc2VUZXh0dXJlID0gZnVuY3Rpb24gKHRleHR1cmUsIHNoYXBlLCB0ZXhUeXBlKSB7XG4gICAgICAgIGlmICh0ZXhUeXBlID09PSB2b2lkIDApIHsgdGV4VHlwZSA9IHRleF91dGlsXzEuVGV4dHVyZVR5cGUuRkxPQVQ7IH1cbiAgICAgICAgdmFyIHNoYXBlS2V5ID0gZ2V0S2V5RnJvbVRleHR1cmVTaGFwZShzaGFwZSwgdGV4VHlwZSk7XG4gICAgICAgIGlmICghKHNoYXBlS2V5IGluIHRoaXMuZnJlZVRleHR1cmVzKSkge1xuICAgICAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mcmVlVGV4dHVyZXNbc2hhcGVLZXldLnB1c2godGV4dHVyZSk7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzKys7XG4gICAgICAgIHRoaXMubnVtVXNlZFRleHR1cmVzLS07XG4gICAgICAgIHRoaXMudXNlZFRleHR1cmVDb3VudFtzaGFwZUtleV0tLTtcbiAgICAgICAgdGhpcy5sb2coKTtcbiAgICB9O1xuICAgIFRleHR1cmVNYW5hZ2VyLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sb2dFbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsID0gdGhpcy5udW1GcmVlVGV4dHVyZXMgKyB0aGlzLm51bVVzZWRUZXh0dXJlcztcbiAgICAgICAgY29uc29sZS5sb2coJ0ZyZWUvVXNlZCcsIHRoaXMubnVtRnJlZVRleHR1cmVzICsgXCIgLyBcIiArIHRoaXMubnVtVXNlZFRleHR1cmVzLCBcIihcIiArIHRvdGFsICsgXCIpXCIpO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bVVzZWRUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtVXNlZFRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmdldE51bUZyZWVUZXh0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVtRnJlZVRleHR1cmVzO1xuICAgIH07XG4gICAgVGV4dHVyZU1hbmFnZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLmFsbG9jYXRlZFRleHR1cmVzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFsbG9jYXRlZFRleHR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHRleHR1cmUpIHtcbiAgICAgICAgICAgIF90aGlzLmdwZ3B1LmRlbGV0ZU1hdHJpeFRleHR1cmUodGV4dHVyZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZyZWVUZXh0dXJlcyA9IG51bGw7XG4gICAgICAgIHRoaXMuYWxsb2NhdGVkVGV4dHVyZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnVzZWRUZXh0dXJlQ291bnQgPSBudWxsO1xuICAgICAgICB0aGlzLm51bVVzZWRUZXh0dXJlcyA9IDA7XG4gICAgICAgIHRoaXMubnVtRnJlZVRleHR1cmVzID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBUZXh0dXJlTWFuYWdlcjtcbn0oKSk7XG5leHBvcnRzLlRleHR1cmVNYW5hZ2VyID0gVGV4dHVyZU1hbmFnZXI7XG5mdW5jdGlvbiBnZXRLZXlGcm9tVGV4dHVyZVNoYXBlKHNoYXBlUm93c0NvbCwgdGV4VHlwZSkge1xuICAgIHJldHVybiBzaGFwZVJvd3NDb2xbMF0gKyBcIl9cIiArIHNoYXBlUm93c0NvbFsxXSArIFwiX1wiICsgdGV4VHlwZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHNoYWRlcl9jb21waWxlcl8xID0gcmVxdWlyZShcIi4vc2hhZGVyX2NvbXBpbGVyXCIpO1xudmFyIFRpbGVQcm9ncmFtID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUaWxlUHJvZ3JhbShhU2hhcGUsIHJlcHMpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHZhciBvdXRwdXRTaGFwZSA9IG5ldyBBcnJheShhU2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0U2hhcGVbaV0gPSBhU2hhcGVbaV0gKiByZXBzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc291cmNlQ29vcmRzID0gZ2V0U291cmNlQ29vcmRzKGFTaGFwZSk7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIHZvaWQgbWFpbigpIHtcXG4gICAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgICAgc2V0T3V0cHV0KGdldEEoXCIgKyBzb3VyY2VDb29yZHMgKyBcIikpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBUaWxlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlRpbGVQcm9ncmFtID0gVGlsZVByb2dyYW07XG5mdW5jdGlvbiBnZXRTb3VyY2VDb29yZHMoYVNoYXBlKSB7XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRpbGUgZm9yIHJhbmsgXCIgKyByYW5rICsgXCIgaXMgbm90IHlldCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIHJldHVybiBcImltb2QocmVzUkMsIFwiICsgYVNoYXBlWzBdICsgXCIpXCI7XG4gICAgfVxuICAgIHZhciBjdXJyZW50Q29vcmRzID0gWydyZXNSQy54JywgJ3Jlc1JDLnknLCAncmVzUkMueicsICdyZXNSQy53J107XG4gICAgdmFyIHNvdXJjZUNvb3JkcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNvdXJjZUNvb3Jkcy5wdXNoKFwiaW1vZChcIiArIGN1cnJlbnRDb29yZHNbaV0gKyBcIiwgXCIgKyBhU2hhcGVbaV0gKyBcIilcIik7XG4gICAgfVxuICAgIHJldHVybiBzb3VyY2VDb29yZHMuam9pbigpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgc2hhZGVyX2NvbXBpbGVyXzEgPSByZXF1aXJlKFwiLi9zaGFkZXJfY29tcGlsZXJcIik7XG52YXIgVHJhbnNwb3NlUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3NlUHJvZ3JhbShhU2hhcGUsIG5ld0RpbSkge1xuICAgICAgICB0aGlzLnZhcmlhYmxlTmFtZXMgPSBbJ0EnXTtcbiAgICAgICAgdmFyIG91dHB1dFNoYXBlID0gbmV3IEFycmF5KGFTaGFwZS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dHB1dFNoYXBlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXRTaGFwZVtpXSA9IGFTaGFwZVtuZXdEaW1baV1dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBvdXRwdXRTaGFwZTtcbiAgICAgICAgdGhpcy5yYW5rID0gb3V0cHV0U2hhcGUubGVuZ3RoO1xuICAgICAgICB2YXIgZHR5cGUgPSBzaGFkZXJfY29tcGlsZXJfMS5nZXRDb29yZHNEYXRhVHlwZSh0aGlzLnJhbmspO1xuICAgICAgICB2YXIgc3dpdGNoZWQgPSBnZXRTd2l0Y2hlZENvb3JkcyhuZXdEaW0pO1xuICAgICAgICB0aGlzLnVzZXJDb2RlID0gXCJcXG4gICAgdm9pZCBtYWluKCkge1xcbiAgICAgIFwiICsgZHR5cGUgKyBcIiByZXNSQyA9IGdldE91dHB1dENvb3JkcygpO1xcbiAgICAgIHNldE91dHB1dChnZXRBKFwiICsgc3dpdGNoZWQgKyBcIikpO1xcbiAgICB9XFxuICAgIFwiO1xuICAgIH1cbiAgICByZXR1cm4gVHJhbnNwb3NlUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9zZVByb2dyYW0gPSBUcmFuc3Bvc2VQcm9ncmFtO1xuZnVuY3Rpb24gZ2V0U3dpdGNoZWRDb29yZHMobmV3RGltKSB7XG4gICAgdmFyIHJhbmsgPSBuZXdEaW0ubGVuZ3RoO1xuICAgIGlmIChyYW5rID4gNCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlRyYW5zcG9zZSBmb3IgcmFuayBcIiArIHJhbmsgKyBcIiBpcyBub3QgeWV0IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgdmFyIG9yaWdpbmFsT3JkZXIgPSBbJ3Jlc1JDLngnLCAncmVzUkMueScsICdyZXNSQy56JywgJ3Jlc1JDLncnXTtcbiAgICB2YXIgc3dpdGNoZWRDb29yZHMgPSBuZXcgQXJyYXkocmFuayk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdEaW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoZWRDb29yZHNbbmV3RGltW2ldXSA9IG9yaWdpbmFsT3JkZXJbaV07XG4gICAgfVxuICAgIHJldHVybiBzd2l0Y2hlZENvb3Jkcy5qb2luKCk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWx1X3V0aWwgPSByZXF1aXJlKFwiLi4vLi4vb3BzL3NlbHVfdXRpbFwiKTtcbnZhciBVbmFyeU9wUHJvZ3JhbSA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVW5hcnlPcFByb2dyYW0oYVNoYXBlLCBvcFNuaXBwZXQpIHtcbiAgICAgICAgdGhpcy52YXJpYWJsZU5hbWVzID0gWydBJ107XG4gICAgICAgIHRoaXMub3V0cHV0U2hhcGUgPSBhU2hhcGU7XG4gICAgICAgIHRoaXMudXNlckNvZGUgPSBcIlxcbiAgICAgIGZsb2F0IHVuYXJ5T3BlcmF0aW9uKGZsb2F0IHgpIHtcXG4gICAgICAgIFwiICsgb3BTbmlwcGV0ICsgXCJcXG4gICAgICB9XFxuXFxuICAgICAgdm9pZCBtYWluKCkge1xcbiAgICAgICAgZmxvYXQgeCA9IGdldEFBdE91dENvb3JkcygpO1xcbiAgICAgICAgZmxvYXQgeSA9IHVuYXJ5T3BlcmF0aW9uKHgpO1xcblxcbiAgICAgICAgc2V0T3V0cHV0KHkpO1xcbiAgICAgIH1cXG4gICAgXCI7XG4gICAgfVxuICAgIHJldHVybiBVbmFyeU9wUHJvZ3JhbTtcbn0oKSk7XG5leHBvcnRzLlVuYXJ5T3BQcm9ncmFtID0gVW5hcnlPcFByb2dyYW07XG52YXIgQ0hFQ0tfTkFOX1NOSVBQRVQgPSBcIlxcbiAgaWYgKGlzTmFOKHgpKSByZXR1cm4geDtcXG5cIjtcbmV4cG9ydHMuQUJTID0gXCJcXG4gIHJldHVybiBhYnMoeCk7XFxuXCI7XG5leHBvcnRzLlJFTFUgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gKHggPCAwLjApID8gMC4wIDogeDtcXG5cIjtcbmV4cG9ydHMuRUxVID0gXCJcXG4gIHJldHVybiAoeCA+PSAwLjApID8geCA6IChleHAoeCkgLSAxLjApO1xcblwiO1xuZXhwb3J0cy5FTFVfREVSID0gXCJcXG4gIHJldHVybiAoeCA+PSAwLjApID8gMS4wIDogZXhwKHgpO1xcblwiO1xuZXhwb3J0cy5TRUxVID0gXCJcXG4gIC8vIFN0YWJsZSBhbmQgQXR0cmFjdGluZyBGaXhlZCBQb2ludCAoMCwgMSkgZm9yIE5vcm1hbGl6ZWQgV2VpZ2h0cy5cXG4gIC8vIHNlZTogaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcXG4gIGZsb2F0IHNjYWxlQWxwaGEgPSBcIiArIHNlbHVfdXRpbC5TRUxVX1NDQUxFQUxQSEEgKyBcIjtcXG4gIGZsb2F0IHNjYWxlID0gXCIgKyBzZWx1X3V0aWwuU0VMVV9TQ0FMRSArIFwiO1xcbiAgcmV0dXJuICh4ID49IDAuMCkgPyBzY2FsZSAqIHggOiBzY2FsZUFscGhhICogKGV4cCh4KSAtIDEuMCk7XFxuXCI7XG5mdW5jdGlvbiBMRUFLWV9SRUxVKGFscGhhKSB7XG4gICAgcmV0dXJuIFwiXFxuICAgIHJldHVybiAoeCA+PSAwLjApID8geCA6IFwiICsgYWxwaGEgKyBcIiAqIHg7XFxuICBcIjtcbn1cbmV4cG9ydHMuTEVBS1lfUkVMVSA9IExFQUtZX1JFTFU7XG5mdW5jdGlvbiBTVEVQKGFscGhhKSB7XG4gICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICByZXR1cm4gQ0hFQ0tfTkFOX1NOSVBQRVQgKyAoXCJcXG4gICAgcmV0dXJuIHggPiAwLjAgPyAxLjAgOiBmbG9hdChcIiArIGFscGhhICsgXCIpO1xcbiAgXCIpO1xufVxuZXhwb3J0cy5TVEVQID0gU1RFUDtcbmV4cG9ydHMuTkVHID0gXCJcXG4gIHJldHVybiAteDtcXG5cIjtcbmV4cG9ydHMuQ0VJTCA9IFwiXFxuICByZXR1cm4gY2VpbCh4KTtcXG5cIjtcbmV4cG9ydHMuRkxPT1IgPSBcIlxcbiAgcmV0dXJuIGZsb29yKHgpO1xcblwiO1xuZXhwb3J0cy5FWFAgPSBcIlxcbiAgcmV0dXJuIGV4cCh4KTtcXG5cIjtcbmV4cG9ydHMuTE9HID0gXCJcXG4gIHJldHVybiBsb2coeCk7XFxuXCI7XG5leHBvcnRzLlNRUlQgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gc3FydCh4KTtcXG5cIjtcbmV4cG9ydHMuU0lHTU9JRCA9IFwiXFxuICByZXR1cm4gMS4wIC8gKDEuMCArIGV4cCgtMS4wICogeCkpO1xcblwiO1xuZXhwb3J0cy5TSU4gPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gc2luKHgpO1xcblwiO1xuZXhwb3J0cy5DT1MgPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gY29zKHgpO1xcblwiO1xuZXhwb3J0cy5UQU4gPSBcIlxcbiAgcmV0dXJuIHRhbih4KTtcXG5cIjtcbmV4cG9ydHMuQVNJTiA9IENIRUNLX05BTl9TTklQUEVUICsgXCJcXG4gIHJldHVybiBhc2luKHgpO1xcblwiO1xuZXhwb3J0cy5BQ09TID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGFjb3MoeCk7XFxuXCI7XG5leHBvcnRzLkFUQU4gPSBDSEVDS19OQU5fU05JUFBFVCArIFwiXFxuICByZXR1cm4gYXRhbih4KTtcXG5cIjtcbmV4cG9ydHMuU0lOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoeCk7XFxuICByZXR1cm4gKGUyeCAtIDEuMCAvIGUyeCkgLyAyLjA7XFxuXCI7XG5leHBvcnRzLkNPU0ggPSBcIlxcbiAgZmxvYXQgZTJ4ID0gZXhwKC14KTtcXG4gIHJldHVybiAoZTJ4ICsgMS4wIC8gZTJ4KSAvIDIuMDtcXG5cIjtcbmV4cG9ydHMuVEFOSCA9IFwiXFxuICBmbG9hdCBlMnggPSBleHAoLTIuMCAqIGFicyh4KSk7XFxuICByZXR1cm4gc2lnbih4KSAqICgxLjAgLSBlMngpIC8gKDEuMCArIGUyeCk7XFxuXCI7XG5leHBvcnRzLlNRVUFSRSA9IFwiXFxuICByZXR1cm4geCAqIHg7XFxuXCI7XG5leHBvcnRzLkxPR0lDQUxfTk9UID0gQ0hFQ0tfTkFOX1NOSVBQRVQgKyBcIlxcbiAgcmV0dXJuIGZsb2F0KCEoeCA+PSAxLjApKTtcXG5cIjtcbmV4cG9ydHMuVE9fSU5UID0gXCJcXG4gIHJldHVybiBmbG9hdChpbnQoeCkpO1xcblwiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTUFYX1RFWFRVUkVfU0laRSA9IG51bGw7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi8uLi91dGlsXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vLi4vZW52aXJvbm1lbnRcIik7XG5mdW5jdGlvbiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHQoYXR0cmlidXRlcykge1xuICAgIHZhciBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSAxO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHJldHVybiBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzKGNhbnZhcywgYXR0cmlidXRlcyk7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dCA9IGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dDtcbmZ1bmN0aW9uIGNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMoY2FudmFzLCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIGdsO1xuICAgIHZhciB3ZWJnbFZlcnNpb24gPSBlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX1ZFUlNJT04nKTtcbiAgICBpZiAod2ViZ2xWZXJzaW9uID09PSAyKSB7XG4gICAgICAgIGdsID0gY2FudmFzLmdldENvbnRleHQoJ3dlYmdsMicsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmICh3ZWJnbFZlcnNpb24gPT09IDEpIHtcbiAgICAgICAgZ2wgPSAoY2FudmFzLmdldENvbnRleHQoJ3dlYmdsJywgYXR0cmlidXRlcykgfHxcbiAgICAgICAgICAgIGNhbnZhcy5nZXRDb250ZXh0KCdleHBlcmltZW50YWwtd2ViZ2wnLCBhdHRyaWJ1dGVzKSk7XG4gICAgfVxuICAgIGlmICh3ZWJnbFZlcnNpb24gPT09IDAgfHwgZ2wgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IFdlYkdMLicpO1xuICAgIH1cbiAgICByZXR1cm4gZ2w7XG59XG5leHBvcnRzLmNyZWF0ZVdlYkdMUmVuZGVyaW5nQ29udGV4dEZyb21DYW52YXMgPSBjcmVhdGVXZWJHTFJlbmRlcmluZ0NvbnRleHRGcm9tQ2FudmFzO1xuZnVuY3Rpb24gY2FsbEFuZENoZWNrKGdsLCBmdW5jKSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gZnVuYygpO1xuICAgIGNoZWNrV2ViR0xFcnJvcihnbCk7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuZXhwb3J0cy5jYWxsQW5kQ2hlY2sgPSBjYWxsQW5kQ2hlY2s7XG52YXIgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZmFsc2U7XG5mdW5jdGlvbiBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZyhlbmFibGVkKSB7XG4gICAgd2ViR0xEZWJ1Z0Vycm9yQ2hlY2tpbmdFbmFibGVkID0gZW5hYmxlZDtcbn1cbmV4cG9ydHMuZW5hYmxlRGVidWdXZWJHTEVycm9yQ2hlY2tpbmcgPSBlbmFibGVEZWJ1Z1dlYkdMRXJyb3JDaGVja2luZztcbmZ1bmN0aW9uIGNoZWNrV2ViR0xFcnJvcihnbCkge1xuICAgIGlmICh3ZWJHTERlYnVnRXJyb3JDaGVja2luZ0VuYWJsZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZ2wuZ2V0RXJyb3IoKTtcbiAgICAgICAgaWYgKGVycm9yICE9PSBnbC5OT19FUlJPUikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJHTCBFcnJvcjogJyArIGdldFdlYkdMRXJyb3JNZXNzYWdlKGdsLCBlcnJvcikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1dlYkdMRXJyb3IgPSBjaGVja1dlYkdMRXJyb3I7XG5mdW5jdGlvbiBnZXRXZWJHTEVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSB7XG4gICAgc3dpdGNoIChzdGF0dXMpIHtcbiAgICAgICAgY2FzZSBnbC5OT19FUlJPUjpcbiAgICAgICAgICAgIHJldHVybiAnTk9fRVJST1InO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRU5VTTpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9FTlVNJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX1ZBTFVFOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX1ZBTFVFJztcbiAgICAgICAgY2FzZSBnbC5JTlZBTElEX09QRVJBVElPTjpcbiAgICAgICAgICAgIHJldHVybiAnSU5WQUxJRF9PUEVSQVRJT04nO1xuICAgICAgICBjYXNlIGdsLklOVkFMSURfRlJBTUVCVUZGRVJfT1BFUkFUSU9OOlxuICAgICAgICAgICAgcmV0dXJuICdJTlZBTElEX0ZSQU1FQlVGRkVSX09QRVJBVElPTic7XG4gICAgICAgIGNhc2UgZ2wuT1VUX09GX01FTU9SWTpcbiAgICAgICAgICAgIHJldHVybiAnT1VUX09GX01FTU9SWSc7XG4gICAgICAgIGNhc2UgZ2wuQ09OVEVYVF9MT1NUX1dFQkdMOlxuICAgICAgICAgICAgcmV0dXJuICdDT05URVhUX0xPU1RfV0VCR0wnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwiVW5rbm93biBlcnJvciBjb2RlIFwiICsgc3RhdHVzO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0V2ViR0xFcnJvck1lc3NhZ2UgPSBnZXRXZWJHTEVycm9yTWVzc2FnZTtcbmZ1bmN0aW9uIGdldEV4dGVuc2lvbk9yVGhyb3coZ2wsIGV4dGVuc2lvbk5hbWUpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmdldEV4dGVuc2lvbihleHRlbnNpb25OYW1lKTsgfSwgJ0V4dGVuc2lvbiBcIicgKyBleHRlbnNpb25OYW1lICsgJ1wiIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyLicpO1xufVxuZXhwb3J0cy5nZXRFeHRlbnNpb25PclRocm93ID0gZ2V0RXh0ZW5zaW9uT3JUaHJvdztcbmZ1bmN0aW9uIGNyZWF0ZVZlcnRleFNoYWRlcihnbCwgdmVydGV4U2hhZGVyU291cmNlKSB7XG4gICAgdmFyIHZlcnRleFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuVkVSVEVYX1NIQURFUik7IH0sICdVbmFibGUgdG8gY3JlYXRlIHZlcnRleCBXZWJHTFNoYWRlci4nKTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnNoYWRlclNvdXJjZSh2ZXJ0ZXhTaGFkZXIsIHZlcnRleFNoYWRlclNvdXJjZSk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuY29tcGlsZVNoYWRlcih2ZXJ0ZXhTaGFkZXIpOyB9KTtcbiAgICBpZiAoZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHZlcnRleFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRTaGFkZXJJbmZvTG9nKHZlcnRleFNoYWRlcikpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWxlZCB0byBjb21waWxlIHZlcnRleCBzaGFkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJ0ZXhTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZVZlcnRleFNoYWRlciA9IGNyZWF0ZVZlcnRleFNoYWRlcjtcbmZ1bmN0aW9uIGNyZWF0ZUZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSkge1xuICAgIHZhciBmcmFnbWVudFNoYWRlciA9IHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVTaGFkZXIoZ2wuRlJBR01FTlRfU0hBREVSKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgZnJhZ21lbnQgV2ViR0xTaGFkZXIuJyk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5zaGFkZXJTb3VyY2UoZnJhZ21lbnRTaGFkZXIsIGZyYWdtZW50U2hhZGVyU291cmNlKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jb21waWxlU2hhZGVyKGZyYWdtZW50U2hhZGVyKTsgfSk7XG4gICAgaWYgKGdsLmdldFNoYWRlclBhcmFtZXRlcihmcmFnbWVudFNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKGZyYWdtZW50U2hhZGVyU291cmNlLCBnbC5nZXRTaGFkZXJJbmZvTG9nKGZyYWdtZW50U2hhZGVyKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNvbXBpbGUgZnJhZ21lbnQgc2hhZGVyLicpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnRTaGFkZXI7XG59XG5leHBvcnRzLmNyZWF0ZUZyYWdtZW50U2hhZGVyID0gY3JlYXRlRnJhZ21lbnRTaGFkZXI7XG52YXIgbGluZU51bWJlclJlZ2V4ID0gL0VSUk9SOiBbMC05XSs6KFswLTldKyk6L2c7XG5mdW5jdGlvbiBsb2dTaGFkZXJTb3VyY2VBbmRJbmZvTG9nKHNoYWRlclNvdXJjZSwgc2hhZGVySW5mb0xvZykge1xuICAgIHZhciBsaW5lTnVtYmVyUmVnZXhSZXN1bHQgPSBsaW5lTnVtYmVyUmVnZXguZXhlYyhzaGFkZXJJbmZvTG9nKTtcbiAgICBpZiAobGluZU51bWJlclJlZ2V4UmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDb3VsZG4ndCBwYXJzZSBsaW5lIG51bWJlciBpbiBlcnJvcjogXCIgKyBzaGFkZXJJbmZvTG9nKTtcbiAgICAgICAgY29uc29sZS5sb2coc2hhZGVyU291cmNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGluZU51bWJlciA9ICtsaW5lTnVtYmVyUmVnZXhSZXN1bHRbMV07XG4gICAgdmFyIHNoYWRlckxpbmVzID0gc2hhZGVyU291cmNlLnNwbGl0KCdcXG4nKTtcbiAgICB2YXIgcGFkID0gc2hhZGVyTGluZXMubGVuZ3RoLnRvU3RyaW5nKCkubGVuZ3RoICsgMjtcbiAgICB2YXIgbGluZXNXaXRoTGluZU51bWJlcnMgPSBzaGFkZXJMaW5lcy5tYXAoZnVuY3Rpb24gKGxpbmUsIGxpbmVOdW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHV0aWwucmlnaHRQYWQoKGxpbmVOdW1iZXIgKyAxKS50b1N0cmluZygpLCBwYWQpICsgbGluZTtcbiAgICB9KTtcbiAgICB2YXIgbWF4TGluZUxlbmd0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc1dpdGhMaW5lTnVtYmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXhMaW5lTGVuZ3RoID0gTWF0aC5tYXgobGluZXNXaXRoTGluZU51bWJlcnNbaV0ubGVuZ3RoLCBtYXhMaW5lTGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGJlZm9yZUVycm9yTGluZXMgPSBsaW5lc1dpdGhMaW5lTnVtYmVycy5zbGljZSgwLCBsaW5lTnVtYmVyIC0gMSk7XG4gICAgdmFyIGVycm9yTGluZSA9IGxpbmVzV2l0aExpbmVOdW1iZXJzLnNsaWNlKGxpbmVOdW1iZXIgLSAxLCBsaW5lTnVtYmVyKTtcbiAgICB2YXIgYWZ0ZXJFcnJvckxpbmVzID0gbGluZXNXaXRoTGluZU51bWJlcnMuc2xpY2UobGluZU51bWJlcik7XG4gICAgY29uc29sZS5sb2coYmVmb3JlRXJyb3JMaW5lcy5qb2luKCdcXG4nKSk7XG4gICAgY29uc29sZS5sb2coc2hhZGVySW5mb0xvZy5zcGxpdCgnXFxuJylbMF0pO1xuICAgIGNvbnNvbGUubG9nKFwiJWMgXCIgKyB1dGlsLnJpZ2h0UGFkKGVycm9yTGluZVswXSwgbWF4TGluZUxlbmd0aCksICdib3JkZXI6MXB4IHNvbGlkIHJlZDsgYmFja2dyb3VuZC1jb2xvcjojZTNkMmQyOyBjb2xvcjojYTYxNzE3Jyk7XG4gICAgY29uc29sZS5sb2coYWZ0ZXJFcnJvckxpbmVzLmpvaW4oJ1xcbicpKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2dyYW0oZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZVByb2dyYW0oKTsgfSwgJ1VuYWJsZSB0byBjcmVhdGUgV2ViR0xQcm9ncmFtLicpO1xufVxuZXhwb3J0cy5jcmVhdGVQcm9ncmFtID0gY3JlYXRlUHJvZ3JhbTtcbmZ1bmN0aW9uIGxpbmtQcm9ncmFtKGdsLCBwcm9ncmFtKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTsgfSk7XG4gICAgaWYgKGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGxpbmsgdmVydGV4IGFuZCBmcmFnbWVudCBzaGFkZXJzLicpO1xuICAgIH1cbn1cbmV4cG9ydHMubGlua1Byb2dyYW0gPSBsaW5rUHJvZ3JhbTtcbmZ1bmN0aW9uIHZhbGlkYXRlUHJvZ3JhbShnbCwgcHJvZ3JhbSkge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wudmFsaWRhdGVQcm9ncmFtKHByb2dyYW0pOyB9KTtcbiAgICBpZiAoZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlcihwcm9ncmFtLCBnbC5WQUxJREFURV9TVEFUVVMpID09PSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhnbC5nZXRQcm9ncmFtSW5mb0xvZyhwcm9ncmFtKSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhZGVyIHByb2dyYW0gdmFsaWRhdGlvbiBmYWlsZWQuJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVByb2dyYW0gPSB2YWxpZGF0ZVByb2dyYW07XG5mdW5jdGlvbiBjcmVhdGVTdGF0aWNWZXJ0ZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIGJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIGRhdGEsIGdsLlNUQVRJQ19EUkFXKTsgfSk7XG4gICAgcmV0dXJuIGJ1ZmZlcjtcbn1cbmV4cG9ydHMuY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyID0gY3JlYXRlU3RhdGljVmVydGV4QnVmZmVyO1xuZnVuY3Rpb24gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXIoZ2wsIGRhdGEpIHtcbiAgICB2YXIgYnVmZmVyID0gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUJ1ZmZlcigpOyB9LCAnVW5hYmxlIHRvIGNyZWF0ZSBXZWJHTEJ1ZmZlcicpO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEJ1ZmZlcihnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5idWZmZXJEYXRhKGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBkYXRhLCBnbC5TVEFUSUNfRFJBVyk7IH0pO1xuICAgIHJldHVybiBidWZmZXI7XG59XG5leHBvcnRzLmNyZWF0ZVN0YXRpY0luZGV4QnVmZmVyID0gY3JlYXRlU3RhdGljSW5kZXhCdWZmZXI7XG5mdW5jdGlvbiBxdWVyeU1heFRleHR1cmVTaXplKGdsKSB7XG4gICAgaWYgKE1BWF9URVhUVVJFX1NJWkUgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbiAgICB9XG4gICAgTUFYX1RFWFRVUkVfU0laRSA9XG4gICAgICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpOyB9KTtcbiAgICByZXR1cm4gTUFYX1RFWFRVUkVfU0laRTtcbn1cbmV4cG9ydHMucXVlcnlNYXhUZXh0dXJlU2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemU7XG5mdW5jdGlvbiBnZXRDaGFubmVsc1BlclRleHR1cmUoKSB7XG4gICAgaWYgKCFlbnZpcm9ubWVudF8xLkVOVi5nZXQoJ1dFQkdMX0ZMT0FUX1RFWFRVUkVfRU5BQkxFRCcpKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBpZiAoZW52aXJvbm1lbnRfMS5FTlYuZ2V0KCdXRUJHTF9WRVJTSU9OJykgPT09IDIpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiA0O1xufVxuZXhwb3J0cy5nZXRDaGFubmVsc1BlclRleHR1cmUgPSBnZXRDaGFubmVsc1BlclRleHR1cmU7XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlKGdsKSB7XG4gICAgcmV0dXJuIHRocm93SWZOdWxsKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5jcmVhdGVUZXh0dXJlKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMVGV4dHVyZS4nKTtcbn1cbmV4cG9ydHMuY3JlYXRlVGV4dHVyZSA9IGNyZWF0ZVRleHR1cmU7XG5mdW5jdGlvbiB2YWxpZGF0ZVRleHR1cmVTaXplKGdsLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIG1heFRleHR1cmVTaXplID0gcXVlcnlNYXhUZXh0dXJlU2l6ZShnbCk7XG4gICAgaWYgKCh3aWR0aCA8PSAwKSB8fCAoaGVpZ2h0IDw9IDApKSB7XG4gICAgICAgIHZhciByZXF1ZXN0ZWQgPSBcIltcIiArIHdpZHRoICsgXCJ4XCIgKyBoZWlnaHQgKyBcIl1cIjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0ZWQgdGV4dHVyZSBzaXplICcgKyByZXF1ZXN0ZWQgKyAnIGlzIGludmFsaWQuJyk7XG4gICAgfVxuICAgIGlmICgod2lkdGggPiBtYXhUZXh0dXJlU2l6ZSkgfHwgKGhlaWdodCA+IG1heFRleHR1cmVTaXplKSkge1xuICAgICAgICB2YXIgcmVxdWVzdGVkID0gXCJbXCIgKyB3aWR0aCArIFwieFwiICsgaGVpZ2h0ICsgXCJdXCI7XG4gICAgICAgIHZhciBtYXggPSBcIltcIiArIG1heFRleHR1cmVTaXplICsgXCJ4XCIgKyBtYXhUZXh0dXJlU2l6ZSArIFwiXVwiO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlcXVlc3RlZCB0ZXh0dXJlIHNpemUgJyArIHJlcXVlc3RlZCArXG4gICAgICAgICAgICAnIGdyZWF0ZXIgdGhhbiBXZWJHTCBtYXhpbXVtIG9uIHRoaXMgYnJvd3NlciAvIEdQVSAnICsgbWF4ICsgJy4nKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlVGV4dHVyZVNpemUgPSB2YWxpZGF0ZVRleHR1cmVTaXplO1xuZnVuY3Rpb24gY3JlYXRlRnJhbWVidWZmZXIoZ2wpIHtcbiAgICByZXR1cm4gdGhyb3dJZk51bGwoZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmNyZWF0ZUZyYW1lYnVmZmVyKCk7IH0sICdVbmFibGUgdG8gY3JlYXRlIFdlYkdMRnJhbWVidWZmZXIuJyk7XG59XG5leHBvcnRzLmNyZWF0ZUZyYW1lYnVmZmVyID0gY3JlYXRlRnJhbWVidWZmZXI7XG5mdW5jdGlvbiBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlKGdsLCBwcm9ncmFtLCBhdHRyaWJ1dGUsIGJ1ZmZlciwgYXJyYXlFbnRyaWVzUGVySXRlbSwgaXRlbVN0cmlkZUluQnl0ZXMsIGl0ZW1PZmZzZXRJbkJ5dGVzKSB7XG4gICAgdmFyIGxvYyA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHJpYnV0ZSk7XG4gICAgaWYgKGxvYyA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jLCBhcnJheUVudHJpZXNQZXJJdGVtLCBnbC5GTE9BVCwgZmFsc2UsIGl0ZW1TdHJpZGVJbkJ5dGVzLCBpdGVtT2Zmc2V0SW5CeXRlcyk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jKTsgfSk7XG59XG5leHBvcnRzLmJpbmRWZXJ0ZXhCdWZmZXJUb1Byb2dyYW1BdHRyaWJ1dGUgPSBiaW5kVmVydGV4QnVmZmVyVG9Qcm9ncmFtQXR0cmlidXRlO1xuZnVuY3Rpb24gYmluZFRleHR1cmVVbml0KGdsLCB0ZXh0dXJlLCB0ZXh0dXJlVW5pdCkge1xuICAgIHZhbGlkYXRlVGV4dHVyZVVuaXQoZ2wsIHRleHR1cmVVbml0KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyB0ZXh0dXJlVW5pdCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVVuaXQgPSBiaW5kVGV4dHVyZVVuaXQ7XG5mdW5jdGlvbiB1bmJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YWxpZGF0ZVRleHR1cmVVbml0KGdsLCB0ZXh0dXJlVW5pdCk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIG51bGwpOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kVGV4dHVyZVVuaXQgPSB1bmJpbmRUZXh0dXJlVW5pdDtcbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb25PclRocm93KGdsLCBwcm9ncmFtLCB1bmlmb3JtTmFtZSkge1xuICAgIHJldHVybiB0aHJvd0lmTnVsbChnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIHVuaWZvcm1OYW1lKTsgfSwgJ3VuaWZvcm0gXCInICsgdW5pZm9ybU5hbWUgKyAnXCIgbm90IHByZXNlbnQgaW4gcHJvZ3JhbS4nKTtcbn1cbmV4cG9ydHMuZ2V0UHJvZ3JhbVVuaWZvcm1Mb2NhdGlvbk9yVGhyb3cgPSBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uT3JUaHJvdztcbmZ1bmN0aW9uIGdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24oZ2wsIHByb2dyYW0sIHVuaWZvcm1OYW1lKSB7XG4gICAgcmV0dXJuIGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG59XG5leHBvcnRzLmdldFByb2dyYW1Vbmlmb3JtTG9jYXRpb24gPSBnZXRQcm9ncmFtVW5pZm9ybUxvY2F0aW9uO1xuZnVuY3Rpb24gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcihnbCwgcHJvZ3JhbSwgdGV4dHVyZSwgdW5pZm9ybVNhbXBsZXJMb2NhdGlvbiwgdGV4dHVyZVVuaXQpIHtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGJpbmRUZXh0dXJlVW5pdChnbCwgdGV4dHVyZSwgdGV4dHVyZVVuaXQpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnVuaWZvcm0xaSh1bmlmb3JtU2FtcGxlckxvY2F0aW9uLCB0ZXh0dXJlVW5pdCk7IH0pO1xufVxuZXhwb3J0cy5iaW5kVGV4dHVyZVRvUHJvZ3JhbVVuaWZvcm1TYW1wbGVyID0gYmluZFRleHR1cmVUb1Byb2dyYW1Vbmlmb3JtU2FtcGxlcjtcbmZ1bmN0aW9uIGJpbmRDYW52YXNUb0ZyYW1lYnVmZmVyKGdsKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpOyB9KTtcbiAgICBjYWxsQW5kQ2hlY2soZ2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGdsLnZpZXdwb3J0KDAsIDAsIGdsLmNhbnZhcy53aWR0aCwgZ2wuY2FudmFzLmhlaWdodCk7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuc2Npc3NvcigwLCAwLCBnbC5jYW52YXMud2lkdGgsIGdsLmNhbnZhcy5oZWlnaHQpOyB9KTtcbn1cbmV4cG9ydHMuYmluZENhbnZhc1RvRnJhbWVidWZmZXIgPSBiaW5kQ2FudmFzVG9GcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyKGdsLCB0ZXh0dXJlLCBmcmFtZWJ1ZmZlcikge1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7IH0pO1xuICAgIGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2wuZnJhbWVidWZmZXJUZXh0dXJlMkQoZ2wuRlJBTUVCVUZGRVIsIGdsLkNPTE9SX0FUVEFDSE1FTlQwLCBnbC5URVhUVVJFXzJELCB0ZXh0dXJlLCAwKTsgfSk7XG59XG5leHBvcnRzLmJpbmRDb2xvclRleHR1cmVUb0ZyYW1lYnVmZmVyID0gYmluZENvbG9yVGV4dHVyZVRvRnJhbWVidWZmZXI7XG5mdW5jdGlvbiB1bmJpbmRDb2xvclRleHR1cmVGcm9tRnJhbWVidWZmZXIoZ2wsIGZyYW1lYnVmZmVyKSB7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTsgfSk7XG4gICAgY2FsbEFuZENoZWNrKGdsLCBmdW5jdGlvbiAoKSB7IHJldHVybiBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIG51bGwsIDApOyB9KTtcbn1cbmV4cG9ydHMudW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyID0gdW5iaW5kQ29sb3JUZXh0dXJlRnJvbUZyYW1lYnVmZmVyO1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFtZWJ1ZmZlcihnbCkge1xuICAgIHZhciBzdGF0dXMgPSBnbC5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGdsLkZSQU1FQlVGRkVSKTtcbiAgICBpZiAoc3RhdHVzICE9PSBnbC5GUkFNRUJVRkZFUl9DT01QTEVURSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGJpbmRpbmcgZnJhbWVidWZmZXI6ICcgKyBnZXRGcmFtZWJ1ZmZlckVycm9yTWVzc2FnZShnbCwgc3RhdHVzKSk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZUZyYW1lYnVmZmVyID0gdmFsaWRhdGVGcmFtZWJ1ZmZlcjtcbmZ1bmN0aW9uIGdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlKGdsLCBzdGF0dXMpIHtcbiAgICBzd2l0Y2ggKHN0YXR1cykge1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9BVFRBQ0hNRU5UJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9JTkNPTVBMRVRFX01JU1NJTkdfQVRUQUNITUVOVDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9NSVNTSU5HX0FUVEFDSE1FTlQnO1xuICAgICAgICBjYXNlIGdsLkZSQU1FQlVGRkVSX0lOQ09NUExFVEVfRElNRU5TSU9OUzpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfSU5DT01QTEVURV9ESU1FTlNJT05TJztcbiAgICAgICAgY2FzZSBnbC5GUkFNRUJVRkZFUl9VTlNVUFBPUlRFRDpcbiAgICAgICAgICAgIHJldHVybiAnRlJBTUVCVUZGRVJfVU5TVVBQT1JURUQnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFwidW5rbm93biBlcnJvciBcIiArIHN0YXR1cztcbiAgICB9XG59XG5leHBvcnRzLmdldEZyYW1lYnVmZmVyRXJyb3JNZXNzYWdlID0gZ2V0RnJhbWVidWZmZXJFcnJvck1lc3NhZ2U7XG5mdW5jdGlvbiB0aHJvd0lmTnVsbChnbCwgcmV0dXJuVE9yTnVsbCwgZmFpbHVyZU1lc3NhZ2UpIHtcbiAgICB2YXIgdE9yTnVsbCA9IGNhbGxBbmRDaGVjayhnbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gcmV0dXJuVE9yTnVsbCgpOyB9KTtcbiAgICBpZiAodE9yTnVsbCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihmYWlsdXJlTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB0T3JOdWxsO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVUZXh0dXJlVW5pdChnbCwgdGV4dHVyZVVuaXQpIHtcbiAgICB2YXIgbWF4VGV4dHVyZVVuaXQgPSBnbC5NQVhfQ09NQklORURfVEVYVFVSRV9JTUFHRV9VTklUUyAtIDE7XG4gICAgdmFyIGdsVGV4dHVyZVVuaXQgPSB0ZXh0dXJlVW5pdCArIGdsLlRFWFRVUkUwO1xuICAgIGlmIChnbFRleHR1cmVVbml0IDwgZ2wuVEVYVFVSRTAgfHwgZ2xUZXh0dXJlVW5pdCA+IG1heFRleHR1cmVVbml0KSB7XG4gICAgICAgIHZhciB0ZXh0dXJlVW5pdFJhbmdlID0gXCJbZ2wuVEVYVFVSRTAsIGdsLlRFWFRVUkVcIiArIG1heFRleHR1cmVVbml0ICsgXCJdXCI7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRleHR1cmVVbml0IG11c3QgYmUgaW4gXCIgKyB0ZXh0dXJlVW5pdFJhbmdlICsgXCIuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGUoZ2wsIGxvZ1NoYXBlKSB7XG4gICAgaWYgKGxvZ1NoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB2YXIgc3F1ZWV6ZVJlc3VsdCA9IHV0aWwuc3F1ZWV6ZVNoYXBlKGxvZ1NoYXBlKTtcbiAgICAgICAgbG9nU2hhcGUgPSBzcXVlZXplUmVzdWx0Lm5ld1NoYXBlO1xuICAgIH1cbiAgICB2YXIgbWF4VGV4U2l6ZSA9IHF1ZXJ5TWF4VGV4dHVyZVNpemUoZ2wpO1xuICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKGxvZ1NoYXBlKTtcbiAgICBpZiAobG9nU2hhcGUubGVuZ3RoIDw9IDEgJiYgc2l6ZSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbc2l6ZSwgMV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gMiAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGxvZ1NoYXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChsb2dTaGFwZS5sZW5ndGggPT09IDMgJiYgbG9nU2hhcGVbMF0gPD0gbWF4VGV4U2l6ZSAmJlxuICAgICAgICBsb2dTaGFwZVsxXSAqIGxvZ1NoYXBlWzJdIDw9IG1heFRleFNpemUpIHtcbiAgICAgICAgcmV0dXJuIFtsb2dTaGFwZVswXSwgbG9nU2hhcGVbMV0gKiBsb2dTaGFwZVsyXV07XG4gICAgfVxuICAgIGVsc2UgaWYgKGxvZ1NoYXBlLmxlbmd0aCA9PT0gNCAmJiBsb2dTaGFwZVswXSA8PSBtYXhUZXhTaXplICYmXG4gICAgICAgIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXSA8PSBtYXhUZXhTaXplKSB7XG4gICAgICAgIHJldHVybiBbbG9nU2hhcGVbMF0sIGxvZ1NoYXBlWzFdICogbG9nU2hhcGVbMl0gKiBsb2dTaGFwZVszXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdXRpbC5zaXplVG9TcXVhcmlzaFNoYXBlKHNpemUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0VGV4dHVyZVNoYXBlRnJvbUxvZ2ljYWxTaGFwZSA9IGdldFRleHR1cmVTaGFwZUZyb21Mb2dpY2FsU2hhcGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgYXJyYXlfb3BzXzEgPSByZXF1aXJlKFwiLi9vcHMvYXJyYXlfb3BzXCIpO1xudmFyIGJhdGNobm9ybV8xID0gcmVxdWlyZShcIi4vb3BzL2JhdGNobm9ybVwiKTtcbnZhciBiaW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi9vcHMvYmluYXJ5X29wc1wiKTtcbnZhciBjb21wYXJlXzEgPSByZXF1aXJlKFwiLi9vcHMvY29tcGFyZVwiKTtcbnZhciBjb252XzEgPSByZXF1aXJlKFwiLi9vcHMvY29udlwiKTtcbnZhciBpbWFnZV9vcHNfMSA9IHJlcXVpcmUoXCIuL29wcy9pbWFnZV9vcHNcIik7XG52YXIgbG9naWNhbF9vcHNfMSA9IHJlcXVpcmUoXCIuL29wcy9sb2dpY2FsX29wc1wiKTtcbnZhciBscm5fMSA9IHJlcXVpcmUoXCIuL29wcy9scm5cIik7XG52YXIgbHN0bV8xID0gcmVxdWlyZShcIi4vb3BzL2xzdG1cIik7XG52YXIgbWF0bXVsXzEgPSByZXF1aXJlKFwiLi9vcHMvbWF0bXVsXCIpO1xudmFyIG5vcm1fMSA9IHJlcXVpcmUoXCIuL29wcy9ub3JtXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wcy9vcHNcIik7XG52YXIgcG9vbF8xID0gcmVxdWlyZShcIi4vb3BzL3Bvb2xcIik7XG52YXIgcmVkdWN0aW9uX29wc18xID0gcmVxdWlyZShcIi4vb3BzL3JlZHVjdGlvbl9vcHNcIik7XG52YXIgcmV2ZXJzZV8xID0gcmVxdWlyZShcIi4vb3BzL3JldmVyc2VcIik7XG52YXIgc2xpY2VfMSA9IHJlcXVpcmUoXCIuL29wcy9zbGljZVwiKTtcbnZhciBzb2Z0bWF4XzEgPSByZXF1aXJlKFwiLi9vcHMvc29mdG1heFwiKTtcbnZhciB0cmFuc3Bvc2VfMSA9IHJlcXVpcmUoXCIuL29wcy90cmFuc3Bvc2VcIik7XG52YXIgdW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi9vcHMvdW5hcnlfb3BzXCIpO1xudmFyIHRyYWNraW5nXzEgPSByZXF1aXJlKFwiLi90cmFja2luZ1wiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciB0aWR5ID0gdHJhY2tpbmdfMS5UcmFja2luZy50aWR5O1xudmFyIGtlZXAgPSB0cmFja2luZ18xLlRyYWNraW5nLmtlZXA7XG52YXIgTkRBcnJheU1hdGggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5EQXJyYXlNYXRoKGJhY2tlbmQsIHNhZmVNb2RlKSB7XG4gICAgICAgIHRoaXMubWF0TXVsID0gbWF0bXVsXzEuTWF0bXVsT3BzLm1hdE11bDtcbiAgICAgICAgdGhpcy52ZWN0b3JUaW1lc01hdHJpeCA9IG1hdG11bF8xLk1hdG11bE9wcy52ZWN0b3JUaW1lc01hdHJpeDtcbiAgICAgICAgdGhpcy5vdXRlclByb2R1Y3QgPSBtYXRtdWxfMS5NYXRtdWxPcHMub3V0ZXJQcm9kdWN0O1xuICAgICAgICB0aGlzLm1hdHJpeFRpbWVzVmVjdG9yID0gbWF0bXVsXzEuTWF0bXVsT3BzLm1hdHJpeFRpbWVzVmVjdG9yO1xuICAgICAgICB0aGlzLmRvdFByb2R1Y3QgPSBtYXRtdWxfMS5NYXRtdWxPcHMuZG90UHJvZHVjdDtcbiAgICAgICAgdGhpcy5zbGljZSA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2U7XG4gICAgICAgIHRoaXMuc2xpY2UxRCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UxZDtcbiAgICAgICAgdGhpcy5zbGljZTJEID0gc2xpY2VfMS5TbGljZU9wcy5zbGljZTJkO1xuICAgICAgICB0aGlzLnNsaWNlM0QgPSBzbGljZV8xLlNsaWNlT3BzLnNsaWNlM2Q7XG4gICAgICAgIHRoaXMuc2xpY2U0RCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2U0ZDtcbiAgICAgICAgdGhpcy5yZXZlcnNlID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTtcbiAgICAgICAgdGhpcy5yZXZlcnNlMUQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlMWQ7XG4gICAgICAgIHRoaXMucmV2ZXJzZTJEID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTJkO1xuICAgICAgICB0aGlzLnJldmVyc2UzRCA9IHJldmVyc2VfMS5SZXZlcnNlT3BzLnJldmVyc2UzZDtcbiAgICAgICAgdGhpcy5yZXZlcnNlNEQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlNGQ7XG4gICAgICAgIHRoaXMuYmF0Y2hOb3JtYWxpemF0aW9uID0gYmF0Y2hub3JtXzEuQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbjtcbiAgICAgICAgdGhpcy5iYXRjaE5vcm1hbGl6YXRpb24yRCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24yZDtcbiAgICAgICAgdGhpcy5iYXRjaE5vcm1hbGl6YXRpb24zRCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24zZDtcbiAgICAgICAgdGhpcy5iYXRjaE5vcm1hbGl6YXRpb240RCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb240ZDtcbiAgICAgICAgdGhpcy5hdmdQb29sID0gcG9vbF8xLlBvb2xPcHMuYXZnUG9vbDtcbiAgICAgICAgdGhpcy5tYXhQb29sID0gcG9vbF8xLlBvb2xPcHMubWF4UG9vbDtcbiAgICAgICAgdGhpcy5taW5Qb29sID0gcG9vbF8xLlBvb2xPcHMubWluUG9vbDtcbiAgICAgICAgdGhpcy5tYXhQb29sQmFja3Byb3AgPSBwb29sXzEuUG9vbE9wcy5tYXhQb29sQmFja3Byb3A7XG4gICAgICAgIHRoaXMuY29udjJkVHJhbnNwb3NlID0gY29udl8xLkNvbnZPcHMuY29udjJkVHJhbnNwb3NlO1xuICAgICAgICB0aGlzLmRlcHRod2lzZUNvbnYyRCA9IGNvbnZfMS5Db252T3BzLmRlcHRod2lzZUNvbnYyZDtcbiAgICAgICAgdGhpcy5jb252MmREZXJGaWx0ZXIgPSBjb252XzEuQ29udk9wcy5jb252MmREZXJGaWx0ZXI7XG4gICAgICAgIHRoaXMuY29udjJkRGVySW5wdXQgPSBjb252XzEuQ29udk9wcy5jb252MmREZXJJbnB1dDtcbiAgICAgICAgdGhpcy5hcmdNYXggPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmFyZ01heDtcbiAgICAgICAgdGhpcy5hcmdNaW4gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmFyZ01pbjtcbiAgICAgICAgdGhpcy5sb2dTdW1FeHAgPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmxvZ1N1bUV4cDtcbiAgICAgICAgdGhpcy5tYXggPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1heDtcbiAgICAgICAgdGhpcy5tZWFuID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5tZWFuO1xuICAgICAgICB0aGlzLm1pbiA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubWluO1xuICAgICAgICB0aGlzLm1vbWVudHMgPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1vbWVudHM7XG4gICAgICAgIHRoaXMuc3VtID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5zdW07XG4gICAgICAgIHRoaXMuYWRkID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5hZGQ7XG4gICAgICAgIHRoaXMuYWRkU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5hZGRTdHJpY3Q7XG4gICAgICAgIHRoaXMuZGl2ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5kaXY7XG4gICAgICAgIHRoaXMuZGl2aWRlID0gdGhpcy5kaXY7XG4gICAgICAgIHRoaXMuZGl2U3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5kaXZTdHJpY3Q7XG4gICAgICAgIHRoaXMuZGl2aWRlU3RyaWN0ID0gdGhpcy5kaXZTdHJpY3Q7XG4gICAgICAgIHRoaXMubWF4aW11bSA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWF4aW11bTtcbiAgICAgICAgdGhpcy5tYXhpbXVtU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5tYXhpbXVtU3RyaWN0O1xuICAgICAgICB0aGlzLm1pbmltdW0gPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1pbmltdW07XG4gICAgICAgIHRoaXMubWluaW11bVN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubWluaW11bVN0cmljdDtcbiAgICAgICAgdGhpcy5tdWwgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm11bDtcbiAgICAgICAgdGhpcy5tdWx0aXBseSA9IHRoaXMubXVsO1xuICAgICAgICB0aGlzLm11bFN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubXVsU3RyaWN0O1xuICAgICAgICB0aGlzLm11bHRpcGx5U3RyaWN0ID0gdGhpcy5tdWxTdHJpY3Q7XG4gICAgICAgIHRoaXMucG93ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5wb3c7XG4gICAgICAgIHRoaXMucG93U3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5wb3dTdHJpY3Q7XG4gICAgICAgIHRoaXMuc3ViID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5zdWI7XG4gICAgICAgIHRoaXMuc3VidHJhY3QgPSB0aGlzLnN1YjtcbiAgICAgICAgdGhpcy5zdWJTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnN1YlN0cmljdDtcbiAgICAgICAgdGhpcy5sb2dpY2FsTm90ID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLmxvZ2ljYWxOb3Q7XG4gICAgICAgIHRoaXMubG9naWNhbEFuZCA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsQW5kO1xuICAgICAgICB0aGlzLmxvZ2ljYWxPciA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsT3I7XG4gICAgICAgIHRoaXMubG9naWNhbFhvciA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsWG9yO1xuICAgICAgICB0aGlzLndoZXJlID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLndoZXJlO1xuICAgICAgICB0aGlzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZV8xLlRyYW5zcG9zZU9wcy50cmFuc3Bvc2U7XG4gICAgICAgIHRoaXMuZXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5lcXVhbDtcbiAgICAgICAgdGhpcy5lcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmVxdWFsU3RyaWN0O1xuICAgICAgICB0aGlzLmdyZWF0ZXIgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyO1xuICAgICAgICB0aGlzLmdyZWF0ZXJTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyU3RyaWN0O1xuICAgICAgICB0aGlzLmdyZWF0ZXJFcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXJFcXVhbDtcbiAgICAgICAgdGhpcy5ncmVhdGVyRXF1YWxTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyRXF1YWxTdHJpY3Q7XG4gICAgICAgIHRoaXMubGVzcyA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3M7XG4gICAgICAgIHRoaXMubGVzc1N0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NTdHJpY3Q7XG4gICAgICAgIHRoaXMubGVzc0VxdWFsID0gY29tcGFyZV8xLkNvbXBhcmVPcHMubGVzc0VxdWFsO1xuICAgICAgICB0aGlzLmxlc3NFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NFcXVhbFN0cmljdDtcbiAgICAgICAgdGhpcy5ub3RFcXVhbCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLm5vdEVxdWFsO1xuICAgICAgICB0aGlzLm5vdEVxdWFsU3RyaWN0ID0gY29tcGFyZV8xLkNvbXBhcmVPcHMubm90RXF1YWxTdHJpY3Q7XG4gICAgICAgIHRoaXMuYWJzID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYWJzO1xuICAgICAgICB0aGlzLmFjb3MgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hY29zO1xuICAgICAgICB0aGlzLmFzaW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hc2luO1xuICAgICAgICB0aGlzLmF0YW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hdGFuO1xuICAgICAgICB0aGlzLmNlaWwgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5jZWlsO1xuICAgICAgICB0aGlzLmNsaXAgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5jbGlwQnlWYWx1ZTtcbiAgICAgICAgdGhpcy5jb3MgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5jb3M7XG4gICAgICAgIHRoaXMuY29zaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNvc2g7XG4gICAgICAgIHRoaXMuZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZWx1O1xuICAgICAgICB0aGlzLmV4cCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmV4cDtcbiAgICAgICAgdGhpcy5mbG9vciA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmZsb29yO1xuICAgICAgICB0aGlzLmxlYWt5UmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmxlYWt5UmVsdTtcbiAgICAgICAgdGhpcy5sb2cgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sb2c7XG4gICAgICAgIHRoaXMubmVnID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMubmVnO1xuICAgICAgICB0aGlzLnByZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMucHJlbHU7XG4gICAgICAgIHRoaXMucmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnJlbHU7XG4gICAgICAgIHRoaXMuc2VsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNlbHU7XG4gICAgICAgIHRoaXMuc2lnbW9pZCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNpZ21vaWQ7XG4gICAgICAgIHRoaXMuc2luID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc2luO1xuICAgICAgICB0aGlzLnNpbmggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaW5oO1xuICAgICAgICB0aGlzLnNxcnQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zcXJ0O1xuICAgICAgICB0aGlzLnNxdWFyZSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNxdWFyZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3RlcDtcbiAgICAgICAgdGhpcy50YW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy50YW47XG4gICAgICAgIHRoaXMudGFuaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnRhbmg7XG4gICAgICAgIHRoaXMubm9ybSA9IG5vcm1fMS5Ob3JtT3BzLm5vcm07XG4gICAgICAgIHRoaXMuYmFzaWNMU1RNQ2VsbCA9IGxzdG1fMS5MU1RNT3BzLmJhc2ljTFNUTUNlbGw7XG4gICAgICAgIHRoaXMubXVsdGlSTk5DZWxsID0gbHN0bV8xLkxTVE1PcHMubXVsdGlSTk5DZWxsO1xuICAgICAgICB0aGlzLnNvZnRtYXggPSBzb2Z0bWF4XzEuU29mdG1heE9wcy5zb2Z0bWF4O1xuICAgICAgICB0aGlzLnNvZnRtYXhDcm9zc0VudHJvcHkgPSBzb2Z0bWF4XzEuU29mdG1heE9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5O1xuICAgICAgICB0aGlzLmNhc3QgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5jYXN0O1xuICAgICAgICB0aGlzLmNsb25lID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuY2xvbmU7XG4gICAgICAgIHRoaXMuZ2F0aGVyID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuZ2F0aGVyO1xuICAgICAgICB0aGlzLnJlc2hhcGUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yZXNoYXBlO1xuICAgICAgICB0aGlzLnRpbGUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50aWxlO1xuICAgICAgICB0aGlzLm9uZUhvdCA9IGFycmF5X29wc18xLkFycmF5T3BzLm9uZUhvdDtcbiAgICAgICAgdGhpcy5tdWx0aW5vbWlhbCA9IGFycmF5X29wc18xLkFycmF5T3BzLm11bHRpbm9taWFsO1xuICAgICAgICB0aGlzLnBhZDFEID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMucGFkMWQ7XG4gICAgICAgIHRoaXMucGFkMkQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQyZDtcbiAgICAgICAgdGhpcy5yZXNpemVCaWxpbmVhcjNEID0gaW1hZ2Vfb3BzXzEuSW1hZ2VPcHMucmVzaXplQmlsaW5lYXI7XG4gICAgICAgIHRoaXMubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24zRCA9IGxybl8xLkxSTk9wcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjtcbiAgICAgICAgdGhpcy5sb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjREID0gbHJuXzEuTFJOT3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uO1xuICAgICAgICB0aGlzLmtlZXAgPSB0cmFja2luZ18xLlRyYWNraW5nLmtlZXA7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLnNldE1hdGgodGhpcywgYmFja2VuZCwgc2FmZU1vZGUpO1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZTtcbiAgICAgICAgdGhpcy5kaXNwb3NlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmRpc3Bvc2UuYmluZChlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUpO1xuICAgICAgICB0aGlzLnJlZ2lzdGVyZWRWYXJpYWJsZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlcztcbiAgICAgICAgdGhpcy5zdGFydFNjb3BlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnN0YXJ0U2NvcGUuYmluZChlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUpO1xuICAgICAgICB0aGlzLmVuZFNjb3BlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmVuZFNjb3BlLmJpbmQoZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lKTtcbiAgICB9XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjb3BlID0gZnVuY3Rpb24gKHNjb3BlRm4pIHtcbiAgICAgICAgdmFyIGtlZXBGbiA9IGZ1bmN0aW9uICh0ZW5zb3IpIHsgcmV0dXJuIGtlZXAodGVuc29yKTsgfTtcbiAgICAgICAgdmFyIHRyYWNrRm4gPSBmdW5jdGlvbiAodGVuc29yKSB7IHJldHVybiB0ZW5zb3I7IH07XG4gICAgICAgIHJldHVybiB0aWR5KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNjb3BlRm4oa2VlcEZuLCB0cmFja0ZuKTsgfSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudHJhY2sgPSBmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUudG9wSyA9IGZ1bmN0aW9uICh4LCBrKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGsgPD0geC5zaXplLCBcIkVycm9yIGluIHRvcEs6IGsgdmFsdWUgKFwiICsgayArIFwiKSBtdXN0IGJlIGxlc3MgdGhhbiBzaXplIG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgIChcInRlbnNvciwgZ290IHNoYXBlIFwiICsgeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHZhciB2YWx1ZXM7XG4gICAgICAgIHZhciBpbmRpY2VzO1xuICAgICAgICB0aWR5KCd0b3BLJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFsdWVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC50b3BLVmFsdWVzKHgsIGspOyB9LCB7IHg6IHggfSk7XG4gICAgICAgICAgICBpbmRpY2VzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC50b3BLSW5kaWNlcyh4LCBrKTsgfSwgeyB4OiB4IH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7IHZhbHVlczogdmFsdWVzLCBpbmRpY2VzOiBpbmRpY2VzIH07XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuZWxlbWVudFdpc2VNdWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5tdWxTdHJpY3QoYik7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyRGl2aWRlZEJ5QXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGFyRGl2aWRlZEJ5QXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IFRlbnNvciBvZiByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIGMuZGl2KGEpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFycmF5RGl2aWRlZEJ5U2NhbGFyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5RGl2aWRlZEJ5U2NhbGFyOiBzZWNvbmQgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgVGVuc29yIG9mIHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gYS5kaXYoYyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc3dpdGNoRGltID0gZnVuY3Rpb24gKHgsIHBlcm0pIHtcbiAgICAgICAgcmV0dXJuIG9wcy50cmFuc3Bvc2UoeCwgcGVybSk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGFyUGx1c0FycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhclBsdXNBcnJheTogZmlyc3QgYXJndW1lbnQgbXVzdCBiZSByYW5rIDAsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkZChjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5zY2FsYXJNaW51c0FycmF5ID0gZnVuY3Rpb24gKGMsIGEpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIHNjYWxhck1pbnVzQXJyYXk6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJ0cmFjdChjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5hcnJheU1pbnVzU2NhbGFyID0gZnVuY3Rpb24gKGEsIGMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYy5zaXplID09PSAxLCBcIkVycm9yIGluIGFycmF5TWludXNTY2FsYXI6IHNlY29uZCBhcmd1bWVudCBtdXN0IGJlIHJhbmsgMCwgYnV0IFwiICtcbiAgICAgICAgICAgIChcImdvdCByYW5rIFwiICsgYy5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VidHJhY3QoYSwgYyk7XG4gICAgfTtcbiAgICBOREFycmF5TWF0aC5wcm90b3R5cGUuc2NhbGVkQXJyYXlBZGQgPSBmdW5jdGlvbiAoYzEsIGEsIGMyLCBiKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMxLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6IGZpcnN0IGFyZ3VtZW50IG11c3QgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcIiByYW5rIFwiICsgYzEucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGMyLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gc2NhbGVkQXJyYXlBZGQ6IHRoaXJkIGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcIlRlbnNvciBvZiByYW5rIFwiICsgYzIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHNjYWxlZEFycmF5QWRkOiAnKTtcbiAgICAgICAgcmV0dXJuIHRpZHkoJ3NjYWxlZEFycmF5QWRkJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFkZChfdGhpcy5tdWx0aXBseShjMSwgYSksIF90aGlzLm11bHRpcGx5KGMyLCBiKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLnNjYWxhclRpbWVzQXJyYXkgPSBmdW5jdGlvbiAoYywgYSkge1xuICAgICAgICB1dGlsLmFzc2VydChjLnNpemUgPT09IDEsIFwiRXJyb3IgaW4gYXJyYXlEaXZpZGVkQnlTY2FsYXI6IGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgcmFuayAwLCBidXQgXCIgK1xuICAgICAgICAgICAgKFwiZ290IHJhbmsgXCIgKyBjLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseShjLCBhKTtcbiAgICB9O1xuICAgIE5EQXJyYXlNYXRoLnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiAoYSwgYiwgYXhpcykge1xuICAgICAgICByZXR1cm4gb3BzLmNvbmNhdChbYSwgYl0sIGF4aXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDFEID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jb25jYXQxZChbYSwgYl0pO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDJEID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jb25jYXQyZChbYSwgYl0sIGF4aXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDNEID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jb25jYXQzZChbYSwgYl0sIGF4aXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbmNhdDREID0gZnVuY3Rpb24gKGEsIGIsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jb25jYXQ0ZChbYSwgYl0sIGF4aXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYxZCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBiaWFzLCBzdHJpZGUsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGJpYXMucmFuayA9PT0gMSwgXCJFcnJvciBpbiBjb252MWQ6IGJpYXMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAgICAgKGJpYXMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IG9wcy5jb252MWQoaW5wdXQsIGZpbHRlciwgc3RyaWRlLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHJldHVybiByZXMuYWRkKGJpYXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIGJpYXMsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGJpYXMucmFuayA9PT0gMSwgXCJFcnJvciBpbiBjb252MmQ6IGJpYXMgbXVzdCBiZSByYW5rIDEsIGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAgICAgKGJpYXMucmFuayArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IG9wcy5jb252MmQoeCwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHJldHVybiByZXMuYWRkKGJpYXMpO1xuICAgIH07XG4gICAgTkRBcnJheU1hdGgucHJvdG90eXBlLmFyZ01heEVxdWFscyA9IGZ1bmN0aW9uICh4MSwgeDIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaCh4MS5zaGFwZSwgeDIuc2hhcGUsICdFcnJvciBpbiBhcmdNYXhFcXVhbHM6ICcpO1xuICAgICAgICByZXR1cm4geDEuYXJnTWF4KCkuZXF1YWwoeDIuYXJnTWF4KCkpO1xuICAgIH07XG4gICAgcmV0dXJuIE5EQXJyYXlNYXRoO1xufSgpKTtcbmV4cG9ydHMuTkRBcnJheU1hdGggPSBOREFycmF5TWF0aDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0ZW5zb3JfdXRpbCA9IHJlcXVpcmUoXCIuLi90ZW5zb3JfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsXzEgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKFwiLi9jb25jYXRcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgcmFuZF8xID0gcmVxdWlyZShcIi4vcmFuZFwiKTtcbnZhciBBcnJheU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJyYXlPcHMoKSB7XG4gICAgfVxuICAgIEFycmF5T3BzLnRlbnNvciA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoc2hhcGUgIT0gbnVsbCAmJiBpbmZlcnJlZFNoYXBlLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgaW5mZXJyZWRTaGFwZSwgXCJFcnJvciBjcmVhdGluZyBhIG5ldyBUZW5zb3IuIFwiICtcbiAgICAgICAgICAgICAgICAoXCJJbmZlcnJlZCBzaGFwZSAoXCIgKyBpbmZlcnJlZFNoYXBlICsgXCIpIGRvZXMgbm90IG1hdGNoIHRoZSBcIikgK1xuICAgICAgICAgICAgICAgIChcInByb3ZpZGVkIHNoYXBlIChcIiArIHNoYXBlICsgXCIpLiBcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5pc1R5cGVkQXJyYXkodmFsdWVzKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICB2YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHRvVHlwZWRBcnJheSh2YWx1ZXMsIGR0eXBlKSB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5zY2FsYXIgPSBmdW5jdGlvbiAodmFsdWUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmICh1dGlsLmlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgYSBuZXcgU2NhbGFyOiB2YWx1ZSBtdXN0IGJlIGEgcHJpbWl0aXZlICcgK1xuICAgICAgICAgICAgICAgICcobnVtYmVyfGJvb2xlYW4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZSwgW10sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRlbnNvcjFkID0gZnVuY3Rpb24gKHZhbHVlcywgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvcjFEOiB2YWx1ZXMgbXVzdCBiZSBhIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBBcnJheU9wcy50ZW5zb3IodmFsdWVzLCBpbmZlcnJlZFNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50ZW5zb3IyZCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDIgJiYgaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgYSBuZXcgVGVuc29yMkQ6IHZhbHVlcyBtdXN0IGJlIG51bWJlcltdW10gJyArXG4gICAgICAgICAgICAgICAgJ29yIGZsYXQvVHlwZWRBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHNoYXBlID0gc2hhcGUgfHwgaW5mZXJyZWRTaGFwZTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcih2YWx1ZXMsIHNoYXBlLCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy50ZW5zb3IzZCA9IGZ1bmN0aW9uICh2YWx1ZXMsIHNoYXBlLCBkdHlwZSkge1xuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICB2YXIgaW5mZXJyZWRTaGFwZSA9IHV0aWwuaW5mZXJTaGFwZSh2YWx1ZXMpO1xuICAgICAgICBpZiAoaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDMgJiYgaW5mZXJyZWRTaGFwZS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IgY3JlYXRpbmcgYSBuZXcgVGVuc29yM0Q6IHZhbHVlcyBtdXN0IGJlIG51bWJlcltdW11bXScgK1xuICAgICAgICAgICAgICAgICdvciBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy50ZW5zb3IodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudGVuc29yNGQgPSBmdW5jdGlvbiAodmFsdWVzLCBzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIGluZmVycmVkU2hhcGUgPSB1dGlsLmluZmVyU2hhcGUodmFsdWVzKTtcbiAgICAgICAgaWYgKGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSA0ICYmIGluZmVycmVkU2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGEgbmV3IFRlbnNvcjREOiB2YWx1ZXMgbXVzdCBiZSBudW1iZXJbXVtdW11bXScgK1xuICAgICAgICAgICAgICAgICdvciBmbGF0L1R5cGVkQXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IHNoYXBlIHx8IGluZmVycmVkU2hhcGU7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy50ZW5zb3IodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMub25lcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VPbmVzVHlwZWRBcnJheSh1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpLCBkdHlwZSk7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgaWYgKGR0eXBlID09PSB2b2lkIDApIHsgZHR5cGUgPSAnZmxvYXQzMic7IH1cbiAgICAgICAgdmFyIHZhbHVlcyA9IG1ha2VaZXJvc1R5cGVkQXJyYXkodXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKSwgZHR5cGUpO1xuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2Uoc2hhcGUsIHsgdmFsdWVzOiB2YWx1ZXMgfSwgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZmlsbCA9IGZ1bmN0aW9uIChzaGFwZSwgdmFsdWUsIGR0eXBlKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHZhciB2YWx1ZXMgPSB1dGlsLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSkpO1xuICAgICAgICB2YWx1ZXMuZmlsbCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5vbmVzTGlrZSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5vbmVzKHguc2hhcGUsIHguZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuemVyb3NMaWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnplcm9zKHguc2hhcGUsIHguZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuY2xvbmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyBkYXRhSWQ6IHguZGF0YUlkIH0sIHguZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucmFuZG9tTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgaWYgKGR0eXBlICE9IG51bGwgJiYgZHR5cGUgPT09ICdib29sJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYW5kR2F1c3MgPSBuZXcgcmFuZF8xLk1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldiwgZHR5cGUsIGZhbHNlLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5kR2F1c3MubmV4dFZhbHVlKCk7IH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnRydW5jYXRlZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSAhPSBudWxsICYmIGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuc3VwcG9ydGVkIGRhdGEgdHlwZSBcIiArIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmFuZEdhdXNzID0gbmV3IHJhbmRfMS5NUFJhbmRHYXVzcyhtZWFuLCBzdGREZXYsIGR0eXBlLCB0cnVlLCBzZWVkKTtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl8xLlRlbnNvci5yYW5kKHNoYXBlLCBmdW5jdGlvbiAoKSB7IHJldHVybiByYW5kR2F1c3MubmV4dFZhbHVlKCk7IH0sIGR0eXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnJhbmRvbVVuaWZvcm0gPSBmdW5jdGlvbiAoc2hhcGUsIG1pbnZhbCwgbWF4dmFsLCBkdHlwZSkge1xuICAgICAgICBpZiAobWludmFsID09PSB2b2lkIDApIHsgbWludmFsID0gMDsgfVxuICAgICAgICBpZiAobWF4dmFsID09PSB2b2lkIDApIHsgbWF4dmFsID0gMTsgfVxuICAgICAgICBpZiAoZHR5cGUgPT09IHZvaWQgMCkgeyBkdHlwZSA9ICdmbG9hdDMyJzsgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLnJhbmQoc2hhcGUsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHV0aWwucmFuZFVuaWZvcm0obWludmFsLCBtYXh2YWwpOyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5yYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYW5kRnVuY3Rpb24sIGR0eXBlKSB7XG4gICAgICAgIHZhciBzaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgdmFyIHZhbHVlcyA9IG51bGw7XG4gICAgICAgIGlmIChkdHlwZSA9PSBudWxsIHx8IGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlc1tpXSA9IHJhbmRGdW5jdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZW5zb3JfMS5UZW5zb3IubWFrZShzaGFwZSwgeyB2YWx1ZXM6IHZhbHVlcyB9LCBkdHlwZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5tdWx0aW5vbWlhbCA9IGZ1bmN0aW9uIChwcm9iYWJpbGl0aWVzLCBudW1TYW1wbGVzLCBzZWVkKSB7XG4gICAgICAgIHZhciBudW1PdXRjb21lcyA9IHByb2JhYmlsaXRpZXMuc2l6ZTtcbiAgICAgICAgdmFyIG9yaWdSYW5rID0gcHJvYmFiaWxpdGllcy5yYW5rO1xuICAgICAgICBpZiAobnVtT3V0Y29tZXMgPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBtdWx0aW5vbWlhbDogeW91IG5lZWQgYXQgbGVhc3QgMiBvdXRjb21lcywgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAgICAgKG51bU91dGNvbWVzICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3JpZ1JhbmsgPiAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSYW5rIG9mIHByb2JhYmlsaXRpZXMgbXVzdCBiZSAxIG9yIDIsIGJ1dCBpcyBcIiArIG9yaWdSYW5rKTtcbiAgICAgICAgfVxuICAgICAgICBzZWVkID0gc2VlZCB8fCBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2YXIgcHJvYjJEID0gb3JpZ1JhbmsgPT09IDEgPyBwcm9iYWJpbGl0aWVzLmFzMkQoMSwgLTEpIDogcHJvYmFiaWxpdGllcztcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubXVsdGlub21pYWwocHJvYjJELCBudW1TYW1wbGVzLCBzZWVkKTsgfSwgeyBwcm9iMkQ6IHByb2IyRCB9KTtcbiAgICAgICAgcmV0dXJuIG9yaWdSYW5rID09PSAxID8gcmVzLmFzMUQoKSA6IHJlcztcbiAgICB9O1xuICAgIEFycmF5T3BzLm9uZUhvdCA9IGZ1bmN0aW9uIChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpIHtcbiAgICAgICAgaWYgKG9uVmFsdWUgPT09IHZvaWQgMCkgeyBvblZhbHVlID0gMTsgfVxuICAgICAgICBpZiAob2ZmVmFsdWUgPT09IHZvaWQgMCkgeyBvZmZWYWx1ZSA9IDA7IH1cbiAgICAgICAgaWYgKGRlcHRoIDwgMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gb25lSG90OiBkZXB0aCBtdXN0IGJlID49MiwgYnV0IGl0IGlzIFwiICsgZGVwdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm9uZUhvdChpbmRpY2VzLCBkZXB0aCwgb25WYWx1ZSwgb2ZmVmFsdWUpOyB9LCB7IGluZGljZXM6IGluZGljZXMgfSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSB2b2lkIDApIHsgbnVtQ2hhbm5lbHMgPSAzOyB9XG4gICAgICAgIGlmIChudW1DaGFubmVscyA+IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbnN0cnVjdCBUZW5zb3Igd2l0aCBtb3JlIHRoYW4gNCBjaGFubmVscyBmcm9tIHBpeGVscy4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmZyb21QaXhlbHMocGl4ZWxzLCBudW1DaGFubmVscyk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5yZXNoYXBlID0gZnVuY3Rpb24gKHgsIHNoYXBlKSB7XG4gICAgICAgIHNoYXBlID0gdXRpbC5pbmZlckZyb21JbXBsaWNpdFNoYXBlKHNoYXBlLCB4LnNpemUpO1xuICAgICAgICB1dGlsLmFzc2VydCh4LnNpemUgPT09IHV0aWwuc2l6ZUZyb21TaGFwZShzaGFwZSksICduZXcgc2hhcGUgYW5kIG9sZCBzaGFwZSBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzLicpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkucmVzaGFwZSh4LnNoYXBlKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2Uoc2hhcGUsIHsgZGF0YUlkOiB4LmRhdGFJZCB9LCB4LmR0eXBlKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuc3F1ZWV6ZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5yZXNoYXBlKHgsIHV0aWwuc3F1ZWV6ZVNoYXBlKHguc2hhcGUsIGF4aXMpLm5ld1NoYXBlKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmNhc3QgPSBmdW5jdGlvbiAoeCwgZHR5cGUpIHtcbiAgICAgICAgdmFyIGZvcncgPSBmdW5jdGlvbiAoYmFja2VuZCkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmhhc0VuY29kaW5nTG9zcyh4LmR0eXBlLCBkdHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yLm1ha2UoeC5zaGFwZSwgeyBkYXRhSWQ6IHguZGF0YUlkIH0sIGR0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBiYWNrZW5kLmludCh4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmFja2VuZC5ub3RFcXVhbCh4LCBBcnJheU9wcy5zY2FsYXIoMCwgeC5kdHlwZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gQ2FzdDogdW5rbm93biBkdHlwZSBhcmd1bWVudCAoXCIgKyBkdHlwZSArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmNsb25lKCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZm9ydywgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMudGlsZSA9IGZ1bmN0aW9uICh4LCByZXBzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gcmVwcy5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgeC5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcmVwcyBcIiArIHJlcHMgKyBcIi5cIikpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlclggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHhHcmFkID0gQXJyYXlPcHMuemVyb3NMaWtlKHgpO1xuICAgICAgICAgICAgICAgIGlmICh4LnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXBzWzBdOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhHcmFkID0geEdyYWQuYWRkKGR5LnNsaWNlKFtpICogeC5zaGFwZVswXV0sIFt4LnNoYXBlWzBdXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHNbMF07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBzWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4R3JhZCA9IHhHcmFkLmFkZChkeS5zbGljZShbaSAqIHguc2hhcGVbMF0sIGogKiB4LnNoYXBlWzFdXSwgW3guc2hhcGVbMF0sIHguc2hhcGVbMV1dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVwc1swXTsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJlcHNbMV07ICsraikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmVwc1syXTsgKytrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhHcmFkID0geEdyYWQuYWRkKGR5LnNsaWNlKFtpICogeC5zaGFwZVswXSwgaiAqIHguc2hhcGVbMV0sIGsgKiB4LnNoYXBlWzJdXSwgW3guc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl1dKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcHNbMF07ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZXBzWzFdOyArK2opIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJlcHNbMl07ICsraykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsID0gMDsgbCA8IHJlcHNbM107ICsrbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeEdyYWQgPSB4R3JhZC5hZGQoZHkuc2xpY2UoW2kgKiB4LnNoYXBlWzBdLCBqICogeC5zaGFwZVsxXSwgayAqIHguc2hhcGVbMl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbCAqIHguc2hhcGVbM11dLCBbeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSwgeC5zaGFwZVszXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR3JhZGllbnQgZm9yIHRpbGUgb3BlcmF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgcmFuay1cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAoeC5yYW5rICsgXCIgdGVuc29ycyB5ZXQuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHhHcmFkO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGRlclggfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQudGlsZSh4LCByZXBzKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuZ2F0aGVyID0gZnVuY3Rpb24gKHgsIGluZGljZXMsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbF8xLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5nYXRoZXIoeCwgaW5kaWNlcywgYXhlc1swXSk7IH0sIHsgeDogeCwgaW5kaWNlczogaW5kaWNlcyB9KTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnBhZDFkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQocGFkZGluZ3MubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIuJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgW3BhZGRpbmdzXSwgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQyZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGNvbnN0YW50VmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBhZGRpbmdzLmxlbmd0aCA9PT0gMiAmJiBwYWRkaW5nc1swXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzFdLmxlbmd0aCA9PT0gMiwgJ0ludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucGFkM2QgPSBmdW5jdGlvbiAoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICB1dGlsLmFzc2VydChwYWRkaW5ncy5sZW5ndGggPT09IDMgJiYgcGFkZGluZ3NbMF0ubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICBwYWRkaW5nc1sxXS5sZW5ndGggPT09IDIgJiYgcGFkZGluZ3NbMl0ubGVuZ3RoID09PSAyLCAnSW52YWxpZCBudW1iZXIgb2YgcGFkZGluZ3MuIE11c3QgYmUgbGVuZ3RoIG9mIDIgZWFjaC4nKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnBhZCh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBBcnJheU9wcy5wYWQ0ZCA9IGZ1bmN0aW9uICh4LCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSkge1xuICAgICAgICBpZiAoY29uc3RhbnRWYWx1ZSA9PT0gdm9pZCAwKSB7IGNvbnN0YW50VmFsdWUgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHBhZGRpbmdzLmxlbmd0aCA9PT0gNCAmJiBwYWRkaW5nc1swXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzFdLmxlbmd0aCA9PT0gMiAmJiBwYWRkaW5nc1syXS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIHBhZGRpbmdzWzNdLmxlbmd0aCA9PT0gMiwgJ0ludmFsaWQgbnVtYmVyIG9mIHBhZGRpbmdzLiBNdXN0IGJlIGxlbmd0aCBvZiAyIGVhY2guJyk7XG4gICAgICAgIHJldHVybiBBcnJheU9wcy5wYWQoeCwgcGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMucGFkID0gZnVuY3Rpb24gKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKSB7XG4gICAgICAgIGlmIChjb25zdGFudFZhbHVlID09PSB2b2lkIDApIHsgY29uc3RhbnRWYWx1ZSA9IDA7IH1cbiAgICAgICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWQoc2NhbGFyKSBpcyBub3QgZGVmaW5lZC4gUGFzcyBub24tc2NhbGFyIHRvIHBhZCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBiZWdpbiA9IHBhZGRpbmdzLm1hcChmdW5jdGlvbiAocCkgeyByZXR1cm4gcFswXTsgfSk7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5zbGljZShiZWdpbiwgeC5zaGFwZSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucGFkKHgsIHBhZGRpbmdzLCBjb25zdGFudFZhbHVlKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuc3RhY2sgPSBmdW5jdGlvbiAodGVuc29ycywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHRlbnNvcnMubGVuZ3RoID49IDIsICdQYXNzIGF0IGxlYXN0IHR3byB0ZW5zb3JzIHRvIGRsLnN0YWNrJyk7XG4gICAgICAgIHZhciByYW5rID0gdGVuc29yc1swXS5yYW5rO1xuICAgICAgICB2YXIgc2hhcGUgPSB0ZW5zb3JzWzBdLnNoYXBlO1xuICAgICAgICB2YXIgZHR5cGUgPSB0ZW5zb3JzWzBdLmR0eXBlO1xuICAgICAgICB1dGlsLmFzc2VydChheGlzIDw9IHJhbmssICdBeGlzIG11c3QgYmUgPD0gcmFuayBvZiB0aGUgdGVuc29yJyk7XG4gICAgICAgIHRlbnNvcnMuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChzaGFwZSwgdC5zaGFwZSwgJ0FsbCB0ZW5zb3JzIHBhc3NlZCB0byBzdGFjayBtdXN0IGhhdmUgbWF0Y2hpbmcgc2hhcGVzJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KGR0eXBlID09PSB0LmR0eXBlLCAnQWxsIHRlbnNvcnMgcGFzc2VkIHRvIHN0YWNrIG11c3QgaGF2ZSBtYXRjaGluZyBkdHlwZXMnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBleHBhbmRlZFRlbnNvcnMgPSB0ZW5zb3JzLm1hcChmdW5jdGlvbiAodCkgeyByZXR1cm4gdC5leHBhbmREaW1zKGF4aXMpOyB9KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQoZXhwYW5kZWRUZW5zb3JzLCBheGlzKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLmV4cGFuZERpbXMgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGF4aXMgPD0geC5yYW5rLCAnQXhpcyBtdXN0IGJlIDw9IHJhbmsgb2YgdGhlIHRlbnNvcicpO1xuICAgICAgICB2YXIgbmV3U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgIG5ld1NoYXBlLnNwbGljZShheGlzLCAwLCAxKTtcbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnJlc2hhcGUoeCwgbmV3U2hhcGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMubGluc3BhY2UgPSBmdW5jdGlvbiAoc3RhcnQsIHN0b3AsIG51bSkge1xuICAgICAgICBpZiAobnVtID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXF1ZXN0IHplcm8gc2FtcGxlcycpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGVwID0gKHN0b3AgLSBzdGFydCkgLyAobnVtIC0gMSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYWtlWmVyb3NUeXBlZEFycmF5KG51bSwgJ2Zsb2F0MzInKTtcbiAgICAgICAgdmFsdWVzWzBdID0gc3RhcnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZXNbaV0gPSB2YWx1ZXNbaSAtIDFdICsgc3RlcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGVuc29yXzEuVGVuc29yMUQubmV3KHZhbHVlcywgJ2Zsb2F0MzInKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnJhbmdlID0gZnVuY3Rpb24gKHN0YXJ0LCBzdG9wLCBzdGVwLCBkdHlwZSkge1xuICAgICAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7IHN0ZXAgPSAxOyB9XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIGlmIChzdGVwID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGEgc3RlcCBvZiB6ZXJvJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhbWVTdGFydFN0b3AgPSBzdGFydCA9PT0gc3RvcDtcbiAgICAgICAgdmFyIGluY3JlYXNpbmdSYW5nZU5lZ2F0aXZlU3RlcCA9IHN0YXJ0IDwgc3RvcCAmJiBzdGVwIDwgMDtcbiAgICAgICAgdmFyIGRlY3JlYXNpbmdSYW5nZVBvc2l0aXZlU3RlcCA9IHN0b3AgPCBzdGFydCAmJiBzdGVwID4gMTtcbiAgICAgICAgaWYgKHNhbWVTdGFydFN0b3AgfHwgaW5jcmVhc2luZ1JhbmdlTmVnYXRpdmVTdGVwIHx8XG4gICAgICAgICAgICBkZWNyZWFzaW5nUmFuZ2VQb3NpdGl2ZVN0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheU9wcy56ZXJvcyhbMF0sIGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbnVtRWxlbWVudHMgPSBNYXRoLmFicyhNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSk7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBtYWtlWmVyb3NUeXBlZEFycmF5KG51bUVsZW1lbnRzLCBkdHlwZSk7XG4gICAgICAgIGlmIChzdG9wIDwgc3RhcnQgJiYgc3RlcCA9PT0gMSkge1xuICAgICAgICAgICAgc3RlcCA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlc1swXSA9IHN0YXJ0O1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWVzW2kgLSAxXSArIHN0ZXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFycmF5T3BzLnRlbnNvcjFkKHZhbHVlcywgZHR5cGUpO1xuICAgIH07XG4gICAgQXJyYXlPcHMuYnVmZmVyID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSwgdmFsdWVzKSB7XG4gICAgICAgIGlmIChkdHlwZSA9PT0gdm9pZCAwKSB7IGR0eXBlID0gJ2Zsb2F0MzInOyB9XG4gICAgICAgIHJldHVybiBuZXcgdGVuc29yXzEuVGVuc29yQnVmZmVyKHNoYXBlLCBkdHlwZSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIEFycmF5T3BzLnByaW50ID0gZnVuY3Rpb24gKHgsIHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgY29uc29sZS5sb2codGVuc29yX3V0aWwudGVuc29yVG9TdHJpbmcoeCwgdmVyYm9zZSkpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwic2NhbGFyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3IxZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwidGVuc29yMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcInRlbnNvcjNkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBBcnJheU9wcywgXCJ0ZW5zb3I0ZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJvbmVzXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInplcm9zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImZpbGxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwib25lc0xpa2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwiemVyb3NMaWtlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImNsb25lXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInJhbmRvbU5vcm1hbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJ0cnVuY2F0ZWROb3JtYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicmFuZG9tVW5pZm9ybVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicmFuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwibXVsdGlub21pYWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwib25lSG90XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImZyb21QaXhlbHNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcInJlc2hhcGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSlcbiAgICBdLCBBcnJheU9wcywgXCJzcXVlZXplXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdUcmFuc2Zvcm1hdGlvbnMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBBcnJheU9wcywgXCJjYXN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwidGlsZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnU2xpY2luZyBhbmQgSm9pbmluZycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImdhdGhlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnVHJhbnNmb3JtYXRpb25zJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwicGFkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQXJyYXlPcHMsIFwic3RhY2tcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1RyYW5zZm9ybWF0aW9ucycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEFycmF5T3BzLCBcImV4cGFuZERpbXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvbixcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwibGluc3BhY2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvbixcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwicmFuZ2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIEFycmF5T3BzLCBcImJ1ZmZlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgQXJyYXlPcHMsIFwicHJpbnRcIiwgbnVsbCk7XG4gICAgcmV0dXJuIEFycmF5T3BzO1xufSgpKTtcbmV4cG9ydHMuQXJyYXlPcHMgPSBBcnJheU9wcztcbmZ1bmN0aW9uIG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gbmV3IEludDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgJCB7ZHR5cGV9XCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VPbmVzVHlwZWRBcnJheShzaXplLCBkdHlwZSkge1xuICAgIHZhciBhcnJheSA9IG1ha2VaZXJvc1R5cGVkQXJyYXkoc2l6ZSwgZHR5cGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyYXlbaV0gPSAxO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5mdW5jdGlvbiB0b1R5cGVkQXJyYXkoYSwgZHR5cGUpIHtcbiAgICBpZiAobm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSkge1xuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgICAgYSA9IHV0aWwuZmxhdHRlbihhKTtcbiAgICB9XG4gICAgcmV0dXJuIHV0aWwuY29weVR5cGVkQXJyYXkoYSwgZHR5cGUpO1xufVxuZnVuY3Rpb24gbm9Db252ZXJzaW9uTmVlZGVkKGEsIGR0eXBlKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgRmxvYXQzMkFycmF5ICYmIGR0eXBlID09PSAnZmxvYXQzMicpIHx8XG4gICAgICAgIChhIGluc3RhbmNlb2YgSW50MzJBcnJheSAmJiBkdHlwZSA9PT0gJ2ludDMyJykgfHxcbiAgICAgICAgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGR0eXBlID09PSAnYm9vbCcpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuaykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXhlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoYXhlc1theGVzLmxlbmd0aCAtIGkgLSAxXSAhPT0gcmFuayAtIDEgLSBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmF4ZXNBcmVJbm5lck1vc3REaW1zID0gYXhlc0FyZUlubmVyTW9zdERpbXM7XG5mdW5jdGlvbiBjb21iaW5lTG9jYXRpb25zKG91dHB1dExvYywgcmVkdWNlTG9jLCBheGVzKSB7XG4gICAgdmFyIHJhbmsgPSBvdXRwdXRMb2MubGVuZ3RoICsgcmVkdWNlTG9jLmxlbmd0aDtcbiAgICB2YXIgbG9jID0gW107XG4gICAgdmFyIG91dElkeCA9IDA7XG4gICAgdmFyIHJlZHVjZUlkeCA9IDA7XG4gICAgZm9yICh2YXIgZGltID0gMDsgZGltIDwgcmFuazsgZGltKyspIHtcbiAgICAgICAgaWYgKGF4ZXMuaW5kZXhPZihkaW0pID09PSAtMSkge1xuICAgICAgICAgICAgbG9jLnB1c2gob3V0cHV0TG9jW291dElkeCsrXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2MucHVzaChyZWR1Y2VMb2NbcmVkdWNlSWR4KytdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9jO1xufVxuZXhwb3J0cy5jb21iaW5lTG9jYXRpb25zID0gY29tYmluZUxvY2F0aW9ucztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoYVNoYXBlLCBheGVzKSB7XG4gICAgdmFyIG91dFNoYXBlID0gW107XG4gICAgdmFyIHJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIGZvciAodmFyIGRpbSA9IDA7IGRpbSA8IHJhbms7IGRpbSsrKSB7XG4gICAgICAgIGlmIChheGVzLmluZGV4T2YoZGltKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG91dFNoYXBlLnB1c2goYVNoYXBlW2RpbV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciByZWR1Y2VTaGFwZSA9IGF4ZXMubWFwKGZ1bmN0aW9uIChkaW0pIHsgcmV0dXJuIGFTaGFwZVtkaW1dOyB9KTtcbiAgICByZXR1cm4gW291dFNoYXBlLCByZWR1Y2VTaGFwZV07XG59XG5leHBvcnRzLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMgPSBjb21wdXRlT3V0QW5kUmVkdWNlU2hhcGVzO1xuZnVuY3Rpb24gZXhwYW5kU2hhcGVUb0tlZXBEaW0oc2hhcGUsIGF4ZXMpIHtcbiAgICB2YXIgcmVkdWNlU3ViU2hhcGUgPSBheGVzLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4gMTsgfSk7XG4gICAgcmV0dXJuIGNvbWJpbmVMb2NhdGlvbnMoc2hhcGUsIHJlZHVjZVN1YlNoYXBlLCBheGVzKTtcbn1cbmV4cG9ydHMuZXhwYW5kU2hhcGVUb0tlZXBEaW0gPSBleHBhbmRTaGFwZVRvS2VlcERpbTtcbmZ1bmN0aW9uIHBhcnNlQXhpc1BhcmFtKGF4aXMsIHNoYXBlKSB7XG4gICAgdmFyIHJhbmsgPSBzaGFwZS5sZW5ndGg7XG4gICAgYXhpcyA9IGF4aXMgPT0gbnVsbCA/IHNoYXBlLm1hcChmdW5jdGlvbiAocywgaSkgeyByZXR1cm4gaTsgfSkgOiBbXS5jb25jYXQoYXhpcyk7XG4gICAgdXRpbC5hc3NlcnQoYXhpcy5ldmVyeShmdW5jdGlvbiAoYXgpIHsgcmV0dXJuIGF4ID49IC1yYW5rICYmIGF4IDwgcmFuazsgfSksIFwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW4gcmFuZ2UgWy1cIiArIHJhbmsgKyBcIiwgXCIgKyByYW5rICsgXCIpIGJ1dCBcIiArXG4gICAgICAgIChcImdvdCBheGlzIFwiICsgYXhpcykpO1xuICAgIHV0aWwuYXNzZXJ0KGF4aXMuZXZlcnkoZnVuY3Rpb24gKGF4KSB7IHJldHVybiB1dGlsLmlzSW50KGF4KTsgfSksIFwiQWxsIHZhbHVlcyBpbiBheGlzIHBhcmFtIG11c3QgYmUgaW50ZWdlcnMgYnV0IFwiICtcbiAgICAgICAgKFwiZ290IGF4aXMgXCIgKyBheGlzKSk7XG4gICAgcmV0dXJuIGF4aXMubWFwKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhIDwgMCA/IHJhbmsgKyBhIDogYTsgfSk7XG59XG5leHBvcnRzLnBhcnNlQXhpc1BhcmFtID0gcGFyc2VBeGlzUGFyYW07XG5mdW5jdGlvbiBhc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyhtc2csIGF4ZXMsIHJhbmspIHtcbiAgICB1dGlsLmFzc2VydChheGVzQXJlSW5uZXJNb3N0RGltcyhheGVzLCByYW5rKSwgbXNnICsgXCIgc3VwcG9ydHMgb25seSBpbm5lci1tb3N0IGF4ZXMgZm9yIG5vdy4gXCIgK1xuICAgICAgICAoXCJHb3QgYXhlcyBcIiArIGF4ZXMgKyBcIiBhbmQgcmFuay1cIiArIHJhbmsgKyBcIiBpbnB1dC5cIikpO1xufVxuZXhwb3J0cy5hc3NlcnRBeGVzQXJlSW5uZXJNb3N0RGltcyA9IGFzc2VydEF4ZXNBcmVJbm5lck1vc3REaW1zO1xuZnVuY3Rpb24gZ2V0QXhlc1Blcm11dGF0aW9uKGF4ZXMsIHJhbmspIHtcbiAgICBpZiAoYXhlc0FyZUlubmVyTW9zdERpbXMoYXhlcywgcmFuaykpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICBpZiAoYXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7IHJldHVybiByZXN1bHQucHVzaChheGlzKTsgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0QXhlc1Blcm11dGF0aW9uID0gZ2V0QXhlc1Blcm11dGF0aW9uO1xuZnVuY3Rpb24gZ2V0VW5kb0F4ZXNQZXJtdXRhdGlvbihheGVzKSB7XG4gICAgcmV0dXJuIGF4ZXMubWFwKGZ1bmN0aW9uIChheGlzLCBpKSB7IHJldHVybiBbaSwgYXhpc107IH0pXG4gICAgICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSlcbiAgICAgICAgLm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geFswXTsgfSk7XG59XG5leHBvcnRzLmdldFVuZG9BeGVzUGVybXV0YXRpb24gPSBnZXRVbmRvQXhlc1Blcm11dGF0aW9uO1xuZnVuY3Rpb24gZ2V0SW5uZXJNb3N0QXhlcyhudW1BeGVzLCByYW5rKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSByYW5rIC0gbnVtQXhlczsgaSA8IHJhbms7ICsraSkge1xuICAgICAgICByZXMucHVzaChpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZ2V0SW5uZXJNb3N0QXhlcyA9IGdldElubmVyTW9zdEF4ZXM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgQmF0Y2hOb3JtT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCYXRjaE5vcm1PcHMoKSB7XG4gICAgfVxuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24yZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMiwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMiB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG1lYW4gbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDIgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24yRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDIgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMiB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjJEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDIgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uMkQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgMiBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24zZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogeCBtdXN0IGJlIHJhbmsgMyBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gMyB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG1lYW4gbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDMgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb24zRDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDMgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gMyB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjNEOiBzY2FsZSBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDMgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uM0Q6IG9mZnNldCBtdXN0IGJlIHJhbmsgMyBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb240ZCA9IGZ1bmN0aW9uICh4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gNCwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogeCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKHgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1lYW4ucmFuayA9PT0gNCB8fCBtZWFuLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IG1lYW4gbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIGJ1dCBcIiArXG4gICAgICAgICAgICAoXCJnb3QgcmFuayBcIiArIG1lYW4ucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHZhcmlhbmNlLnJhbmsgPT09IDQgfHwgdmFyaWFuY2UucmFuayA9PT0gMSwgXCJFcnJvciBpbiBiYXRjaE5vcm1hbGl6YXRpb240RDogdmFyaWFuY2UgbXVzdCBiZSByYW5rIDQgb3IgcmFuayAxIFwiICtcbiAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHZhcmlhbmNlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQoc2NhbGUucmFuayA9PT0gNCB8fCBzY2FsZS5yYW5rID09PSAxLCBcIkVycm9yIGluIGJhdGNoTm9ybWFsaXphdGlvbjREOiBzY2FsZSBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIHNjYWxlLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQob2Zmc2V0LnJhbmsgPT09IDQgfHwgb2Zmc2V0LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gYmF0Y2hOb3JtYWxpemF0aW9uNEQ6IG9mZnNldCBtdXN0IGJlIHJhbmsgNCBvciByYW5rIDEgXCIgK1xuICAgICAgICAgICAgICAgIChcImJ1dCBnb3QgcmFuayBcIiArIG9mZnNldC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KTtcbiAgICB9O1xuICAgIEJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgbWVhbiwgdmFyaWFuY2UsIHZhcmlhbmNlRXBzaWxvbiwgc2NhbGUsIG9mZnNldCkge1xuICAgICAgICBpZiAodmFyaWFuY2VFcHNpbG9uID09PSB2b2lkIDApIHsgdmFyaWFuY2VFcHNpbG9uID0gLjAwMTsgfVxuICAgICAgICB2YXIgeDREO1xuICAgICAgICBpZiAoeC5yYW5rID09PSAwIHx8IHgucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgeDREID0geC5hczREKDEsIDEsIDEsIHguc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4NEQgPSB4O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmJhdGNoTm9ybWFsaXphdGlvbjREKHg0RCwgYmF0Y2hub3JtUmVzaGFwZTREKG1lYW4pLCBiYXRjaG5vcm1SZXNoYXBlNEQodmFyaWFuY2UpLCB2YXJpYW5jZUVwc2lsb24sIGJhdGNobm9ybVJlc2hhcGU0RChzY2FsZSksIGJhdGNobm9ybVJlc2hhcGU0RChvZmZzZXQpKTsgfSwgeyB4OiB4LCBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfSk7XG4gICAgICAgIHJldHVybiByZXMucmVzaGFwZSh4LnNoYXBlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCYXRjaE5vcm1PcHMsIFwiYmF0Y2hOb3JtYWxpemF0aW9uMmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJhdGNoTm9ybU9wcywgXCJiYXRjaE5vcm1hbGl6YXRpb24zZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmF0Y2hOb3JtT3BzLCBcImJhdGNoTm9ybWFsaXphdGlvbjRkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdOb3JtYWxpemF0aW9uJyB9KVxuICAgIF0sIEJhdGNoTm9ybU9wcywgXCJiYXRjaE5vcm1hbGl6YXRpb25cIiwgbnVsbCk7XG4gICAgcmV0dXJuIEJhdGNoTm9ybU9wcztcbn0oKSk7XG5leHBvcnRzLkJhdGNoTm9ybU9wcyA9IEJhdGNoTm9ybU9wcztcbmZ1bmN0aW9uIGJhdGNobm9ybVJlc2hhcGU0RCh4KSB7XG4gICAgaWYgKHggPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHgucmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4geC5hczFEKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMSkge1xuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gICAgZWxzZSBpZiAoeC5yYW5rID09PSAyKSB7XG4gICAgICAgIHJldHVybiB4LmFzNEQoMSwgMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICByZXR1cm4geC5hczREKDEsIHguc2hhcGVbMF0sIHguc2hhcGVbMV0sIHguc2hhcGVbMl0pO1xuICAgIH1cbiAgICByZXR1cm4geDtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBicm9hZGNhc3RfdXRpbCA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdF91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIEJpbmFyeU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQmluYXJ5T3BzKCkge1xuICAgIH1cbiAgICBCaW5hcnlPcHMuYWRkID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5O1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoYS5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGR5O1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXMgPSByZXMuc3VtKHJlZHVjZUF4ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUoYi5zaGFwZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hZGQoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLmFkZFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIGFkZFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmFkZChiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5zdWIgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGEuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHk7XG4gICAgICAgICAgICAgICAgdmFyIHJlZHVjZUF4ZXMgPSBicm9hZGNhc3RfdXRpbC5nZXRSZWR1Y3Rpb25BeGVzKGIuc2hhcGUsIG91dFNoYXBlKTtcbiAgICAgICAgICAgICAgICBpZiAocmVkdWNlQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcyA9IHJlcy5zdW0ocmVkdWNlQXhlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMubmVnKCkucmVzaGFwZShiLnNoYXBlKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnN1YnRyYWN0KGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5zdWJTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBzdWJTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5zdWIoYik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMucG93ID0gZnVuY3Rpb24gKGJhc2UsIGV4cCkge1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShiYXNlLnNoYXBlLCBleHAuc2hhcGUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGJhc2Uuc2hhcGUsIGV4cC5zaGFwZSkgJiZcbiAgICAgICAgICAgICAgICAhdXRpbC5pc1NjYWxhclNoYXBlKGV4cC5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBvZiBwb3cgbm90IHlldCBzdXBwb3J0ZWQgZm9yIGJyb2FkY2FzdGVkIHNoYXBlcy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZGVyQmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwRmxvYXQgPSBleHAudG9GbG9hdCgpO1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IGV4cEZsb2F0Lm11bChiYXNlLnRvRmxvYXQoKS5wb3coZXhwRmxvYXQuc3ViKG9wc18xLnNjYWxhcigxKSkpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZHkubXVsU3RyaWN0KGR4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBiYXNlOiBkZXJCYXNlIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnBvdyhiYXNlLCBleHApOyB9LCB7IGJhc2U6IGJhc2UgfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMucG93U3RyaWN0ID0gZnVuY3Rpb24gKGJhc2UsIGV4cCkge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGJhc2Uuc2hhcGUsIGV4cC5zaGFwZSwgJ0Vycm9yIGluIHBvd1N0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBiYXNlLnBvdyhleHApO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm11bCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgdmFyIG91dFNoYXBlID0gYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHZhciBkZXIgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHZhciBkZXJBID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYi50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhhLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGEuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBkeS5tdWwoYS50b0Zsb2F0KCkpO1xuICAgICAgICAgICAgICAgIHZhciByZWR1Y2VBeGVzID0gYnJvYWRjYXN0X3V0aWwuZ2V0UmVkdWN0aW9uQXhlcyhiLnNoYXBlLCBvdXRTaGFwZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlZHVjZUF4ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IGE6IGRlckEsIGI6IGRlckIgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubXVsdGlwbHkoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm11bFN0cmljdCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIG11bHRpcGx5U3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubXVsKGIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLmRpdiA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBvdXRTaGFwZSA9IGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkuZGl2KGIudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYS5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5zdW0ocmVkdWNlQXhlcykucmVzaGFwZShhLnNoYXBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgZGVyQiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzID0gZHkubXVsKGEudG9GbG9hdCgpKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVkdWNlQXhlcyA9IGJyb2FkY2FzdF91dGlsLmdldFJlZHVjdGlvbkF4ZXMoYi5zaGFwZSwgb3V0U2hhcGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWR1Y2VBeGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzID0gcmVzLnN1bShyZWR1Y2VBeGVzKS5yZXNoYXBlKGIuc2hhcGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gYi5zcXVhcmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmRpdih0bXAudG9GbG9hdCgpKS5uZWcoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmRpdmlkZShhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0sIGRlcik7XG4gICAgfTtcbiAgICBCaW5hcnlPcHMuZGl2U3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZGl2aWRlU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEuZGl2KGIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm1pbmltdW0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICB2YXIgZGVyQSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bChhLmxlc3NFcXVhbChiKS50b0Zsb2F0KCkpOyB9O1xuICAgICAgICAgICAgdmFyIGRlckIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWwoYS5ncmVhdGVyKGIpLnRvRmxvYXQoKSk7IH07XG4gICAgICAgICAgICByZXR1cm4geyBhOiBkZXJBLCBiOiBkZXJCIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1pbmltdW0oYSwgYik7IH0sIHsgYTogYSwgYjogYiB9LCBkZXIpO1xuICAgIH07XG4gICAgQmluYXJ5T3BzLm1pbmltdW1TdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBtaW5pbXVtU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubWluaW11bShiKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tYXhpbXVtID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIGRlckEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWwoYS5ncmVhdGVyRXF1YWwoYikudG9GbG9hdCgpKTsgfTtcbiAgICAgICAgICAgIHZhciBkZXJCID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsKGEubGVzcyhiKS50b0Zsb2F0KCkpOyB9O1xuICAgICAgICAgICAgcmV0dXJuIHsgYTogZGVyQSwgYjogZGVyQiB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXhpbXVtKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSwgZGVyKTtcbiAgICB9O1xuICAgIEJpbmFyeU9wcy5tYXhpbXVtU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbWluaW11bVN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm1heGltdW0oYik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJhZGRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJhZGRTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwic3ViXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwic3ViU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInBvd1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcInBvd1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQXJpdGhtZXRpYycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtdWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0FyaXRobWV0aWMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiZGl2XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBCaW5hcnlPcHMsIFwiZGl2U3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1pbmltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtaW5pbXVtU3RyaWN0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdBcml0aG1ldGljJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQmluYXJ5T3BzLCBcIm1heGltdW1cIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIEJpbmFyeU9wcywgXCJtYXhpbXVtU3RyaWN0XCIsIG51bGwpO1xuICAgIHJldHVybiBCaW5hcnlPcHM7XG59KCkpO1xuZXhwb3J0cy5CaW5hcnlPcHMgPSBCaW5hcnlPcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGdldEJyb2FkY2FzdERpbXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgaW5SYW5rID0gaW5TaGFwZS5sZW5ndGg7XG4gICAgdmFyIGRpbXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluUmFuazsgaSsrKSB7XG4gICAgICAgIHZhciBkaW0gPSBpblJhbmsgLSAxIC0gaTtcbiAgICAgICAgdmFyIGEgPSBpblNoYXBlW2RpbV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBvdXRTaGFwZVtvdXRTaGFwZS5sZW5ndGggLSAxIC0gaV0gfHwgMTtcbiAgICAgICAgaWYgKGIgPiAxICYmIGEgPT09IDEpIHtcbiAgICAgICAgICAgIGRpbXMudW5zaGlmdChkaW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaW1zO1xufVxuZXhwb3J0cy5nZXRCcm9hZGNhc3REaW1zID0gZ2V0QnJvYWRjYXN0RGltcztcbmZ1bmN0aW9uIGdldFJlZHVjdGlvbkF4ZXMoaW5TaGFwZSwgb3V0U2hhcGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRTaGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaW5EaW0gPSBpblNoYXBlW2luU2hhcGUubGVuZ3RoIC0gaSAtIDFdO1xuICAgICAgICB2YXIgb3V0QXhpcyA9IG91dFNoYXBlLmxlbmd0aCAtIGkgLSAxO1xuICAgICAgICB2YXIgb3V0RGltID0gb3V0U2hhcGVbb3V0QXhpc107XG4gICAgICAgIGlmIChpbkRpbSA9PSBudWxsIHx8IChpbkRpbSA9PT0gMSAmJiBvdXREaW0gPiAxKSkge1xuICAgICAgICAgICAgcmVzdWx0LnVuc2hpZnQob3V0QXhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuZ2V0UmVkdWN0aW9uQXhlcyA9IGdldFJlZHVjdGlvbkF4ZXM7XG5mdW5jdGlvbiBicm9hZGNhc3REaW1zQXJlT3V0ZXIoZGltcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGltcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGltc1tpXSAhPT0gaSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5icm9hZGNhc3REaW1zQXJlT3V0ZXIgPSBicm9hZGNhc3REaW1zQXJlT3V0ZXI7XG5mdW5jdGlvbiBhc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShzaGFwZUEsIHNoYXBlQikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgZXJyTXNnID0gXCJPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzIFwiICtcbiAgICAgICAgKHNoYXBlQSArIFwiIGFuZCBcIiArIHNoYXBlQiArIFwiLlwiKTtcbiAgICB2YXIgbCA9IE1hdGgubWF4KHNoYXBlQS5sZW5ndGgsIHNoYXBlQi5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBhID0gc2hhcGVBW3NoYXBlQS5sZW5ndGggLSBpIC0gMV0gfHwgMTtcbiAgICAgICAgdmFyIGIgPSBzaGFwZUJbc2hhcGVCLmxlbmd0aCAtIGkgLSAxXSB8fCAxO1xuICAgICAgICBpZiAoYSA+IDEgJiYgYiA+IDEgJiYgYSAhPT0gYikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoZXJyTXNnKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQudW5zaGlmdChNYXRoLm1heChhLCBiKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlID0gYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYnJvYWRjYXN0X3V0aWwgPSByZXF1aXJlKFwiLi9icm9hZGNhc3RfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBDb21wYXJlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb21wYXJlT3BzKCkge1xuICAgIH1cbiAgICBDb21wYXJlT3BzLm5vdEVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubm90RXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMubm90RXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBub3RFcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLm5vdEVxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubGVzcyhhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbGVzc1N0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmxlc3MoYik7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmVxdWFsID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMuZXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBlcXVhbFN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmVxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5sZXNzRXF1YWwgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFR5cGVzTWF0Y2goYSwgYik7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sZXNzRXF1YWwoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIENvbXBhcmVPcHMubGVzc0VxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gbGVzc0VxdWFsU3RyaWN0OiAnKTtcbiAgICAgICAgcmV0dXJuIGEubGVzc0VxdWFsKGIpO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRUeXBlc01hdGNoKGEsIGIpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuZ3JlYXRlcihhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyU3RyaWN0ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChhLnNoYXBlLCBiLnNoYXBlLCAnRXJyb3IgaW4gZ3JlYXRlclN0cmljdDogJyk7XG4gICAgICAgIHJldHVybiBhLmdyZWF0ZXIoYik7XG4gICAgfTtcbiAgICBDb21wYXJlT3BzLmdyZWF0ZXJFcXVhbCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0VHlwZXNNYXRjaChhLCBiKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmdyZWF0ZXJFcXVhbChhLCBiKTsgfSwgeyBhOiBhLCBiOiBiIH0pO1xuICAgIH07XG4gICAgQ29tcGFyZU9wcy5ncmVhdGVyRXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydFNoYXBlc01hdGNoKGEuc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiBncmVhdGVyRXF1YWxTdHJpY3Q6ICcpO1xuICAgICAgICByZXR1cm4gYS5ncmVhdGVyRXF1YWwoYik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibm90RXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibm90RXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImxlc3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwibGVzc1N0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZXF1YWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImxlc3NFcXVhbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29tcGFyZU9wcywgXCJsZXNzRXF1YWxTdHJpY3RcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0xvZ2ljYWwnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZ3JlYXRlclN0cmljdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbXBhcmVPcHMsIFwiZ3JlYXRlckVxdWFsXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb21wYXJlT3BzLCBcImdyZWF0ZXJFcXVhbFN0cmljdFwiLCBudWxsKTtcbiAgICByZXR1cm4gQ29tcGFyZU9wcztcbn0oKSk7XG5leHBvcnRzLkNvbXBhcmVPcHMgPSBDb21wYXJlT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGF4aXNfdXRpbF8xID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIGNvbmNhdF91dGlsID0gcmVxdWlyZShcIi4vY29uY2F0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgQ29uY2F0T3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb25jYXRPcHMoKSB7XG4gICAgfVxuICAgIENvbmNhdE9wcy5jb25jYXQxZCA9IGZ1bmN0aW9uICh0ZW5zb3JzKSB7XG4gICAgICAgIHJldHVybiBDb25jYXRPcHMuY29uY2F0KHRlbnNvcnMsIDApO1xuICAgIH07XG4gICAgQ29uY2F0T3BzLmNvbmNhdDJkID0gZnVuY3Rpb24gKHRlbnNvcnMsIGF4aXMpIHtcbiAgICAgICAgcmV0dXJuIENvbmNhdE9wcy5jb25jYXQodGVuc29ycywgYXhpcyk7XG4gICAgfTtcbiAgICBDb25jYXRPcHMuY29uY2F0M2QgPSBmdW5jdGlvbiAodGVuc29ycywgYXhpcykge1xuICAgICAgICByZXR1cm4gQ29uY2F0T3BzLmNvbmNhdCh0ZW5zb3JzLCBheGlzKTtcbiAgICB9O1xuICAgIENvbmNhdE9wcy5jb25jYXQ0ZCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBheGlzKSB7XG4gICAgICAgIHJldHVybiBDb25jYXRPcHMuY29uY2F0KHRlbnNvcnMsIGF4aXMpO1xuICAgIH07XG4gICAgQ29uY2F0T3BzLmNvbmNhdCA9IGZ1bmN0aW9uICh0ZW5zb3JzLCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQodGVuc29ycy5sZW5ndGggPj0gMiwgJ1Bhc3MgYXQgbGVhc3QgdHdvIHRlbnNvcnMgdG8gY29uY2F0Jyk7XG4gICAgICAgIHZhciByZXN1bHQgPSB0ZW5zb3JzWzBdO1xuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbF8xLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHJlc3VsdC5zaGFwZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29uY2F0MlRlbnNvcnMocmVzdWx0LCB0ZW5zb3JzW2ldLCBheGVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBDb25jYXRPcHMsIFwiY29uY2F0XCIsIG51bGwpO1xuICAgIHJldHVybiBDb25jYXRPcHM7XG59KCkpO1xuZXhwb3J0cy5Db25jYXRPcHMgPSBDb25jYXRPcHM7XG5mdW5jdGlvbiBjb25jYXQyVGVuc29ycyhhLCBiLCBheGlzKSB7XG4gICAgY29uY2F0X3V0aWwuYXNzZXJ0UGFyYW1zKGEuc2hhcGUsIGIuc2hhcGUsIGF4aXMpO1xuICAgIHZhciBvdXRTaGFwZSA9IGNvbmNhdF91dGlsLmNvbXB1dGVPdXRTaGFwZShhLnNoYXBlLCBiLnNoYXBlLCBheGlzKTtcbiAgICB2YXIgYTJEID0gYS5hczJEKC0xLCB1dGlsLnNpemVGcm9tU2hhcGUoYS5zaGFwZS5zbGljZShheGlzKSkpO1xuICAgIHZhciBiMkQgPSBiLmFzMkQoLTEsIHV0aWwuc2l6ZUZyb21TaGFwZShiLnNoYXBlLnNsaWNlKGF4aXMpKSk7XG4gICAgdmFyIF9hID0gY29uY2F0X3V0aWwuY29tcHV0ZUdyYWRpZW50U2xpY2VTaGFwZXMoYTJELnNoYXBlLCBiMkQuc2hhcGUpLCBhQmVnaW4gPSBfYS5hQmVnaW4sIGFTaXplID0gX2EuYVNpemUsIGJCZWdpbiA9IF9hLmJCZWdpbiwgYlNpemUgPSBfYS5iU2l6ZTtcbiAgICB2YXIgZGVyID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgIHJldHVybiB7IGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LnNsaWNlKGFCZWdpbiwgYVNpemUpOyB9LCBiOiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5zbGljZShiQmVnaW4sIGJTaXplKTsgfSB9O1xuICAgIH07XG4gICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY29uY2F0KGEyRCwgYjJEKTsgfSwgeyBhOiBhMkQsIGI6IGIyRCB9LCBkZXIpO1xuICAgIHJldHVybiByZXMucmVzaGFwZShvdXRTaGFwZSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBhc3NlcnRQYXJhbXMoYVNoYXBlLCBiU2hhcGUsIGF4aXMpIHtcbiAgICB2YXIgYVJhbmsgPSBhU2hhcGUubGVuZ3RoO1xuICAgIHZhciBiUmFuayA9IGJTaGFwZS5sZW5ndGg7XG4gICAgdXRpbC5hc3NlcnQoYVNoYXBlLmxlbmd0aCA9PT0gYlNoYXBlLmxlbmd0aCwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiByYW5rIG9mIHgxIChcIiArIGFSYW5rICsgXCIpIGFuZCB4MiAoXCIgKyBiUmFuayArIFwiKSBcIiArXG4gICAgICAgIFwibXVzdCBiZSB0aGUgc2FtZS5cIik7XG4gICAgdXRpbC5hc3NlcnQoYXhpcyA+PSAwICYmIGF4aXMgPCBhUmFuaywgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBheGlzIG11c3QgYmUgXCIgK1xuICAgICAgICAoXCJiZXR3ZWVuIDAgYW5kIFwiICsgKGFSYW5rIC0gMSkgKyBcIi5cIikpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYVJhbms7IGkrKykge1xuICAgICAgICB1dGlsLmFzc2VydCgoaSA9PT0gYXhpcykgfHwgKGFTaGFwZVtpXSA9PT0gYlNoYXBlW2ldKSwgXCJFcnJvciBpbiBjb25jYXRcIiArIGFSYW5rICsgXCJEOiBTaGFwZSAoXCIgKyBhU2hhcGUgKyBcIikgZG9lcyBub3QgbWF0Y2ggXCIgK1xuICAgICAgICAgICAgKFwiKFwiICsgYlNoYXBlICsgXCIpIGFsb25nIHRoZSBub24tY29uY2F0ZW5hdGVkIGF4aXMgXCIgKyBpICsgXCIuXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydFBhcmFtcyA9IGFzc2VydFBhcmFtcztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRTaGFwZTFEKHgxU2hhcGUsIHgyU2hhcGUpIHtcbiAgICB1dGlsLmFzc2VydCh4MVNoYXBlLmxlbmd0aCA9PT0gMSAmJiB4MlNoYXBlLmxlbmd0aCA9PT0gMSwgJ3gxIGFuZCB4MiBzaG91bGQgYmUgMWQgYXJyYXkuJyk7XG4gICAgdmFyIG91dHB1dFNoYXBlID0geDFTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlWzBdICs9IHgyU2hhcGVbMF07XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xufVxuZXhwb3J0cy5jb21wdXRlT3V0U2hhcGUxRCA9IGNvbXB1dGVPdXRTaGFwZTFEO1xuZnVuY3Rpb24gY29tcHV0ZU91dFNoYXBlKHgxU2hhcGUsIHgyU2hhcGUsIGF4aXMpIHtcbiAgICB1dGlsLmFzc2VydCh4MVNoYXBlLmxlbmd0aCA9PT0geDJTaGFwZS5sZW5ndGgsICd4MSBhbmQgeDIgc2hvdWxkIGhhdmUgdGhlIHNhbWUgcmFuay4nKTtcbiAgICB2YXIgb3V0cHV0U2hhcGUgPSB4MVNoYXBlLnNsaWNlKCk7XG4gICAgb3V0cHV0U2hhcGVbYXhpc10gKz0geDJTaGFwZVtheGlzXTtcbiAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG59XG5leHBvcnRzLmNvbXB1dGVPdXRTaGFwZSA9IGNvbXB1dGVPdXRTaGFwZTtcbmZ1bmN0aW9uIGNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzKGFTaGFwZSwgYlNoYXBlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYUJlZ2luOiBbMCwgMF0sXG4gICAgICAgIGFTaXplOiBhU2hhcGUsXG4gICAgICAgIGJCZWdpbjogWzAsIGFTaGFwZVsxXV0sXG4gICAgICAgIGJTaXplOiBiU2hhcGVcbiAgICB9O1xufVxuZXhwb3J0cy5jb21wdXRlR3JhZGllbnRTbGljZVNoYXBlcyA9IGNvbXB1dGVHcmFkaWVudFNsaWNlU2hhcGVzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBDb252T3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBDb252T3BzKCkge1xuICAgIH1cbiAgICBDb252T3BzLmNvbnYxZCA9IGZ1bmN0aW9uIChpbnB1dCwgZmlsdGVyLCBzdHJpZGUsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHZhciBpbnB1dDNEID0gaW5wdXQ7XG4gICAgICAgIHZhciByZXNoYXBlZFRvM0QgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlucHV0LnJhbmsgPT09IDIpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG8zRCA9IHRydWU7XG4gICAgICAgICAgICBpbnB1dDNEID0gaW5wdXQuYXMzRCgxLCBpbnB1dC5zaGFwZVswXSwgaW5wdXQuc2hhcGVbMV0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0M0QucmFuayA9PT0gMywgXCJFcnJvciBpbiBjb252MWQ6IGlucHV0IG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgKyBpbnB1dDNELnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSAzLCBcIkVycm9yIGluIGNvbnYxZDogZmlsdGVyIG11c3QgYmUgcmFuayAzLCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gY29udjFkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQzRC5zaGFwZVsyXSA9PT0gZmlsdGVyLnNoYXBlWzFdLCBcIkVycm9yIGluIGNvbnYxZDogZGVwdGggb2YgaW5wdXQgKFwiICsgaW5wdXQzRC5zaGFwZVsyXSArIFwiKSBtdXN0IG1hdGNoICBcIiArXG4gICAgICAgICAgICAoXCJpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzFdICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGZpbHRlcjREID0gZmlsdGVyLmFzNEQoMSwgZmlsdGVyLnNoYXBlWzBdLCBmaWx0ZXIuc2hhcGVbMV0sIGZpbHRlci5zaGFwZVsyXSk7XG4gICAgICAgIHZhciBpbnB1dDREID0gaW5wdXQzRC5hczREKGlucHV0M0Quc2hhcGVbMF0sIDEsIGlucHV0M0Quc2hhcGVbMV0sIGlucHV0M0Quc2hhcGVbMl0pO1xuICAgICAgICB2YXIgc3RyaWRlcyA9IFsxLCBzdHJpZGVdO1xuICAgICAgICB2YXIgcmVzID0gQ29udk9wcy5jb252MmQoaW5wdXQ0RCwgZmlsdGVyNEQsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG8zRCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczJEKHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzBdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgfTtcbiAgICBDb252T3BzLmNvbnYyZCA9IGZ1bmN0aW9uICh4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCByYW5rIFwiICsgeDRELnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gY29udjJkOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnNoYXBlWzNdID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkOiBkZXB0aCBvZiBpbnB1dCAoXCIgKyB4NEQuc2hhcGVbM10gKyBcIikgbXVzdCBtYXRjaCAgXCIgK1xuICAgICAgICAgICAgKFwiaW5wdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBDb252T3BzLmNvbnYyZERlcklucHV0KHg0RC5zaGFwZSwgZHksIGZpbHRlciwgc3RyaWRlcywgcGFkKTsgfSxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENvbnZPcHMuY29udjJkRGVyRmlsdGVyKHg0RCwgZHksIGZpbHRlci5zaGFwZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5jb252MmQoeDRELCBmaWx0ZXIsIGNvbnZJbmZvKTsgfSwgeyB4OiB4NEQsIGZpbHRlcjogZmlsdGVyIH0sIGdyYWQpO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIENvbnZPcHMuY29udjJkRGVySW5wdXQgPSBmdW5jdGlvbiAoeFNoYXBlLCBkeSwgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh4U2hhcGUubGVuZ3RoID09PSBkeS5yYW5rLCBcIkxlbmd0aCBvZiBpblNoYXBlIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIHhTaGFwZS5sZW5ndGggKyBcIikgYW5kIHJhbmsgb2YgZHkgKFwiICsgZHkucmFuayArIFwiKSBtdXN0IG1hdGNoXCIpKTtcbiAgICAgICAgdmFyIHhTaGFwZTREID0geFNoYXBlO1xuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChkeS5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgICAgICAgICB4U2hhcGU0RCA9IFsxLCB4U2hhcGVbMF0sIHhTaGFwZVsxXSwgeFNoYXBlWzJdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5EZXB0aCA9IHhTaGFwZTREWzNdO1xuICAgICAgICB2YXIgb3V0RGVwdGggPSBkeTRELnNoYXBlWzNdO1xuICAgICAgICB1dGlsLmFzc2VydCh4U2hhcGU0RC5sZW5ndGggPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGluU2hhcGUgbXVzdCBiZSBsZW5ndGggNCwgYnV0IGdvdCBsZW5ndGggXCIgK1xuICAgICAgICAgICAgKHhTaGFwZTRELmxlbmd0aCArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGR5NEQucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXIucmFuayA9PT0gNCwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBmaWx0ZXIucmFuaykpO1xuICAgICAgICB1dGlsLmFzc2VydChpbkRlcHRoID09PSBmaWx0ZXIuc2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVySW5wdXQ6IGRlcHRoIG9mIGlucHV0IChcIiArIGluRGVwdGggKyBcIikgbXVzdCBcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBpbnB1dCBkZXB0aCBmb3IgZmlsdGVyIFwiICsgZmlsdGVyLnNoYXBlWzJdICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQob3V0RGVwdGggPT09IGZpbHRlci5zaGFwZVszXSwgXCJFcnJvciBpbiBjb252MmREZXJJbnB1dDogZGVwdGggb2Ygb3V0cHV0IChcIiArIG91dERlcHRoICsgXCIpIG11c3RcIiArXG4gICAgICAgICAgICAoXCJtYXRjaCBvdXRwdXQgZGVwdGggZm9yIGZpbHRlciBcIiArIGZpbHRlci5zaGFwZVszXSArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZERlcklucHV0OiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyh4U2hhcGU0RCwgZmlsdGVyLnNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY29udjJkRGVySW5wdXQoZHk0RCwgZmlsdGVyLCBjb252SW5mbyk7IH0sIHsgZHk0RDogZHk0RCB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBDb252T3BzLmNvbnYyZERlckZpbHRlciA9IGZ1bmN0aW9uICh4LCBkeSwgZmlsdGVyU2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICBpZiAoeC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR5NEQgPSBkeTtcbiAgICAgICAgaWYgKGR5NEQucmFuayA9PT0gMykge1xuICAgICAgICAgICAgZHk0RCA9IGR5LmFzNEQoMSwgZHkuc2hhcGVbMF0sIGR5LnNoYXBlWzFdLCBkeS5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoeDRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCwgYnV0IGdvdCBzaGFwZSBcIiArXG4gICAgICAgICAgICAoeDRELnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoZHk0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZHkgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKGR5NEQuc2hhcGUgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChmaWx0ZXJTaGFwZS5sZW5ndGggPT09IDQsIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBmaWx0ZXJTaGFwZSBtdXN0IGJlIGxlbmd0aCA0LCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChmaWx0ZXJTaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHg0RC5zaGFwZVszXSA9PT0gZmlsdGVyU2hhcGVbMl0sIFwiRXJyb3IgaW4gY29udjJkRGVyRmlsdGVyOiBkZXB0aCBvZiBpbnB1dCBcIiArIHg0RC5zaGFwZVszXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIGlucHV0IGRlcHRoIGluIGZpbHRlciAoXCIgKyBmaWx0ZXJTaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQuc2hhcGVbM10gPT09IGZpbHRlclNoYXBlWzNdLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogZGVwdGggb2YgZHkgKFwiICsgZHk0RC5zaGFwZVszXSArIFwiKSBtdXN0IFwiICtcbiAgICAgICAgICAgIChcIm1hdGNoIG91dHB1dCBkZXB0aCBmb3IgZmlsdGVyIChcIiArIGZpbHRlclNoYXBlWzNdICsgXCIpLlwiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGNvbnYyZERlckZpbHRlcjogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkaWxhdGlvbnMgPSAxO1xuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZUNvbnYyREluZm8oeDRELnNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvbnYyZERlckZpbHRlcih4NEQsIGR5NEQsIGNvbnZJbmZvKTsgfSwgeyB4NEQ6IHg0RCwgZHk0RDogZHk0RCB9KTtcbiAgICB9O1xuICAgIENvbnZPcHMuY29udjJkVHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIGZpbHRlciwgb3V0cHV0U2hhcGUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHJldHVybiBDb252T3BzLmNvbnYyZERlcklucHV0KG91dHB1dFNoYXBlLCB4LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIENvbnZPcHMuZGVwdGh3aXNlQ29udjJkID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGlsYXRpb25zLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgaWYgKGRpbGF0aW9ucyA9PT0gdm9pZCAwKSB7IGRpbGF0aW9ucyA9IFsxLCAxXTsgfVxuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogaW5wdXQgbXVzdCBiZSByYW5rIDQsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIGlucHV0NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGZpbHRlci5yYW5rID09PSA0LCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogZmlsdGVyIG11c3QgYmUgcmFuayA0LCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGZpbHRlci5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5zaGFwZVszXSA9PT0gZmlsdGVyLnNoYXBlWzJdLCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogbnVtYmVyIG9mIGlucHV0IGNoYW5uZWxzIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIGlucHV0NEQuc2hhcGVbM10gKyBcIikgbXVzdCBtYXRjaCB0aGUgaW5DaGFubmVscyBkaW1lbnNpb24gaW4gXCIpICtcbiAgICAgICAgICAgIChcImZpbHRlciBcIiArIGZpbHRlci5zaGFwZVsyXSArIFwiLlwiKSk7XG4gICAgICAgIGlmIChkaWxhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGlsYXRpb25zID0gWzEsIDFdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IHBhcnNlVHVwbGVQYXJhbShkaWxhdGlvbnMpLCBkaWxhdGlvbkhlaWdodCA9IF9hWzBdLCBkaWxhdGlvbldpZHRoID0gX2FbMV07XG4gICAgICAgIHV0aWwuYXNzZXJ0KGRpbGF0aW9uSGVpZ2h0ID09PSAxICYmIGRpbGF0aW9uV2lkdGggPT09IDEsICdFcnJvciBpbiBkZXB0aHdpc2VDb252MkQ6IGRpbGF0aW9uIHJhdGVzIGdyZWF0ZXIgdGhhbiAxIGFyZSBub3QgeWV0ICcgK1xuICAgICAgICAgICAgKFwic3VwcG9ydGVkLiBHb3QgZGlsYXRpb25zICdcIiArIGRpbGF0aW9ucyArIFwiJ1wiKSk7XG4gICAgICAgIGlmIChkaW1Sb3VuZGluZ01vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChwYWQpLCBcIkVycm9yIGluIGRlcHRod2lzZUNvbnYyRDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlQ29udjJESW5mbyhpbnB1dDRELnNoYXBlLCBmaWx0ZXIuc2hhcGUsIHN0cmlkZXMsIGRpbGF0aW9ucywgcGFkLCBkaW1Sb3VuZGluZ01vZGUsIHRydWUpO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5kZXB0aHdpc2VDb252MkQoaW5wdXQ0RCwgZmlsdGVyLCBjb252SW5mbyk7IH0sIHsgaW5wdXQ0RDogaW5wdXQ0RCwgZmlsdGVyOiBmaWx0ZXIgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MWRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0NvbnZvbHV0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgQ29udk9wcywgXCJjb252MmRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkRGVySW5wdXRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkRGVyRmlsdGVyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiY29udjJkVHJhbnNwb3NlXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIENvbnZPcHMsIFwiZGVwdGh3aXNlQ29udjJkXCIsIG51bGwpO1xuICAgIHJldHVybiBDb252T3BzO1xufSgpKTtcbmV4cG9ydHMuQ29udk9wcyA9IENvbnZPcHM7XG5mdW5jdGlvbiBwYXJzZVR1cGxlUGFyYW0ocGFyYW0pIHtcbiAgICByZXR1cm4gdHlwZW9mIHBhcmFtID09PSAnbnVtYmVyJyA/IFtwYXJhbSwgcGFyYW1dIDogcGFyYW07XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG5mdW5jdGlvbiBjb21wdXRlUG9vbDJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIHJvdW5kaW5nTW9kZSwgZGF0YUZvcm1hdCkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSB2b2lkIDApIHsgZGF0YUZvcm1hdCA9ICdjaGFubmVsc0xhc3QnOyB9XG4gICAgdmFyIF9hID0gcGFyc2VUdXBsZVBhcmFtKGZpbHRlclNpemUpLCBmaWx0ZXJIZWlnaHQgPSBfYVswXSwgZmlsdGVyV2lkdGggPSBfYVsxXTtcbiAgICB2YXIgZmlsdGVyU2hhcGU7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIGZpbHRlclNoYXBlID0gW2ZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIGluU2hhcGVbM10sIGluU2hhcGVbM11dO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgZmlsdGVyU2hhcGUgPSBbZmlsdGVySGVpZ2h0LCBmaWx0ZXJXaWR0aCwgaW5TaGFwZVsxXSwgaW5TaGFwZVsxXV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIgKyBkYXRhRm9ybWF0KTtcbiAgICB9XG4gICAgdmFyIGRpbGF0aW9ucyA9IDE7XG4gICAgcmV0dXJuIGNvbXB1dGVDb252MkRJbmZvKGluU2hhcGUsIGZpbHRlclNoYXBlLCBzdHJpZGVzLCBkaWxhdGlvbnMsIHBhZCwgcm91bmRpbmdNb2RlLCBmYWxzZSwgZGF0YUZvcm1hdCk7XG59XG5leHBvcnRzLmNvbXB1dGVQb29sMkRJbmZvID0gY29tcHV0ZVBvb2wyREluZm87XG5mdW5jdGlvbiBjb21wdXRlQ29udjJESW5mbyhpblNoYXBlLCBmaWx0ZXJTaGFwZSwgc3RyaWRlcywgZGlsYXRpb25zLCBwYWQsIHJvdW5kaW5nTW9kZSwgZGVwdGh3aXNlLCBkYXRhRm9ybWF0KSB7XG4gICAgaWYgKGRlcHRod2lzZSA9PT0gdm9pZCAwKSB7IGRlcHRod2lzZSA9IGZhbHNlOyB9XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09IHZvaWQgMCkgeyBkYXRhRm9ybWF0ID0gJ2NoYW5uZWxzTGFzdCc7IH1cbiAgICB2YXIgX2EgPSBbLTEsIC0xLCAtMSwgLTFdLCBiYXRjaFNpemUgPSBfYVswXSwgaW5IZWlnaHQgPSBfYVsxXSwgaW5XaWR0aCA9IF9hWzJdLCBpbkNoYW5uZWxzID0gX2FbM107XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIGJhdGNoU2l6ZSA9IGluU2hhcGVbMF0sIGluSGVpZ2h0ID0gaW5TaGFwZVsxXSwgaW5XaWR0aCA9IGluU2hhcGVbMl0sIGluQ2hhbm5lbHMgPSBpblNoYXBlWzNdO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgYmF0Y2hTaXplID0gaW5TaGFwZVswXSwgaW5DaGFubmVscyA9IGluU2hhcGVbMV0sIGluSGVpZ2h0ID0gaW5TaGFwZVsyXSwgaW5XaWR0aCA9IGluU2hhcGVbM107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGRhdGFGb3JtYXQgXCIgKyBkYXRhRm9ybWF0KTtcbiAgICB9XG4gICAgdmFyIGZpbHRlckhlaWdodCA9IGZpbHRlclNoYXBlWzBdLCBmaWx0ZXJXaWR0aCA9IGZpbHRlclNoYXBlWzFdLCBmaWx0ZXJDaGFubmVscyA9IGZpbHRlclNoYXBlWzNdO1xuICAgIHZhciBfYiA9IHBhcnNlVHVwbGVQYXJhbShzdHJpZGVzKSwgc3RyaWRlSGVpZ2h0ID0gX2JbMF0sIHN0cmlkZVdpZHRoID0gX2JbMV07XG4gICAgdmFyIF9jID0gcGFyc2VUdXBsZVBhcmFtKGRpbGF0aW9ucyksIGRpbGF0aW9uSGVpZ2h0ID0gX2NbMF0sIGRpbGF0aW9uV2lkdGggPSBfY1sxXTtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVySGVpZ2h0ID0gZ2V0RWZmZWN0aXZlRmlsdGVyU2l6ZShmaWx0ZXJIZWlnaHQsIGRpbGF0aW9uSGVpZ2h0KTtcbiAgICB2YXIgZWZmZWN0aXZlRmlsdGVyV2lkdGggPSBnZXRFZmZlY3RpdmVGaWx0ZXJTaXplKGZpbHRlcldpZHRoLCBkaWxhdGlvbldpZHRoKTtcbiAgICB2YXIgX2QgPSBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGVmZmVjdGl2ZUZpbHRlckhlaWdodCwgZWZmZWN0aXZlRmlsdGVyV2lkdGgsIHJvdW5kaW5nTW9kZSksIHBhZEluZm8gPSBfZC5wYWRJbmZvLCBvdXRIZWlnaHQgPSBfZC5vdXRIZWlnaHQsIG91dFdpZHRoID0gX2Qub3V0V2lkdGg7XG4gICAgdmFyIG91dENoYW5uZWxzID0gZGVwdGh3aXNlID8gZmlsdGVyQ2hhbm5lbHMgKiBpbkNoYW5uZWxzIDogZmlsdGVyQ2hhbm5lbHM7XG4gICAgdmFyIG91dFNoYXBlO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgb3V0U2hhcGUgPSBbYmF0Y2hTaXplLCBvdXRDaGFubmVscywgb3V0SGVpZ2h0LCBvdXRXaWR0aF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIG91dFNoYXBlID0gW2JhdGNoU2l6ZSwgb3V0SGVpZ2h0LCBvdXRXaWR0aCwgb3V0Q2hhbm5lbHNdO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBiYXRjaFNpemU6IGJhdGNoU2l6ZSxcbiAgICAgICAgZGF0YUZvcm1hdDogZGF0YUZvcm1hdCxcbiAgICAgICAgaW5IZWlnaHQ6IGluSGVpZ2h0LFxuICAgICAgICBpbldpZHRoOiBpbldpZHRoLFxuICAgICAgICBpbkNoYW5uZWxzOiBpbkNoYW5uZWxzLFxuICAgICAgICBvdXRIZWlnaHQ6IG91dEhlaWdodCxcbiAgICAgICAgb3V0V2lkdGg6IG91dFdpZHRoLFxuICAgICAgICBvdXRDaGFubmVsczogb3V0Q2hhbm5lbHMsXG4gICAgICAgIHBhZEluZm86IHBhZEluZm8sXG4gICAgICAgIHN0cmlkZUhlaWdodDogc3RyaWRlSGVpZ2h0LFxuICAgICAgICBzdHJpZGVXaWR0aDogc3RyaWRlV2lkdGgsXG4gICAgICAgIGZpbHRlckhlaWdodDogZmlsdGVySGVpZ2h0LFxuICAgICAgICBmaWx0ZXJXaWR0aDogZmlsdGVyV2lkdGgsXG4gICAgICAgIGluU2hhcGU6IGluU2hhcGUsXG4gICAgICAgIG91dFNoYXBlOiBvdXRTaGFwZSxcbiAgICAgICAgZmlsdGVyU2hhcGU6IGZpbHRlclNoYXBlXG4gICAgfTtcbn1cbmV4cG9ydHMuY29tcHV0ZUNvbnYyREluZm8gPSBjb21wdXRlQ29udjJESW5mbztcbmZ1bmN0aW9uIGNvbXB1dGVPdXRwdXRTaGFwZTNEKGluU2hhcGUsIGZpZWxkU2l6ZSwgb3V0RGVwdGgsIHN0cmlkZSwgemVyb1BhZCwgcm91bmRpbmdNb2RlKSB7XG4gICAgaWYgKHplcm9QYWQgPT0gbnVsbCkge1xuICAgICAgICB6ZXJvUGFkID0gY29tcHV0ZURlZmF1bHRQYWQoaW5TaGFwZSwgZmllbGRTaXplLCBzdHJpZGUpO1xuICAgIH1cbiAgICB2YXIgaW5wdXRSb3dzID0gaW5TaGFwZVswXTtcbiAgICB2YXIgaW5wdXRDb2xzID0gaW5TaGFwZVsxXTtcbiAgICB2YXIgb3V0cHV0Um93cyA9IGNvbmRpdGlvbmFsUm91bmQoKGlucHV0Um93cyAtIGZpZWxkU2l6ZSArIDIgKiB6ZXJvUGFkKSAvIHN0cmlkZSArIDEsIHJvdW5kaW5nTW9kZSk7XG4gICAgdXRpbC5hc3NlcnQodXRpbC5pc0ludChvdXRwdXRSb3dzKSwgXCJUaGUgb3V0cHV0ICMgb2Ygcm93cyAoXCIgKyBvdXRwdXRSb3dzICsgXCIpIG11c3QgYmUgYW4gaW50ZWdlci4gQ2hhbmdlIHRoZSBcIiArXG4gICAgICAgIFwic3RyaWRlIGFuZC9vciB6ZXJvIHBhZCBwYXJhbWV0ZXJzXCIpO1xuICAgIHZhciBvdXRwdXRDb2xzID0gY29uZGl0aW9uYWxSb3VuZCgoaW5wdXRDb2xzIC0gZmllbGRTaXplICsgMiAqIHplcm9QYWQpIC8gc3RyaWRlICsgMSwgcm91bmRpbmdNb2RlKTtcbiAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KG91dHB1dENvbHMpLCBcIlRoZSBvdXRwdXQgIyBvZiBjb2x1bW5zIChcIiArIG91dHB1dENvbHMgKyBcIikgbXVzdCBiZSBhbiBpbnRlZ2VyLiBDaGFuZ2UgXCIgK1xuICAgICAgICBcInRoZSBzdHJpZGUgYW5kL29yIHplcm8gcGFkIHBhcmFtZXRlcnNcIik7XG4gICAgcmV0dXJuIFtvdXRwdXRSb3dzLCBvdXRwdXRDb2xzLCBvdXREZXB0aF07XG59XG5leHBvcnRzLmNvbXB1dGVPdXRwdXRTaGFwZTNEID0gY29tcHV0ZU91dHB1dFNoYXBlM0Q7XG5mdW5jdGlvbiBjb21wdXRlRGVmYXVsdFBhZChpbnB1dFNoYXBlLCBmaWVsZFNpemUsIHN0cmlkZSkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKChpbnB1dFNoYXBlWzBdICogKHN0cmlkZSAtIDEpIC0gc3RyaWRlICsgZmllbGRTaXplKSAvIDIpO1xufVxuZXhwb3J0cy5jb21wdXRlRGVmYXVsdFBhZCA9IGNvbXB1dGVEZWZhdWx0UGFkO1xuZnVuY3Rpb24gY29tcHV0ZVdlaWdodHNTaGFwZTREKGlucHV0RGVwdGgsIG91dHB1dERlcHRoLCBmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoKSB7XG4gICAgcmV0dXJuIFtmaWx0ZXJIZWlnaHQsIGZpbHRlcldpZHRoLCBpbnB1dERlcHRoLCBvdXRwdXREZXB0aF07XG59XG5leHBvcnRzLmNvbXB1dGVXZWlnaHRzU2hhcGU0RCA9IGNvbXB1dGVXZWlnaHRzU2hhcGU0RDtcbmZ1bmN0aW9uIGNvbXB1dGVEaWxhdGVkUkMocmMsIG9yaWdTdHJpZGUpIHtcbiAgICB2YXIgcm93c0RpbGF0ZWQgPSAocmNbMF0gLSAxKSAqIG9yaWdTdHJpZGUgKyAxO1xuICAgIHZhciBjb2xzRGlsYXRlZCA9IChyY1sxXSAtIDEpICogb3JpZ1N0cmlkZSArIDE7XG4gICAgcmV0dXJuIFtyb3dzRGlsYXRlZCwgY29sc0RpbGF0ZWRdO1xufVxuZXhwb3J0cy5jb21wdXRlRGlsYXRlZFJDID0gY29tcHV0ZURpbGF0ZWRSQztcbmZ1bmN0aW9uIHBhcnNlVHVwbGVQYXJhbShwYXJhbSkge1xuICAgIHJldHVybiB0eXBlb2YgcGFyYW0gPT09ICdudW1iZXInID8gW3BhcmFtLCBwYXJhbV0gOiBwYXJhbTtcbn1cbmZ1bmN0aW9uIGdldEVmZmVjdGl2ZUZpbHRlclNpemUoZmlsdGVyU2l6ZSwgZGlsYXRpb24pIHtcbiAgICBpZiAoZGlsYXRpb24gPD0gMSkge1xuICAgICAgICByZXR1cm4gZmlsdGVyU2l6ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XG59XG5mdW5jdGlvbiBnZXRQYWRBbmRPdXRJbmZvKHBhZCwgaW5IZWlnaHQsIGluV2lkdGgsIHN0cmlkZUhlaWdodCwgc3RyaWRlV2lkdGgsIGZpbHRlckhlaWdodCwgZmlsdGVyV2lkdGgsIHJvdW5kaW5nTW9kZSkge1xuICAgIHZhciBwYWRJbmZvO1xuICAgIHZhciBvdXRIZWlnaHQ7XG4gICAgdmFyIG91dFdpZHRoO1xuICAgIGlmICh0eXBlb2YgcGFkID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYWRJbmZvID0geyB0b3A6IHBhZCwgYm90dG9tOiBwYWQsIGxlZnQ6IHBhZCwgcmlnaHQ6IHBhZCB9O1xuICAgICAgICB2YXIgb3V0U2hhcGUgPSBjb21wdXRlT3V0cHV0U2hhcGUzRChbaW5IZWlnaHQsIGluV2lkdGgsIDFdLCBmaWx0ZXJIZWlnaHQsIDEsIHN0cmlkZUhlaWdodCwgcGFkLCByb3VuZGluZ01vZGUpO1xuICAgICAgICBvdXRIZWlnaHQgPSBvdXRTaGFwZVswXTtcbiAgICAgICAgb3V0V2lkdGggPSBvdXRTaGFwZVsxXTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAnc2FtZScpIHtcbiAgICAgICAgb3V0SGVpZ2h0ID0gTWF0aC5jZWlsKGluSGVpZ2h0IC8gc3RyaWRlSGVpZ2h0KTtcbiAgICAgICAgb3V0V2lkdGggPSBNYXRoLmNlaWwoaW5XaWR0aCAvIHN0cmlkZVdpZHRoKTtcbiAgICAgICAgdmFyIHBhZEFsb25nSGVpZ2h0ID0gKG91dEhlaWdodCAtIDEpICogc3RyaWRlSGVpZ2h0ICsgZmlsdGVySGVpZ2h0IC0gaW5IZWlnaHQ7XG4gICAgICAgIHZhciBwYWRBbG9uZ1dpZHRoID0gKG91dFdpZHRoIC0gMSkgKiBzdHJpZGVXaWR0aCArIGZpbHRlcldpZHRoIC0gaW5XaWR0aDtcbiAgICAgICAgdmFyIHRvcF8xID0gTWF0aC5mbG9vcihwYWRBbG9uZ0hlaWdodCAvIDIpO1xuICAgICAgICB2YXIgYm90dG9tID0gcGFkQWxvbmdIZWlnaHQgLSB0b3BfMTtcbiAgICAgICAgdmFyIGxlZnQgPSBNYXRoLmZsb29yKHBhZEFsb25nV2lkdGggLyAyKTtcbiAgICAgICAgdmFyIHJpZ2h0ID0gcGFkQWxvbmdXaWR0aCAtIGxlZnQ7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogdG9wXzEsIGJvdHRvbTogYm90dG9tLCBsZWZ0OiBsZWZ0LCByaWdodDogcmlnaHQgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFkID09PSAndmFsaWQnKSB7XG4gICAgICAgIHBhZEluZm8gPSB7IHRvcDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCByaWdodDogMCB9O1xuICAgICAgICBvdXRIZWlnaHQgPSBNYXRoLmNlaWwoKGluSGVpZ2h0IC0gZmlsdGVySGVpZ2h0ICsgMSkgLyBzdHJpZGVIZWlnaHQpO1xuICAgICAgICBvdXRXaWR0aCA9IE1hdGguY2VpbCgoaW5XaWR0aCAtIGZpbHRlcldpZHRoICsgMSkgLyBzdHJpZGVXaWR0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIlVua25vd24gcGFkZGluZyBwYXJhbWV0ZXI6IFwiICsgcGFkKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgcGFkSW5mbzogcGFkSW5mbywgb3V0SGVpZ2h0OiBvdXRIZWlnaHQsIG91dFdpZHRoOiBvdXRXaWR0aCB9O1xufVxuZnVuY3Rpb24gY29uZGl0aW9uYWxSb3VuZCh2YWx1ZSwgcm91bmRpbmdNb2RlKSB7XG4gICAgaWYgKCFyb3VuZGluZ01vZGUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdW5kaW5nTW9kZSkge1xuICAgICAgICBjYXNlICdyb3VuZCc6XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ2NlaWwnOlxuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbCh2YWx1ZSk7XG4gICAgICAgIGNhc2UgJ2Zsb29yJzpcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmZsb29yKHZhbHVlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gcm91bmRpbmdNb2RlIFwiICsgcm91bmRpbmdNb2RlKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgSW1hZ2VPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEltYWdlT3BzKCkge1xuICAgIH1cbiAgICBJbWFnZU9wcy5yZXNpemVCaWxpbmVhciA9IGZ1bmN0aW9uIChpbWFnZXMsIHNpemUsIGFsaWduQ29ybmVycykge1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW1hZ2VzLnJhbmsgPT09IDMgfHwgaW1hZ2VzLnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gcmVzaXplQmlsaW5lYXI6IHggbXVzdCBiZSByYW5rIDMgb3IgNCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJyYW5rIFwiICsgaW1hZ2VzLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChzaXplLmxlbmd0aCA9PT0gMiwgXCJFcnJvciBpbiByZXNpemVCaWxpbmVhcjogbmV3IHNoYXBlIG11c3QgMkQsIGJ1dCBnb3Qgc2hhcGUgXCIgK1xuICAgICAgICAgICAgKHNpemUgKyBcIi5cIikpO1xuICAgICAgICB2YXIgYmF0Y2hJbWFnZXMgPSBpbWFnZXM7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGltYWdlcy5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgYmF0Y2hJbWFnZXMgPVxuICAgICAgICAgICAgICAgIGltYWdlcy5hczREKDEsIGltYWdlcy5zaGFwZVswXSwgaW1hZ2VzLnNoYXBlWzFdLCBpbWFnZXMuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuZXdIZWlnaHQgPSBzaXplWzBdLCBuZXdXaWR0aCA9IHNpemVbMV07XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnJlc2l6ZUJpbGluZWFyKGJhdGNoSW1hZ2VzLCBuZXdIZWlnaHQsIG5ld1dpZHRoLCBhbGlnbkNvcm5lcnMpOyB9LCB7IGJhdGNoSW1hZ2VzOiBiYXRjaEltYWdlcyB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnSW1hZ2VzJywgbmFtZXNwYWNlOiAnaW1hZ2UnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBJbWFnZU9wcywgXCJyZXNpemVCaWxpbmVhclwiLCBudWxsKTtcbiAgICByZXR1cm4gSW1hZ2VPcHM7XG59KCkpO1xuZXhwb3J0cy5JbWFnZU9wcyA9IEltYWdlT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi4vdHlwZXNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGJyb2FkY2FzdF91dGlsID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0X3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgTG9naWNhbE9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTG9naWNhbE9wcygpIHtcbiAgICB9XG4gICAgTG9naWNhbE9wcy5sb2dpY2FsTm90ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmxvZ2ljYWxOb3QoeCk7IH0sIHsgeDogeCB9KTtcbiAgICB9O1xuICAgIExvZ2ljYWxPcHMubG9naWNhbEFuZCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEuZHR5cGUgPT09ICdib29sJyAmJiBiLmR0eXBlID09PSAnYm9vbCcsICdFcnJvciBBcnJheSBtdXN0IGJlIG9mIHR5cGUgYm9vbC4nKTtcbiAgICAgICAgYnJvYWRjYXN0X3V0aWwuYXNzZXJ0QW5kR2V0QnJvYWRjYXN0U2hhcGUoYS5zaGFwZSwgYi5zaGFwZSk7XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmxvZ2ljYWxBbmQoYSwgYik7IH0sIHsgYTogYSwgYjogYiB9KTtcbiAgICB9O1xuICAgIExvZ2ljYWxPcHMubG9naWNhbE9yID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoYS5kdHlwZSA9PT0gJ2Jvb2wnICYmIGIuZHR5cGUgPT09ICdib29sJywgJ0Vycm9yIEFycmF5IG11c3QgYmUgb2YgdHlwZSBib29sLicpO1xuICAgICAgICBicm9hZGNhc3RfdXRpbC5hc3NlcnRBbmRHZXRCcm9hZGNhc3RTaGFwZShhLnNoYXBlLCBiLnNoYXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9naWNhbE9yKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBMb2dpY2FsT3BzLmxvZ2ljYWxYb3IgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydChhLmR0eXBlID09PSAnYm9vbCcgJiYgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIGJyb2FkY2FzdF91dGlsLmFzc2VydEFuZEdldEJyb2FkY2FzdFNoYXBlKGEuc2hhcGUsIGIuc2hhcGUpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5sb2dpY2FsWG9yKGEsIGIpOyB9LCB7IGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBMb2dpY2FsT3BzLndoZXJlID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgYSwgYikge1xuICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uZHR5cGUgPT09ICdib29sJyB8fCBhLmR0eXBlID09PSAnYm9vbCcgfHwgYi5kdHlwZSA9PT0gJ2Jvb2wnLCAnRXJyb3IgQXJyYXkgbXVzdCBiZSBvZiB0eXBlIGJvb2wuJyk7XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2goYS5zaGFwZSwgYi5zaGFwZSwgJ0Vycm9yIGluIHdoZXJlOiAnKTtcbiAgICAgICAgaWYgKGNvbmRpdGlvbi5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydChjb25kaXRpb24uc2hhcGVbMF0gPT09IGEuc2hhcGVbMF0sICdUaGUgZmlyc3QgZGltZW5zaW9uIG9mIGBhYCBtdXN0IG1hdGNoIHRoZSBzaXplIG9mIGBjb25kaXRpb25gLicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXRpbC5hc3NlcnRTaGFwZXNNYXRjaChjb25kaXRpb24uc2hhcGUsIGIuc2hhcGUsICdFcnJvciBpbiB3aGVyZTogJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGR0eXBlID0gdHlwZXMudXBjYXN0VHlwZShhLmR0eXBlLCBiLmR0eXBlKTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQud2hlcmUoY29uZGl0aW9uLCBhLCBiLCBkdHlwZSk7IH0sIHsgY29uZGl0aW9uOiBjb25kaXRpb24sIGE6IGEsIGI6IGIgfSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbE5vdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbEFuZFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTG9naWNhbCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExvZ2ljYWxPcHMsIFwibG9naWNhbE9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJsb2dpY2FsWG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdMb2dpY2FsJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTG9naWNhbE9wcywgXCJ3aGVyZVwiLCBudWxsKTtcbiAgICByZXR1cm4gTG9naWNhbE9wcztcbn0oKSk7XG5leHBvcnRzLkxvZ2ljYWxPcHMgPSBMb2dpY2FsT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIExSTk9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTFJOT3BzKCkge1xuICAgIH1cbiAgICBMUk5PcHMubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAoeCwgcmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbikge1xuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHsgcmFkaXVzID0gNTsgfVxuICAgICAgICBpZiAoYmlhcyA9PT0gdm9pZCAwKSB7IGJpYXMgPSAxOyB9XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMTsgfVxuICAgICAgICBpZiAoYmV0YSA9PT0gdm9pZCAwKSB7IGJldGEgPSAwLjU7IH1cbiAgICAgICAgaWYgKG5vcm1SZWdpb24gPT09IHZvaWQgMCkgeyBub3JtUmVnaW9uID0gJ2Fjcm9zc0NoYW5uZWxzJzsgfVxuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQgfHwgeC5yYW5rID09PSAzLCBcIkVycm9yIGluIGxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uOiB4IG11c3QgYmUgcmFuayAzIG9yIDQgYnV0IGdvdFxcbiAgICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocmFkaXVzKSwgXCJFcnJvciBpbiBsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvbjNEOiByYWRpdXMgbXVzdCBiZSBhbiBpbnRlZ2VyXFxuICAgICAgICAgICAgICAgICAgICAgYnV0IGdvdCByYWRpdXMgXCIgKyByYWRpdXMgKyBcIi5cIik7XG4gICAgICAgIHZhciB4NEQgPSB4O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICB4NEQgPSB4LmFzNEQoMSwgeC5zaGFwZVswXSwgeC5zaGFwZVsxXSwgeC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb240RCh4NEQsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEsIG5vcm1SZWdpb24pOyB9LCB7IHg0RDogeDREIH0pO1xuICAgICAgICBpZiAocmVzaGFwZWRUbzREKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzLmFzM0QocmVzLnNoYXBlWzFdLCByZXMuc2hhcGVbMl0sIHJlcy5zaGFwZVszXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIExSTk9wcywgXCJsb2NhbFJlc3BvbnNlTm9ybWFsaXphdGlvblwiLCBudWxsKTtcbiAgICByZXR1cm4gTFJOT3BzO1xufSgpKTtcbmV4cG9ydHMuTFJOT3BzID0gTFJOT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIExTVE1PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExTVE1PcHMoKSB7XG4gICAgfVxuICAgIExTVE1PcHMubXVsdGlSTk5DZWxsID0gZnVuY3Rpb24gKGxzdG1DZWxscywgZGF0YSwgYywgaCkge1xuICAgICAgICB2YXIgaW5wdXQgPSBkYXRhO1xuICAgICAgICB2YXIgbmV3U3RhdGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbHN0bUNlbGxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gbHN0bUNlbGxzW2ldKGlucHV0LCBjW2ldLCBoW2ldKTtcbiAgICAgICAgICAgIG5ld1N0YXRlcy5wdXNoKG91dHB1dFswXSk7XG4gICAgICAgICAgICBuZXdTdGF0ZXMucHVzaChvdXRwdXRbMV0pO1xuICAgICAgICAgICAgaW5wdXQgPSBvdXRwdXRbMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5ld0MgPSBbXTtcbiAgICAgICAgdmFyIG5ld0ggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgIG5ld0MucHVzaChuZXdTdGF0ZXNbaV0pO1xuICAgICAgICAgICAgbmV3SC5wdXNoKG5ld1N0YXRlc1tpICsgMV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbbmV3QywgbmV3SF07XG4gICAgfTtcbiAgICBMU1RNT3BzLmJhc2ljTFNUTUNlbGwgPSBmdW5jdGlvbiAoZm9yZ2V0QmlhcywgbHN0bUtlcm5lbCwgbHN0bUJpYXMsIGRhdGEsIGMsIGgpIHtcbiAgICAgICAgdmFyIGNvbWJpbmVkID0gZGF0YS5jb25jYXQoaCwgMSk7XG4gICAgICAgIHZhciB3ZWlnaHRlZCA9IGNvbWJpbmVkLm1hdE11bChsc3RtS2VybmVsKTtcbiAgICAgICAgdmFyIHJlcyA9IHdlaWdodGVkLmFkZChsc3RtQmlhcyk7XG4gICAgICAgIHZhciBiYXRjaFNpemUgPSByZXMuc2hhcGVbMF07XG4gICAgICAgIHZhciBzbGljZUNvbHMgPSByZXMuc2hhcGVbMV0gLyA0O1xuICAgICAgICB2YXIgc2xpY2VTaXplID0gW2JhdGNoU2l6ZSwgc2xpY2VDb2xzXTtcbiAgICAgICAgdmFyIGkgPSByZXMuc2xpY2UoWzAsIDBdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgaiA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzXSwgc2xpY2VTaXplKTtcbiAgICAgICAgdmFyIGYgPSByZXMuc2xpY2UoWzAsIHNsaWNlQ29scyAqIDJdLCBzbGljZVNpemUpO1xuICAgICAgICB2YXIgbyA9IHJlcy5zbGljZShbMCwgc2xpY2VDb2xzICogM10sIHNsaWNlU2l6ZSk7XG4gICAgICAgIHZhciBuZXdDID0gaS5zaWdtb2lkKCkubXVsU3RyaWN0KGoudGFuaCgpKS5hZGRTdHJpY3QoYy5tdWxTdHJpY3QoZm9yZ2V0Qmlhcy5hZGQoZikuc2lnbW9pZCgpKSk7XG4gICAgICAgIHZhciBuZXdIID0gbmV3Qy50YW5oKCkubXVsU3RyaWN0KG8uc2lnbW9pZCgpKTtcbiAgICAgICAgcmV0dXJuIFtuZXdDLCBuZXdIXTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSTk4nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBMU1RNT3BzLCBcIm11bHRpUk5OQ2VsbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUk5OJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTFNUTU9wcywgXCJiYXNpY0xTVE1DZWxsXCIsIG51bGwpO1xuICAgIHJldHVybiBMU1RNT3BzO1xufSgpKTtcbmV4cG9ydHMuTFNUTU9wcyA9IExTVE1PcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgTWF0cml4T3JpZW50YXRpb247XG4oZnVuY3Rpb24gKE1hdHJpeE9yaWVudGF0aW9uKSB7XG4gICAgTWF0cml4T3JpZW50YXRpb25bTWF0cml4T3JpZW50YXRpb25bXCJSRUdVTEFSXCJdID0gMF0gPSBcIlJFR1VMQVJcIjtcbiAgICBNYXRyaXhPcmllbnRhdGlvbltNYXRyaXhPcmllbnRhdGlvbltcIlRSQU5TUE9TRURcIl0gPSAxXSA9IFwiVFJBTlNQT1NFRFwiO1xufSkoTWF0cml4T3JpZW50YXRpb24gPSBleHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uIHx8IChleHBvcnRzLk1hdHJpeE9yaWVudGF0aW9uID0ge30pKTtcbnZhciBNYXRtdWxPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hdG11bE9wcygpIHtcbiAgICB9XG4gICAgTWF0bXVsT3BzLm1hdE11bCA9IGZ1bmN0aW9uIChhLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKSB7XG4gICAgICAgIGlmICh0cmFuc3Bvc2VBID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQSA9IGZhbHNlOyB9XG4gICAgICAgIGlmICh0cmFuc3Bvc2VCID09PSB2b2lkIDApIHsgdHJhbnNwb3NlQiA9IGZhbHNlOyB9XG4gICAgICAgIF9hID0gW2VudW1Ub0Jvb2wodHJhbnNwb3NlQSksIGVudW1Ub0Jvb2wodHJhbnNwb3NlQildLCB0cmFuc3Bvc2VBID0gX2FbMF0sIHRyYW5zcG9zZUIgPSBfYVsxXTtcbiAgICAgICAgdmFyIGlubmVyU2hhcGVBID0gdHJhbnNwb3NlQSA/IGEuc2hhcGVbMF0gOiBhLnNoYXBlWzFdO1xuICAgICAgICB2YXIgaW5uZXJTaGFwZUIgPSB0cmFuc3Bvc2VCID8gYi5zaGFwZVsxXSA6IGIuc2hhcGVbMF07XG4gICAgICAgIHV0aWwuYXNzZXJ0KGEucmFuayA9PT0gMiAmJiBiLnJhbmsgPT09IDIsIFwiRXJyb3IgaW4gbWF0TXVsOiBpbnB1dHMgbXVzdCBiZSByYW5rIDIsIGdvdCByYW5rcyBcIiArIGEucmFuayArXG4gICAgICAgICAgICAoXCIgYW5kIFwiICsgYi5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5uZXJTaGFwZUEgPT09IGlubmVyU2hhcGVCLCBcIkVycm9yIGluIG1hdE11bDogaW5uZXIgc2hhcGVzIChcIiArIGlubmVyU2hhcGVBICsgXCIpIGFuZCAoXCIgK1xuICAgICAgICAgICAgKGlubmVyU2hhcGVCICsgXCIpIG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgXCIgKyBhLnNoYXBlICsgXCIgYW5kIFwiKSArXG4gICAgICAgICAgICAoYi5zaGFwZSArIFwiIGFuZCB0cmFuc3Bvc2VBPVwiICsgdHJhbnNwb3NlQSkgK1xuICAgICAgICAgICAgKFwiIGFuZCB0cmFuc3Bvc2VCPVwiICsgdHJhbnNwb3NlQiArIFwiIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc3Bvc2VBIHx8IHRyYW5zcG9zZUIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrcHJvcCBmb3IgdHJhbnNwb3NlZCBNYXRNdWwgbm90IHlldCBpbXBsZW1lbnRlZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGE6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm1hdE11bChiLnRvRmxvYXQoKSwgZmFsc2UsIHRydWUpOyB9LFxuICAgICAgICAgICAgICAgIGI6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGEudG9GbG9hdCgpLm1hdE11bChkeSwgdHJ1ZSwgZmFsc2UpOyB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXRNdWwoYSwgYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQik7IH0sIHsgYTogYSwgYjogYiB9LCBncmFkKTtcbiAgICAgICAgdmFyIF9hO1xuICAgIH07XG4gICAgTWF0bXVsT3BzLnZlY3RvclRpbWVzTWF0cml4ID0gZnVuY3Rpb24gKHYsIG1hdHJpeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh2LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gdmVjdG9yVGltZXNNYXRyaXg6IGZpcnN0IGlucHV0IG11c3QgYmUgcmFuayAxLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyB2LnJhbmsgKyBcIi5cIikpO1xuICAgICAgICB1dGlsLmFzc2VydChtYXRyaXgucmFuayA9PT0gMiwgXCJFcnJvciBpbiB2ZWN0b3JUaW1lc01hdHJpeDogc2Vjb25kIGlucHV0IG11c3QgYmUgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzBdLCBcIkVycm9yIGluIHZlY3RvclRpbWVzTWF0cml4OiBzaXplIG9mIHZlY3RvciAoXCIgKyB2LnNpemUgKyBcIikgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBmaXJzdCBkaW1lbnNpb24gb2YgbWF0cml4IChcIiArIG1hdHJpeC5zaGFwZVswXSArIFwiKVwiKSk7XG4gICAgICAgIHJldHVybiB2LmFzMkQoMSwgLTEpLm1hdE11bChtYXRyaXgpLmFzMUQoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5tYXRyaXhUaW1lc1ZlY3RvciA9IGZ1bmN0aW9uIChtYXRyaXgsIHYpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQodi5yYW5rID09PSAxLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzZWNvbmQgaW5wdXQgbXVzdCByYW5rIDEsIGJ1dCBnb3QgXCIgK1xuICAgICAgICAgICAgKFwicmFuayBcIiArIHYucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KG1hdHJpeC5yYW5rID09PSAyLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBmaXJzdCBpbnB1dCBtdXN0IGJlIGEgcmFuayAyLCBidXQgZ290IFwiICtcbiAgICAgICAgICAgIChcInJhbmsgXCIgKyBtYXRyaXgucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYuc2l6ZSA9PT0gbWF0cml4LnNoYXBlWzFdLCBcIkVycm9yIGluIG1hdHJpeFRpbWVzVmVjdG9yOiBzaXplIG9mIGZpcnN0IHJhbmsgMSBpbnB1dCBcIiArIHYuc2l6ZSArIFwiIFwiICtcbiAgICAgICAgICAgIFwibXVzdCBtYXRjaCBpbm5lciBkaW1lbnNpb24gb2Ygc2Vjb25kIHJhbmsgMiBpbnB1dCwgYnV0IGdvdCBcIiArXG4gICAgICAgICAgICAoXCJzaGFwZSBcIiArIG1hdHJpeC5zaGFwZSArIFwiLlwiKSk7XG4gICAgICAgIHJldHVybiBtYXRyaXgubWF0TXVsKHYuYXMyRCgtMSwgMSkpLmFzMUQoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5kb3RQcm9kdWN0ID0gZnVuY3Rpb24gKHYxLCB2Mikge1xuICAgICAgICB1dGlsLmFzc2VydCh2MS5yYW5rID09PSAxICYmIHYyLnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogaW5wdXRzIG11c3QgYmUgcmFuayAxLCBidXQgZ290IHJhbmtzIFwiICtcbiAgICAgICAgICAgICh2MS5yYW5rICsgXCIgYW5kIFwiICsgdjIucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnNpemUgPT09IHYyLnNpemUsIFwiRXJyb3IgaW4gZG90UHJvZHVjdDogc2l6ZSBvZiBpbnB1dHMgKFwiICsgdjEuc2l6ZSArIFwiKSBhbmQgKFwiICtcbiAgICAgICAgICAgICh2Mi5zaXplICsgXCIpIG11c3QgbWF0Y2guXCIpKTtcbiAgICAgICAgcmV0dXJuIHYxLmFzMkQoMSwgLTEpLm1hdE11bCh2Mi5hczJEKC0xLCAxKSkuYXNTY2FsYXIoKTtcbiAgICB9O1xuICAgIE1hdG11bE9wcy5vdXRlclByb2R1Y3QgPSBmdW5jdGlvbiAodjEsIHYyKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHYxLnJhbmsgPT09IDEgJiYgdjIucmFuayA9PT0gMSwgXCJFcnJvciBpbiBvdXRlclByb2R1Y3Q6IGlucHV0cyBtdXN0IGJlIHJhbmsgMSwgYnV0IGdvdCByYW5rcyBcIiArXG4gICAgICAgICAgICAodjEucmFuayArIFwiIGFuZCBcIiArIHYyLnJhbmsgKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gdjEuYXMyRCgtMSwgMSkubWF0TXVsKHYyLmFzMkQoMSwgLTEpKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJtYXRNdWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE1hdG11bE9wcywgXCJ2ZWN0b3JUaW1lc01hdHJpeFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgTWF0bXVsT3BzLCBcIm1hdHJpeFRpbWVzVmVjdG9yXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwiZG90UHJvZHVjdFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTWF0cmljZXMnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBNYXRtdWxPcHMsIFwib3V0ZXJQcm9kdWN0XCIsIG51bGwpO1xuICAgIHJldHVybiBNYXRtdWxPcHM7XG59KCkpO1xuZXhwb3J0cy5NYXRtdWxPcHMgPSBNYXRtdWxPcHM7XG5mdW5jdGlvbiBlbnVtVG9Cb29sKHRyYW5zcG9zZSkge1xuICAgIGlmICh0cmFuc3Bvc2UgPT09IE1hdHJpeE9yaWVudGF0aW9uLlJFR1VMQVIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodHJhbnNwb3NlID09PSBNYXRyaXhPcmllbnRhdGlvbi5UUkFOU1BPU0VEKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3NlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGF4aXNfdXRpbCA9IHJlcXVpcmUoXCIuL2F4aXNfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBvcHMgPSByZXF1aXJlKFwiLi9vcHNcIik7XG52YXIgTm9ybU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9ybU9wcygpIHtcbiAgICB9XG4gICAgTm9ybU9wcy5ub3JtID0gZnVuY3Rpb24gKHgsIG9yZCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKG9yZCA9PT0gdm9pZCAwKSB7IG9yZCA9ICdldWNsaWRlYW4nOyB9XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgbm9ybSA9IG5vcm1JbXBsKHgsIG9yZCwgYXhpcyk7XG4gICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbm9ybS5zaGFwZTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgICAgIGtlZXBEaW1zU2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0obm9ybS5zaGFwZSwgYXhlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vcm0ucmVzaGFwZShrZWVwRGltc1NoYXBlKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdNYXRyaWNlcycgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIE5vcm1PcHMsIFwibm9ybVwiLCBudWxsKTtcbiAgICByZXR1cm4gTm9ybU9wcztcbn0oKSk7XG5leHBvcnRzLk5vcm1PcHMgPSBOb3JtT3BzO1xuZnVuY3Rpb24gbm9ybUltcGwoeCwgcCwgYXhpcykge1xuICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICBpZiAoeC5yYW5rID09PSAwKSB7XG4gICAgICAgIHJldHVybiB4LmFicygpO1xuICAgIH1cbiAgICBpZiAoeC5yYW5rICE9PSAxICYmIGF4aXMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1JbXBsKHgucmVzaGFwZShbLTFdKSwgcCwgYXhpcyk7XG4gICAgfVxuICAgIGlmICh4LnJhbmsgPT09IDEgfHwgdHlwZW9mIGF4aXMgPT09ICdudW1iZXInIHx8XG4gICAgICAgIGF4aXMgaW5zdGFuY2VvZiBBcnJheSAmJiBheGlzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAocCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkubWF4KGF4aXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLm1pbihheGlzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gJ2V1Y2xpZGVhbicgfHwgcCA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkucG93KG9wcy5zY2FsYXIoMiwgJ2ludDMyJykpLnN1bShheGlzKS5zcXJ0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBvcmQgdmFsdWU6IFwiICsgcCk7XG4gICAgfVxuICAgIGlmIChheGlzIGluc3RhbmNlb2YgQXJyYXkgJiYgYXhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKHAgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB4LmFicygpLnN1bShheGlzWzBdKS5tYXgoYXhpc1sxXSAtIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIHguYWJzKCkuc3VtKGF4aXNbMV0pLm1heChheGlzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4geC5hYnMoKS5zdW0oYXhpc1sxXSkubWluKGF4aXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwID09PSAnZnJvJyB8fCBwID09PSAnZXVjbGlkZWFuJykge1xuICAgICAgICAgICAgcmV0dXJuIHguc3F1YXJlKCkuc3VtKGF4aXMpLnNxcnQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBub3JtOiBpbnZhbGlkIG9yZCB2YWx1ZTogXCIgKyBwKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgaW4gbm9ybTogaW52YWxpZCBheGlzOiBcIiArIGF4aXMpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG5mdW5jdGlvbiBvcGVyYXRpb24odGFyZ2V0LCBuYW1lLCBkZXNjcmlwdG9yKSB7XG4gICAgdmFyIGZuID0gZGVzY3JpcHRvci52YWx1ZTtcbiAgICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudGlkeShuYW1lLCBmdW5jdGlvbiAoKSB7IHJldHVybiBmbi5hcHBseSh2b2lkIDAsIGFyZ3MpOyB9KTtcbiAgICB9O1xuICAgIHJldHVybiBkZXNjcmlwdG9yO1xufVxuZXhwb3J0cy5vcGVyYXRpb24gPSBvcGVyYXRpb247XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBhcnJheV9vcHNfMSA9IHJlcXVpcmUoXCIuL2FycmF5X29wc1wiKTtcbnZhciBiYXRjaG5vcm1fMSA9IHJlcXVpcmUoXCIuL2JhdGNobm9ybVwiKTtcbnZhciBiaW5hcnlfb3BzXzEgPSByZXF1aXJlKFwiLi9iaW5hcnlfb3BzXCIpO1xudmFyIGNvbXBhcmVfMSA9IHJlcXVpcmUoXCIuL2NvbXBhcmVcIik7XG52YXIgY29uY2F0XzEgPSByZXF1aXJlKFwiLi9jb25jYXRcIik7XG52YXIgY29udl8xID0gcmVxdWlyZShcIi4vY29udlwiKTtcbnZhciBpbWFnZV9vcHNfMSA9IHJlcXVpcmUoXCIuL2ltYWdlX29wc1wiKTtcbnZhciBsb2dpY2FsX29wc18xID0gcmVxdWlyZShcIi4vbG9naWNhbF9vcHNcIik7XG52YXIgbHJuXzEgPSByZXF1aXJlKFwiLi9scm5cIik7XG52YXIgbHN0bV8xID0gcmVxdWlyZShcIi4vbHN0bVwiKTtcbnZhciBtYXRtdWxfMSA9IHJlcXVpcmUoXCIuL21hdG11bFwiKTtcbnZhciBub3JtXzEgPSByZXF1aXJlKFwiLi9ub3JtXCIpO1xudmFyIHBvb2xfMSA9IHJlcXVpcmUoXCIuL3Bvb2xcIik7XG52YXIgcmVkdWN0aW9uX29wc18xID0gcmVxdWlyZShcIi4vcmVkdWN0aW9uX29wc1wiKTtcbnZhciByZXZlcnNlXzEgPSByZXF1aXJlKFwiLi9yZXZlcnNlXCIpO1xudmFyIHNsaWNlXzEgPSByZXF1aXJlKFwiLi9zbGljZVwiKTtcbnZhciBzb2Z0bWF4XzEgPSByZXF1aXJlKFwiLi9zb2Z0bWF4XCIpO1xudmFyIHRyYW5zcG9zZV8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3NlXCIpO1xudmFyIHVuYXJ5X29wc18xID0gcmVxdWlyZShcIi4vdW5hcnlfb3BzXCIpO1xuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24gPSBiYXRjaG5vcm1fMS5CYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uO1xuZXhwb3J0cy5iYXRjaE5vcm1hbGl6YXRpb24yZCA9IGJhdGNobm9ybV8xLkJhdGNoTm9ybU9wcy5iYXRjaE5vcm1hbGl6YXRpb24yZDtcbmV4cG9ydHMuYmF0Y2hOb3JtYWxpemF0aW9uM2QgPSBiYXRjaG5vcm1fMS5CYXRjaE5vcm1PcHMuYmF0Y2hOb3JtYWxpemF0aW9uM2Q7XG5leHBvcnRzLmJhdGNoTm9ybWFsaXphdGlvbjRkID0gYmF0Y2hub3JtXzEuQmF0Y2hOb3JtT3BzLmJhdGNoTm9ybWFsaXphdGlvbjRkO1xuZXhwb3J0cy5jb25jYXQgPSBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0O1xuZXhwb3J0cy5jb25jYXQxZCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQxZDtcbmV4cG9ydHMuY29uY2F0MmQgPSBjb25jYXRfMS5Db25jYXRPcHMuY29uY2F0MmQ7XG5leHBvcnRzLmNvbmNhdDNkID0gY29uY2F0XzEuQ29uY2F0T3BzLmNvbmNhdDNkO1xuZXhwb3J0cy5jb25jYXQ0ZCA9IGNvbmNhdF8xLkNvbmNhdE9wcy5jb25jYXQ0ZDtcbmV4cG9ydHMuY29udjFkID0gY29udl8xLkNvbnZPcHMuY29udjFkO1xuZXhwb3J0cy5jb252MmQgPSBjb252XzEuQ29udk9wcy5jb252MmQ7XG5leHBvcnRzLmNvbnYyZFRyYW5zcG9zZSA9IGNvbnZfMS5Db252T3BzLmNvbnYyZFRyYW5zcG9zZTtcbmV4cG9ydHMuZGVwdGh3aXNlQ29udjJkID0gY29udl8xLkNvbnZPcHMuZGVwdGh3aXNlQ29udjJkO1xuZXhwb3J0cy5tYXRNdWwgPSBtYXRtdWxfMS5NYXRtdWxPcHMubWF0TXVsO1xuZXhwb3J0cy5tYXRyaXhUaW1lc1ZlY3RvciA9IG1hdG11bF8xLk1hdG11bE9wcy5tYXRyaXhUaW1lc1ZlY3RvcjtcbmV4cG9ydHMub3V0ZXJQcm9kdWN0ID0gbWF0bXVsXzEuTWF0bXVsT3BzLm91dGVyUHJvZHVjdDtcbmV4cG9ydHMudmVjdG9yVGltZXNNYXRyaXggPSBtYXRtdWxfMS5NYXRtdWxPcHMudmVjdG9yVGltZXNNYXRyaXg7XG5leHBvcnRzLmF2Z1Bvb2wgPSBwb29sXzEuUG9vbE9wcy5hdmdQb29sO1xuZXhwb3J0cy5tYXhQb29sID0gcG9vbF8xLlBvb2xPcHMubWF4UG9vbDtcbmV4cG9ydHMubWluUG9vbCA9IHBvb2xfMS5Qb29sT3BzLm1pblBvb2w7XG5leHBvcnRzLnRyYW5zcG9zZSA9IHRyYW5zcG9zZV8xLlRyYW5zcG9zZU9wcy50cmFuc3Bvc2U7XG5leHBvcnRzLnJldmVyc2UgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlO1xuZXhwb3J0cy5yZXZlcnNlMWQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlMWQ7XG5leHBvcnRzLnJldmVyc2UyZCA9IHJldmVyc2VfMS5SZXZlcnNlT3BzLnJldmVyc2UyZDtcbmV4cG9ydHMucmV2ZXJzZTNkID0gcmV2ZXJzZV8xLlJldmVyc2VPcHMucmV2ZXJzZTNkO1xuZXhwb3J0cy5yZXZlcnNlNGQgPSByZXZlcnNlXzEuUmV2ZXJzZU9wcy5yZXZlcnNlNGQ7XG5leHBvcnRzLnNsaWNlID0gc2xpY2VfMS5TbGljZU9wcy5zbGljZTtcbmV4cG9ydHMuc2xpY2UxZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UxZDtcbmV4cG9ydHMuc2xpY2UyZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UyZDtcbmV4cG9ydHMuc2xpY2UzZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2UzZDtcbmV4cG9ydHMuc2xpY2U0ZCA9IHNsaWNlXzEuU2xpY2VPcHMuc2xpY2U0ZDtcbmV4cG9ydHMuYXJnTWF4ID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5hcmdNYXg7XG5leHBvcnRzLmFyZ01pbiA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMuYXJnTWluO1xuZXhwb3J0cy5sb2dTdW1FeHAgPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLmxvZ1N1bUV4cDtcbmV4cG9ydHMubWF4ID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5tYXg7XG5leHBvcnRzLm1lYW4gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLm1lYW47XG5leHBvcnRzLm1pbiA9IHJlZHVjdGlvbl9vcHNfMS5SZWR1Y3Rpb25PcHMubWluO1xuZXhwb3J0cy5tb21lbnRzID0gcmVkdWN0aW9uX29wc18xLlJlZHVjdGlvbk9wcy5tb21lbnRzO1xuZXhwb3J0cy5zdW0gPSByZWR1Y3Rpb25fb3BzXzEuUmVkdWN0aW9uT3BzLnN1bTtcbmV4cG9ydHMuZXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5lcXVhbDtcbmV4cG9ydHMuZXF1YWxTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5lcXVhbFN0cmljdDtcbmV4cG9ydHMuZ3JlYXRlciA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXI7XG5leHBvcnRzLmdyZWF0ZXJTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyU3RyaWN0O1xuZXhwb3J0cy5ncmVhdGVyRXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ncmVhdGVyRXF1YWw7XG5leHBvcnRzLmdyZWF0ZXJFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmdyZWF0ZXJFcXVhbFN0cmljdDtcbmV4cG9ydHMubGVzcyA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3M7XG5leHBvcnRzLmxlc3NTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5sZXNzU3RyaWN0O1xuZXhwb3J0cy5sZXNzRXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5sZXNzRXF1YWw7XG5leHBvcnRzLmxlc3NFcXVhbFN0cmljdCA9IGNvbXBhcmVfMS5Db21wYXJlT3BzLmxlc3NFcXVhbFN0cmljdDtcbmV4cG9ydHMubm90RXF1YWwgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ub3RFcXVhbDtcbmV4cG9ydHMubm90RXF1YWxTdHJpY3QgPSBjb21wYXJlXzEuQ29tcGFyZU9wcy5ub3RFcXVhbFN0cmljdDtcbmV4cG9ydHMubG9naWNhbE5vdCA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsTm90O1xuZXhwb3J0cy5sb2dpY2FsQW5kID0gbG9naWNhbF9vcHNfMS5Mb2dpY2FsT3BzLmxvZ2ljYWxBbmQ7XG5leHBvcnRzLmxvZ2ljYWxPciA9IGxvZ2ljYWxfb3BzXzEuTG9naWNhbE9wcy5sb2dpY2FsT3I7XG5leHBvcnRzLmxvZ2ljYWxYb3IgPSBsb2dpY2FsX29wc18xLkxvZ2ljYWxPcHMubG9naWNhbFhvcjtcbmV4cG9ydHMud2hlcmUgPSBsb2dpY2FsX29wc18xLkxvZ2ljYWxPcHMud2hlcmU7XG5leHBvcnRzLmFicyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFicztcbmV4cG9ydHMuYWNvcyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmFjb3M7XG5leHBvcnRzLmFzaW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5hc2luO1xuZXhwb3J0cy5hdGFuID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuYXRhbjtcbmV4cG9ydHMuY2VpbCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNlaWw7XG5leHBvcnRzLmNsaXBCeVZhbHVlID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuY2xpcEJ5VmFsdWU7XG5leHBvcnRzLmNvcyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNvcztcbmV4cG9ydHMuY29zaCA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmNvc2g7XG5leHBvcnRzLmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmVsdTtcbmV4cG9ydHMuZXhwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuZXhwO1xuZXhwb3J0cy5mbG9vciA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmZsb29yO1xuZXhwb3J0cy5sZWFreVJlbHUgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5sZWFreVJlbHU7XG5leHBvcnRzLmxvZyA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLmxvZztcbmV4cG9ydHMubmVnID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMubmVnO1xuZXhwb3J0cy5wcmVsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnByZWx1O1xuZXhwb3J0cy5yZWx1ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMucmVsdTtcbmV4cG9ydHMuc2VsdSA9IHVuYXJ5X29wc18xLlVuYXJ5T3BzLnNlbHU7XG5leHBvcnRzLnNpZ21vaWQgPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaWdtb2lkO1xuZXhwb3J0cy5zaW4gPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaW47XG5leHBvcnRzLnNpbmggPSB1bmFyeV9vcHNfMS5VbmFyeU9wcy5zaW5oO1xuZXhwb3J0cy5zcXJ0ID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3FydDtcbmV4cG9ydHMuc3F1YXJlID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3F1YXJlO1xuZXhwb3J0cy5zdGVwID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMuc3RlcDtcbmV4cG9ydHMudGFuID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMudGFuO1xuZXhwb3J0cy50YW5oID0gdW5hcnlfb3BzXzEuVW5hcnlPcHMudGFuaDtcbmV4cG9ydHMuYWRkID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5hZGQ7XG5leHBvcnRzLmFkZFN0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMuYWRkU3RyaWN0O1xuZXhwb3J0cy5kaXYgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLmRpdjtcbmV4cG9ydHMuZGl2U3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5kaXZTdHJpY3Q7XG5leHBvcnRzLm1heGltdW0gPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1heGltdW07XG5leHBvcnRzLm1heGltdW1TdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1heGltdW1TdHJpY3Q7XG5leHBvcnRzLm1pbmltdW0gPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1pbmltdW07XG5leHBvcnRzLm1pbmltdW1TdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm1pbmltdW1TdHJpY3Q7XG5leHBvcnRzLm11bCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMubXVsO1xuZXhwb3J0cy5tdWxTdHJpY3QgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLm11bFN0cmljdDtcbmV4cG9ydHMucG93ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5wb3c7XG5leHBvcnRzLnBvd1N0cmljdCA9IGJpbmFyeV9vcHNfMS5CaW5hcnlPcHMucG93U3RyaWN0O1xuZXhwb3J0cy5zdWIgPSBiaW5hcnlfb3BzXzEuQmluYXJ5T3BzLnN1YjtcbmV4cG9ydHMuc3ViU3RyaWN0ID0gYmluYXJ5X29wc18xLkJpbmFyeU9wcy5zdWJTdHJpY3Q7XG5leHBvcnRzLm5vcm0gPSBub3JtXzEuTm9ybU9wcy5ub3JtO1xuZXhwb3J0cy5jYXN0ID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuY2FzdDtcbmV4cG9ydHMuY2xvbmUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5jbG9uZTtcbmV4cG9ydHMuZnJvbVBpeGVscyA9IGFycmF5X29wc18xLkFycmF5T3BzLmZyb21QaXhlbHM7XG5leHBvcnRzLm9uZXMgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5vbmVzO1xuZXhwb3J0cy5vbmVzTGlrZSA9IGFycmF5X29wc18xLkFycmF5T3BzLm9uZXNMaWtlO1xuZXhwb3J0cy56ZXJvcyA9IGFycmF5X29wc18xLkFycmF5T3BzLnplcm9zO1xuZXhwb3J0cy56ZXJvc0xpa2UgPSBhcnJheV9vcHNfMS5BcnJheU9wcy56ZXJvc0xpa2U7XG5leHBvcnRzLnJhbmQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yYW5kO1xuZXhwb3J0cy5yYW5kb21Ob3JtYWwgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yYW5kb21Ob3JtYWw7XG5leHBvcnRzLnRydW5jYXRlZE5vcm1hbCA9IGFycmF5X29wc18xLkFycmF5T3BzLnRydW5jYXRlZE5vcm1hbDtcbmV4cG9ydHMucmFuZG9tVW5pZm9ybSA9IGFycmF5X29wc18xLkFycmF5T3BzLnJhbmRvbVVuaWZvcm07XG5leHBvcnRzLnJlc2hhcGUgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5yZXNoYXBlO1xuZXhwb3J0cy5zcXVlZXplID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc3F1ZWV6ZTtcbmV4cG9ydHMudGlsZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnRpbGU7XG5leHBvcnRzLmdhdGhlciA9IGFycmF5X29wc18xLkFycmF5T3BzLmdhdGhlcjtcbmV4cG9ydHMub25lSG90ID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMub25lSG90O1xuZXhwb3J0cy5saW5zcGFjZSA9IGFycmF5X29wc18xLkFycmF5T3BzLmxpbnNwYWNlO1xuZXhwb3J0cy5yYW5nZSA9IGFycmF5X29wc18xLkFycmF5T3BzLnJhbmdlO1xuZXhwb3J0cy5idWZmZXIgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5idWZmZXI7XG5leHBvcnRzLmZpbGwgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5maWxsO1xuZXhwb3J0cy50ZW5zb3IgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3I7XG5leHBvcnRzLnNjYWxhciA9IGFycmF5X29wc18xLkFycmF5T3BzLnNjYWxhcjtcbmV4cG9ydHMudGVuc29yMWQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IxZDtcbmV4cG9ydHMudGVuc29yMmQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IyZDtcbmV4cG9ydHMudGVuc29yM2QgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3IzZDtcbmV4cG9ydHMudGVuc29yNGQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy50ZW5zb3I0ZDtcbmV4cG9ydHMucHJpbnQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wcmludDtcbmV4cG9ydHMuZXhwYW5kRGltcyA9IGFycmF5X29wc18xLkFycmF5T3BzLmV4cGFuZERpbXM7XG5leHBvcnRzLnN0YWNrID0gYXJyYXlfb3BzXzEuQXJyYXlPcHMuc3RhY2s7XG5leHBvcnRzLnBhZCA9IGFycmF5X29wc18xLkFycmF5T3BzLnBhZDtcbmV4cG9ydHMucGFkMWQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQxZDtcbmV4cG9ydHMucGFkMmQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQyZDtcbmV4cG9ydHMucGFkM2QgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQzZDtcbmV4cG9ydHMucGFkNGQgPSBhcnJheV9vcHNfMS5BcnJheU9wcy5wYWQ0ZDtcbmV4cG9ydHMuYmFzaWNMU1RNQ2VsbCA9IGxzdG1fMS5MU1RNT3BzLmJhc2ljTFNUTUNlbGw7XG5leHBvcnRzLm11bHRpUk5OQ2VsbCA9IGxzdG1fMS5MU1RNT3BzLm11bHRpUk5OQ2VsbDtcbmV4cG9ydHMuc29mdG1heCA9IHNvZnRtYXhfMS5Tb2Z0bWF4T3BzLnNvZnRtYXg7XG5leHBvcnRzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uID0gbHJuXzEuTFJOT3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB0eXBlc18xID0gcmVxdWlyZShcIi4uL3R5cGVzXCIpO1xuW3RlbnNvcl8xLlRlbnNvciwgdHlwZXNfMS5SYW5rLCB0ZW5zb3JfMS5UZW5zb3IzRCwgdGVuc29yXzEuVGVuc29yNERdO1xuZXhwb3J0cy5sb3NzZXMgPSB7XG4gICAgc29mdG1heENyb3NzRW50cm9weTogc29mdG1heF8xLlNvZnRtYXhPcHMuc29mdG1heENyb3NzRW50cm9weVxufTtcbmV4cG9ydHMuaW1hZ2UgPSB7XG4gICAgcmVzaXplQmlsaW5lYXI6IGltYWdlX29wc18xLkltYWdlT3BzLnJlc2l6ZUJpbGluZWFyXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIGNvbnZfdXRpbCA9IHJlcXVpcmUoXCIuL2NvbnZfdXRpbFwiKTtcbnZhciBvcGVyYXRpb25fMSA9IHJlcXVpcmUoXCIuL29wZXJhdGlvblwiKTtcbnZhciBQb29sT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQb29sT3BzKCkge1xuICAgIH1cbiAgICBQb29sT3BzLm1heFBvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBtYXhQb29sOiBpbnB1dCBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgKyB4NEQucmFuayArIFwiLlwiKTtcbiAgICAgICAgaWYgKGRpbVJvdW5kaW5nTW9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh1dGlsLmlzSW50KHBhZCksIFwiRXJyb3IgaW4gbWF4UG9vbDogcGFkIG11c3QgYmUgYW4gaW50ZWdlciB3aGVuIHVzaW5nLCBcIiArXG4gICAgICAgICAgICAgICAgKFwiZGltUm91bmRpbmdNb2RlIFwiICsgZGltUm91bmRpbmdNb2RlICsgXCIgYnV0IGdvdCBwYWQgXCIgKyBwYWQgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb252SW5mbyA9IGNvbnZfdXRpbC5jb21wdXRlUG9vbDJESW5mbyh4NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9vbE9wcy5tYXhQb29sQmFja3Byb3AoZHksIHg0RCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubWF4UG9vbCh4NEQsIGNvbnZJbmZvKTsgfSwgeyB4OiB4NEQgfSwgZ3JhZCk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUG9vbE9wcy5tYXhQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB1dGlsLmFzc2VydChpbnB1dC5yYW5rID09PSBkeS5yYW5rLCBcIlJhbmsgb2YgaW5wdXQgKFwiICsgaW5wdXQucmFuayArIFwiKSBkb2VzIG5vdCBtYXRjaCByYW5rIG9mIGR5IChcIiArIGR5LnJhbmsgKyBcIilcIik7XG4gICAgICAgIHZhciBpbnB1dDREID0gaW5wdXQ7XG4gICAgICAgIHZhciBkeTREID0gZHk7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKGlucHV0LnJhbmsgPT09IDMpIHtcbiAgICAgICAgICAgIHJlc2hhcGVkVG80RCA9IHRydWU7XG4gICAgICAgICAgICBpbnB1dDREID0gaW5wdXQuYXM0RCgxLCBpbnB1dC5zaGFwZVswXSwgaW5wdXQuc2hhcGVbMV0sIGlucHV0LnNoYXBlWzJdKTtcbiAgICAgICAgICAgIGR5NEQgPSBkeS5hczREKDEsIGR5LnNoYXBlWzBdLCBkeS5zaGFwZVsxXSwgZHkuc2hhcGVbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0KGR5NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IGR5IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoZHk0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1heFBvb2xCYWNrcHJvcDogaW5wdXQgbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICtcbiAgICAgICAgICAgIChpbnB1dDRELnJhbmsgKyBcIi5cIikpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBtYXhQb29sQmFja3Byb3A6IHBhZCBtdXN0IGJlIGFuIGludGVnZXIgd2hlbiB1c2luZywgXCIgK1xuICAgICAgICAgICAgICAgIChcImRpbVJvdW5kaW5nTW9kZSBcIiArIGRpbVJvdW5kaW5nTW9kZSArIFwiIGJ1dCBnb3QgcGFkIFwiICsgcGFkICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udkluZm8gPSBjb252X3V0aWwuY29tcHV0ZVBvb2wyREluZm8oaW5wdXQ0RC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXhQb29sQmFja3Byb3AoZHk0RCwgaW5wdXQ0RCwgY29udkluZm8pOyB9LCB7IGR5NEQ6IGR5NEQsIGlucHV0NEQ6IGlucHV0NEQgfSk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUG9vbE9wcy5taW5Qb29sID0gZnVuY3Rpb24gKGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQ0RC5yYW5rID09PSA0LCBcIkVycm9yIGluIG1pblBvb2w6IHggbXVzdCBiZSByYW5rIDQgYnV0IGdvdCByYW5rIFwiICsgaW5wdXQ0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBtaW5Qb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubWluUG9vbChpbnB1dDRELCBjb252SW5mbyk7IH0sIHsgaW5wdXQ0RDogaW5wdXQ0RCB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBQb29sT3BzLmF2Z1Bvb2wgPSBmdW5jdGlvbiAoeCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdmFyIHg0RCA9IHg7XG4gICAgICAgIHZhciByZXNoYXBlZFRvNEQgPSBmYWxzZTtcbiAgICAgICAgaWYgKHgucmFuayA9PT0gMykge1xuICAgICAgICAgICAgcmVzaGFwZWRUbzREID0gdHJ1ZTtcbiAgICAgICAgICAgIHg0RCA9IHguYXM0RCgxLCB4LnNoYXBlWzBdLCB4LnNoYXBlWzFdLCB4LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydCh4NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBhdmdQb29sOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArIHg0RC5yYW5rICsgXCIuXCIpO1xuICAgICAgICBpZiAoZGltUm91bmRpbmdNb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0KHV0aWwuaXNJbnQocGFkKSwgXCJFcnJvciBpbiBhdmdQb29sOiBwYWQgbXVzdCBiZSBhbiBpbnRlZ2VyIHdoZW4gdXNpbmcsIFwiICtcbiAgICAgICAgICAgICAgICAoXCJkaW1Sb3VuZGluZ01vZGUgXCIgKyBkaW1Sb3VuZGluZ01vZGUgKyBcIiBidXQgZ290IHBhZCBcIiArIHBhZCArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKHg0RC5zaGFwZSwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUG9vbE9wcy5hdmdQb29sQmFja3Byb3AoZHksIHg0RCwgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXZnUG9vbCh4NEQsIGNvbnZJbmZvKTsgfSwgeyB4OiB4NEQgfSwgZ3JhZCk7XG4gICAgICAgIGlmIChyZXNoYXBlZFRvNEQpIHtcbiAgICAgICAgICAgIHJldHVybiByZXMuYXMzRChyZXMuc2hhcGVbMV0sIHJlcy5zaGFwZVsyXSwgcmVzLnNoYXBlWzNdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH07XG4gICAgUG9vbE9wcy5hdmdQb29sQmFja3Byb3AgPSBmdW5jdGlvbiAoZHksIGlucHV0LCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gZHkucmFuaywgXCJSYW5rIG9mIGlucHV0IChcIiArIGlucHV0LnJhbmsgKyBcIikgZG9lcyBub3QgbWF0Y2ggcmFuayBvZiBkeSAoXCIgKyBkeS5yYW5rICsgXCIpXCIpO1xuICAgICAgICB2YXIgaW5wdXQ0RCA9IGlucHV0O1xuICAgICAgICB2YXIgZHk0RCA9IGR5O1xuICAgICAgICB2YXIgcmVzaGFwZWRUbzREID0gZmFsc2U7XG4gICAgICAgIGlmIChpbnB1dC5yYW5rID09PSAzKSB7XG4gICAgICAgICAgICByZXNoYXBlZFRvNEQgPSB0cnVlO1xuICAgICAgICAgICAgaW5wdXQ0RCA9IGlucHV0LmFzNEQoMSwgaW5wdXQuc2hhcGVbMF0sIGlucHV0LnNoYXBlWzFdLCBpbnB1dC5zaGFwZVsyXSk7XG4gICAgICAgICAgICBkeTREID0gZHkuYXM0RCgxLCBkeS5zaGFwZVswXSwgZHkuc2hhcGVbMV0sIGR5LnNoYXBlWzJdKTtcbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydChkeTRELnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gYXZnUG9vbEJhY2twcm9wOiBkeSBtdXN0IGJlIHJhbmsgNCBidXQgZ290IHJhbmsgXCIgK1xuICAgICAgICAgICAgKGR5NEQucmFuayArIFwiLlwiKSk7XG4gICAgICAgIHV0aWwuYXNzZXJ0KGlucHV0NEQucmFuayA9PT0gNCwgXCJFcnJvciBpbiBhdmdQb29sQmFja3Byb3A6IGlucHV0IG11c3QgYmUgcmFuayA0IGJ1dCBnb3QgcmFuayBcIiArXG4gICAgICAgICAgICAoaW5wdXQ0RC5yYW5rICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIGNvbnZJbmZvID0gY29udl91dGlsLmNvbXB1dGVQb29sMkRJbmZvKGlucHV0NEQuc2hhcGUsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCk7XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmF2Z1Bvb2xCYWNrcHJvcChkeTRELCBpbnB1dDRELCBjb252SW5mbyk7IH0sIHsgZHk0RDogZHk0RCwgaW5wdXQ0RDogaW5wdXQ0RCB9KTtcbiAgICAgICAgaWYgKHJlc2hhcGVkVG80RCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlcy5hczNEKHJlcy5zaGFwZVsxXSwgcmVzLnNoYXBlWzJdLCByZXMuc2hhcGVbM10pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBQb29sT3BzLCBcIm1heFBvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFBvb2xPcHMsIFwibWF4UG9vbEJhY2twcm9wXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdDb252b2x1dGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFBvb2xPcHMsIFwibWluUG9vbFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQ29udm9sdXRpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBQb29sT3BzLCBcImF2Z1Bvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFBvb2xPcHMsIFwiYXZnUG9vbEJhY2twcm9wXCIsIG51bGwpO1xuICAgIHJldHVybiBQb29sT3BzO1xufSgpKTtcbmV4cG9ydHMuUG9vbE9wcyA9IFBvb2xPcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBzZWVkcmFuZG9tID0gcmVxdWlyZShcInNlZWRyYW5kb21cIik7XG52YXIgTVBSYW5kR2F1c3MgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1QUmFuZEdhdXNzKG1lYW4sIHN0ZERldmlhdGlvbiwgZHR5cGUsIHRydW5jYXRlZCwgc2VlZCkge1xuICAgICAgICB0aGlzLm1lYW4gPSBtZWFuO1xuICAgICAgICB0aGlzLnN0ZERldiA9IHN0ZERldmlhdGlvbjtcbiAgICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlO1xuICAgICAgICB0aGlzLm5leHRWYWwgPSBOYU47XG4gICAgICAgIHRoaXMudHJ1bmNhdGVkID0gdHJ1bmNhdGVkO1xuICAgICAgICBpZiAodGhpcy50cnVuY2F0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXIgPSB0aGlzLm1lYW4gKyB0aGlzLnN0ZERldiAqIDI7XG4gICAgICAgICAgICB0aGlzLmxvd2VyID0gdGhpcy5tZWFuIC0gdGhpcy5zdGREZXYgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWVkVmFsdWUgPSBzZWVkID8gc2VlZCA6IE1hdGgucmFuZG9tKCk7XG4gICAgICAgIHRoaXMucmFuZG9tID0gc2VlZHJhbmRvbS5hbGVhKHNlZWRWYWx1ZS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgTVBSYW5kR2F1c3MucHJvdG90eXBlLm5leHRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc05hTih0aGlzLm5leHRWYWwpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLm5leHRWYWw7XG4gICAgICAgICAgICB0aGlzLm5leHRWYWwgPSBOYU47XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlc3VsdFgsIHJlc3VsdFk7XG4gICAgICAgIHZhciBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIHdoaWxlICghaXNWYWxpZCkge1xuICAgICAgICAgICAgdmFyIHYxID0gdm9pZCAwLCB2MiA9IHZvaWQgMCwgcyA9IHZvaWQgMDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2MSA9IDIgKiB0aGlzLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgICAgICAgICB2MiA9IDIgKiB0aGlzLnJhbmRvbSgpIC0gMTtcbiAgICAgICAgICAgICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgfHwgcyA9PT0gMCk7XG4gICAgICAgICAgICB2YXIgbXVsID0gTWF0aC5zcXJ0KC0yLjAgKiBNYXRoLmxvZyhzKSAvIHMpO1xuICAgICAgICAgICAgcmVzdWx0WCA9IHRoaXMubWVhbiArIHRoaXMuc3RkRGV2ICogdjEgKiBtdWw7XG4gICAgICAgICAgICByZXN1bHRZID0gdGhpcy5tZWFuICsgdGhpcy5zdGREZXYgKiB2MiAqIG11bDtcbiAgICAgICAgICAgIGlmICghdGhpcy50cnVuY2F0ZWQgfHwgdGhpcy5pc1ZhbGlkVHJ1bmNhdGVkKHJlc3VsdFgpKSB7XG4gICAgICAgICAgICAgICAgaXNWYWxpZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnRydW5jYXRlZCB8fCB0aGlzLmlzVmFsaWRUcnVuY2F0ZWQocmVzdWx0WSkpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFZhbCA9IHRoaXMuY29udmVydFZhbHVlKHJlc3VsdFkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRWYWx1ZShyZXN1bHRYKTtcbiAgICB9O1xuICAgIE1QUmFuZEdhdXNzLnByb3RvdHlwZS5jb252ZXJ0VmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZHR5cGUgPT0gbnVsbCB8fCB0aGlzLmR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfTtcbiAgICBNUFJhbmRHYXVzcy5wcm90b3R5cGUuaXNWYWxpZFRydW5jYXRlZCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy51cHBlciAmJiB2YWx1ZSA+PSB0aGlzLmxvd2VyO1xuICAgIH07XG4gICAgcmV0dXJuIE1QUmFuZEdhdXNzO1xufSgpKTtcbmV4cG9ydHMuTVBSYW5kR2F1c3MgPSBNUFJhbmRHYXVzcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QQVJBTExFTElaRV9USFJFU0hPTEQgPSAzMDtcbmZ1bmN0aW9uIGNvbXB1dGVPcHRpbWFsV2luZG93U2l6ZShpblNpemUpIHtcbiAgICBpZiAoaW5TaXplIDw9IGV4cG9ydHMuUEFSQUxMRUxJWkVfVEhSRVNIT0xEKSB7XG4gICAgICAgIHJldHVybiBpblNpemU7XG4gICAgfVxuICAgIHJldHVybiBuZWFyZXN0RGl2aXNvcihpblNpemUsIE1hdGguZmxvb3IoTWF0aC5zcXJ0KGluU2l6ZSkpKTtcbn1cbmV4cG9ydHMuY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplID0gY29tcHV0ZU9wdGltYWxXaW5kb3dTaXplO1xuZnVuY3Rpb24gbmVhcmVzdERpdmlzb3Ioc2l6ZSwgc3RhcnQpIHtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBzaXplOyArK2kpIHtcbiAgICAgICAgaWYgKHNpemUgJSBpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2l6ZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBSZWR1Y3Rpb25PcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlZHVjdGlvbk9wcygpIHtcbiAgICB9XG4gICAgUmVkdWN0aW9uT3BzLmxvZ1N1bUV4cCA9IGZ1bmN0aW9uIChpbnB1dCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIGlucHV0LnNoYXBlKTtcbiAgICAgICAgdmFyIHhNYXggPSBpbnB1dC5tYXgoYXhlcywgdHJ1ZSk7XG4gICAgICAgIHZhciBhID0gaW5wdXQuc3ViKHhNYXgpO1xuICAgICAgICB2YXIgYiA9IGEuZXhwKCk7XG4gICAgICAgIHZhciBjID0gYi5zdW0oYXhlcyk7XG4gICAgICAgIHZhciBkID0gYy5sb2coKTtcbiAgICAgICAgdmFyIHJlcyA9IHhNYXgucmVzaGFwZShkLnNoYXBlKS5hZGQoZCk7XG4gICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgdmFyIG5ld1NoYXBlID0gYXhpc191dGlsLmV4cGFuZFNoYXBlVG9LZWVwRGltKHJlcy5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMuc3VtID0gZnVuY3Rpb24gKHgsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGN1c3RvbU9wID0gZ2xvYmFsc18xLmN1c3RvbUdyYWQoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICAgIHZhciBwZXJtdXRhdGlvbiA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgICAgIHZhciByZWR1Y3Rpb25BeGVzID0gYXhlcztcbiAgICAgICAgICAgIHZhciBwZXJtdXRlZFggPSB4O1xuICAgICAgICAgICAgaWYgKHBlcm11dGF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwZXJtdXRlZFggPSB4LnRyYW5zcG9zZShwZXJtdXRhdGlvbik7XG4gICAgICAgICAgICAgICAgcmVkdWN0aW9uQXhlcyA9XG4gICAgICAgICAgICAgICAgICAgIGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKHJlZHVjdGlvbkF4ZXMubGVuZ3RoLCB4LnJhbmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zdW0ocGVybXV0ZWRYLCByZWR1Y3Rpb25BeGVzKTsgfSwgeyBwZXJtdXRlZFg6IHBlcm11dGVkWCB9KTtcbiAgICAgICAgICAgIGlmIChrZWVwRGltcykge1xuICAgICAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbSh2YWx1ZS5zaGFwZSwgYXhlcyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXNoYXBlKG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBncmFkRnVuYyA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5U2hhcGUgPSB4LnNoYXBlLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgYXhlcy5mb3JFYWNoKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkRHlTaGFwZVtheGlzXSA9IDE7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdmFyIGV4cGFuZGVkRHkgPSBkeS5yZXNoYXBlKGV4cGFuZGVkRHlTaGFwZSk7XG4gICAgICAgICAgICAgICAgdmFyIGRlclggPSBleHBhbmRlZER5Lm11bCh0ZW5zb3JfMS5UZW5zb3Iub25lcyh4LnNoYXBlLCAnZmxvYXQzMicpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVyWDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRGdW5jOiBncmFkRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1c3RvbU9wKHgpO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1lYW4gPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgc2hhcGVzID0gYXhpc191dGlsLmNvbXB1dGVPdXRBbmRSZWR1Y2VTaGFwZXMoeC5zaGFwZSwgYXhlcyk7XG4gICAgICAgIHZhciByZWR1Y2VTaGFwZSA9IHNoYXBlc1sxXTtcbiAgICAgICAgdmFyIHJlZHVjZVNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUocmVkdWNlU2hhcGUpO1xuICAgICAgICB2YXIgY3VzdG9tT3AgPSBnbG9iYWxzXzEuY3VzdG9tR3JhZChmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgdmFyIHJlZHVjZVNpemVTY2FsYXIgPSBvcHMuc2NhbGFyKHJlZHVjZVNpemUpO1xuICAgICAgICAgICAgdmFyIHJlcyA9IHguZGl2KHJlZHVjZVNpemVTY2FsYXIpO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcmVzLnN1bShheGlzLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIgZ3JhZEZ1bmMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXhwYW5kZWREeVNoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICAgICAgICAgICAgICAgIGF4ZXMuZm9yRWFjaChmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgICAgICBleHBhbmRlZER5U2hhcGVbYXhpc10gPSAxO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBleHBhbmRlZER5ID0gZHkucmVzaGFwZShleHBhbmRlZER5U2hhcGUpO1xuICAgICAgICAgICAgICAgIHZhciBkZXJYID0gZXhwYW5kZWREeS5tdWwodGVuc29yXzEuVGVuc29yLm9uZXMoeC5zaGFwZSwgJ2Zsb2F0MzInKSlcbiAgICAgICAgICAgICAgICAgICAgLmRpdihyZWR1Y2VTaXplU2NhbGFyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVyWDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRGdW5jOiBncmFkRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1c3RvbU9wKHgpO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1pbiA9IGZ1bmN0aW9uICh4LCBheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG9yaWdBeGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgYXhlcyA9IG9yaWdBeGVzO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCB4LnJhbmspO1xuICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB4LnRyYW5zcG9zZShwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4LnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXMgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLm1pbih4LCBheGVzKTsgfSwgeyB4OiB4IH0pO1xuICAgICAgICBpZiAoa2VlcERpbXMpIHtcbiAgICAgICAgICAgIHZhciBuZXdTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShyZXMuc2hhcGUsIG9yaWdBeGVzKTtcbiAgICAgICAgICAgIHJldHVybiByZXMucmVzaGFwZShuZXdTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5tYXggPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBvcmlnQXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGF4ZXMgPSBvcmlnQXhlcztcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5tYXgoeCwgYXhlcyk7IH0sIHsgeDogeCB9KTtcbiAgICAgICAgaWYgKGtlZXBEaW1zKSB7XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGUgPSBheGlzX3V0aWwuZXhwYW5kU2hhcGVUb0tlZXBEaW0ocmVzLnNoYXBlLCBvcmlnQXhlcyk7XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGUobmV3U2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICBSZWR1Y3Rpb25PcHMuYXJnTWluID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB2YXIgYXhlcyA9IGF4aXNfdXRpbC5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIHBlcm11dGVkQXhlcyA9IGF4aXNfdXRpbC5nZXRBeGVzUGVybXV0YXRpb24oYXhlcywgeC5yYW5rKTtcbiAgICAgICAgaWYgKHBlcm11dGVkQXhlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB4ID0geC50cmFuc3Bvc2UocGVybXV0ZWRBeGVzKTtcbiAgICAgICAgICAgIGF4ZXMgPSBheGlzX3V0aWwuZ2V0SW5uZXJNb3N0QXhlcyhheGVzLmxlbmd0aCwgeC5yYW5rKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hcmdNaW4oeCwgYXhlcyk7IH0sIHsgeDogeCB9KTtcbiAgICB9O1xuICAgIFJlZHVjdGlvbk9wcy5hcmdNYXggPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgcGVybXV0ZWRBeGVzID0gYXhpc191dGlsLmdldEF4ZXNQZXJtdXRhdGlvbihheGVzLCB4LnJhbmspO1xuICAgICAgICBpZiAocGVybXV0ZWRBeGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHggPSB4LnRyYW5zcG9zZShwZXJtdXRlZEF4ZXMpO1xuICAgICAgICAgICAgYXhlcyA9IGF4aXNfdXRpbC5nZXRJbm5lck1vc3RBeGVzKGF4ZXMubGVuZ3RoLCB4LnJhbmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFyZ01heCh4LCBheGVzKTsgfSwgeyB4OiB4IH0pO1xuICAgIH07XG4gICAgUmVkdWN0aW9uT3BzLm1vbWVudHMgPSBmdW5jdGlvbiAoeCwgYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHZhciBheGVzID0gYXhpc191dGlsLnBhcnNlQXhpc1BhcmFtKGF4aXMsIHguc2hhcGUpO1xuICAgICAgICB2YXIgbWVhbiA9IHgubWVhbihheGVzLCBrZWVwRGltcyk7XG4gICAgICAgIHZhciBrZWVwRGltc1NoYXBlID0gbWVhbi5zaGFwZTtcbiAgICAgICAgaWYgKCFrZWVwRGltcykge1xuICAgICAgICAgICAga2VlcERpbXNTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShtZWFuLnNoYXBlLCBheGVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGV2U3F1YXJlZCA9IHgudG9GbG9hdCgpLnN1YihtZWFuLnJlc2hhcGUoa2VlcERpbXNTaGFwZSkpLnNxdWFyZSgpO1xuICAgICAgICB2YXIgdmFyaWFuY2UgPSBkZXZTcXVhcmVkLm1lYW4oYXhlcywga2VlcERpbXMpO1xuICAgICAgICByZXR1cm4geyBtZWFuOiBtZWFuLCB2YXJpYW5jZTogdmFyaWFuY2UgfTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwibG9nU3VtRXhwXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwic3VtXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdSZWR1Y3Rpb24nIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBSZWR1Y3Rpb25PcHMsIFwibWVhblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcIm1pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcIm1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcImFyZ01pblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnUmVkdWN0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmVkdWN0aW9uT3BzLCBcImFyZ01heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnTm9ybWFsaXphdGlvbicgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFJlZHVjdGlvbk9wcywgXCJtb21lbnRzXCIsIG51bGwpO1xuICAgIHJldHVybiBSZWR1Y3Rpb25PcHM7XG59KCkpO1xuZXhwb3J0cy5SZWR1Y3Rpb25PcHMgPSBSZWR1Y3Rpb25PcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsXzEgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgUmV2ZXJzZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUmV2ZXJzZU9wcygpIHtcbiAgICB9XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlMWQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDEsIFwiRXJyb3IgaW4gcmV2ZXJzZTFEOiB4IG11c3QgYmUgcmFuayAxIGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIFJldmVyc2VPcHMucmV2ZXJzZSh4LCAwKTtcbiAgICB9O1xuICAgIFJldmVyc2VPcHMucmV2ZXJzZTJkID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSAyLCBcIkVycm9yIGluIHJldmVyc2UyRDogeCBtdXN0IGJlIHJhbmsgMiBidXQgZ290XFxuICAgICAgICAgICAgIHJhbmsgXCIgKyB4LnJhbmsgKyBcIi5cIik7XG4gICAgICAgIHJldHVybiBSZXZlcnNlT3BzLnJldmVyc2UoeCwgYXhpcyk7XG4gICAgfTtcbiAgICBSZXZlcnNlT3BzLnJldmVyc2UzZCA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJFcnJvciBpbiByZXZlcnNlM0Q6IHggbXVzdCBiZSByYW5rIDMgYnV0IGdvdFxcbiAgICAgICAgICAgICByYW5rIFwiICsgeC5yYW5rICsgXCIuXCIpO1xuICAgICAgICByZXR1cm4gUmV2ZXJzZU9wcy5yZXZlcnNlKHgsIGF4aXMpO1xuICAgIH07XG4gICAgUmV2ZXJzZU9wcy5yZXZlcnNlNGQgPSBmdW5jdGlvbiAoeCwgYXhpcykge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDQsIFwiRXJyb3IgaW4gcmV2ZXJzZTREOiB4IG11c3QgYmUgcmFuayA0IGJ1dCBnb3RcXG4gICAgICAgICAgICAgcmFuayBcIiArIHgucmFuayArIFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIFJldmVyc2VPcHMucmV2ZXJzZSh4LCBheGlzKTtcbiAgICB9O1xuICAgIFJldmVyc2VPcHMucmV2ZXJzZSA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB4LmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGF4ZXMgPSBheGlzX3V0aWxfMS5wYXJzZUF4aXNQYXJhbShheGlzLCB4LnNoYXBlKTtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LnJldmVyc2UoYXhlcyk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHJlcyA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucmV2ZXJzZSh4LCBheGVzKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgICAgICByZXR1cm4gcmVzLnJlc2hhcGVBcyh4KTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdTbGljaW5nIGFuZCBKb2luaW5nJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgUmV2ZXJzZU9wcywgXCJyZXZlcnNlXCIsIG51bGwpO1xuICAgIHJldHVybiBSZXZlcnNlT3BzO1xufSgpKTtcbmV4cG9ydHMuUmV2ZXJzZU9wcyA9IFJldmVyc2VPcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU0VMVV9TQ0FMRUFMUEhBID0gMS43NTgwOTkzNDA4NDczNzY4NTk5NDAyMTc1MjA4MTIzO1xuZXhwb3J0cy5TRUxVX1NDQUxFID0gMS4wNTA3MDA5ODczNTU0ODA0OTM0MTkzMzQ5ODUyOTQ2O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIHNsaWNlX3V0aWwgPSByZXF1aXJlKFwiLi9zbGljZV91dGlsXCIpO1xudmFyIFNsaWNlT3BzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTbGljZU9wcygpIHtcbiAgICB9XG4gICAgU2xpY2VPcHMuc2xpY2UxZCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDEsIFwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0xIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIgKyB4LnJhbmsgKyBcIiB0ZW5zb3JcIik7XG4gICAgICAgIHJldHVybiBTbGljZU9wcy5zbGljZSh4LCBbYmVnaW5dLCBbc2l6ZV0pO1xuICAgIH07XG4gICAgU2xpY2VPcHMuc2xpY2UyZCA9IGZ1bmN0aW9uICh4LCBiZWdpbiwgc2l6ZSkge1xuICAgICAgICB1dGlsLmFzc2VydCh4LnJhbmsgPT09IDIsIFwic2xpY2UxZCBleHBlY3RzIGEgcmFuay0yIHRlbnNvciwgYnV0IGdvdCBhIHJhbmstXCIgKyB4LnJhbmsgKyBcIiB0ZW5zb3JcIik7XG4gICAgICAgIHJldHVybiBTbGljZU9wcy5zbGljZSh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgfTtcbiAgICBTbGljZU9wcy5zbGljZTNkID0gZnVuY3Rpb24gKHgsIGJlZ2luLCBzaXplKSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gMywgXCJzbGljZTFkIGV4cGVjdHMgYSByYW5rLTMgdGVuc29yLCBidXQgZ290IGEgcmFuay1cIiArIHgucmFuayArIFwiIHRlbnNvclwiKTtcbiAgICAgICAgcmV0dXJuIFNsaWNlT3BzLnNsaWNlKHgsIGJlZ2luLCBzaXplKTtcbiAgICB9O1xuICAgIFNsaWNlT3BzLnNsaWNlNGQgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgdXRpbC5hc3NlcnQoeC5yYW5rID09PSA0LCBcInNsaWNlMWQgZXhwZWN0cyBhIHJhbmstNCB0ZW5zb3IsIGJ1dCBnb3QgYSByYW5rLVwiICsgeC5yYW5rICsgXCIgdGVuc29yXCIpO1xuICAgICAgICByZXR1cm4gU2xpY2VPcHMuc2xpY2UoeCwgYmVnaW4sIHNpemUpO1xuICAgIH07XG4gICAgU2xpY2VPcHMuc2xpY2UgPSBmdW5jdGlvbiAoeCwgYmVnaW4sIHNpemUpIHtcbiAgICAgICAgc2xpY2VfdXRpbC5hc3NlcnRQYXJhbXNWYWxpZCh4LCBiZWdpbiwgc2l6ZSk7XG4gICAgICAgIGlmICh4LnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2xpY2luZyBzY2FsYXIgaXMgbm90IHBvc3NpYmxlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGlucHV0U2hhcGUgPSB4LnNoYXBlO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHBhZGRpbmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGR5LnJhbms7IGkrKykge1xuICAgICAgICAgICAgICAgIHBhZGRpbmdzLnB1c2goW2JlZ2luW2ldLCBpbnB1dFNoYXBlW2ldIC0gYmVnaW5baV0gLSBzaXplW2ldXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5wYWQocGFkZGluZ3MpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNsaWNlKHgsIGJlZ2luLCBzaXplKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ1NsaWNpbmcgYW5kIEpvaW5pbmcnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBTbGljZU9wcywgXCJzbGljZVwiLCBudWxsKTtcbiAgICByZXR1cm4gU2xpY2VPcHM7XG59KCkpO1xuZXhwb3J0cy5TbGljZU9wcyA9IFNsaWNlT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xuZnVuY3Rpb24gYXNzZXJ0UGFyYW1zVmFsaWQoaW5wdXQsIGJlZ2luLCBzaXplKSB7XG4gICAgdXRpbC5hc3NlcnQoaW5wdXQucmFuayA9PT0gYmVnaW4ubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2YgYmVnaW4gXCIgKyBiZWdpbiArIFwiIG11c3QgXCIgK1xuICAgICAgICAoXCJtYXRjaCB0aGUgcmFuayBvZiB0aGUgYXJyYXkgKFwiICsgaW5wdXQucmFuayArIFwiKS5cIikpO1xuICAgIHV0aWwuYXNzZXJ0KGlucHV0LnJhbmsgPT09IHNpemUubGVuZ3RoLCBcIkVycm9yIGluIHNsaWNlXCIgKyBpbnB1dC5yYW5rICsgXCJEOiBMZW5ndGggb2Ygc2l6ZSBcIiArIHNpemUgKyBcIiBtdXN0IFwiICtcbiAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgb2YgdGhlIGFycmF5IChcIiArIGlucHV0LnJhbmsgKyBcIikuXCIpKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0LnJhbms7ICsraSkge1xuICAgICAgICB1dGlsLmFzc2VydChiZWdpbltpXSArIHNpemVbaV0gPD0gaW5wdXQuc2hhcGVbaV0sIFwiRXJyb3IgaW4gc2xpY2VcIiArIGlucHV0LnJhbmsgKyBcIkQ6IGJlZ2luW1wiICsgaSArIFwiXSArIHNpemVbXCIgKyBpICsgXCJdIFwiICtcbiAgICAgICAgICAgIChcIihcIiArIChiZWdpbltpXSArIHNpemVbaV0pICsgXCIpIHdvdWxkIG92ZXJmbG93IGlucHV0LnNoYXBlW1wiICsgaSArIFwiXSAoXCIgKyBpbnB1dC5zaGFwZVtpXSArIFwiKVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5hc3NlcnRQYXJhbXNWYWxpZCA9IGFzc2VydFBhcmFtc1ZhbGlkO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi4vdXRpbFwiKTtcbnZhciBheGlzX3V0aWwgPSByZXF1aXJlKFwiLi9heGlzX3V0aWxcIik7XG52YXIgb3BlcmF0aW9uXzEgPSByZXF1aXJlKFwiLi9vcGVyYXRpb25cIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4vb3BzXCIpO1xudmFyIFNvZnRtYXhPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvZnRtYXhPcHMoKSB7XG4gICAgfVxuICAgIFNvZnRtYXhPcHMuc29mdG1heCA9IGZ1bmN0aW9uIChsb2dpdHMsIGRpbSkge1xuICAgICAgICBpZiAoZGltID09PSB2b2lkIDApIHsgZGltID0gLTE7IH1cbiAgICAgICAgaWYgKGRpbSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRpbSA9IGxvZ2l0cy5yYW5rIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltICE9PSBsb2dpdHMucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdTb2Z0bWF4IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLiAnICtcbiAgICAgICAgICAgICAgICAoXCJMb2dpdHMgd2FzIHJhbmsgXCIgKyBsb2dpdHMucmFuayArIFwiIGFuZCBkaW0gd2FzIFwiICsgZGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbU9wID0gZ2xvYmFsc18xLmN1c3RvbUdyYWQoZnVuY3Rpb24gKGxvZ2l0cykge1xuICAgICAgICAgICAgdmFyIGtlZXBEaW1zID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBsc2UgPSBsb2dpdHMubG9nU3VtRXhwKFtkaW1dLCBrZWVwRGltcyk7XG4gICAgICAgICAgICB2YXIgbG9nUmVzdWx0ID0gbG9naXRzLnRvRmxvYXQoKS5zdWIobHNlKTtcbiAgICAgICAgICAgIHZhciB5ID0gbG9nUmVzdWx0LmV4cCgpO1xuICAgICAgICAgICAgdmFyIGdyYWRGdW5jID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGR5VGltZXNZID0gZHkubXVsKHkpO1xuICAgICAgICAgICAgICAgIHZhciBrZWVwRGltcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGR5VGltZXNZLnN1YihkeVRpbWVzWS5zdW0oW2RpbV0sIGtlZXBEaW1zKS5tdWwoeSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiB5LCBncmFkRnVuYzogZ3JhZEZ1bmMgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBjdXN0b21PcChsb2dpdHMpO1xuICAgIH07XG4gICAgU29mdG1heE9wcy5zb2Z0bWF4Q3Jvc3NFbnRyb3B5ID0gZnVuY3Rpb24gKGxhYmVscywgbG9naXRzLCBkaW0pIHtcbiAgICAgICAgaWYgKGRpbSA9PT0gdm9pZCAwKSB7IGRpbSA9IC0xOyB9XG4gICAgICAgIHV0aWwuYXNzZXJ0U2hhcGVzTWF0Y2gobGFiZWxzLnNoYXBlLCBsb2dpdHMuc2hhcGUsICdFcnJvciBpbiBzb2Z0bWF4Q3Jvc3NFbnRyb3B5OiAnKTtcbiAgICAgICAgaWYgKGRpbSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGRpbSA9IGxvZ2l0cy5yYW5rIC0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGltICE9PSBsb2dpdHMucmFuayAtIDEpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiU29mdG1heCBjcm9zcyBlbnRyb3B5IGFsb25nIGEgbm9uLWxhc3QgZGltZW5zaW9uIGlzIG5vdCB5ZXQgXCIgK1xuICAgICAgICAgICAgICAgIChcInN1cHBvcnRlZC4gTGFiZWxzIC8gbG9naXRzIHdhcyByYW5rIFwiICsgbG9naXRzLnJhbmsgKyBcIiBcIikgK1xuICAgICAgICAgICAgICAgIChcImFuZCBkaW0gd2FzIFwiICsgZGltKSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN1c3RvbU9wID0gZ2xvYmFsc18xLmN1c3RvbUdyYWQoZnVuY3Rpb24gKGxhYmVscywgbG9naXRzKSB7XG4gICAgICAgICAgICB2YXIgcHJlZGljdGVkUHJvYnMgPSBsb2dpdHMuc29mdG1heChkaW0pO1xuICAgICAgICAgICAgdmFyIGNvc3RWZWN0b3IgPSBvcHMuc2NhbGFyKDFlLTUpLmFkZChwcmVkaWN0ZWRQcm9icykubG9nKCkubXVsKGxhYmVscykubmVnKCk7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBjb3N0VmVjdG9yLnN1bShbZGltXSk7XG4gICAgICAgICAgICB2YXIgZ3JhZEZ1bmMgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHlTaGFwZSA9IGF4aXNfdXRpbC5leHBhbmRTaGFwZVRvS2VlcERpbShkeS5zaGFwZSwgW2RpbV0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGR5LnJlc2hhcGUoZHlTaGFwZSkubXVsKGxhYmVscy50b0Zsb2F0KCkuc3ViKHByZWRpY3RlZFByb2JzKSksXG4gICAgICAgICAgICAgICAgICAgIGR5LnJlc2hhcGUoZHlTaGFwZSkubXVsKHByZWRpY3RlZFByb2JzLnN1YihsYWJlbHMudG9GbG9hdCgpKSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWUsIGdyYWRGdW5jOiBncmFkRnVuYyB9O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGN1c3RvbU9wKGxhYmVscywgbG9naXRzKTtcbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdOb3JtYWxpemF0aW9uJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgU29mdG1heE9wcywgXCJzb2Z0bWF4XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnTG9zc2VzJywgbmFtZXNwYWNlOiAnbG9zc2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgU29mdG1heE9wcywgXCJzb2Z0bWF4Q3Jvc3NFbnRyb3B5XCIsIG51bGwpO1xuICAgIHJldHVybiBTb2Z0bWF4T3BzO1xufSgpKTtcbmV4cG9ydHMuU29mdG1heE9wcyA9IFNvZnRtYXhPcHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2RlY29yYXRlID0gKHRoaXMgJiYgdGhpcy5fX2RlY29yYXRlKSB8fCBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBkb2NfMSA9IHJlcXVpcmUoXCIuLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4uL3V0aWxcIik7XG52YXIgYXhpc191dGlsID0gcmVxdWlyZShcIi4vYXhpc191dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIFRyYW5zcG9zZU9wcyA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3NlT3BzKCkge1xuICAgIH1cbiAgICBUcmFuc3Bvc2VPcHMudHJhbnNwb3NlID0gZnVuY3Rpb24gKHgsIHBlcm0pIHtcbiAgICAgICAgaWYgKHBlcm0gPT0gbnVsbCkge1xuICAgICAgICAgICAgcGVybSA9IHguc2hhcGUubWFwKGZ1bmN0aW9uIChzLCBpKSB7IHJldHVybiBpOyB9KS5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlciA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHVuZG9QZXJtID0gYXhpc191dGlsLmdldFVuZG9BeGVzUGVybXV0YXRpb24ocGVybSk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS50cmFuc3Bvc2UodW5kb1Blcm0pOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHV0aWwuYXNzZXJ0KHgucmFuayA9PT0gcGVybS5sZW5ndGgsIFwiRXJyb3IgaW4gdHJhbnNwb3NlOiByYW5rIG9mIGlucHV0IFwiICsgeC5yYW5rICsgXCIgXCIgK1xuICAgICAgICAgICAgKFwibXVzdCBtYXRjaCBsZW5ndGggb2YgcGVybSBcIiArIHBlcm0gKyBcIi5cIikpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC50cmFuc3Bvc2UoeCwgcGVybSk7IH0sIHsgeDogeCB9LCBkZXIpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ01hdHJpY2VzJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVHJhbnNwb3NlT3BzLCBcInRyYW5zcG9zZVwiLCBudWxsKTtcbiAgICByZXR1cm4gVHJhbnNwb3NlT3BzO1xufSgpKTtcbmV4cG9ydHMuVHJhbnNwb3NlT3BzID0gVHJhbnNwb3NlT3BzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi91dGlsXCIpO1xudmFyIG9wZXJhdGlvbl8xID0gcmVxdWlyZShcIi4vb3BlcmF0aW9uXCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuL29wc1wiKTtcbnZhciBzZWx1X3V0aWwgPSByZXF1aXJlKFwiLi9zZWx1X3V0aWxcIik7XG52YXIgVW5hcnlPcHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFVuYXJ5T3BzKCkge1xuICAgIH1cbiAgICBVbmFyeU9wcy5uZWcgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubmVnKCk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubmVnKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5jZWlsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNlaWwoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmZsb29yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmZsb29yKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5leHAgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgYmNrID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdCh5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCwgc2F2ZSkgeyByZXR1cm4gc2F2ZShiYWNrZW5kLmV4cCh4KSk7IH0sIHsgeDogeCB9LCBiY2spO1xuICAgIH07XG4gICAgVW5hcnlPcHMubG9nID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdlN0cmljdCh4LnRvRmxvYXQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubG9nKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zcXJ0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5LmRpdlN0cmljdCh4LnRvRmxvYXQoKS5zcXJ0KCkubXVsKG9wcy5zY2FsYXIoMikpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zcXJ0KHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5zcXVhcmUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHgudG9GbG9hdCgpLm11bChvcHMuc2NhbGFyKDIpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc3F1YXJlKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5hYnMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkubXVsU3RyaWN0KHgudG9GbG9hdCgpLnN0ZXAoLTEpKTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5hYnMoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmNsaXBCeVZhbHVlID0gZnVuY3Rpb24gKHgsIGNsaXBWYWx1ZU1pbiwgY2xpcFZhbHVlTWF4KSB7XG4gICAgICAgIHV0aWwuYXNzZXJ0KChjbGlwVmFsdWVNaW4gPD0gY2xpcFZhbHVlTWF4KSwgXCJFcnJvciBpbiBjbGlwOiBtaW4gKFwiICsgY2xpcFZhbHVlTWluICsgXCIpIG11c3QgYmVcIiArXG4gICAgICAgICAgICAoXCJsZXNzIHRoYW4gb3IgZXF1YWwgdG8gbWF4IChcIiArIGNsaXBWYWx1ZU1heCArIFwiKS5cIikpO1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS53aGVyZSh4LmdyZWF0ZXIob3BzLnNjYWxhcihjbGlwVmFsdWVNaW4pKVxuICAgICAgICAgICAgICAgICAgICAubG9naWNhbEFuZCh4Lmxlc3Mob3BzLnNjYWxhcihjbGlwVmFsdWVNYXgpKSksIG9wc18xLnplcm9zTGlrZShkeSkpOyB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY2xpcCh4LCBjbGlwVmFsdWVNaW4sIGNsaXBWYWx1ZU1heCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnJlbHUgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgdmFyIHN0ZXBSZXMgPSB4LnN0ZXAoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdChzdGVwUmVzLnRvRmxvYXQoKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQucmVsdSh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuZWx1ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdChlbHVEZXIoeCkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmVsdSh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2VsdSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2sgPSB4LmdyZWF0ZXIob3BzLnNjYWxhcigwKSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzY2FsZUFscGhhID0gb3BzLnNjYWxhcihzZWx1X3V0aWwuU0VMVV9TQ0FMRUFMUEhBKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjYWxlID0gb3BzLnNjYWxhcihzZWx1X3V0aWwuU0VMVV9TQ0FMRSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBncmVhdGVyVGhhblplcm9EZXIgPSBkeS5tdWwoc2NhbGUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVzc0VxdWFsWmVyb0RlciA9IGR5Lm11bChzY2FsZUFscGhhKS5tdWwoeC50b0Zsb2F0KCkuZXhwKCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3BzLndoZXJlKG1hc2ssIGdyZWF0ZXJUaGFuWmVyb0RlciwgbGVzc0VxdWFsWmVyb0Rlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuc2VsdSh4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMubGVha3lSZWx1ID0gZnVuY3Rpb24gKHgsIGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4yOyB9XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBkeS5tdWxTdHJpY3QoeC5zdGVwKGFscGhhKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQubGVha3lSZWx1KHgsIGFscGhhKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMucHJlbHUgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdChwcmVsdURlcih4LCBhbHBoYSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnByZWx1KHgsIGFscGhhKTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2lnbW9pZCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5LCBzYXZlZCkge1xuICAgICAgICAgICAgdmFyIHkgPSBzYXZlZFswXTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGR5Lm11bFN0cmljdCh5Lm11bChvcHMuc2NhbGFyKDEpLnN1Yih5KSkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQuc2lnbW9pZCh4KSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4LnRvRmxvYXQoKS5jb3MoKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnNpbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuY29zID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHgudG9GbG9hdCgpLnNpbigpLm5lZygpLm11bFN0cmljdChkeSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuY29zKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy50YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KHguY29zKCkuc3F1YXJlKCkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnRhbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuYXNpbiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGR5LmRpdlN0cmljdChVbmFyeU9wcy5zcXJ0KG9wcy5zY2FsYXIoMSkuc3ViKHgudG9GbG9hdCgpLnNxdWFyZSgpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFzaW4oeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmFjb3MgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB4OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkeS5kaXZTdHJpY3QoVW5hcnlPcHMuc3FydChvcHMuc2NhbGFyKDEpLnN1Yih4LnRvRmxvYXQoKS5zcXVhcmUoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgLm5lZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmFjb3MoeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLmF0YW4gPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZHkuZGl2U3RyaWN0KG9wcy5zY2FsYXIoMSkuYWRkKHgudG9GbG9hdCgpLnNxdWFyZSgpKSk7IH0gfTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5ydW5LZXJuZWwoZnVuY3Rpb24gKGJhY2tlbmQpIHsgcmV0dXJuIGJhY2tlbmQuYXRhbih4KTsgfSwgeyB4OiB4IH0sIGdyYWQpO1xuICAgIH07XG4gICAgVW5hcnlPcHMuc2luaCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHZhciBncmFkID0gZnVuY3Rpb24gKGR5KSB7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiB4LnRvRmxvYXQoKS5jb3NoKCkubXVsU3RyaWN0KGR5KTsgfSB9O1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5zaW5oKHgpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBVbmFyeU9wcy5jb3NoID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHgudG9GbG9hdCgpLnNpbmgoKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLmNvc2goeCk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnRhbmggPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB2YXIgZ3JhZCA9IGZ1bmN0aW9uIChkeSwgc2F2ZWQpIHtcbiAgICAgICAgICAgIHZhciB5ID0gc2F2ZWRbMF07XG4gICAgICAgICAgICByZXR1cm4geyB4OiBmdW5jdGlvbiAoKSB7IHJldHVybiBvcHMuc2NhbGFyKDEpLnN1Yih5LnNxdWFyZSgpKS5tdWxTdHJpY3QoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kLCBzYXZlKSB7IHJldHVybiBzYXZlKGJhY2tlbmQudGFuaCh4KSk7IH0sIHsgeDogeCB9LCBncmFkKTtcbiAgICB9O1xuICAgIFVuYXJ5T3BzLnN0ZXAgPSBmdW5jdGlvbiAoeCwgYWxwaGEpIHtcbiAgICAgICAgaWYgKGFscGhhID09PSB2b2lkIDApIHsgYWxwaGEgPSAwLjA7IH1cbiAgICAgICAgdmFyIGdyYWQgPSBmdW5jdGlvbiAoZHkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9wcy56ZXJvc0xpa2UoZHkpOyB9IH07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucnVuS2VybmVsKGZ1bmN0aW9uIChiYWNrZW5kKSB7IHJldHVybiBiYWNrZW5kLnN0ZXAoeCwgYWxwaGEpOyB9LCB7IHg6IHggfSwgZ3JhZCk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcIm5lZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImNlaWxcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJmbG9vclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImV4cFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImxvZ1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInNxcnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzcXVhcmVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhYnNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJjbGlwQnlWYWx1ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcInJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwibGVha3lSZWx1XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwicHJlbHVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJzaWdtb2lkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic2luXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiY29zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwidGFuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwiYXNpblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImFjb3NcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJhdGFuXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic2luaFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ09wZXJhdGlvbnMnLCBzdWJoZWFkaW5nOiAnQmFzaWMgbWF0aCcgfSksXG4gICAgICAgIG9wZXJhdGlvbl8xLm9wZXJhdGlvblxuICAgIF0sIFVuYXJ5T3BzLCBcImNvc2hcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdPcGVyYXRpb25zJywgc3ViaGVhZGluZzogJ0Jhc2ljIG1hdGgnIH0pLFxuICAgICAgICBvcGVyYXRpb25fMS5vcGVyYXRpb25cbiAgICBdLCBVbmFyeU9wcywgXCJ0YW5oXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnT3BlcmF0aW9ucycsIHN1YmhlYWRpbmc6ICdCYXNpYyBtYXRoJyB9KSxcbiAgICAgICAgb3BlcmF0aW9uXzEub3BlcmF0aW9uXG4gICAgXSwgVW5hcnlPcHMsIFwic3RlcFwiLCBudWxsKTtcbiAgICByZXR1cm4gVW5hcnlPcHM7XG59KCkpO1xuZXhwb3J0cy5VbmFyeU9wcyA9IFVuYXJ5T3BzO1xuZnVuY3Rpb24gcHJlbHVEZXIoeCwgYWxwaGEpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5wcmVsdURlcih4LCBhbHBoYSk7IH0sIHsgeDogeCwgYWxwaGE6IGFscGhhIH0pO1xufVxuZnVuY3Rpb24gZWx1RGVyKHgpIHtcbiAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJ1bktlcm5lbChmdW5jdGlvbiAoYmFja2VuZCkgeyByZXR1cm4gYmFja2VuZC5lbHVEZXIoeCk7IH0sIHsgeDogeCB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGgvdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFkZWx0YU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYWRlbHRhT3B0aW1pemVyLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFkYWRlbHRhT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgcmhvLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QsIGVwc2lsb24pIHtcbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRHcmFkcyA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXMgPSB7fTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzR3JhcGggPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlc0dyYXBoID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKC1sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzaWxvbiA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihlcHNpbG9uKSk7XG4gICAgICAgIF90aGlzLnJobyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihyaG8pKTtcbiAgICAgICAgX3RoaXMub25lTWludXNSaG8gPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIHJobykpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWRlbHRhT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGVfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWQgPSB0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkVXBkYXRlID0gdGhpc18xLmFjY3VtdWxhdGVkVXBkYXRlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZEdyYWQgPSBfdGhpcy5yaG8ubXVsKGFjY3VtdWxhdGVkR3JhZClcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c1Joby5tdWwoZ3JhZGllbnQuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcyA9IGFjY3VtdWxhdGVkVXBkYXRlLmFkZChfdGhpcy5lcHNpbG9uKVxuICAgICAgICAgICAgICAgICAgICAuc3FydCgpXG4gICAgICAgICAgICAgICAgICAgIC5kaXYoYWNjdW11bGF0ZWRHcmFkLmFkZChfdGhpcy5lcHNpbG9uKS5zcXJ0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5tdWwoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZFVwZGF0ZSA9IF90aGlzLnJoby5tdWwoYWNjdW11bGF0ZWRVcGRhdGUpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNSaG8ubXVsKHVwZGF0ZXMuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkR3JhZCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkVXBkYXRlKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3VmFsdWUgPSBfdGhpcy5jLm11bCh1cGRhdGVzKS5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzR3JhcGguc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50c0dyYXBoLnNldChub2RlLm91dHB1dCwgdGVuc29yXzEuVGVuc29yLnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzR3JhcGguc2V0KG5vZGUub3V0cHV0LCB0ZW5zb3JfMS5UZW5zb3IuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFkZWx0YU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5vbmUgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbmUgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSkpO1xuICAgICAgICB9XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGRWYXJpYWJsZSA9IGFjdGl2YXRpb25BcnJheU1hcC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZENhY2hlID0gX3RoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzR3JhcGguZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVXBkYXRlcyA9IF90aGlzLmFjY3VtdWxhdGVkVXBkYXRlc0dyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50U3F1YXJlID0gbWF0aC5tdWx0aXBseShncmFkaWVudCwgZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIHZhciBjYWNoZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMucmhvLCBvbGRDYWNoZSwgbWF0aC5zdWJ0cmFjdChfdGhpcy5vbmUsIF90aGlzLnJobyksIGdyYWRpZW50U3F1YXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgdXBkYXRlcyA9IG1hdGgubXVsdGlwbHkobWF0aC5kaXZpZGUobWF0aC5zcXJ0KG1hdGguYWRkKG9sZFVwZGF0ZXMsIF90aGlzLmVwc2lsb24pKSwgbWF0aC5zcXJ0KG1hdGguYWRkKG9sZENhY2hlLCBfdGhpcy5lcHNpbG9uKSkpLCBncmFkaWVudCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jR3JhcGgsIHVwZGF0ZXMsIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIHZhciB1cGRhdGVTcXVhcmUgPSBtYXRoLm11bHRpcGx5KHVwZGF0ZXMsIHVwZGF0ZXMpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdVcGRhdGVzID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5yaG8sIG9sZFVwZGF0ZXMsIG1hdGguc3VidHJhY3QoX3RoaXMub25lLCBfdGhpcy5yaG8pLCB1cGRhdGVTcXVhcmUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50c0dyYXBoLnNldChub2RlLm91dHB1dCwgZ2xvYmFsc18xLmtlZXAoY2FjaGUpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFVwZGF0ZXNHcmFwaC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKG5ld1VwZGF0ZXMpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRDYWNoZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkVXBkYXRlcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgIH07XG4gICAgQWRhZGVsdGFPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwc2lsb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLnJoby5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lTWludXNSaG8uZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5vbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50c0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0ZWRTcXVhcmVkR3JhZGllbnRzR3JhcGguZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlc0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0ZWRVcGRhdGVzR3JhcGguZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkVXBkYXRlcylcbiAgICAgICAgICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gX3RoaXMuYWNjdW11bGF0ZWRVcGRhdGVzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkR3JhZHMpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkR3JhZHNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEFkYWRlbHRhT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZGVsdGFPcHRpbWl6ZXIgPSBBZGFkZWx0YU9wdGltaXplcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGgvdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4uL3RlbnNvclwiKTtcbnZhciBvcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplclwiKTtcbnZhciBBZGFncmFkT3B0aW1pemVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWRhZ3JhZE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0LCBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSkge1xuICAgICAgICBpZiAoaW5pdGlhbEFjY3VtdWxhdG9yVmFsdWUgPT09IHZvaWQgMCkgeyBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9IDAuMTsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9IGluaXRpYWxBY2N1bXVsYXRvclZhbHVlO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzID0ge307XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigtbGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIF90aGlzLmVwc2lsb24gPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMWUtOCkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKHZhcmlhYmxlTmFtZSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGlmICh0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkR3JhZHNbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS5maWxsKHZhbHVlLnNoYXBlLCBfdGhpcy5pbml0aWFsQWNjdW11bGF0b3JWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIHZhciBhY2N1bXVsYXRlZEdyYWQgPSB0aGlzXzEuYWNjdW11bGF0ZWRHcmFkc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZEdyYWQgPSBhY2N1bXVsYXRlZEdyYWQuYWRkKGdyYWRpZW50LnNxdWFyZSgpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkR3JhZCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuY1xuICAgICAgICAgICAgICAgICAgICAubXVsKGdyYWRpZW50LmRpdihuZXdBY2N1bXVsYXRlZEdyYWQuYWRkKF90aGlzLmVwc2lsb24pLnNxcnQoKSkpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQodmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIHRlbnNvcl8xLlRlbnNvci56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFkYWdyYWRPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMub25lID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25lID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEpKTtcbiAgICAgICAgfVxuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRDYWNoZSA9IF90aGlzLmFjY3VtdWxhdGVkU3F1YXJlZEdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudFNxdWFyZSA9IG1hdGgubXVsdGlwbHkoZ3JhZGllbnQsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgY2FjaGUgPSBtYXRoLmFkZChvbGRDYWNoZSwgZ3JhZGllbnRTcXVhcmUpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMuY0dyYXBoLCBtYXRoLmRpdmlkZShncmFkaWVudCwgbWF0aC5hZGQobWF0aC5zcXJ0KGNhY2hlKSwgX3RoaXMuZXBzaWxvbikpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcChjYWNoZSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZENhY2hlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFncmFkT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5lcHNpbG9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgaWYgKHRoaXMub25lICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMub25lLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5hY2N1bXVsYXRlZFNxdWFyZWRHcmFkaWVudHMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkR3JhZHMgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZEdyYWRzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZEdyYWRzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBBZGFncmFkT3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhZ3JhZE9wdGltaXplciA9IEFkYWdyYWRPcHRpbWl6ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi4vZW52aXJvbm1lbnRcIik7XG52YXIgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL2dyYXBoL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgQWRhbU9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1PcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWRhbU9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgZXBzaWxvbiwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCA9IHt9O1xuICAgICAgICBfdGhpcy5maXJzdE1vbWVudEdyYXBoID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5zZWNvbmRNb21lbnRHcmFwaCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgX3RoaXMuYyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigtbGVhcm5pbmdSYXRlKSk7XG4gICAgICAgIF90aGlzLmVwcyA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcihlcHNpbG9uKSk7XG4gICAgICAgIF90aGlzLmJldGExID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGJldGExKSk7XG4gICAgICAgIF90aGlzLmJldGEyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGJldGEyKSk7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGExID0gb3BzXzEuc2NhbGFyKGJldGExKS52YXJpYWJsZSgpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTIgPSBvcHNfMS5zY2FsYXIoYmV0YTIpLnZhcmlhYmxlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpcy5vbmVNaW51c0JldGExID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEgLSBiZXRhMSkpO1xuICAgICAgICBfdGhpcy5vbmVNaW51c0JldGEyID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKDEgLSBiZXRhMikpO1xuICAgICAgICBfdGhpcy5vbmUgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSkpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFkYW1PcHRpbWl6ZXIucHJvdG90eXBlLmFwcGx5R3JhZGllbnRzID0gZnVuY3Rpb24gKHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbmVNaW51c0FjY0JldGExID0gX3RoaXMub25lLnN1YihfdGhpcy5hY2NCZXRhMSk7XG4gICAgICAgICAgICB2YXIgb25lTWludXNBY2NCZXRhMiA9IF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTIpO1xuICAgICAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRTZWNvbmRNb21lbnRbdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0TW9tZW50ID0gX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRNb21lbnQgPSBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IF90aGlzLmJldGExLm11bChmaXJzdE1vbWVudCkuYWRkKF90aGlzLm9uZU1pbnVzQmV0YTEubXVsKGdyYWRpZW50KSk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1NlY29uZE1vbWVudCA9IF90aGlzLmJldGEyLm11bChzZWNvbmRNb21lbnQpXG4gICAgICAgICAgICAgICAgICAgIC5hZGQoX3RoaXMub25lTWludXNCZXRhMi5tdWwoZ3JhZGllbnQuc3F1YXJlKCkpKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZEZpcnN0TW9tZW50ID0gbmV3Rmlyc3RNb21lbnQuZGl2KG9uZU1pbnVzQWNjQmV0YTEpO1xuICAgICAgICAgICAgICAgIHZhciBiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50ID0gbmV3U2Vjb25kTW9tZW50LmRpdihvbmVNaW51c0FjY0JldGEyKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0ZpcnN0TW9tZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFt2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdTZWNvbmRNb21lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IF90aGlzLmNcbiAgICAgICAgICAgICAgICAgICAgLm11bChiaWFzQ29ycmVjdGVkRmlyc3RNb21lbnQuZGl2KF90aGlzLmVwcy5hZGQoYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudC5zcXJ0KCkpKSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmFjY0JldGExLmFzc2lnbihfdGhpcy5hY2NCZXRhMS5tdWwoX3RoaXMuYmV0YTEpKTtcbiAgICAgICAgICAgIF90aGlzLmFjY0JldGEyLmFzc2lnbihfdGhpcy5hY2NCZXRhMi5tdWwoX3RoaXMuYmV0YTIpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudEdyYXBoLnNpemUoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5maXJzdE1vbWVudEdyYXBoLnNldChub2RlLm91dHB1dCwgdGVuc29yXzEuVGVuc29yLnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZWNvbmRNb21lbnRHcmFwaC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2Vjb25kTW9tZW50R3JhcGguc2V0KG5vZGUub3V0cHV0LCB0ZW5zb3JfMS5UZW5zb3IuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBvbmVNaW51c0FjY0JldGExID0gX3RoaXMub25lLnN1YihfdGhpcy5hY2NCZXRhMSk7XG4gICAgICAgICAgICB2YXIgb25lTWludXNBY2NCZXRhMiA9IF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTIpO1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudEdyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFNlY29uZE1vbWVudCA9IF90aGlzLnNlY29uZE1vbWVudEdyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iZXRhMSwgb2xkRmlyc3RNb21lbnQsIF90aGlzLm9uZU1pbnVzQmV0YTEsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3U2Vjb25kTW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iZXRhMiwgb2xkU2Vjb25kTW9tZW50LCBfdGhpcy5vbmVNaW51c0JldGEyLCBncmFkaWVudC5zcXVhcmUoKSk7XG4gICAgICAgICAgICAgICAgdmFyIGJpYXNDb3JyZWN0ZWRGaXJzdE1vbWVudCA9IG5ld0ZpcnN0TW9tZW50LmRpdihvbmVNaW51c0FjY0JldGExKTtcbiAgICAgICAgICAgICAgICB2YXIgYmlhc0NvcnJlY3RlZFNlY29uZE1vbWVudCA9IG5ld1NlY29uZE1vbWVudC5kaXYob25lTWludXNBY2NCZXRhMik7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5jR3JhcGgsIGJpYXNDb3JyZWN0ZWRGaXJzdE1vbWVudC5kaXYoX3RoaXMuZXBzLmFkZChiaWFzQ29ycmVjdGVkU2Vjb25kTW9tZW50LnNxcnQoKSkpLCBfdGhpcy5vbmUsIG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIF90aGlzLmZpcnN0TW9tZW50R3JhcGguc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcChuZXdGaXJzdE1vbWVudCkpO1xuICAgICAgICAgICAgICAgIF90aGlzLnNlY29uZE1vbWVudEdyYXBoLnNldChub2RlLm91dHB1dCwgZ2xvYmFsc18xLmtlZXAobmV3U2Vjb25kTW9tZW50KSk7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRGaXJzdE1vbWVudC5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgb2xkU2Vjb25kTW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTEuYXNzaWduKF90aGlzLmFjY0JldGExLm11bChfdGhpcy5iZXRhMSkpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTIuYXNzaWduKF90aGlzLmFjY0JldGEyLm11bChfdGhpcy5iZXRhMikpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBBZGFtT3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmRpc3Bvc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgdGhpcy5jLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5lcHMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5iZXRhMi5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYWNjQmV0YTEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmFjY0JldGEyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c0JldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c0JldGEyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudEdyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RNb21lbnRHcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2Vjb25kTW9tZW50R3JhcGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zZWNvbmRNb21lbnRHcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkU2Vjb25kTW9tZW50KVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZFNlY29uZE1vbWVudFtuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWRhbU9wdGltaXplcjtcbn0ob3B0aW1pemVyXzEuT3B0aW1pemVyKSk7XG5leHBvcnRzLkFkYW1PcHRpbWl6ZXIgPSBBZGFtT3B0aW1pemVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaC90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIEFkYW1heE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFkYW1heE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBZGFtYXhPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24sIGRlY2F5LCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICBpZiAoZGVjYXkgPT09IHZvaWQgMCkgeyBkZWNheSA9IDAuMDsgfVxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBsZWFybmluZ1JhdGUsIHNwZWNpZmllZFZhcmlhYmxlTGlzdCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50ID0ge307XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtID0ge307XG4gICAgICAgIF90aGlzLmZpcnN0TW9tZW50R3JhcGggPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybUdyYXBoID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKC1sZWFybmluZ1JhdGUpKTtcbiAgICAgICAgX3RoaXMuZXBzID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGVwc2lsb24pKTtcbiAgICAgICAgX3RoaXMuYmV0YTEgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTEpKTtcbiAgICAgICAgX3RoaXMuYmV0YTIgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoYmV0YTIpKTtcbiAgICAgICAgX3RoaXMuZGVjYXkgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZGVjYXkpKTtcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuaXRlcmF0aW9uID0gb3BzXzEuc2NhbGFyKDApLnZhcmlhYmxlKCk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCZXRhMSA9IG9wc18xLnNjYWxhcihiZXRhMSkudmFyaWFibGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLm9uZU1pbnVzQmV0YTEgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoMSAtIGJldGExKSk7XG4gICAgICAgIF90aGlzLm9uZSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxKSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb25lTWludXNBY2NCZXRhMSA9IF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTEpO1xuICAgICAgICAgICAgdmFyIGxyID0gX3RoaXMuYy5kaXYoX3RoaXMub25lLmFkZChfdGhpcy5kZWNheS5tdWwoX3RoaXMuaXRlcmF0aW9uKSkpO1xuICAgICAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRXZWlnaHRlZEluZk5vcm1bdmFyaWFibGVOYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHNfMS56ZXJvc0xpa2UodmFsdWUpLnZhcmlhYmxlKHRyYWluYWJsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICAgICAgdmFyIGZpcnN0TW9tZW50ID0gX3RoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudFt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRlZEluZk5vcm0gPSBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBuZXdGaXJzdE1vbWVudCA9IF90aGlzLmJldGExLm11bChmaXJzdE1vbWVudCkuYWRkKF90aGlzLm9uZU1pbnVzQmV0YTEubXVsKGdyYWRpZW50KSk7XG4gICAgICAgICAgICAgICAgdmFyIHV0MCA9IF90aGlzLmJldGEyLm11bCh3ZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciB1dDEgPSBncmFkaWVudC5hYnMoKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3V2VpZ2h0ZWRJbmZOb3JtID0gdXQwLm1heGltdW0odXQxKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZEZpcnN0TW9tZW50W3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0ZpcnN0TW9tZW50KTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVt2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdXZWlnaHRlZEluZk5vcm0pO1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGxyLmRpdihvbmVNaW51c0FjY0JldGExKVxuICAgICAgICAgICAgICAgICAgICAubXVsKG5ld0ZpcnN0TW9tZW50LmRpdihfdGhpcy5lcHMuYWRkKG5ld1dlaWdodGVkSW5mTm9ybSkpKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5hc3NpZ24obmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXRlcmF0aW9uLmFzc2lnbihfdGhpcy5pdGVyYXRpb24uYWRkKF90aGlzLm9uZSkpO1xuICAgICAgICAgICAgX3RoaXMuYWNjQmV0YTEuYXNzaWduKF90aGlzLmFjY0JldGExLm11bChfdGhpcy5iZXRhMSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5iZWZvcmVCYXRjaC5jYWxsKHRoaXMsIG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKTtcbiAgICAgICAgaWYgKHRoaXMuZmlyc3RNb21lbnRHcmFwaC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnRHcmFwaC5zZXQobm9kZS5vdXRwdXQsIHRlbnNvcl8xLlRlbnNvci56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWRJbmZOb3JtR3JhcGguc2l6ZSgpID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLndlaWdodGVkSW5mTm9ybUdyYXBoLnNldChub2RlLm91dHB1dCwgdGVuc29yXzEuVGVuc29yLnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWRhbWF4T3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBsciA9IF90aGlzLmNHcmFwaC5kaXYoX3RoaXMub25lLmFkZChfdGhpcy5kZWNheS5tdWwoX3RoaXMuaXRlcmF0aW9uKSkpO1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkRmlyc3RNb21lbnQgPSBfdGhpcy5maXJzdE1vbWVudEdyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFdlaWdodGVkSW5mTm9ybSA9IF90aGlzLndlaWdodGVkSW5mTm9ybUdyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0ZpcnN0TW9tZW50ID0gbWF0aC5zY2FsZWRBcnJheUFkZChfdGhpcy5iZXRhMSwgb2xkRmlyc3RNb21lbnQsIF90aGlzLm9uZU1pbnVzQmV0YTEsIGdyYWRpZW50KTtcbiAgICAgICAgICAgICAgICB2YXIgdXQwID0gX3RoaXMuYmV0YTIubXVsKG9sZFdlaWdodGVkSW5mTm9ybSk7XG4gICAgICAgICAgICAgICAgdmFyIHV0MSA9IGdyYWRpZW50LmFicygpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdXZWlnaHRlZEluZk5vcm0gPSB1dDAubWF4aW11bSh1dDEpO1xuICAgICAgICAgICAgICAgIHZhciB2YXJpYWJsZSA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMub25lLCBvbGRWYXJpYWJsZSwgbHIuZGl2KF90aGlzLm9uZS5zdWIoX3RoaXMuYWNjQmV0YTEpKSwgbmV3Rmlyc3RNb21lbnQuZGl2KF90aGlzLmVwcy5hZGQobmV3V2VpZ2h0ZWRJbmZOb3JtKSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgX3RoaXMuZmlyc3RNb21lbnRHcmFwaC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKG5ld0ZpcnN0TW9tZW50KSk7XG4gICAgICAgICAgICAgICAgX3RoaXMud2VpZ2h0ZWRJbmZOb3JtR3JhcGguc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcChuZXdXZWlnaHRlZEluZk5vcm0pKTtcbiAgICAgICAgICAgICAgICBvbGRWYXJpYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgZ3JhZGllbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZEZpcnN0TW9tZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRXZWlnaHRlZEluZk5vcm0uZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfdGhpcy5pdGVyYXRpb24uYXNzaWduKF90aGlzLml0ZXJhdGlvbi5hZGQoX3RoaXMub25lKSk7XG4gICAgICAgICAgICBfdGhpcy5hY2NCZXRhMS5hc3NpZ24oX3RoaXMuYWNjQmV0YTEubXVsKF90aGlzLmJldGExKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIEFkYW1heE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuYy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuZXBzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5hY2NCZXRhMS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuYmV0YTEuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmJldGEyLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmVNaW51c0JldGExLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5kZWNheS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuaXRlcmF0aW9uLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5maXJzdE1vbWVudEdyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyc3RNb21lbnRHcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMud2VpZ2h0ZWRJbmZOb3JtR3JhcGggIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy53ZWlnaHRlZEluZk5vcm1HcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRGaXJzdE1vbWVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnQpXG4gICAgICAgICAgICAgICAgLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIF90aGlzLmFjY3VtdWxhdGVkRmlyc3RNb21lbnRbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybSAhPSBudWxsKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmFjY3VtdWxhdGVkV2VpZ2h0ZWRJbmZOb3JtKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZFdlaWdodGVkSW5mTm9ybVtuYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gQWRhbWF4T3B0aW1pemVyO1xufShvcHRpbWl6ZXJfMS5PcHRpbWl6ZXIpKTtcbmV4cG9ydHMuQWRhbWF4T3B0aW1pemVyID0gQWRhbWF4T3B0aW1pemVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHRlbnNvcl9hcnJheV9tYXBfMSA9IHJlcXVpcmUoXCIuLi9ncmFwaC90ZW5zb3JfYXJyYXlfbWFwXCIpO1xudmFyIG9wc18xID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NnZF9vcHRpbWl6ZXJcIik7XG52YXIgTW9tZW50dW1PcHRpbWl6ZXIgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhNb21lbnR1bU9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNb21lbnR1bU9wdGltaXplcihsZWFybmluZ1JhdGUsIG1vbWVudHVtLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QsIHVzZU5lc3Rlcm92KSB7XG4gICAgICAgIGlmICh1c2VOZXN0ZXJvdiA9PT0gdm9pZCAwKSB7IHVzZU5lc3Rlcm92ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICAgICAgX3RoaXMudXNlTmVzdGVyb3YgPSB1c2VOZXN0ZXJvdjtcbiAgICAgICAgX3RoaXMubSA9IG9wc18xLnNjYWxhcihfdGhpcy5tb21lbnR1bSk7XG4gICAgICAgIF90aGlzLmFjY3VtdWxhdGlvbnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYXBwbHlHcmFkaWVudHMgPSBmdW5jdGlvbiAodmFyaWFibGVHcmFkaWVudHMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAodmFyaWFibGVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJlZFZhcmlhYmxlc1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgaWYgKHRoaXNfMS5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFpbmFibGVfMSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGlvbiA9IHRoaXNfMS5hY2N1bXVsYXRpb25zW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSB2YXJpYWJsZUdyYWRpZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0aW9uID0gX3RoaXMubS5tdWwoYWNjdW11bGF0aW9uKS5hZGQoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VOZXN0ZXJvdikge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jLm11bChncmFkaWVudC5hZGQobmV3QWNjdW11bGF0aW9uLm11bChfdGhpcy5tKSkpLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSA9IF90aGlzLmMubXVsKG5ld0FjY3VtdWxhdGlvbikuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdLmFzc2lnbihuZXdBY2N1bXVsYXRpb24pO1xuICAgICAgICAgICAgICAgIHZhbHVlLmFzc2lnbihuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHRoaXNfMSA9IHRoaXM7XG4gICAgICAgIGZvciAodmFyIHZhcmlhYmxlTmFtZSBpbiB2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICAgICAgX2xvb3BfMSh2YXJpYWJsZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMudmFyaWFibGVWZWxvY2l0aWVzR3JhcGggPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy52YXJpYWJsZVZlbG9jaXRpZXNHcmFwaCA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICAgICAgfVxuICAgICAgICBfc3VwZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoLmNhbGwodGhpcywgbWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApO1xuICAgICAgICBpZiAodGhpcy52YXJpYWJsZVZlbG9jaXRpZXNHcmFwaC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzR3JhcGguc2V0KG5vZGUub3V0cHV0LCB0ZW5zb3JfMS5UZW5zb3IuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuYWZ0ZXJCYXRjaCA9IGZ1bmN0aW9uIChtYXRoLCBiYXRjaFNpemUsIHJ1bnRpbWUsIGFjdGl2YXRpb25BcnJheU1hcCwgZ3JhZGllbnRBcnJheU1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkVmFyaWFibGUgPSBhY3RpdmF0aW9uQXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgZ3JhZGllbnQgPSBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRWZWxvY2l0eSA9IF90aGlzLnZhcmlhYmxlVmVsb2NpdGllc0dyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IF90aGlzLm0ubXVsKG9sZFZlbG9jaXR5KS5hZGQoZ3JhZGllbnQpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy51c2VOZXN0ZXJvdikge1xuICAgICAgICAgICAgICAgICAgICB2YXJpYWJsZSA9IF90aGlzLmNHcmFwaC5tdWwoZ3JhZGllbnQuYWRkKHZlbG9jaXR5Lm11bChfdGhpcy5tKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuYWRkKG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlID0gX3RoaXMuY0dyYXBoLm11bCh2ZWxvY2l0eSkuYWRkKG9sZFZhcmlhYmxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVWZWxvY2l0aWVzR3JhcGguc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcCh2ZWxvY2l0eSkpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgICAgIG9sZFZlbG9jaXR5LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cy5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMudmFyaWFibGVHcmFkaWVudHMgPSBuZXcgdGVuc29yX2FycmF5X21hcF8xLlRlbnNvckFycmF5TWFwKCk7XG4gICAgfTtcbiAgICBNb21lbnR1bU9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3N1cGVyLnByb3RvdHlwZS5kaXNwb3NlLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMubS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLnZhcmlhYmxlVmVsb2NpdGllc0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVWZWxvY2l0aWVzR3JhcGguZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGlvbnMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHRoaXMuYWNjdW11bGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWNjdW11bGF0aW9uc1t2YXJpYWJsZU5hbWVdLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTW9tZW50dW1PcHRpbWl6ZXIucHJvdG90eXBlLnNldE1vbWVudHVtID0gZnVuY3Rpb24gKG1vbWVudHVtKSB7XG4gICAgICAgIHRoaXMubW9tZW50dW0gPSBtb21lbnR1bTtcbiAgICB9O1xuICAgIHJldHVybiBNb21lbnR1bU9wdGltaXplcjtcbn0oc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcikpO1xuZXhwb3J0cy5Nb21lbnR1bU9wdGltaXplciA9IE1vbWVudHVtT3B0aW1pemVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi4vZG9jXCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaC9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL2dyYXBoL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3BzID0gcmVxdWlyZShcIi4uL29wcy9vcHNcIik7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi4vdGVuc29yXCIpO1xudmFyIE9wdGltaXplciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0KSB7XG4gICAgICAgIHRoaXMubGVhcm5pbmdSYXRlID0gbGVhcm5pbmdSYXRlO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBpZiAoc3BlY2lmaWVkVmFyaWFibGVMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9IHNwZWNpZmllZFZhcmlhYmxlTGlzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBPcHRpbWl6ZXIucHJvdG90eXBlLm1pbmltaXplID0gZnVuY3Rpb24gKGYsIHJldHVybkNvc3QsIHZhckxpc3QpIHtcbiAgICAgICAgaWYgKHJldHVybkNvc3QgPT09IHZvaWQgMCkgeyByZXR1cm5Db3N0ID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIF9hID0gdGhpcy5jb21wdXRlR3JhZGllbnRzKGYsIHZhckxpc3QpLCB2YWx1ZSA9IF9hLnZhbHVlLCBncmFkcyA9IF9hLmdyYWRzO1xuICAgICAgICB0aGlzLmFwcGx5R3JhZGllbnRzKGdyYWRzKTtcbiAgICAgICAgdmFyIHZhck5hbWVzID0gT2JqZWN0LmtleXMoZ3JhZHMpO1xuICAgICAgICB2YXJOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh2YXJOYW1lKSB7IHJldHVybiBncmFkc1t2YXJOYW1lXS5kaXNwb3NlKCk7IH0pO1xuICAgICAgICBpZiAocmV0dXJuQ29zdCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuY29tcHV0ZUdyYWRpZW50cyA9IGZ1bmN0aW9uIChmLCB2YXJMaXN0KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxzXzEudmFyaWFibGVHcmFkcyhmLCB2YXJMaXN0KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuYmVmb3JlQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzID0gdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzID09IG51bGwgP1xuICAgICAgICAgICAgc2Vzc2lvbl91dGlsLmdldFZhcmlhYmxlTm9kZXNGcm9tRXZhbHVhdGlvblNldChydW50aW1lLm5vZGVzKSA6XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXM7XG4gICAgICAgIGlmIChiYXRjaFNpemUgIT09IHRoaXMucHJldkJhdGNoU2l6ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNHcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByZXZCYXRjaFNpemUgPSBiYXRjaFNpemU7XG4gICAgICAgICAgICB0aGlzLmNHcmFwaCA9IG1hdGgua2VlcChvcHMuc2NhbGFyKC10aGlzLmxlYXJuaW5nUmF0ZSAvIGJhdGNoU2l6ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHJldHVybiBfdGhpcy52YXJpYWJsZUdyYWRpZW50cy5zZXQobm9kZS5vdXRwdXQsIG1hdGgua2VlcCh0ZW5zb3JfMS5UZW5zb3IuemVyb3Mobm9kZS5vdXRwdXQuc2hhcGUpKSk7IH0pO1xuICAgIH07XG4gICAgT3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckV4YW1wbGUgPSBmdW5jdGlvbiAobWF0aCwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLnZhcmlhYmxlTm9kZXMuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBncmFkaWVudCA9IGdyYWRpZW50QXJyYXlNYXAuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRHcmFkaWVudCA9IF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmFyaWFibGVHcmFkaWVudHMuc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcChtYXRoLmFkZChncmFkaWVudCwgYWNjdW11bGF0ZWRHcmFkaWVudCkpKTtcbiAgICAgICAgICAgICAgICBhY2N1bXVsYXRlZEdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE9wdGltaXplci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY0dyYXBoICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY0dyYXBoLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy52YXJpYWJsZU5vZGVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnNwZWNpZmllZFZhcmlhYmxlTm9kZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmRhdGEuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnT3B0aW1pemVycycgfSlcbiAgICBdLCBPcHRpbWl6ZXIucHJvdG90eXBlLCBcIm1pbmltaXplXCIsIG51bGwpO1xuICAgIE9wdGltaXplciA9IF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIG5hbWVzcGFjZTogJ3RyYWluJyB9KVxuICAgIF0sIE9wdGltaXplcik7XG4gICAgcmV0dXJuIE9wdGltaXplcjtcbn0oKSk7XG5leHBvcnRzLk9wdGltaXplciA9IE9wdGltaXplcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4uL2RvY1wiKTtcbnZhciBhZGFkZWx0YV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYWRlbHRhX29wdGltaXplclwiKTtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vYWRhZ3JhZF9vcHRpbWl6ZXJcIik7XG52YXIgYWRhbV9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYW1fb3B0aW1pemVyXCIpO1xudmFyIGFkYW1heF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL2FkYW1heF9vcHRpbWl6ZXJcIik7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9tb21lbnR1bV9vcHRpbWl6ZXJcIik7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3Jtc3Byb3Bfb3B0aW1pemVyXCIpO1xudmFyIHNnZF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL3NnZF9vcHRpbWl6ZXJcIik7XG52YXIgT3B0aW1pemVyQ29uc3RydWN0b3JzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMoKSB7XG4gICAgfVxuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5zZ2QgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgc2dkX29wdGltaXplcl8xLlNHRE9wdGltaXplcihsZWFybmluZ1JhdGUpO1xuICAgIH07XG4gICAgT3B0aW1pemVyQ29uc3RydWN0b3JzLm1vbWVudHVtID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgbW9tZW50dW0sIHVzZU5lc3Rlcm92KSB7XG4gICAgICAgIGlmICh1c2VOZXN0ZXJvdiA9PT0gdm9pZCAwKSB7IHVzZU5lc3Rlcm92ID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBtb21lbnR1bV9vcHRpbWl6ZXJfMS5Nb21lbnR1bU9wdGltaXplcihsZWFybmluZ1JhdGUsIG1vbWVudHVtLCB1bmRlZmluZWQsIHVzZU5lc3Rlcm92KTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5ybXNwcm9wID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgZGVjYXksIG1vbWVudHVtLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChkZWNheSA9PT0gdm9pZCAwKSB7IGRlY2F5ID0gLjk7IH1cbiAgICAgICAgaWYgKG1vbWVudHVtID09PSB2b2lkIDApIHsgbW9tZW50dW0gPSAwLjA7IH1cbiAgICAgICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gMWUtODsgfVxuICAgICAgICByZXR1cm4gbmV3IHJtc3Byb3Bfb3B0aW1pemVyXzEuUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGRlY2F5LCBtb21lbnR1bSwgdW5kZWZpbmVkLCBlcHNpbG9uKTtcbiAgICB9O1xuICAgIE9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChsZWFybmluZ1JhdGUgPT09IHZvaWQgMCkgeyBsZWFybmluZ1JhdGUgPSAwLjAwMTsgfVxuICAgICAgICBpZiAoYmV0YTEgPT09IHZvaWQgMCkgeyBiZXRhMSA9IDAuOTsgfVxuICAgICAgICBpZiAoYmV0YTIgPT09IHZvaWQgMCkgeyBiZXRhMiA9IDAuOTk5OyB9XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgcmV0dXJuIG5ldyBhZGFtX29wdGltaXplcl8xLkFkYW1PcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBiZXRhMSwgYmV0YTIsIGVwc2lsb24sIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZGVsdGEgPSBmdW5jdGlvbiAobGVhcm5pbmdSYXRlLCByaG8sIGVwc2lsb24pIHtcbiAgICAgICAgaWYgKGxlYXJuaW5nUmF0ZSA9PT0gdm9pZCAwKSB7IGxlYXJuaW5nUmF0ZSA9IC4wMDE7IH1cbiAgICAgICAgaWYgKHJobyA9PT0gdm9pZCAwKSB7IHJobyA9IC45NTsgfVxuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIHJldHVybiBuZXcgYWRhZGVsdGFfb3B0aW1pemVyXzEuQWRhZGVsdGFPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCByaG8sIHVuZGVmaW5lZCwgZXBzaWxvbik7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhbWF4ID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSwgYmV0YTEsIGJldGEyLCBlcHNpbG9uLCBkZWNheSkge1xuICAgICAgICBpZiAobGVhcm5pbmdSYXRlID09PSB2b2lkIDApIHsgbGVhcm5pbmdSYXRlID0gMC4wMDI7IH1cbiAgICAgICAgaWYgKGJldGExID09PSB2b2lkIDApIHsgYmV0YTEgPSAwLjk7IH1cbiAgICAgICAgaWYgKGJldGEyID09PSB2b2lkIDApIHsgYmV0YTIgPSAwLjk5OTsgfVxuICAgICAgICBpZiAoZXBzaWxvbiA9PT0gdm9pZCAwKSB7IGVwc2lsb24gPSAxZS04OyB9XG4gICAgICAgIGlmIChkZWNheSA9PT0gdm9pZCAwKSB7IGRlY2F5ID0gMC4wOyB9XG4gICAgICAgIHJldHVybiBuZXcgYWRhbWF4X29wdGltaXplcl8xLkFkYW1heE9wdGltaXplcihsZWFybmluZ1JhdGUsIGJldGExLCBiZXRhMiwgZXBzaWxvbiwgZGVjYXksIHVuZGVmaW5lZCk7XG4gICAgfTtcbiAgICBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMuYWRhZ3JhZCA9IGZ1bmN0aW9uIChsZWFybmluZ1JhdGUsIGluaXRpYWxBY2N1bXVsYXRvclZhbHVlKSB7XG4gICAgICAgIGlmIChpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSA9PT0gdm9pZCAwKSB7IGluaXRpYWxBY2N1bXVsYXRvclZhbHVlID0gMC4xOyB9XG4gICAgICAgIHJldHVybiBuZXcgYWRhZ3JhZF9vcHRpbWl6ZXJfMS5BZGFncmFkT3B0aW1pemVyKGxlYXJuaW5nUmF0ZSwgdW5kZWZpbmVkLCBpbml0aWFsQWNjdW11bGF0b3JWYWx1ZSk7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwic2dkXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVHJhaW5pbmcnLCBzdWJoZWFkaW5nOiAnT3B0aW1pemVycycsIG5hbWVzcGFjZTogJ3RyYWluJyB9KVxuICAgIF0sIE9wdGltaXplckNvbnN0cnVjdG9ycywgXCJtb21lbnR1bVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwicm1zcHJvcFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhbVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhZGVsdGFcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUcmFpbmluZycsIHN1YmhlYWRpbmc6ICdPcHRpbWl6ZXJzJywgbmFtZXNwYWNlOiAndHJhaW4nIH0pXG4gICAgXSwgT3B0aW1pemVyQ29uc3RydWN0b3JzLCBcImFkYW1heFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RyYWluaW5nJywgc3ViaGVhZGluZzogJ09wdGltaXplcnMnLCBuYW1lc3BhY2U6ICd0cmFpbicgfSlcbiAgICBdLCBPcHRpbWl6ZXJDb25zdHJ1Y3RvcnMsIFwiYWRhZ3JhZFwiLCBudWxsKTtcbiAgICByZXR1cm4gT3B0aW1pemVyQ29uc3RydWN0b3JzO1xufSgpKTtcbmV4cG9ydHMuT3B0aW1pemVyQ29uc3RydWN0b3JzID0gT3B0aW1pemVyQ29uc3RydWN0b3JzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChiLmhhc093blByb3BlcnR5KHApKSBkW3BdID0gYltwXTsgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4uL2Vudmlyb25tZW50XCIpO1xudmFyIGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9nbG9iYWxzXCIpO1xudmFyIHNlc3Npb25fdXRpbCA9IHJlcXVpcmUoXCIuLi9ncmFwaC9zZXNzaW9uX3V0aWxcIik7XG52YXIgdGVuc29yX2FycmF5X21hcF8xID0gcmVxdWlyZShcIi4uL2dyYXBoL3RlbnNvcl9hcnJheV9tYXBcIik7XG52YXIgb3BzXzEgPSByZXF1aXJlKFwiLi4vb3BzL29wc1wiKTtcbnZhciB0ZW5zb3JfMSA9IHJlcXVpcmUoXCIuLi90ZW5zb3JcIik7XG52YXIgb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJcIik7XG52YXIgUk1TUHJvcE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJNU1Byb3BPcHRpbWl6ZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUk1TUHJvcE9wdGltaXplcihsZWFybmluZ1JhdGUsIGRlY2F5LCBtb21lbnR1bSwgc3BlY2lmaWVkVmFyaWFibGVMaXN0LCBlcHNpbG9uKSB7XG4gICAgICAgIGlmIChkZWNheSA9PT0gdm9pZCAwKSB7IGRlY2F5ID0gMC45OyB9XG4gICAgICAgIGlmIChtb21lbnR1bSA9PT0gdm9pZCAwKSB7IG1vbWVudHVtID0gMC4wOyB9XG4gICAgICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IDFlLTg7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlcyA9IHt9O1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudHMgPSB7fTtcbiAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlZEdyYXBoID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudEdyYXBoID0gbmV3IHRlbnNvcl9hcnJheV9tYXBfMS5UZW5zb3JBcnJheU1hcCgpO1xuICAgICAgICBfdGhpcy5jID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGxlYXJuaW5nUmF0ZSkpO1xuICAgICAgICBfdGhpcy5lcHNpbG9uID0gZ2xvYmFsc18xLmtlZXAob3BzXzEuc2NhbGFyKGVwc2lsb24pKTtcbiAgICAgICAgX3RoaXMuZGVjYXkgPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIoZGVjYXkpKTtcbiAgICAgICAgX3RoaXMubW9tZW50dW0gPSBnbG9iYWxzXzEua2VlcChvcHNfMS5zY2FsYXIobW9tZW50dW0pKTtcbiAgICAgICAgX3RoaXMub25lTWludXNEZWNheSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxIC0gZGVjYXkpKTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSTVNQcm9wT3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uICh2YXJpYWJsZU5hbWUpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWdpc3RlcmVkVmFyaWFibGVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkTWVhblNxdWFyZXNbdmFyaWFibGVOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyYWluYWJsZV8xID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3ZhcmlhYmxlTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgb3BzXzEuemVyb3NMaWtlKHZhbHVlKS52YXJpYWJsZSh0cmFpbmFibGVfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc18xLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHJhaW5hYmxlXzIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wc18xLnplcm9zTGlrZSh2YWx1ZSkudmFyaWFibGUodHJhaW5hYmxlXzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFjY3VtdWxhdGVkTWVhblNxdWFyZSA9IHRoaXNfMS5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3ZhcmlhYmxlTmFtZV07XG4gICAgICAgICAgICB2YXIgYWNjdW11bGF0ZWRNb21lbnRzID0gdGhpc18xLmFjY3VtdWxhdGVkTW9tZW50c1t2YXJpYWJsZU5hbWVdO1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdmFyaWFibGVHcmFkaWVudHNbdmFyaWFibGVOYW1lXTtcbiAgICAgICAgICAgIGdsb2JhbHNfMS50aWR5KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3QWNjdW11bGF0ZWRNZWFuU3F1YXJlID0gX3RoaXMuZGVjYXkubXVsKGFjY3VtdWxhdGVkTWVhblNxdWFyZSlcbiAgICAgICAgICAgICAgICAgICAgLmFkZChfdGhpcy5vbmVNaW51c0RlY2F5Lm11bChncmFkaWVudC5zcXVhcmUoKSkpO1xuICAgICAgICAgICAgICAgIHZhciBuZXdBY2N1bXVsYXRlZE1vbWVudHMgPSBfdGhpcy5tb21lbnR1bS5tdWwoYWNjdW11bGF0ZWRNb21lbnRzKVxuICAgICAgICAgICAgICAgICAgICAuYWRkKF90aGlzLmMubXVsKGdyYWRpZW50KS5kaXYobmV3QWNjdW11bGF0ZWRNZWFuU3F1YXJlLmFkZChfdGhpcy5lcHNpbG9uKS5zcXJ0KCkpKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkTWVhblNxdWFyZSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRzW3ZhcmlhYmxlTmFtZV0uYXNzaWduKG5ld0FjY3VtdWxhdGVkTW9tZW50cyk7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gdmFsdWUuc3ViKG5ld0FjY3VtdWxhdGVkTW9tZW50cyk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdGhpc18xID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgdmFyaWFibGVOYW1lIGluIHZhcmlhYmxlR3JhZGllbnRzKSB7XG4gICAgICAgICAgICBfbG9vcF8xKHZhcmlhYmxlTmFtZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmJlZm9yZUJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMudmFyaWFibGVOb2RlcyA9IHRoaXMuc3BlY2lmaWVkVmFyaWFibGVOb2RlcyA9PSBudWxsID9cbiAgICAgICAgICAgIHNlc3Npb25fdXRpbC5nZXRWYXJpYWJsZU5vZGVzRnJvbUV2YWx1YXRpb25TZXQocnVudGltZS5ub2RlcykgOlxuICAgICAgICAgICAgdGhpcy5zcGVjaWZpZWRWYXJpYWJsZU5vZGVzO1xuICAgICAgICBpZiAoYmF0Y2hTaXplICE9PSB0aGlzLnByZXZCYXRjaFNpemUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNHcmFwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jR3JhcGguZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcmV2QmF0Y2hTaXplID0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgdGhpcy5jR3JhcGggPSBtYXRoLmtlZXAob3BzXzEuc2NhbGFyKHRoaXMubGVhcm5pbmdSYXRlIC8gYmF0Y2hTaXplKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YXJpYWJsZU5vZGVzLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHsgcmV0dXJuIF90aGlzLnZhcmlhYmxlR3JhZGllbnRzLnNldChub2RlLm91dHB1dCwgbWF0aC5rZWVwKHRlbnNvcl8xLlRlbnNvci56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpKTsgfSk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZWRHcmFwaC5zaXplKCkgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlZEdyYXBoLnNldChub2RlLm91dHB1dCwgdGVuc29yXzEuVGVuc29yLnplcm9zKG5vZGUub3V0cHV0LnNoYXBlKSk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNb21lbnRHcmFwaC5zZXQobm9kZS5vdXRwdXQsIHRlbnNvcl8xLlRlbnNvci56ZXJvcyhub2RlLm91dHB1dC5zaGFwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmFmdGVyQmF0Y2ggPSBmdW5jdGlvbiAobWF0aCwgYmF0Y2hTaXplLCBydW50aW1lLCBhY3RpdmF0aW9uQXJyYXlNYXAsIGdyYWRpZW50QXJyYXlNYXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgb2xkTWVhblNxdWFyZSA9IF90aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZWRHcmFwaC5nZXQobm9kZS5vdXRwdXQpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRNb21lbnQgPSBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudEdyYXBoLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIG1lYW5TcXVhcmUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmRlY2F5LCBvbGRNZWFuU3F1YXJlLCBfdGhpcy5vbmVNaW51c0RlY2F5LCBncmFkaWVudC5zcXVhcmUoKSk7XG4gICAgICAgICAgICAgICAgdmFyIG1vbWVudCA9IG1hdGguc2NhbGVkQXJyYXlBZGQoX3RoaXMubW9tZW50dW0sIG9sZE1vbWVudCwgX3RoaXMuY0dyYXBoLCBncmFkaWVudC5kaXYobWVhblNxdWFyZS5hZGQoX3RoaXMuZXBzaWxvbikuc3FydCgpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHZhcmlhYmxlID0gb2xkVmFyaWFibGUuc3ViKG1vbWVudCk7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWNjdW11bGF0ZWRNZWFuU3F1YXJlZEdyYXBoLnNldChub2RlLm91dHB1dCwgZ2xvYmFsc18xLmtlZXAobWVhblNxdWFyZSkpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFjY3VtdWxhdGVkTW9tZW50R3JhcGguc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcChtb21lbnQpKTtcbiAgICAgICAgICAgICAgICBhY3RpdmF0aW9uQXJyYXlNYXAuc2V0KG5vZGUub3V0cHV0LCBnbG9iYWxzXzEua2VlcCh2YXJpYWJsZSkpO1xuICAgICAgICAgICAgICAgIG5vZGUuZGF0YSA9IHZhcmlhYmxlO1xuICAgICAgICAgICAgICAgIG9sZFZhcmlhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRNZWFuU3F1YXJlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBvbGRNb21lbnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIFJNU1Byb3BPcHRpbWl6ZXIucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmVwc2lsb24uZGlzcG9zZSgpO1xuICAgICAgICB0aGlzLmRlY2F5LmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy5tb21lbnR1bS5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMub25lTWludXNEZWNheS5kaXNwb3NlKCk7XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZWRHcmFwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZWRHcmFwaC5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRHcmFwaCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmFjY3VtdWxhdGVkTW9tZW50R3JhcGguZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjY3VtdWxhdGVkTWVhblNxdWFyZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZE1lYW5TcXVhcmVzW25hbWVdLmRpc3Bvc2UoKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuYWNjdW11bGF0ZWRNb21lbnRzKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBfdGhpcy5hY2N1bXVsYXRlZE1vbWVudHNbbmFtZV0uZGlzcG9zZSgpOyB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIFJNU1Byb3BPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5STVNQcm9wT3B0aW1pemVyID0gUk1TUHJvcE9wdGltaXplcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuLi9lbnZpcm9ubWVudFwiKTtcbnZhciBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vZ2xvYmFsc1wiKTtcbnZhciB0ZW5zb3JfYXJyYXlfbWFwXzEgPSByZXF1aXJlKFwiLi4vZ3JhcGgvdGVuc29yX2FycmF5X21hcFwiKTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuLi9vcHMvb3BzXCIpO1xudmFyIG9wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVyXCIpO1xudmFyIFNHRE9wdGltaXplciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNHRE9wdGltaXplciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTR0RPcHRpbWl6ZXIobGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbGVhcm5pbmdSYXRlLCBzcGVjaWZpZWRWYXJpYWJsZUxpc3QpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgX3RoaXMuc2V0TGVhcm5pbmdSYXRlKGxlYXJuaW5nUmF0ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5hcHBseUdyYWRpZW50cyA9IGZ1bmN0aW9uICh2YXJpYWJsZUdyYWRpZW50cykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdmFyTmFtZXMgPSBPYmplY3Qua2V5cyh2YXJpYWJsZUdyYWRpZW50cyk7XG4gICAgICAgIHZhck5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHZhck5hbWUpIHtcbiAgICAgICAgICAgIHZhciBncmFkaWVudCA9IHZhcmlhYmxlR3JhZGllbnRzW3Zhck5hbWVdO1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyZWRWYXJpYWJsZXNbdmFyTmFtZV07XG4gICAgICAgICAgICBnbG9iYWxzXzEudGlkeShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0gX3RoaXMuYy5tdWwoZ3JhZGllbnQpLmFkZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdmFsdWUuYXNzaWduKG5ld1ZhbHVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFNHRE9wdGltaXplci5wcm90b3R5cGUuc2V0TGVhcm5pbmdSYXRlID0gZnVuY3Rpb24gKGxlYXJuaW5nUmF0ZSkge1xuICAgICAgICB0aGlzLmxlYXJuaW5nUmF0ZSA9IGxlYXJuaW5nUmF0ZTtcbiAgICAgICAgaWYgKHRoaXMuYyAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYyA9IGVudmlyb25tZW50XzEuRU5WLm1hdGgua2VlcChvcHNfMS5zY2FsYXIoLWxlYXJuaW5nUmF0ZSkpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmMuZGlzcG9zZSgpO1xuICAgICAgICBpZiAodGhpcy5vbmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5vbmUuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIF9zdXBlci5wcm90b3R5cGUuZGlzcG9zZS5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgU0dET3B0aW1pemVyLnByb3RvdHlwZS5hZnRlckJhdGNoID0gZnVuY3Rpb24gKG1hdGgsIGJhdGNoU2l6ZSwgcnVudGltZSwgYWN0aXZhdGlvbkFycmF5TWFwLCBncmFkaWVudEFycmF5TWFwKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLm9uZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm9uZSA9IGdsb2JhbHNfMS5rZWVwKG9wc18xLnNjYWxhcigxKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsc18xLnRpZHkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudmFyaWFibGVOb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhcmlhYmxlID0gYWN0aXZhdGlvbkFycmF5TWFwLmdldChub2RlLm91dHB1dCk7XG4gICAgICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gX3RoaXMudmFyaWFibGVHcmFkaWVudHMuZ2V0KG5vZGUub3V0cHV0KTtcbiAgICAgICAgICAgICAgICB2YXIgdmFyaWFibGUgPSBtYXRoLnNjYWxlZEFycmF5QWRkKF90aGlzLmNHcmFwaCwgZ3JhZGllbnQsIF90aGlzLm9uZSwgb2xkVmFyaWFibGUpO1xuICAgICAgICAgICAgICAgIGFjdGl2YXRpb25BcnJheU1hcC5zZXQobm9kZS5vdXRwdXQsIGdsb2JhbHNfMS5rZWVwKHZhcmlhYmxlKSk7XG4gICAgICAgICAgICAgICAgbm9kZS5kYXRhID0gdmFyaWFibGU7XG4gICAgICAgICAgICAgICAgb2xkVmFyaWFibGUuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnZhcmlhYmxlR3JhZGllbnRzLmRpc3Bvc2UoKTtcbiAgICAgICAgdGhpcy52YXJpYWJsZUdyYWRpZW50cyA9IG5ldyB0ZW5zb3JfYXJyYXlfbWFwXzEuVGVuc29yQXJyYXlNYXAoKTtcbiAgICB9O1xuICAgIHJldHVybiBTR0RPcHRpbWl6ZXI7XG59KG9wdGltaXplcl8xLk9wdGltaXplcikpO1xuZXhwb3J0cy5TR0RPcHRpbWl6ZXIgPSBTR0RPcHRpbWl6ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBQcm9maWxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJvZmlsZXIoYmFja2VuZFRpbWVyLCBsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5iYWNrZW5kVGltZXIgPSBiYWNrZW5kVGltZXI7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgICAgICBpZiAobG9nZ2VyID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubG9nZ2VyID0gbmV3IExvZ2dlcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFByb2ZpbGVyLnByb3RvdHlwZS5wcm9maWxlS2VybmVsID0gZnVuY3Rpb24gKG5hbWUsIGYpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgdmFyIGhvbGRSZXN1bHRXcmFwcGVyRm4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBmKCk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciB0aW1lciA9IHRoaXMuYmFja2VuZFRpbWVyLnRpbWUoaG9sZFJlc3VsdFdyYXBwZXJGbik7XG4gICAgICAgIHZhciB2YWxzID0gcmVzdWx0LmRhdGFTeW5jKCk7XG4gICAgICAgIHV0aWwuY2hlY2tGb3JOYU4odmFscywgcmVzdWx0LmR0eXBlLCBuYW1lKTtcbiAgICAgICAgdGltZXIudGhlbihmdW5jdGlvbiAodGltaW5nKSB7XG4gICAgICAgICAgICBfdGhpcy5sb2dnZXIubG9nS2VybmVsUHJvZmlsZShuYW1lLCByZXN1bHQsIHZhbHMsIHRpbWluZy5rZXJuZWxNcyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFByb2ZpbGVyO1xufSgpKTtcbmV4cG9ydHMuUHJvZmlsZXIgPSBQcm9maWxlcjtcbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICB9XG4gICAgTG9nZ2VyLnByb3RvdHlwZS5sb2dLZXJuZWxQcm9maWxlID0gZnVuY3Rpb24gKG5hbWUsIHJlc3VsdCwgdmFscywgdGltZU1zKSB7XG4gICAgICAgIHZhciB0aW1lID0gdXRpbC5yaWdodFBhZCh0aW1lTXMgKyBcIm1zXCIsIDkpO1xuICAgICAgICB2YXIgcGFkZGVkTmFtZSA9IHV0aWwucmlnaHRQYWQobmFtZSwgMjUpO1xuICAgICAgICB2YXIgcmFuayA9IHJlc3VsdC5yYW5rO1xuICAgICAgICB2YXIgc2l6ZSA9IHJlc3VsdC5zaXplO1xuICAgICAgICB2YXIgc2hhcGUgPSB1dGlsLnJpZ2h0UGFkKHJlc3VsdC5zaGFwZS50b1N0cmluZygpLCAxNCk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiJWNcIiArIHBhZGRlZE5hbWUgKyBcIlxcdCVjXCIgKyB0aW1lICsgXCJcXHQlY1wiICsgcmFuayArIFwiRCBcIiArIHNoYXBlICsgXCJcXHQlY1wiICsgc2l6ZSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnLCAnY29sb3I6cmVkJywgJ2NvbG9yOmJsdWUnLCAnY29sb3I6IG9yYW5nZScpO1xuICAgIH07XG4gICAgcmV0dXJuIExvZ2dlcjtcbn0oKSk7XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZnVuY3Rpb24gZ2V0RmlsdGVyZWROb2Rlc1hUb1kodGFwZSwgeHMsIHkpIHtcbiAgICB2YXIgdGVuc29yc0Zyb21YID0ge307XG4gICAgdmFyIG5vZGVzRnJvbVggPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRlbnNvcnNGcm9tWFt4c1tpXS5pZF0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG5vZGUgPSB0YXBlW2ldO1xuICAgICAgICB2YXIgbm9kZUlucHV0cyA9IG5vZGUuaW5wdXRzO1xuICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZUlucHV0cykge1xuICAgICAgICAgICAgdmFyIGlucHV0ID0gbm9kZUlucHV0c1tpbnB1dE5hbWVdO1xuICAgICAgICAgICAgdmFyIGFueUlucHV0RnJvbVggPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgeHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGVuc29yc0Zyb21YW2lucHV0LmlkXSkge1xuICAgICAgICAgICAgICAgICAgICB0ZW5zb3JzRnJvbVhbbm9kZS5vdXRwdXQuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYW55SW5wdXRGcm9tWCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzRnJvbVhbbm9kZS5pZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYW55SW5wdXRGcm9tWCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHZhciB0ZW5zb3JzTGVhZFRvWSA9IHt9O1xuICAgIHRlbnNvcnNMZWFkVG9ZW3kuaWRdID0gdHJ1ZTtcbiAgICB2YXIgbm9kZXNUb1kgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gdGFwZS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgbm9kZSA9IHRhcGVbaV07XG4gICAgICAgIHZhciBub2RlSW5wdXRzID0gbm9kZS5pbnB1dHM7XG4gICAgICAgIHZhciBvdXRwdXRzID0gW107XG4gICAgICAgIG91dHB1dHMucHVzaChub2RlLm91dHB1dCk7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgb3V0cHV0cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgaWYgKHRlbnNvcnNMZWFkVG9ZW291dHB1dHNbal0uaWRdKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5wdXROYW1lIGluIG5vZGVJbnB1dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVuc29yc0xlYWRUb1lbbm9kZUlucHV0c1tpbnB1dE5hbWVdLmlkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzVG9ZW25vZGUuaWRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGZpbHRlcmVkVGFwZSA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGFwZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IHRhcGVbaV07XG4gICAgICAgIGlmIChub2Rlc0Zyb21YW25vZGUuaWRdICYmIG5vZGVzVG9ZW25vZGUuaWRdKSB7XG4gICAgICAgICAgICB2YXIgcHJ1bmVkSW5wdXRzID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZUlucHV0ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGVuc29yc0Zyb21YW25vZGVJbnB1dC5pZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcHJ1bmVkSW5wdXRzW2lucHV0TmFtZV0gPSBub2RlSW5wdXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHBydW5lZE5vZGUgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICAgICAgICAgIHBydW5lZE5vZGUuaW5wdXRzID0gcHJ1bmVkSW5wdXRzO1xuICAgICAgICAgICAgcHJ1bmVkTm9kZS5vdXRwdXQgPSBub2RlLm91dHB1dDtcbiAgICAgICAgICAgIGZpbHRlcmVkVGFwZS5wdXNoKHBydW5lZE5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZFRhcGU7XG59XG5leHBvcnRzLmdldEZpbHRlcmVkTm9kZXNYVG9ZID0gZ2V0RmlsdGVyZWROb2Rlc1hUb1k7XG5mdW5jdGlvbiBiYWNrcHJvcGFnYXRlR3JhZGllbnRzKHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXAsIGZpbHRlcmVkVGFwZSkge1xuICAgIGZvciAodmFyIGkgPSBmaWx0ZXJlZFRhcGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmaWx0ZXJlZFRhcGVbaV07XG4gICAgICAgIHZhciBkeSA9IHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbbm9kZS5vdXRwdXQuaWRdO1xuICAgICAgICBpZiAobm9kZS5ncmFkaWVudCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29tcHV0ZSBncmFkaWVudDogZ3JhZGllbnQgZnVuY3Rpb24gbm90IGZvdW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJmb3IgXCIgKyBub2RlLm5hbWUgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpbnB1dEdyYWRpZW50cyA9IG5vZGUuZ3JhZGllbnQoZHkpO1xuICAgICAgICBmb3IgKHZhciBpbnB1dE5hbWUgaW4gbm9kZS5pbnB1dHMpIHtcbiAgICAgICAgICAgIGlmICghKGlucHV0TmFtZSBpbiBpbnB1dEdyYWRpZW50cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYmFja3Byb3AgdGhyb3VnaCBpbnB1dCBcIiArIGlucHV0TmFtZSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgIChcIkF2YWlsYWJsZSBncmFkaWVudHMgZm91bmQ6IFwiICsgT2JqZWN0LmtleXMoaW5wdXRHcmFkaWVudHMpICsgXCIuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkeCA9IGlucHV0R3JhZGllbnRzW2lucHV0TmFtZV0oKTtcbiAgICAgICAgICAgIHZhciB4ID0gbm9kZS5pbnB1dHNbaW5wdXROYW1lXTtcbiAgICAgICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChkeC5zaGFwZSwgeC5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBpbiBncmFkaWVudCBmb3Igb3AgXCIgKyBub2RlLm5hbWUgKyBcIi4gVGhlIGdyYWRpZW50IG9mIGlucHV0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgKFwiJ1wiICsgaW5wdXROYW1lICsgXCInIGhhcyBzaGFwZSAnXCIgKyBkeC5zaGFwZSArIFwiJywgd2hpY2ggZG9lcyBub3QgbWF0Y2ggXCIpICtcbiAgICAgICAgICAgICAgICAgICAgKFwidGhlIHNoYXBlIG9mIHRoZSBpbnB1dCAnXCIgKyB4LnNoYXBlICsgXCInXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdID0gZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VyR3JhZGllbnQgPSB0ZW5zb3JBY2N1bXVsYXRlZEdyYWRpZW50TWFwW3guaWRdO1xuICAgICAgICAgICAgICAgIHRlbnNvckFjY3VtdWxhdGVkR3JhZGllbnRNYXBbeC5pZF0gPSBjdXJHcmFkaWVudC5hZGQoZHgpO1xuICAgICAgICAgICAgICAgIGN1ckdyYWRpZW50LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYmFja3Byb3BhZ2F0ZUdyYWRpZW50cyA9IGJhY2twcm9wYWdhdGVHcmFkaWVudHM7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZShyZXN1bHQudmFsdWUpOyB9KS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFswLCB0LnZhbHVlXTtcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xuICAgIH1cbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgZG9jXzEgPSByZXF1aXJlKFwiLi9kb2NcIik7XG52YXIgZW52aXJvbm1lbnRfMSA9IHJlcXVpcmUoXCIuL2Vudmlyb25tZW50XCIpO1xudmFyIG9wcyA9IHJlcXVpcmUoXCIuL29wcy9vcHNcIik7XG52YXIgdGVuc29yX3V0aWwgPSByZXF1aXJlKFwiLi90ZW5zb3JfdXRpbFwiKTtcbnZhciB1dGlsID0gcmVxdWlyZShcIi4vdXRpbFwiKTtcbnZhciBUZW5zb3JCdWZmZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRlbnNvckJ1ZmZlcihzaGFwZSwgZHR5cGUsIHZhbHVlcykge1xuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnQobiA9PT0gc2l6ZSwgXCJMZW5ndGggb2YgdmFsdWVzICdcIiArIG4gKyBcIicgZG9lcyBub3QgbWF0Y2ggdGhlIHNpemUgXCIgK1xuICAgICAgICAgICAgICAgIChcImluZmVycmVkIGJ5IHRoZSBzaGFwZSAnXCIgKyBzaXplICsgXCInXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlcyA9XG4gICAgICAgICAgICB2YWx1ZXMgfHwgdXRpbC5nZXRUeXBlZEFycmF5RnJvbURUeXBlKGR0eXBlLCB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpKTtcbiAgICAgICAgdGhpcy5zdHJpZGVzID0gY29tcHV0ZVN0cmlkZXMoc2hhcGUpO1xuICAgICAgICB0aGlzLnNpemUgPSB1dGlsLnNpemVGcm9tU2hhcGUoc2hhcGUpO1xuICAgIH1cbiAgICBUZW5zb3JCdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY3MgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnQobG9jcy5sZW5ndGggPT09IHRoaXMucmFuaywgXCJUaGUgbnVtYmVyIG9mIHByb3ZpZGVkIGNvb3JkaW5hdGVzIChcIiArIGxvY3MubGVuZ3RoICsgXCIpIG11c3QgXCIgK1xuICAgICAgICAgICAgKFwibWF0Y2ggdGhlIHJhbmsgKFwiICsgdGhpcy5yYW5rICsgXCIpXCIpKTtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5sb2NUb0luZGV4KGxvY3MpO1xuICAgICAgICB0aGlzLnZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbG9jcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbG9jc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgbG9jcyA9IFswXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzW2luZGV4XTtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUubG9jVG9JbmRleCA9IGZ1bmN0aW9uIChsb2NzKSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmFuayA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9O1xuICAgIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUuaW5kZXhUb0xvYyA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5yYW5rID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbG9jcyA9IG5ldyBBcnJheSh0aGlzLnNoYXBlLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGxvY3NbaV0gPSBNYXRoLmZsb29yKGluZGV4IC8gdGhpcy5zdHJpZGVzW2ldKTtcbiAgICAgICAgICAgIGluZGV4IC09IGxvY3NbaV0gKiB0aGlzLnN0cmlkZXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9jc1tsb2NzLmxlbmd0aCAtIDFdID0gaW5kZXg7XG4gICAgICAgIHJldHVybiBsb2NzO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvckJ1ZmZlci5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW5zb3JCdWZmZXIucHJvdG90eXBlLnRvVGVuc29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVGVuc29yLm1ha2UodGhpcy5zaGFwZSwgeyB2YWx1ZXM6IHRoaXMudmFsdWVzIH0sIHRoaXMuZHR5cGUpO1xuICAgIH07XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NyZWF0aW9uJyB9KVxuICAgIF0sIFRlbnNvckJ1ZmZlci5wcm90b3R5cGUsIFwic2V0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBUZW5zb3JCdWZmZXIucHJvdG90eXBlLCBcImdldFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ3JlYXRpb24nIH0pXG4gICAgXSwgVGVuc29yQnVmZmVyLnByb3RvdHlwZSwgXCJ0b1RlbnNvclwiLCBudWxsKTtcbiAgICBUZW5zb3JCdWZmZXIgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3JCdWZmZXIpO1xuICAgIHJldHVybiBUZW5zb3JCdWZmZXI7XG59KCkpO1xuZXhwb3J0cy5UZW5zb3JCdWZmZXIgPSBUZW5zb3JCdWZmZXI7XG52YXIgVGVuc29yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZW5zb3Ioc2hhcGUsIGR0eXBlLCB2YWx1ZXMsIGRhdGFJZCkge1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zaXplID0gdXRpbC5zaXplRnJvbVNoYXBlKHNoYXBlKTtcbiAgICAgICAgaWYgKHZhbHVlcyAhPSBudWxsKSB7XG4gICAgICAgICAgICB1dGlsLmFzc2VydCh0aGlzLnNpemUgPT09IHZhbHVlcy5sZW5ndGgsIFwiQ29uc3RydWN0aW5nIHRlbnNvciBvZiBzaGFwZSAoXCIgKyB0aGlzLnNpemUgKyBcIikgc2hvdWxkIG1hdGNoIHRoZSBcIiArXG4gICAgICAgICAgICAgICAgKFwibGVuZ3RoIG9mIHZhbHVlcyAoXCIgKyB2YWx1ZXMubGVuZ3RoICsgXCIpXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNoYXBlID0gc2hhcGU7XG4gICAgICAgIHRoaXMuZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgICAgIHRoaXMuc3RyaWRlcyA9IGNvbXB1dGVTdHJpZGVzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5kYXRhSWQgPSBkYXRhSWQgIT0gbnVsbCA/IGRhdGFJZCA6IHt9O1xuICAgICAgICB0aGlzLmlkID0gVGVuc29yXzEubmV4dElkKys7XG4gICAgICAgIHRoaXMucmFua1R5cGUgPSAodGhpcy5yYW5rIDwgNSA/IHRoaXMucmFuay50b1N0cmluZygpIDogJ2hpZ2hlcicpO1xuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJUZW5zb3IodGhpcyk7XG4gICAgICAgIGlmICh2YWx1ZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLndyaXRlKHRoaXMuZGF0YUlkLCB2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRlbnNvcl8xID0gVGVuc29yO1xuICAgIFRlbnNvci5vbmVzID0gZnVuY3Rpb24gKHNoYXBlLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gb3BzLm9uZXMoc2hhcGUsIGR0eXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci56ZXJvcyA9IGZ1bmN0aW9uIChzaGFwZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9wcy56ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgVGVuc29yLm9uZXNMaWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5vbmVzTGlrZSh4KTtcbiAgICB9O1xuICAgIFRlbnNvci56ZXJvc0xpa2UgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICByZXR1cm4gb3BzLnplcm9zTGlrZSh4KTtcbiAgICB9O1xuICAgIFRlbnNvci5saWtlID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5jbG9uZSh4KTtcbiAgICB9O1xuICAgIFRlbnNvci5tYWtlID0gZnVuY3Rpb24gKHNoYXBlLCBkYXRhLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFRlbnNvcl8xKHNoYXBlLCBkdHlwZSwgZGF0YS52YWx1ZXMsIGRhdGEuZGF0YUlkKTtcbiAgICB9O1xuICAgIFRlbnNvci5mcm9tUGl4ZWxzID0gZnVuY3Rpb24gKHBpeGVscywgbnVtQ2hhbm5lbHMpIHtcbiAgICAgICAgaWYgKG51bUNoYW5uZWxzID09PSB2b2lkIDApIHsgbnVtQ2hhbm5lbHMgPSAzOyB9XG4gICAgICAgIHJldHVybiBvcHMuZnJvbVBpeGVscyhwaXhlbHMsIG51bUNoYW5uZWxzKTtcbiAgICB9O1xuICAgIFRlbnNvci5yYW5kID0gZnVuY3Rpb24gKHNoYXBlLCByYW5kRnVuY3Rpb24sIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBvcHMucmFuZChzaGFwZSwgcmFuZEZ1bmN0aW9uLCBkdHlwZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucmFuZE5vcm1hbCA9IGZ1bmN0aW9uIChzaGFwZSwgbWVhbiwgc3RkRGV2LCBkdHlwZSwgc2VlZCkge1xuICAgICAgICBpZiAobWVhbiA9PT0gdm9pZCAwKSB7IG1lYW4gPSAwOyB9XG4gICAgICAgIGlmIChzdGREZXYgPT09IHZvaWQgMCkgeyBzdGREZXYgPSAxOyB9XG4gICAgICAgIHJldHVybiBvcHMucmFuZG9tTm9ybWFsKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKTtcbiAgICB9O1xuICAgIFRlbnNvci5yYW5kVHJ1bmNhdGVkTm9ybWFsID0gZnVuY3Rpb24gKHNoYXBlLCBtZWFuLCBzdGREZXYsIGR0eXBlLCBzZWVkKSB7XG4gICAgICAgIGlmIChtZWFuID09PSB2b2lkIDApIHsgbWVhbiA9IDA7IH1cbiAgICAgICAgaWYgKHN0ZERldiA9PT0gdm9pZCAwKSB7IHN0ZERldiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIG9wcy50cnVuY2F0ZWROb3JtYWwoc2hhcGUsIG1lYW4sIHN0ZERldiwgZHR5cGUsIHNlZWQpO1xuICAgIH07XG4gICAgVGVuc29yLnJhbmRVbmlmb3JtID0gZnVuY3Rpb24gKHNoYXBlLCBhLCBiLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gb3BzLnJhbmRvbVVuaWZvcm0oc2hhcGUsIGEsIGIsIGR0eXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZmxhdHRlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXMxRCgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hc1NjYWxhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdXRpbC5hc3NlcnQodGhpcy5zaXplID09PSAxLCAnVGhlIGFycmF5IG11c3QgaGF2ZSBvbmx5IDEgZWxlbWVudC4nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzMUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3RoaXMuc2l6ZV0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczJEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaGFwZShbcm93cywgY29sdW1uc10pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hczNEID0gZnVuY3Rpb24gKHJvd3MsIGNvbHVtbnMsIGRlcHRoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc2hhcGUoW3Jvd3MsIGNvbHVtbnMsIGRlcHRoXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzNEQgPSBmdW5jdGlvbiAocm93cywgY29sdW1ucywgZGVwdGgsIGRlcHRoMikge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKFtyb3dzLCBjb2x1bW5zLCBkZXB0aCwgZGVwdGgyXSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFzVHlwZSA9IGZ1bmN0aW9uIChkdHlwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNhc3QodGhpcywgZHR5cGUpO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRlbnNvci5wcm90b3R5cGUsIFwicmFua1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGUubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGxvY3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGxvY3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAobG9jcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvY3MgPSBbMF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gbG9jc1tsb2NzLmxlbmd0aCAtIDFdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvY3MubGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgICAgICBpbmRleCArPSB0aGlzLnN0cmlkZXNbaV0gKiBsb2NzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTeW5jKClbaW5kZXhdO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS52YWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsb2NzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBsb2NzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jcyA9IFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIHRoaXMuZGF0YSgpXTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB0aGlzLmdldC5hcHBseSh0aGlzLCBsb2NzKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2NUb0luZGV4ID0gZnVuY3Rpb24gKGxvY3MpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgaWYgKHRoaXMucmFuayA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jc1swXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW5kZXggPSBsb2NzW2xvY3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbG9jcy5sZW5ndGggLSAxOyArK2kpIHtcbiAgICAgICAgICAgIGluZGV4ICs9IHRoaXMuc3RyaWRlc1tpXSAqIGxvY3NbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5pbmRleFRvTG9jID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGlmICh0aGlzLnJhbmsgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJhbmsgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsb2NzID0gbmV3IEFycmF5KHRoaXMuc2hhcGUubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsb2NzLmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgbG9jc1tpXSA9IE1hdGguZmxvb3IoaW5kZXggLyB0aGlzLnN0cmlkZXNbaV0pO1xuICAgICAgICAgICAgaW5kZXggLT0gbG9jc1tpXSAqIHRoaXMuc3RyaWRlc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBsb2NzW2xvY3MubGVuZ3RoIC0gMV0gPSBpbmRleDtcbiAgICAgICAgcmV0dXJuIGxvY3M7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmdldFZhbHVlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVN5bmMoKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ2V0VmFsdWVzQXN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEoKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gb3BzLmJ1ZmZlcih0aGlzLnNoYXBlLCB0aGlzLmR0eXBlLCB0aGlzLmRhdGFTeW5jKCkpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWzIsIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5yZWFkKHRoaXMuZGF0YUlkKV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRhdGFTeW5jID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlYWRTeW5jKHRoaXMuZGF0YUlkKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5kaXNwb3NlVGVuc29yKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50aHJvd0lmRGlzcG9zZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRlbnNvciBpcyBkaXNwb3NlZC5cIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudG9GbG9hdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdmbG9hdDMyJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvSW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hc1R5cGUoJ2ludDMyJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRvQm9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNUeXBlKCdib29sJyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnByaW50ID0gZnVuY3Rpb24gKHZlcmJvc2UpIHtcbiAgICAgICAgaWYgKHZlcmJvc2UgPT09IHZvaWQgMCkgeyB2ZXJib3NlID0gZmFsc2U7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5wcmludCh0aGlzLCB2ZXJib3NlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmVzaGFwZSA9IGZ1bmN0aW9uIChuZXdTaGFwZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJlc2hhcGUodGhpcywgbmV3U2hhcGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yZXNoYXBlQXMgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNoYXBlKHguc2hhcGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5leHBhbmREaW1zID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICByZXR1cm4gb3BzLmV4cGFuZERpbXModGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxdWVlemUgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxdWVlemUodGhpcywgYXhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNsb25lKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRlbnNvcl91dGlsLnRlbnNvclRvU3RyaW5nKHRoaXMsIHRydWUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS50aWxlID0gZnVuY3Rpb24gKHJlcHMpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50aWxlKHRoaXMsIHJlcHMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5nYXRoZXIgPSBmdW5jdGlvbiAoaW5kaWNlcywgYXhpcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSAwOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZ2F0aGVyKHRoaXMsIGluZGljZXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXRNdWwgPSBmdW5jdGlvbiAoYiwgdHJhbnNwb3NlQSwgdHJhbnNwb3NlQikge1xuICAgICAgICBpZiAodHJhbnNwb3NlQSA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUEgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodHJhbnNwb3NlQiA9PT0gdm9pZCAwKSB7IHRyYW5zcG9zZUIgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm1hdE11bCh0aGlzLCBiLCB0cmFuc3Bvc2VBLCB0cmFuc3Bvc2VCKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubm9ybSA9IGZ1bmN0aW9uIChvcmQsIGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChvcmQgPT09IHZvaWQgMCkgeyBvcmQgPSAnZXVjbGlkZWFuJzsgfVxuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ub3JtKHRoaXMsIG9yZCwgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIChiZWdpbiwgc2l6ZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNsaWNlKHRoaXMsIGJlZ2luLCBzaXplKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMucmV2ZXJzZSh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gKHgsIGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gMDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvbmNhdChbdGhpcywgeF0sIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zdGFjayA9IGZ1bmN0aW9uICh4LCBheGlzKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IDA7IH1cbiAgICAgICAgcmV0dXJuIG9wcy5zdGFjayhbdGhpcywgeF0sIGF4aXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5wYWQgPSBmdW5jdGlvbiAocGFkZGluZ3MsIGNvbnN0YW50VmFsdWUpIHtcbiAgICAgICAgaWYgKGNvbnN0YW50VmFsdWUgPT09IHZvaWQgMCkgeyBjb25zdGFudFZhbHVlID0gMDsgfVxuICAgICAgICByZXR1cm4gb3BzLnBhZCh0aGlzLCBwYWRkaW5ncywgY29uc3RhbnRWYWx1ZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmJhdGNoTm9ybWFsaXphdGlvbiA9IGZ1bmN0aW9uIChtZWFuLCB2YXJpYW5jZSwgdmFyaWFuY2VFcHNpbG9uLCBzY2FsZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh2YXJpYW5jZUVwc2lsb24gPT09IHZvaWQgMCkgeyB2YXJpYW5jZUVwc2lsb24gPSAuMDAxOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYmF0Y2hOb3JtYWxpemF0aW9uKHRoaXMsIG1lYW4sIHZhcmlhbmNlLCB2YXJpYW5jZUVwc2lsb24sIHNjYWxlLCBvZmZzZXQpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dTdW1FeHAgPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nU3VtRXhwKHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3VtID0gZnVuY3Rpb24gKGF4aXMsIGtlZXBEaW1zKSB7XG4gICAgICAgIGlmIChheGlzID09PSB2b2lkIDApIHsgYXhpcyA9IG51bGw7IH1cbiAgICAgICAgaWYgKGtlZXBEaW1zID09PSB2b2lkIDApIHsga2VlcERpbXMgPSBmYWxzZTsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN1bSh0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1lYW4gPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWVhbih0aGlzLCBheGlzLCBrZWVwRGltcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1pbiA9IGZ1bmN0aW9uIChheGlzLCBrZWVwRGltcykge1xuICAgICAgICBpZiAoYXhpcyA9PT0gdm9pZCAwKSB7IGF4aXMgPSBudWxsOyB9XG4gICAgICAgIGlmIChrZWVwRGltcyA9PT0gdm9pZCAwKSB7IGtlZXBEaW1zID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW4odGhpcywgYXhpcywga2VlcERpbXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXggPSBmdW5jdGlvbiAoYXhpcywga2VlcERpbXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICBpZiAoa2VlcERpbXMgPT09IHZvaWQgMCkgeyBrZWVwRGltcyA9IGZhbHNlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4KHRoaXMsIGF4aXMsIGtlZXBEaW1zKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXJnTWluID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFyZ01pbih0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXJnTWF4ID0gZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgaWYgKGF4aXMgPT09IHZvaWQgMCkgeyBheGlzID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFyZ01heCh0aGlzLCBheGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hZGQodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFkZFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYWRkU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN1Yih0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3ViU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zdWJTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIChleHApIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5wb3codGhpcywgZXhwKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucG93U3RyaWN0ID0gZnVuY3Rpb24gKGV4cCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnBvd1N0cmljdCh0aGlzLCBleHApO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm11bCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubXVsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5tdWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZGl2KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kaXZTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmRpdlN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWluaW11bSh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWluaW11bVN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWluaW11bVN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4aW11bSh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubWF4aW11bVN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4aW11bVN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudHJhbnNwb3NlID0gZnVuY3Rpb24gKHBlcm0pIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy50cmFuc3Bvc2UodGhpcywgcGVybSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm5vdEVxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ub3RFcXVhbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubm90RXF1YWxTdHJpY3QgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLm5vdEVxdWFsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sZXNzID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sZXNzU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5lcXVhbCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5lcXVhbFN0cmljdCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubGVzc0VxdWFsID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sZXNzRXF1YWwodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxlc3NFcXVhbFN0cmljdCA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubGVzc0VxdWFsU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ncmVhdGVyID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ncmVhdGVyU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyU3RyaWN0KHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5ncmVhdGVyRXF1YWwgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmdyZWF0ZXJFcXVhbCh0aGlzLCB4KTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuZ3JlYXRlckVxdWFsU3RyaWN0ID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5ncmVhdGVyRXF1YWxTdHJpY3QodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxvZ2ljYWxBbmQgPSBmdW5jdGlvbiAoeCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmxvZ2ljYWxBbmQodGhpcywgeCk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmxvZ2ljYWxPciA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9naWNhbE9yKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2dpY2FsWG9yID0gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5sb2dpY2FsWG9yKHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS53aGVyZSA9IGZ1bmN0aW9uIChjb25kaXRpb24sIHgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy53aGVyZShjb25kaXRpb24sIHRoaXMsIHgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubmVnKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jZWlsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNlaWwodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmZsb29yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmZsb29yKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5leHAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuZXhwKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5sb2cgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubG9nKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zcXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNxcnQodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNxdWFyZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zcXVhcmUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hYnModGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNsaXBCeVZhbHVlID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY2xpcEJ5VmFsdWUodGhpcywgbWluLCBtYXgpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5yZWx1ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnJlbHUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmVsdSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5lbHUodGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNlbHUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2VsdSh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubGVha3lSZWx1ID0gZnVuY3Rpb24gKGFscGhhKSB7XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMC4yOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubGVha3lSZWx1KHRoaXMsIGFscGhhKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUucHJlbHUgPSBmdW5jdGlvbiAoYWxwaGEpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5wcmVsdSh0aGlzLCBhbHBoYSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnNpZ21vaWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuc2lnbW9pZCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2luID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnNpbih0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuY29zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvcyh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUudGFuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnRhbih0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXNpbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5hc2luKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5hY29zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmFjb3ModGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmF0YW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuYXRhbih0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc2luaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zaW5oKHRoaXMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb3NoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmNvc2godGhpcyk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnRhbmggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMudGFuaCh0aGlzKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuc3RlcCA9IGZ1bmN0aW9uIChhbHBoYSkge1xuICAgICAgICBpZiAoYWxwaGEgPT09IHZvaWQgMCkgeyBhbHBoYSA9IDAuMDsgfVxuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLnN0ZXAodGhpcywgYWxwaGEpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5zb2Z0bWF4ID0gZnVuY3Rpb24gKGRpbSkge1xuICAgICAgICBpZiAoZGltID09PSB2b2lkIDApIHsgZGltID0gLTE7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5zb2Z0bWF4KHRoaXMsIGRpbSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLnJlc2l6ZUJpbGluZWFyID0gZnVuY3Rpb24gKG5ld1NoYXBlMkQsIGFsaWduQ29ybmVycykge1xuICAgICAgICBpZiAoYWxpZ25Db3JuZXJzID09PSB2b2lkIDApIHsgYWxpZ25Db3JuZXJzID0gZmFsc2U7IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5pbWFnZS5yZXNpemVCaWxpbmVhcih0aGlzLCBuZXdTaGFwZTJELCBhbGlnbkNvcm5lcnMpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb252MWQgPSBmdW5jdGlvbiAoZmlsdGVyLCBzdHJpZGUsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29udjFkKHRoaXMsIGZpbHRlciwgc3RyaWRlLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLmNvbnYyZCA9IGZ1bmN0aW9uIChmaWx0ZXIsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMuY29udjJkKHRoaXMsIGZpbHRlciwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5jb252MmRUcmFuc3Bvc2UgPSBmdW5jdGlvbiAoZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5jb252MmRUcmFuc3Bvc2UodGhpcywgZmlsdGVyLCBvdXRwdXRTaGFwZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5kZXB0aHdpc2VDb252MkQgPSBmdW5jdGlvbiAoZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIGlmIChkaWxhdGlvbnMgPT09IHZvaWQgMCkgeyBkaWxhdGlvbnMgPSBbMSwgMV07IH1cbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5kZXB0aHdpc2VDb252MmQodGhpcywgZmlsdGVyLCBzdHJpZGVzLCBwYWQsIGRpbGF0aW9ucywgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUuYXZnUG9vbCA9IGZ1bmN0aW9uIChmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICByZXR1cm4gb3BzLmF2Z1Bvb2wodGhpcywgZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS5tYXhQb29sID0gZnVuY3Rpb24gKGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBvcHMubWF4UG9vbCh0aGlzLCBmaWx0ZXJTaXplLCBzdHJpZGVzLCBwYWQsIGRpbVJvdW5kaW5nTW9kZSk7XG4gICAgfTtcbiAgICBUZW5zb3IucHJvdG90eXBlLm1pblBvb2wgPSBmdW5jdGlvbiAoZmlsdGVyU2l6ZSwgc3RyaWRlcywgcGFkLCBkaW1Sb3VuZGluZ01vZGUpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIG9wcy5taW5Qb29sKHRoaXMsIGZpbHRlclNpemUsIHN0cmlkZXMsIHBhZCwgZGltUm91bmRpbmdNb2RlKTtcbiAgICB9O1xuICAgIFRlbnNvci5wcm90b3R5cGUubG9jYWxSZXNwb25zZU5vcm1hbGl6YXRpb24gPSBmdW5jdGlvbiAocmFkaXVzLCBiaWFzLCBhbHBoYSwgYmV0YSwgbm9ybVJlZ2lvbikge1xuICAgICAgICBpZiAocmFkaXVzID09PSB2b2lkIDApIHsgcmFkaXVzID0gNTsgfVxuICAgICAgICBpZiAoYmlhcyA9PT0gdm9pZCAwKSB7IGJpYXMgPSAxOyB9XG4gICAgICAgIGlmIChhbHBoYSA9PT0gdm9pZCAwKSB7IGFscGhhID0gMTsgfVxuICAgICAgICBpZiAoYmV0YSA9PT0gdm9pZCAwKSB7IGJldGEgPSAwLjU7IH1cbiAgICAgICAgaWYgKG5vcm1SZWdpb24gPT09IHZvaWQgMCkgeyBub3JtUmVnaW9uID0gJ2Fjcm9zc0NoYW5uZWxzJzsgfVxuICAgICAgICByZXR1cm4gb3BzLmxvY2FsUmVzcG9uc2VOb3JtYWxpemF0aW9uKHRoaXMsIHJhZGl1cywgYmlhcywgYWxwaGEsIGJldGEsIG5vcm1SZWdpb24pO1xuICAgIH07XG4gICAgVGVuc29yLnByb3RvdHlwZS52YXJpYWJsZSA9IGZ1bmN0aW9uICh0cmFpbmFibGUsIG5hbWUsIGR0eXBlKSB7XG4gICAgICAgIGlmICh0cmFpbmFibGUgPT09IHZvaWQgMCkgeyB0cmFpbmFibGUgPSB0cnVlOyB9XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiBWYXJpYWJsZS52YXJpYWJsZSh0aGlzLCB0cmFpbmFibGUsIG5hbWUsIGR0eXBlKTtcbiAgICB9O1xuICAgIFRlbnNvci5uZXh0SWQgPSAwO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiZmxhdHRlblwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzU2NhbGFyXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXMxRFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzMkRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJhczNEXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwiYXM0RFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImFzVHlwZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImJ1ZmZlclwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImRhdGFcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJkYXRhU3luY1wiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImRpc3Bvc2VcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b0Zsb2F0XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwidG9JbnRcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJ0b0Jvb2xcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJwcmludFwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcInJlc2hhcGVcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJyZXNoYXBlQXNcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdUZW5zb3JzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnIH0pXG4gICAgXSwgVGVuc29yLnByb3RvdHlwZSwgXCJleHBhbmREaW1zXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwic3F1ZWV6ZVwiLCBudWxsKTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IucHJvdG90eXBlLCBcImNsb25lXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyB9KVxuICAgIF0sIFRlbnNvci5wcm90b3R5cGUsIFwidG9TdHJpbmdcIiwgbnVsbCk7XG4gICAgVGVuc29yID0gVGVuc29yXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBUZW5zb3IpO1xuICAgIHJldHVybiBUZW5zb3I7XG4gICAgdmFyIFRlbnNvcl8xO1xufSgpKTtcbmV4cG9ydHMuVGVuc29yID0gVGVuc29yO1xuZXhwb3J0cy5OREFycmF5ID0gVGVuc29yO1xudmFyIFNjYWxhciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFNjYWxhciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBTY2FsYXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2NhbGFyLm5ldyA9IGZ1bmN0aW9uICh2YWx1ZSwgZHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG9wcy5zY2FsYXIodmFsdWUsIGR0eXBlKTtcbiAgICB9O1xuICAgIHJldHVybiBTY2FsYXI7XG59KFRlbnNvcikpO1xuZXhwb3J0cy5TY2FsYXIgPSBTY2FsYXI7XG52YXIgVGVuc29yMUQgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhUZW5zb3IxRCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBUZW5zb3IxRCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBUZW5zb3IxRC5uZXcgPSBmdW5jdGlvbiAodmFsdWVzLCBkdHlwZSkge1xuICAgICAgICByZXR1cm4gb3BzLnRlbnNvcjFkKHZhbHVlcywgZHR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvcjFEO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVGVuc29yMUQgPSBUZW5zb3IxRDtcbmV4cG9ydHMuQXJyYXkxRCA9IFRlbnNvcjFEO1xudmFyIFRlbnNvcjJEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yMkQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yMkQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yMkQubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yMmQodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvcjJEO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVGVuc29yMkQgPSBUZW5zb3IyRDtcbmV4cG9ydHMuQXJyYXkyRCA9IFRlbnNvcjJEO1xudmFyIFRlbnNvcjNEID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yM0QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yM0QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yM0QubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yM2QodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvcjNEO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVGVuc29yM0QgPSBUZW5zb3IzRDtcbmV4cG9ydHMuQXJyYXkzRCA9IFRlbnNvcjNEO1xudmFyIFRlbnNvcjREID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVGVuc29yNEQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVGVuc29yNEQoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgVGVuc29yNEQubmV3ID0gZnVuY3Rpb24gKHNoYXBlLCB2YWx1ZXMsIGR0eXBlKSB7XG4gICAgICAgIHJldHVybiBvcHMudGVuc29yNGQodmFsdWVzLCBzaGFwZSwgZHR5cGUpO1xuICAgIH07XG4gICAgcmV0dXJuIFRlbnNvcjREO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVGVuc29yNEQgPSBUZW5zb3I0RDtcbmV4cG9ydHMuQXJyYXk0RCA9IFRlbnNvcjREO1xudmFyIFZhcmlhYmxlID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmFyaWFibGUsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmFyaWFibGUoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHRyYWluYWJsZSA9PT0gdm9pZCAwKSB7IHRyYWluYWJsZSA9IHRydWU7IH1cbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgaW5pdGlhbFZhbHVlLnNoYXBlLCBpbml0aWFsVmFsdWUuZHR5cGUsIG51bGwsIGluaXRpYWxWYWx1ZS5kYXRhSWQpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnRyYWluYWJsZSA9IHRyYWluYWJsZTtcbiAgICAgICAgX3RoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIGlmIChfdGhpcy5uYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIF90aGlzLm5hbWUgPSBWYXJpYWJsZV8xLm5leHRWYXJJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgVmFyaWFibGVfMS5uZXh0VmFySWQrKztcbiAgICAgICAgfVxuICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUucmVnaXN0ZXJWYXJpYWJsZShfdGhpcyk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgVmFyaWFibGVfMSA9IFZhcmlhYmxlO1xuICAgIFZhcmlhYmxlLnZhcmlhYmxlID0gZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSwgdHJhaW5hYmxlLCBuYW1lLCBkdHlwZSkge1xuICAgICAgICBpZiAodHJhaW5hYmxlID09PSB2b2lkIDApIHsgdHJhaW5hYmxlID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoZHR5cGUgIT0gbnVsbCAmJiBkdHlwZSAhPT0gaW5pdGlhbFZhbHVlLmR0eXBlKSB7XG4gICAgICAgICAgICBpbml0aWFsVmFsdWUgPSBpbml0aWFsVmFsdWUuYXNUeXBlKGR0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFZhcmlhYmxlXzEoaW5pdGlhbFZhbHVlLCB0cmFpbmFibGUsIG5hbWUpO1xuICAgIH07XG4gICAgVmFyaWFibGUucHJvdG90eXBlLmFzc2lnbiA9IGZ1bmN0aW9uIChuZXdWYWx1ZSkge1xuICAgICAgICBpZiAobmV3VmFsdWUuZHR5cGUgIT09IHRoaXMuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImR0eXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiICsgbmV3VmFsdWUuZHR5cGUgKyBcIikgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwcmV2aW91cyB2YWx1ZSAoXCIgKyB0aGlzLmR0eXBlICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChuZXdWYWx1ZS5zaGFwZSwgdGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNoYXBlIG9mIHRoZSBuZXcgdmFsdWUgKFwiICsgbmV3VmFsdWUuc2hhcGUgKyBcIikgYW5kIFwiICtcbiAgICAgICAgICAgICAgICAoXCJwcmV2aW91cyB2YWx1ZSAoXCIgKyB0aGlzLnNoYXBlICsgXCIpIG11c3QgbWF0Y2hcIikpO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5kaXNwb3NlVGVuc29yKHRoaXMpO1xuICAgICAgICB0aGlzLmRhdGFJZCA9IG5ld1ZhbHVlLmRhdGFJZDtcbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnJlZ2lzdGVyVGVuc29yKHRoaXMpO1xuICAgIH07XG4gICAgVmFyaWFibGUubmV4dFZhcklkID0gMDtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBWYXJpYWJsZS5wcm90b3R5cGUsIFwiYXNzaWduXCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnVGVuc29ycycsIHN1YmhlYWRpbmc6ICdDcmVhdGlvbicgfSlcbiAgICBdLCBWYXJpYWJsZSwgXCJ2YXJpYWJsZVwiLCBudWxsKTtcbiAgICBWYXJpYWJsZSA9IFZhcmlhYmxlXzEgPSBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1RlbnNvcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycgfSlcbiAgICBdLCBWYXJpYWJsZSk7XG4gICAgcmV0dXJuIFZhcmlhYmxlO1xuICAgIHZhciBWYXJpYWJsZV8xO1xufShUZW5zb3IpKTtcbmV4cG9ydHMuVmFyaWFibGUgPSBWYXJpYWJsZTtcbnZhciB2YXJpYWJsZSA9IFZhcmlhYmxlLnZhcmlhYmxlO1xuZXhwb3J0cy52YXJpYWJsZSA9IHZhcmlhYmxlO1xuZnVuY3Rpb24gY29tcHV0ZVN0cmlkZXMoc2hhcGUpIHtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA8IDIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YXIgc3RyaWRlcyA9IG5ldyBBcnJheShyYW5rIC0gMSk7XG4gICAgc3RyaWRlc1tyYW5rIC0gMl0gPSBzaGFwZVtyYW5rIC0gMV07XG4gICAgZm9yICh2YXIgaSA9IHJhbmsgLSAzOyBpID49IDA7IC0taSkge1xuICAgICAgICBzdHJpZGVzW2ldID0gc3RyaWRlc1tpICsgMV0gKiBzaGFwZVtpICsgMV07XG4gICAgfVxuICAgIHJldHVybiBzdHJpZGVzO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRk9STUFUX0xJTUlUX05VTV9WQUxTID0gMjA7XG52YXIgRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFMgPSAzO1xudmFyIEZPUk1BVF9OVU1fU0lHX0RJR0lUUyA9IDc7XG5mdW5jdGlvbiB0ZW5zb3JUb1N0cmluZyh0LCB2ZXJib3NlKSB7XG4gICAgdmFyIHZhbHMgPSB0LmRhdGFTeW5jKCk7XG4gICAgdmFyIHBhZFBlckNvbCA9IGNvbXB1dGVNYXhTaXplUGVyQ29sdW1uKHQpO1xuICAgIHZhciB2YWxzTGluZXMgPSBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLCB0LnNoYXBlLCB0LnN0cmlkZXMsIHBhZFBlckNvbCk7XG4gICAgdmFyIGxpbmVzID0gWydUZW5zb3InXTtcbiAgICBpZiAodmVyYm9zZSkge1xuICAgICAgICBsaW5lcy5wdXNoKFwiICBkdHlwZTogXCIgKyB0LmR0eXBlKTtcbiAgICAgICAgbGluZXMucHVzaChcIiAgcmFuazogXCIgKyB0LnJhbmspO1xuICAgICAgICBsaW5lcy5wdXNoKFwiICBzaGFwZTogW1wiICsgdC5zaGFwZSArIFwiXVwiKTtcbiAgICAgICAgbGluZXMucHVzaChcIiAgdmFsdWVzOlwiKTtcbiAgICB9XG4gICAgbGluZXMucHVzaCh2YWxzTGluZXMubWFwKGZ1bmN0aW9uIChsKSB7IHJldHVybiAnICAgICcgKyBsOyB9KS5qb2luKCdcXG4nKSk7XG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuZXhwb3J0cy50ZW5zb3JUb1N0cmluZyA9IHRlbnNvclRvU3RyaW5nO1xuZnVuY3Rpb24gY29tcHV0ZU1heFNpemVQZXJDb2x1bW4odCkge1xuICAgIHZhciB2YWxzID0gdC5kYXRhU3luYygpO1xuICAgIHZhciBuID0gdC5zaXplO1xuICAgIHZhciBudW1Db2xzID0gdC5zdHJpZGVzW3Quc3RyaWRlcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgcGFkUGVyQ29sID0gbmV3IEFycmF5KG51bUNvbHMpLmZpbGwoMCk7XG4gICAgaWYgKHQucmFuayA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbiAvIG51bUNvbHM7IHJvdysrKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gcm93ICogbnVtQ29scztcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbnVtQ29sczsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGFkUGVyQ29sW2pdID1cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgocGFkUGVyQ29sW2pdLCB2YWxUb1N0cmluZyh2YWxzW29mZnNldCArIGpdLCAwKS5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYWRQZXJDb2w7XG59XG5mdW5jdGlvbiB2YWxUb1N0cmluZyh2YWwsIHBhZCkge1xuICAgIHJldHVybiB1dGlsLnJpZ2h0UGFkKHBhcnNlRmxvYXQodmFsLnRvRml4ZWQoRk9STUFUX05VTV9TSUdfRElHSVRTKSkudG9TdHJpbmcoKSwgcGFkKTtcbn1cbmZ1bmN0aW9uIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMsIHNoYXBlLCBzdHJpZGVzLCBwYWRQZXJDb2wsIGlzTGFzdCkge1xuICAgIGlmIChpc0xhc3QgPT09IHZvaWQgMCkgeyBpc0xhc3QgPSB0cnVlOyB9XG4gICAgdmFyIHNpemUgPSBzaGFwZVswXTtcbiAgICB2YXIgcmFuayA9IHNoYXBlLmxlbmd0aDtcbiAgICBpZiAocmFuayA9PT0gMCkge1xuICAgICAgICByZXR1cm4gW3ZhbHNbMF0udG9TdHJpbmcoKV07XG4gICAgfVxuICAgIGlmIChyYW5rID09PSAxKSB7XG4gICAgICAgIGlmIChzaXplID4gRk9STUFUX0xJTUlUX05VTV9WQUxTKSB7XG4gICAgICAgICAgICB2YXIgZmlyc3RWYWxzID0gQXJyYXkuZnJvbSh2YWxzLnN1YmFycmF5KDAsIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTKSk7XG4gICAgICAgICAgICB2YXIgbGFzdFZhbHMgPSBBcnJheS5mcm9tKHZhbHMuc3ViYXJyYXkoc2l6ZSAtIEZPUk1BVF9OVU1fRklSU1RfTEFTVF9WQUxTLCBzaXplKSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICdbJyArIGZpcnN0VmFscy5tYXAoZnVuY3Rpb24gKHgsIGkpIHsgcmV0dXJuIHZhbFRvU3RyaW5nKHgsIHBhZFBlckNvbFtpXSk7IH0pLmpvaW4oJywgJykgK1xuICAgICAgICAgICAgICAgICAgICAnLCAuLi4sICcgK1xuICAgICAgICAgICAgICAgICAgICBsYXN0VmFsc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoeCwgaSkgeyByZXR1cm4gdmFsVG9TdHJpbmcoeCwgcGFkUGVyQ29sW3NpemUgLSBGT1JNQVRfTlVNX0ZJUlNUX0xBU1RfVkFMUyArIGldKTsgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAgICAgJ10nXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAnWycgK1xuICAgICAgICAgICAgICAgIEFycmF5LmZyb20odmFscykubWFwKGZ1bmN0aW9uICh4LCBpKSB7IHJldHVybiB2YWxUb1N0cmluZyh4LCBwYWRQZXJDb2xbaV0pOyB9KS5qb2luKCcsICcpICtcbiAgICAgICAgICAgICAgICAnXSdcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmFyIHN1YnNoYXBlID0gc2hhcGUuc2xpY2UoMSk7XG4gICAgdmFyIHN1YnN0cmlkZXMgPSBzdHJpZGVzLnNsaWNlKDEpO1xuICAgIHZhciBzdHJpZGUgPSBzdHJpZGVzWzBdO1xuICAgIHZhciBsaW5lcyA9IFtdO1xuICAgIGlmIChzaXplID4gRk9STUFUX0xJTUlUX05VTV9WQUxTKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFM7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIHN0cmlkZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmlkZTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHN1YnNoYXBlLCBzdWJzdHJpZGVzLCBwYWRQZXJDb2wsIGZhbHNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGluZXMucHVzaCgnLi4uJyk7XG4gICAgICAgIGZvciAodmFyIGkgPSBzaXplIC0gRk9STUFUX05VTV9GSVJTVF9MQVNUX1ZBTFM7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IGkgKiBzdHJpZGU7XG4gICAgICAgICAgICB2YXIgZW5kID0gc3RhcnQgKyBzdHJpZGU7XG4gICAgICAgICAgICBsaW5lcy5wdXNoLmFwcGx5KGxpbmVzLCBzdWJUZW5zb3JUb1N0cmluZyh2YWxzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLCBzdWJzaGFwZSwgc3Vic3RyaWRlcywgcGFkUGVyQ29sLCBpID09PSBzaXplIC0gMSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gaSAqIHN0cmlkZTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBzdGFydCArIHN0cmlkZTtcbiAgICAgICAgICAgIGxpbmVzLnB1c2guYXBwbHkobGluZXMsIHN1YlRlbnNvclRvU3RyaW5nKHZhbHMuc3ViYXJyYXkoc3RhcnQsIGVuZCksIHN1YnNoYXBlLCBzdWJzdHJpZGVzLCBwYWRQZXJDb2wsIGkgPT09IHNpemUgLSAxKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHNlcCA9IHJhbmsgPT09IDIgPyAnLCcgOiAnJztcbiAgICBsaW5lc1swXSA9ICdbJyArIGxpbmVzWzBdICsgc2VwO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbGluZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGxpbmVzW2ldID0gJyAnICsgbGluZXNbaV0gKyBzZXA7XG4gICAgfVxuICAgIHZhciBuZXdMaW5lU2VwID0gJyxcXG4nO1xuICAgIGZvciAodmFyIGkgPSAyOyBpIDwgcmFuazsgaSsrKSB7XG4gICAgICAgIG5ld0xpbmVTZXAgKz0gJ1xcbic7XG4gICAgfVxuICAgIGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdID1cbiAgICAgICAgJyAnICsgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0gKyAnXScgKyAoaXNMYXN0ID8gJycgOiBuZXdMaW5lU2VwKTtcbiAgICByZXR1cm4gbGluZXM7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBlbnZpcm9ubWVudF8xID0gcmVxdWlyZShcIi4vZW52aXJvbm1lbnRcIik7XG52YXIgYmFja2VuZF9jcHVfMSA9IHJlcXVpcmUoXCIuL2tlcm5lbHMvYmFja2VuZF9jcHVcIik7XG52YXIgYmFja2VuZF93ZWJnbF8xID0gcmVxdWlyZShcIi4va2VybmVscy9iYWNrZW5kX3dlYmdsXCIpO1xudmFyIHRlbnNvcl8xID0gcmVxdWlyZShcIi4vdGVuc29yXCIpO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuZXhwb3J0cy5XRUJHTF9FTlZTID0gW1xuICAgIHsgJ0JBQ0tFTkQnOiAnd2ViZ2wnLCAnV0VCR0xfRkxPQVRfVEVYVFVSRV9FTkFCTEVEJzogdHJ1ZSwgJ1dFQkdMX1ZFUlNJT04nOiAxIH0sXG4gICAgeyAnQkFDS0VORCc6ICd3ZWJnbCcsICdXRUJHTF9GTE9BVF9URVhUVVJFX0VOQUJMRUQnOiB0cnVlLCAnV0VCR0xfVkVSU0lPTic6IDIgfSxcbl07XG5leHBvcnRzLkNQVV9FTlZTID0gW3sgJ0JBQ0tFTkQnOiAnY3B1JyB9XTtcbmV4cG9ydHMuQUxMX0VOVlMgPSBleHBvcnRzLldFQkdMX0VOVlMuY29uY2F0KGV4cG9ydHMuQ1BVX0VOVlMpO1xuZXhwb3J0cy5URVNUX0VQU0lMT04gPSAxZS0zO1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlzQ2xvc2UoYWN0dWFsLCBleHBlY3RlZCwgZXBzaWxvbikge1xuICAgIGlmIChlcHNpbG9uID09PSB2b2lkIDApIHsgZXBzaWxvbiA9IGV4cG9ydHMuVEVTVF9FUFNJTE9OOyB9XG4gICAgaWYgKCEoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSAmJiAhKGV4cGVjdGVkIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSkge1xuICAgICAgICB2YXIgYVR5cGUgPSBhY3R1YWwuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgdmFyIGJUeXBlID0gZXhwZWN0ZWQuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgaWYgKGFUeXBlICE9PSBiVHlwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXJyYXlzIGFyZSBvZiBkaWZmZXJlbnQgdHlwZSBhY3R1YWw6IFwiICsgYVR5cGUgKyBcIiBcIiArXG4gICAgICAgICAgICAgICAgKFwidnMgZXhwZWN0ZWQ6IFwiICsgYlR5cGUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgaWYgKGFjdHVhbC5kdHlwZSAhPT0gZXhwZWN0ZWQuZHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBhcmUgb2YgZGlmZmVyZW50IHR5cGUgYWN0dWFsOiBcIiArIGFjdHVhbC5kdHlwZSArIFwiIFwiICtcbiAgICAgICAgICAgICAgICAoXCJ2cyBleHBlY3RlZDogXCIgKyBleHBlY3RlZC5kdHlwZSArIFwiLlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1dGlsLmFycmF5c0VxdWFsKGFjdHVhbC5zaGFwZSwgZXhwZWN0ZWQuc2hhcGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgYXJlIG9mIGRpZmZlcmVudCBzaGFwZSBhY3R1YWw6IFwiICsgYWN0dWFsLnNoYXBlICsgXCIgXCIgK1xuICAgICAgICAgICAgICAgIChcInZzIGV4cGVjdGVkOiBcIiArIGV4cGVjdGVkLnNoYXBlICsgXCIuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgYWN0dWFsVmFsdWVzO1xuICAgIHZhciBleHBlY3RlZFZhbHVlcztcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIGFjdHVhbFZhbHVlcyA9IGFjdHVhbC5kYXRhU3luYygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYWN0dWFsVmFsdWVzID0gYWN0dWFsO1xuICAgIH1cbiAgICBpZiAoZXhwZWN0ZWQgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgZXhwZWN0ZWRWYWx1ZXMgPSBleHBlY3RlZC5kYXRhU3luYygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZXhwZWN0ZWRWYWx1ZXMgPSBleHBlY3RlZDtcbiAgICB9XG4gICAgaWYgKGFjdHVhbFZhbHVlcy5sZW5ndGggIT09IGV4cGVjdGVkVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcnJheXMgaGF2ZSBkaWZmZXJlbnQgbGVuZ3RocyBhY3R1YWw6IFwiICsgYWN0dWFsVmFsdWVzLmxlbmd0aCArIFwiIHZzIFwiICtcbiAgICAgICAgICAgIChcImV4cGVjdGVkOiBcIiArIGV4cGVjdGVkVmFsdWVzLmxlbmd0aCArIFwiLlxcblwiKSArXG4gICAgICAgICAgICAoXCJBY3R1YWw6ICAgXCIgKyBhY3R1YWxWYWx1ZXMgKyBcIi5cXG5cIikgK1xuICAgICAgICAgICAgKFwiRXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWRWYWx1ZXMgKyBcIi5cIikpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBhID0gYWN0dWFsVmFsdWVzW2ldO1xuICAgICAgICB2YXIgZSA9IGV4cGVjdGVkVmFsdWVzW2ldO1xuICAgICAgICBpZiAoIWFyZUNsb3NlKGEsIE51bWJlcihlKSwgZXBzaWxvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFycmF5cyBkaWZmZXI6IGFjdHVhbFtcIiArIGkgKyBcIl0gPSBcIiArIGEgKyBcIiwgZXhwZWN0ZWRbXCIgKyBpICsgXCJdID0gXCIgKyBlICsgXCIuXFxuXCIgK1xuICAgICAgICAgICAgICAgIChcIkFjdHVhbDogICBcIiArIGFjdHVhbFZhbHVlcyArIFwiLlxcblwiKSArXG4gICAgICAgICAgICAgICAgKFwiRXhwZWN0ZWQ6IFwiICsgZXhwZWN0ZWRWYWx1ZXMgKyBcIi5cIikpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5leHBlY3RBcnJheXNDbG9zZSA9IGV4cGVjdEFycmF5c0Nsb3NlO1xuZnVuY3Rpb24gZXhwZWN0QXJyYXlzRXF1YWwoYWN0dWFsLCBleHBlY3RlZCkge1xuICAgIHJldHVybiBleHBlY3RBcnJheXNDbG9zZShhY3R1YWwsIGV4cGVjdGVkLCAwKTtcbn1cbmV4cG9ydHMuZXhwZWN0QXJyYXlzRXF1YWwgPSBleHBlY3RBcnJheXNFcXVhbDtcbmZ1bmN0aW9uIGV4cGVjdE51bWJlcnNDbG9zZShhLCBlLCBlcHNpbG9uKSB7XG4gICAgaWYgKGVwc2lsb24gPT09IHZvaWQgMCkgeyBlcHNpbG9uID0gZXhwb3J0cy5URVNUX0VQU0lMT047IH1cbiAgICBpZiAoIWFyZUNsb3NlKGEsIGUsIGVwc2lsb24pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk51bWJlcnMgZGlmZmVyOiBhY3R1YWwgPT09IFwiICsgYSArIFwiLCBleHBlY3RlZCA9PT0gXCIgKyBlKTtcbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdE51bWJlcnNDbG9zZSA9IGV4cGVjdE51bWJlcnNDbG9zZTtcbmZ1bmN0aW9uIGFyZUNsb3NlKGEsIGUsIGVwc2lsb24pIHtcbiAgICBpZiAoaXNOYU4oYSkgJiYgaXNOYU4oZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChpc05hTihhKSB8fCBpc05hTihlKSB8fCBNYXRoLmFicyhhIC0gZSkgPiBlcHNpbG9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBleHBlY3RWYWx1ZXNJblJhbmdlKGFjdHVhbCwgbG93LCBoaWdoKSB7XG4gICAgdmFyIGFjdHVhbFZhbHM7XG4gICAgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIHRlbnNvcl8xLlRlbnNvcikge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsLmRhdGFTeW5jKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhY3R1YWxWYWxzID0gYWN0dWFsO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdHVhbFZhbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFjdHVhbFZhbHNbaV0gPCBsb3cgfHwgYWN0dWFsVmFsc1tpXSA+IGhpZ2gpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIG91dCBvZiByYW5nZTpcIiArIGFjdHVhbFZhbHNbaV0gKyBcIiBsb3c6IFwiICsgbG93ICsgXCIsIGhpZ2g6IFwiICsgaGlnaCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmV4cGVjdFZhbHVlc0luUmFuZ2UgPSBleHBlY3RWYWx1ZXNJblJhbmdlO1xuZnVuY3Rpb24gZGVzY3JpYmVXaXRoRmxhZ3MobmFtZSwgZmVhdHVyZXNMaXN0LCB0ZXN0cykge1xuICAgIGZlYXR1cmVzTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICB2YXIgdGVzdE5hbWUgPSBuYW1lICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoZmVhdHVyZXMpO1xuICAgICAgICBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcyk7XG4gICAgfSk7XG59XG5leHBvcnRzLmRlc2NyaWJlV2l0aEZsYWdzID0gZGVzY3JpYmVXaXRoRmxhZ3M7XG5mdW5jdGlvbiBleGVjdXRlVGVzdHModGVzdE5hbWUsIHRlc3RzLCBmZWF0dXJlcykge1xuICAgIGRlc2NyaWJlKHRlc3ROYW1lLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJlZm9yZUVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuc2V0RmVhdHVyZXMoZmVhdHVyZXMgfHwge30pO1xuICAgICAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuYWRkQ3VzdG9tQmFja2VuZCgnd2ViZ2wnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgYmFja2VuZF93ZWJnbF8xLk1hdGhCYWNrZW5kV2ViR0woKTsgfSk7XG4gICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5hZGRDdXN0b21CYWNrZW5kKCdjcHUnLCBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgYmFja2VuZF9jcHVfMS5NYXRoQmFja2VuZENQVSgpOyB9KTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlcyAmJiBmZWF0dXJlcy5CQUNLRU5EICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVudmlyb25tZW50LnNldEJhY2tlbmQoZmVhdHVyZXMuQkFDS0VORCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbnZpcm9ubWVudF8xLkVOVi5lbmdpbmUuc3RhcnRTY29wZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWZ0ZXJFYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5lbmRTY29wZShudWxsKTtcbiAgICAgICAgICAgIGVudmlyb25tZW50XzEuRU5WLnJlc2V0KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0ZXN0cygpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYXNzZXJ0SXNOYW4odmFsLCBkdHlwZSkge1xuICAgIGlmICghdXRpbC5pc1ZhbE5hTih2YWwsIGR0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBcIiArIHZhbCArIFwiIGRvZXMgbm90IHJlcHJlc2VudCBOYU4gZm9yIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuYXNzZXJ0SXNOYW4gPSBhc3NlcnRJc05hbjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGRvY18xID0gcmVxdWlyZShcIi4vZG9jXCIpO1xudmFyIGVudmlyb25tZW50XzEgPSByZXF1aXJlKFwiLi9lbnZpcm9ubWVudFwiKTtcbnZhciB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xudmFyIFRyYWNraW5nID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUcmFja2luZygpIHtcbiAgICB9XG4gICAgVHJhY2tpbmcudGlkeSA9IGZ1bmN0aW9uIChuYW1lT3JGbiwgZm4sIGdyYWRNb2RlKSB7XG4gICAgICAgIGlmIChncmFkTW9kZSA9PT0gdm9pZCAwKSB7IGdyYWRNb2RlID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIG5hbWUgPSBudWxsO1xuICAgICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lT3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgYSBmdW5jdGlvbiB0byBkbC50aWR5KCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZuID0gbmFtZU9yRm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5hbWVPckZuICE9PSAnc3RyaW5nJyAmJiAhKG5hbWVPckZuIGluc3RhbmNlb2YgU3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2hlbiBjYWxsaW5nIHdpdGggdHdvIGFyZ3VtZW50cywgdGhlIGZpcnN0IGFyZ3VtZW50ICcgK1xuICAgICAgICAgICAgICAgICAgICAndG8gZGwudGlkeSgpIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gY2FsbGluZyB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSAybmQgYXJndW1lbnQgJyArXG4gICAgICAgICAgICAgICAgICAgICd0byBkbC50aWR5KCkgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYW1lID0gbmFtZU9yRm47XG4gICAgICAgIH1cbiAgICAgICAgZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnN0YXJ0U2NvcGUobmFtZSwgZ3JhZE1vZGUpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZm4oKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignUmV0dXJuaW5nIGEgcHJvbWlzZSBpbnNpZGUgb2YgdGlkeSBpcyBkYW5nZXJvdXMuICcgK1xuICAgICAgICAgICAgICAgICdUaGlzIHdpbGwgYmUgYSBydW4tdGltZSBlcnJvciBpbiAwLjYuMCcpO1xuICAgICAgICB9XG4gICAgICAgIGVudmlyb25tZW50XzEuRU5WLmVuZ2luZS5lbmRTY29wZShyZXN1bHQsIGdyYWRNb2RlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFRyYWNraW5nLmRpc3Bvc2UgPSBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICAgIHZhciB0ZW5zb3JzID0gdXRpbF8xLmV4dHJhY3RUZW5zb3JzRnJvbUFueShjb250YWluZXIpO1xuICAgICAgICB0ZW5zb3JzLmZvckVhY2goZnVuY3Rpb24gKHRlbnNvcikgeyByZXR1cm4gdGVuc29yLmRpc3Bvc2UoKTsgfSk7XG4gICAgfTtcbiAgICBUcmFja2luZy5rZWVwID0gZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLmtlZXAocmVzdWx0KTtcbiAgICB9O1xuICAgIFRyYWNraW5nLnRpbWUgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gZW52aXJvbm1lbnRfMS5FTlYuZW5naW5lLnRpbWUoZik7XG4gICAgfTtcbiAgICBfX2RlY29yYXRlKFtcbiAgICAgICAgZG9jXzEuZG9jKHsgaGVhZGluZzogJ1BlcmZvcm1hbmNlJywgc3ViaGVhZGluZzogJ01lbW9yeScgfSlcbiAgICBdLCBUcmFja2luZywgXCJ0aWR5XCIsIG51bGwpO1xuICAgIF9fZGVjb3JhdGUoW1xuICAgICAgICBkb2NfMS5kb2MoeyBoZWFkaW5nOiAnUGVyZm9ybWFuY2UnLCBzdWJoZWFkaW5nOiAnTWVtb3J5JyB9KVxuICAgIF0sIFRyYWNraW5nLCBcImtlZXBcIiwgbnVsbCk7XG4gICAgX19kZWNvcmF0ZShbXG4gICAgICAgIGRvY18xLmRvYyh7IGhlYWRpbmc6ICdQZXJmb3JtYW5jZScsIHN1YmhlYWRpbmc6ICdUaW1pbmcnIH0pXG4gICAgXSwgVHJhY2tpbmcsIFwidGltZVwiLCBudWxsKTtcbiAgICByZXR1cm4gVHJhY2tpbmc7XG59KCkpO1xuZXhwb3J0cy5UcmFja2luZyA9IFRyYWNraW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYWRhZGVsdGFfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYWRlbHRhX29wdGltaXplclwiKTtcbnZhciBhZGFncmFkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFncmFkX29wdGltaXplclwiKTtcbnZhciBhZGFtX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9hZGFtX29wdGltaXplclwiKTtcbnZhciBhZGFtYXhfb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL2FkYW1heF9vcHRpbWl6ZXJcIik7XG52YXIgbW9tZW50dW1fb3B0aW1pemVyXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL21vbWVudHVtX29wdGltaXplclwiKTtcbnZhciBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEgPSByZXF1aXJlKFwiLi9vcHRpbWl6ZXJzL29wdGltaXplcl9jb25zdHJ1Y3RvcnNcIik7XG52YXIgcm1zcHJvcF9vcHRpbWl6ZXJfMSA9IHJlcXVpcmUoXCIuL29wdGltaXplcnMvcm1zcHJvcF9vcHRpbWl6ZXJcIik7XG52YXIgc2dkX29wdGltaXplcl8xID0gcmVxdWlyZShcIi4vb3B0aW1pemVycy9zZ2Rfb3B0aW1pemVyXCIpO1xuW21vbWVudHVtX29wdGltaXplcl8xLk1vbWVudHVtT3B0aW1pemVyLCBzZ2Rfb3B0aW1pemVyXzEuU0dET3B0aW1pemVyLCBhZGFkZWx0YV9vcHRpbWl6ZXJfMS5BZGFkZWx0YU9wdGltaXplciwgYWRhZ3JhZF9vcHRpbWl6ZXJfMS5BZGFncmFkT3B0aW1pemVyLFxuICAgIHJtc3Byb3Bfb3B0aW1pemVyXzEuUk1TUHJvcE9wdGltaXplciwgYWRhbWF4X29wdGltaXplcl8xLkFkYW1heE9wdGltaXplciwgYWRhbV9vcHRpbWl6ZXJfMS5BZGFtT3B0aW1pemVyXTtcbmV4cG9ydHMudHJhaW4gPSB7XG4gICAgc2dkOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLnNnZCxcbiAgICBtb21lbnR1bTogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5tb21lbnR1bSxcbiAgICBhZGFkZWx0YTogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFkZWx0YSxcbiAgICBhZGFncmFkOiBvcHRpbWl6ZXJfY29uc3RydWN0b3JzXzEuT3B0aW1pemVyQ29uc3RydWN0b3JzLmFkYWdyYWQsXG4gICAgcm1zcHJvcDogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5ybXNwcm9wLFxuICAgIGFkYW1heDogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtYXgsXG4gICAgYWRhbTogb3B0aW1pemVyX2NvbnN0cnVjdG9yc18xLk9wdGltaXplckNvbnN0cnVjdG9ycy5hZGFtXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgRFR5cGU7XG4oZnVuY3Rpb24gKERUeXBlKSB7XG4gICAgRFR5cGVbXCJmbG9hdDMyXCJdID0gXCJmbG9hdDMyXCI7XG4gICAgRFR5cGVbXCJpbnQzMlwiXSA9IFwiaW50MzJcIjtcbiAgICBEVHlwZVtcImJvb2xcIl0gPSBcImJvb2xcIjtcbn0pKERUeXBlID0gZXhwb3J0cy5EVHlwZSB8fCAoZXhwb3J0cy5EVHlwZSA9IHt9KSk7XG52YXIgUmFuaztcbihmdW5jdGlvbiAoUmFuaykge1xuICAgIFJhbmtbXCJSMFwiXSA9IFwiUjBcIjtcbiAgICBSYW5rW1wiUjFcIl0gPSBcIlIxXCI7XG4gICAgUmFua1tcIlIyXCJdID0gXCJSMlwiO1xuICAgIFJhbmtbXCJSM1wiXSA9IFwiUjNcIjtcbiAgICBSYW5rW1wiUjRcIl0gPSBcIlI0XCI7XG59KShSYW5rID0gZXhwb3J0cy5SYW5rIHx8IChleHBvcnRzLlJhbmsgPSB7fSkpO1xudmFyIFVwY2FzdEludDMyQW5kTWFwO1xuKGZ1bmN0aW9uIChVcGNhc3RJbnQzMkFuZE1hcCkge1xuICAgIFVwY2FzdEludDMyQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEludDMyQW5kTWFwW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgVXBjYXN0SW50MzJBbmRNYXBbXCJib29sXCJdID0gXCJpbnQzMlwiO1xufSkoVXBjYXN0SW50MzJBbmRNYXAgfHwgKFVwY2FzdEludDMyQW5kTWFwID0ge30pKTtcbnZhciBVcGNhc3RCb29sQW5kTWFwO1xuKGZ1bmN0aW9uIChVcGNhc3RCb29sQW5kTWFwKSB7XG4gICAgVXBjYXN0Qm9vbEFuZE1hcFtcImZsb2F0MzJcIl0gPSBcImZsb2F0MzJcIjtcbiAgICBVcGNhc3RCb29sQW5kTWFwW1wiaW50MzJcIl0gPSBcImludDMyXCI7XG4gICAgVXBjYXN0Qm9vbEFuZE1hcFtcImJvb2xcIl0gPSBcImJvb2xcIjtcbn0pKFVwY2FzdEJvb2xBbmRNYXAgfHwgKFVwY2FzdEJvb2xBbmRNYXAgPSB7fSkpO1xudmFyIFVwY2FzdEZsb2F0MzJBbmRNYXA7XG4oZnVuY3Rpb24gKFVwY2FzdEZsb2F0MzJBbmRNYXApIHtcbiAgICBVcGNhc3RGbG9hdDMyQW5kTWFwW1wiZmxvYXQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJpbnQzMlwiXSA9IFwiZmxvYXQzMlwiO1xuICAgIFVwY2FzdEZsb2F0MzJBbmRNYXBbXCJib29sXCJdID0gXCJmbG9hdDMyXCI7XG59KShVcGNhc3RGbG9hdDMyQW5kTWFwIHx8IChVcGNhc3RGbG9hdDMyQW5kTWFwID0ge30pKTtcbnZhciB1cGNhc3RUeXBlTWFwID0ge1xuICAgIGZsb2F0MzI6IFVwY2FzdEZsb2F0MzJBbmRNYXAsXG4gICAgaW50MzI6IFVwY2FzdEludDMyQW5kTWFwLFxuICAgIGJvb2w6IFVwY2FzdEJvb2xBbmRNYXBcbn07XG5mdW5jdGlvbiB1cGNhc3RUeXBlKHR5cGVBLCB0eXBlQikge1xuICAgIHJldHVybiB1cGNhc3RUeXBlTWFwW3R5cGVBXVt0eXBlQl07XG59XG5leHBvcnRzLnVwY2FzdFR5cGUgPSB1cGNhc3RUeXBlO1xuZnVuY3Rpb24gc3VtT3V0VHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIHVwY2FzdFR5cGUodHlwZSwgJ2ludDMyJyk7XG59XG5leHBvcnRzLnN1bU91dFR5cGUgPSBzdW1PdXRUeXBlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdGVuc29yXzEgPSByZXF1aXJlKFwiLi90ZW5zb3JcIik7XG5mdW5jdGlvbiBzaHVmZmxlKGFycmF5KSB7XG4gICAgdmFyIGNvdW50ZXIgPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIHRlbXAgPSAwO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGNvdW50ZXIgPiAwKSB7XG4gICAgICAgIGluZGV4ID0gKE1hdGgucmFuZG9tKCkgKiBjb3VudGVyKSB8IDA7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgdGVtcCA9IGFycmF5W2NvdW50ZXJdO1xuICAgICAgICBhcnJheVtjb3VudGVyXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdGVtcDtcbiAgICB9XG59XG5leHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuZnVuY3Rpb24gY2xhbXAobWluLCB4LCBtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbih4LCBtYXgpKTtcbn1cbmV4cG9ydHMuY2xhbXAgPSBjbGFtcDtcbmZ1bmN0aW9uIHJhbmRVbmlmb3JtKGEsIGIpIHtcbiAgICByZXR1cm4gTWF0aC5yYW5kb20oKSAqIChiIC0gYSkgKyBhO1xufVxuZXhwb3J0cy5yYW5kVW5pZm9ybSA9IHJhbmRVbmlmb3JtO1xuZnVuY3Rpb24gZGlzdFNxdWFyZWQoYSwgYikge1xuICAgIHZhciByZXN1bHQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlmZiA9IE51bWJlcihhW2ldKSAtIE51bWJlcihiW2ldKTtcbiAgICAgICAgcmVzdWx0ICs9IGRpZmYgKiBkaWZmO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kaXN0U3F1YXJlZCA9IGRpc3RTcXVhcmVkO1xuZnVuY3Rpb24gYXNzZXJ0KGV4cHIsIG1zZykge1xuICAgIGlmICghZXhwcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmZ1bmN0aW9uIGFzc2VydFNoYXBlc01hdGNoKHNoYXBlQSwgc2hhcGVCLCBlcnJvck1lc3NhZ2VQcmVmaXgpIHtcbiAgICBpZiAoZXJyb3JNZXNzYWdlUHJlZml4ID09PSB2b2lkIDApIHsgZXJyb3JNZXNzYWdlUHJlZml4ID0gJyc7IH1cbiAgICBhc3NlcnQoYXJyYXlzRXF1YWwoc2hhcGVBLCBzaGFwZUIpLCBlcnJvck1lc3NhZ2VQcmVmaXggKyAoXCJTaGFwZXMgXCIgKyBzaGFwZUEgKyBcIiBhbmQgXCIgKyBzaGFwZUIgKyBcIiBtdXN0IG1hdGNoXCIpKTtcbn1cbmV4cG9ydHMuYXNzZXJ0U2hhcGVzTWF0Y2ggPSBhc3NlcnRTaGFwZXNNYXRjaDtcbmZ1bmN0aW9uIGFzc2VydFR5cGVzTWF0Y2goYSwgYikge1xuICAgIGFzc2VydChhLmR0eXBlID09PSBiLmR0eXBlLCBcIlRoZSBkdHlwZXMgb2YgdGhlIGZpcnN0IChcIiArIGEuZHR5cGUgKyBcIikgYW5kIFwiICtcbiAgICAgICAgKFwic2Vjb25kIChcIiArIGIuZHR5cGUgKyBcIikgaW5wdXQgbXVzdCBtYXRjaFwiKSk7XG59XG5leHBvcnRzLmFzc2VydFR5cGVzTWF0Y2ggPSBhc3NlcnRUeXBlc01hdGNoO1xuZnVuY3Rpb24gZmxhdHRlbihhcnIsIHJldCkge1xuICAgIGlmIChyZXQgPT09IHZvaWQgMCkgeyByZXQgPSBbXTsgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGZsYXR0ZW4oYXJyW2ldLCByZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXQucHVzaChhcnIpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xufVxuZXhwb3J0cy5mbGF0dGVuID0gZmxhdHRlbjtcbmZ1bmN0aW9uIGluZmVyU2hhcGUodmFsKSB7XG4gICAgaWYgKGlzVHlwZWRBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBbdmFsLmxlbmd0aF07XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIHNoYXBlID0gW107XG4gICAgd2hpbGUgKHZhbCBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgIHNoYXBlLnB1c2godmFsLmxlbmd0aCk7XG4gICAgICAgIHZhbCA9IHZhbFswXTtcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xufVxuZXhwb3J0cy5pbmZlclNoYXBlID0gaW5mZXJTaGFwZTtcbmZ1bmN0aW9uIHNpemVGcm9tU2hhcGUoc2hhcGUpIHtcbiAgICBpZiAoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IHNoYXBlWzBdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2hhcGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc2l6ZSAqPSBzaGFwZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5leHBvcnRzLnNpemVGcm9tU2hhcGUgPSBzaXplRnJvbVNoYXBlO1xuZnVuY3Rpb24gaXNTY2FsYXJTaGFwZShzaGFwZSkge1xuICAgIHJldHVybiBzaGFwZS5sZW5ndGggPT09IDA7XG59XG5leHBvcnRzLmlzU2NhbGFyU2hhcGUgPSBpc1NjYWxhclNoYXBlO1xuZnVuY3Rpb24gYXJyYXlzRXF1YWwobjEsIG4yKSB7XG4gICAgaWYgKG4xLmxlbmd0aCAhPT0gbjIubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuMS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAobjFbaV0gIT09IG4yW2ldKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmFycmF5c0VxdWFsID0gYXJyYXlzRXF1YWw7XG5mdW5jdGlvbiBpc0ludChhKSB7XG4gICAgcmV0dXJuIGEgJSAxID09PSAwO1xufVxuZXhwb3J0cy5pc0ludCA9IGlzSW50O1xuZnVuY3Rpb24gdGFuaCh4KSB7XG4gICAgaWYgKE1hdGgudGFuaCAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnRhbmgoeCk7XG4gICAgfVxuICAgIGlmICh4ID09PSBJbmZpbml0eSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9XG4gICAgZWxzZSBpZiAoeCA9PT0gLUluZmluaXR5KSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZhciBlMnggPSBNYXRoLmV4cCgyICogeCk7XG4gICAgICAgIHJldHVybiAoZTJ4IC0gMSkgLyAoZTJ4ICsgMSk7XG4gICAgfVxufVxuZXhwb3J0cy50YW5oID0gdGFuaDtcbmZ1bmN0aW9uIHNpemVUb1NxdWFyaXNoU2hhcGUoc2l6ZSkge1xuICAgIGZvciAodmFyIGEgPSBNYXRoLmZsb29yKE1hdGguc3FydChzaXplKSk7IGEgPiAxOyAtLWEpIHtcbiAgICAgICAgaWYgKHNpemUgJSBhID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gW2EsIHNpemUgLyBhXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gWzEsIHNpemVdO1xufVxuZXhwb3J0cy5zaXplVG9TcXVhcmlzaFNoYXBlID0gc2l6ZVRvU3F1YXJpc2hTaGFwZTtcbmZ1bmN0aW9uIGNyZWF0ZVNodWZmbGVkSW5kaWNlcyhuKSB7XG4gICAgdmFyIHNodWZmbGVkSW5kaWNlcyA9IG5ldyBVaW50MzJBcnJheShuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgICBzaHVmZmxlZEluZGljZXNbaV0gPSBpO1xuICAgIH1cbiAgICBzaHVmZmxlKHNodWZmbGVkSW5kaWNlcyk7XG4gICAgcmV0dXJuIHNodWZmbGVkSW5kaWNlcztcbn1cbmV4cG9ydHMuY3JlYXRlU2h1ZmZsZWRJbmRpY2VzID0gY3JlYXRlU2h1ZmZsZWRJbmRpY2VzO1xuZnVuY3Rpb24gcmlnaHRQYWQoYSwgc2l6ZSkge1xuICAgIGlmIChzaXplIDw9IGEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBhO1xuICAgIH1cbiAgICByZXR1cm4gYSArICcgJy5yZXBlYXQoc2l6ZSAtIGEubGVuZ3RoKTtcbn1cbmV4cG9ydHMucmlnaHRQYWQgPSByaWdodFBhZDtcbmZ1bmN0aW9uIHJlcGVhdGVkVHJ5KGNoZWNrRm4sIGRlbGF5Rm4sIG1heENvdW50ZXIpIHtcbiAgICBpZiAoZGVsYXlGbiA9PT0gdm9pZCAwKSB7IGRlbGF5Rm4gPSBmdW5jdGlvbiAoY291bnRlcikgeyByZXR1cm4gMDsgfTsgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciB0cnlDb3VudCA9IDA7XG4gICAgICAgIHZhciB0cnlGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChjaGVja0ZuKCkpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5Q291bnQrKztcbiAgICAgICAgICAgIHZhciBuZXh0QmFja29mZiA9IGRlbGF5Rm4odHJ5Q291bnQpO1xuICAgICAgICAgICAgaWYgKG1heENvdW50ZXIgIT0gbnVsbCAmJiB0cnlDb3VudCA+PSBtYXhDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dCh0cnlGbiwgbmV4dEJhY2tvZmYpO1xuICAgICAgICB9O1xuICAgICAgICBzZXRUaW1lb3V0KHRyeUZuLCAwKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucmVwZWF0ZWRUcnkgPSByZXBlYXRlZFRyeTtcbmZ1bmN0aW9uIGdldFF1ZXJ5UGFyYW1zKHF1ZXJ5U3RyaW5nKSB7XG4gICAgdmFyIHBhcmFtcyA9IHt9O1xuICAgIHF1ZXJ5U3RyaW5nLnJlcGxhY2UoL1s/Jl0oW149PyZdKykoPzo9KFteJl0qKSk/L2csIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgIHZhciB0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB0W19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGRlY29kZVBhcmFtKHBhcmFtcywgdFswXSwgdFsxXSk7XG4gICAgICAgIHJldHVybiB0LmpvaW4oJz0nKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZXhwb3J0cy5nZXRRdWVyeVBhcmFtcyA9IGdldFF1ZXJ5UGFyYW1zO1xuZnVuY3Rpb24gZGVjb2RlUGFyYW0ocGFyYW1zLCBuYW1lLCB2YWx1ZSkge1xuICAgIHBhcmFtc1tkZWNvZGVVUklDb21wb25lbnQobmFtZSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlIHx8ICcnKTtcbn1cbmZ1bmN0aW9uIGluZmVyRnJvbUltcGxpY2l0U2hhcGUoc2hhcGUsIHNpemUpIHtcbiAgICB2YXIgc2hhcGVQcm9kID0gMTtcbiAgICB2YXIgaW1wbGljaXRJZHggPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChzaGFwZVtpXSA+IDApIHtcbiAgICAgICAgICAgIHNoYXBlUHJvZCAqPSBzaGFwZVtpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzaGFwZVtpXSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGlmIChpbXBsaWNpdElkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNoYXBlcyBjYW4gb25seSBoYXZlIDEgaW1wbGljaXQgc2l6ZS4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAoXCJGb3VuZCAtMSBhdCBkaW0gXCIgKyBpbXBsaWNpdElkeCArIFwiIGFuZCBkaW0gXCIgKyBpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbXBsaWNpdElkeCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hhcGVbaV0gPD0gMCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJTaGFwZXMgY2FuIG5vdCBiZSA8PSAwLiBGb3VuZCBcIiArIHNoYXBlW2ldICsgXCIgYXQgZGltIFwiICsgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGltcGxpY2l0SWR4ID09PSAtMSkge1xuICAgICAgICBpZiAoc2l6ZSA+IDAgJiYgc2l6ZSAhPT0gc2hhcGVQcm9kKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlNpemUgKFwiICsgc2l6ZSArIFwiKSBtdXN0IG1hdGNoIHRoZSBwcm9kdWN0IG9mIHNoYXBlIFwiICsgc2hhcGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFwZTtcbiAgICB9XG4gICAgaWYgKHNpemUgJSBzaGFwZVByb2QgIT09IDApIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgaW1wbGljaXQgc2hhcGUgY2FuJ3QgYmUgYSBmcmFjdGlvbmFsIG51bWJlci4gXCIgK1xuICAgICAgICAgICAgKFwiR290IFwiICsgc2l6ZSArIFwiIC8gXCIgKyBzaGFwZVByb2QpKTtcbiAgICB9XG4gICAgdmFyIG5ld1NoYXBlID0gc2hhcGUuc2xpY2UoKTtcbiAgICBuZXdTaGFwZVtpbXBsaWNpdElkeF0gPSBzaXplIC8gc2hhcGVQcm9kO1xuICAgIHJldHVybiBuZXdTaGFwZTtcbn1cbmV4cG9ydHMuaW5mZXJGcm9tSW1wbGljaXRTaGFwZSA9IGluZmVyRnJvbUltcGxpY2l0U2hhcGU7XG5leHBvcnRzLk5BTl9JTlQzMiA9IDEgPDwgMzE7XG5leHBvcnRzLk5BTl9CT09MID0gMjU1O1xuZXhwb3J0cy5OQU5fRkxPQVQzMiA9IE5hTjtcbmZ1bmN0aW9uIGdldE5hTihkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLk5BTl9GTE9BVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2ludDMyJykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5OQU5fSU5UMzI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMuTkFOX0JPT0w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2V0TmFOID0gZ2V0TmFOO1xuZnVuY3Rpb24gaXNWYWxOYU4odmFsLCBkdHlwZSkge1xuICAgIGlmIChpc05hTih2YWwpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IGV4cG9ydHMuTkFOX0lOVDMyO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09IGV4cG9ydHMuTkFOX0JPT0w7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGR0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuaXNWYWxOYU4gPSBpc1ZhbE5hTjtcbmZ1bmN0aW9uIHNxdWVlemVTaGFwZShzaGFwZSwgYXhpcykge1xuICAgIHZhciBuZXdTaGFwZSA9IFtdO1xuICAgIHZhciBrZXB0RGltcyA9IFtdO1xuICAgIHZhciBqID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChheGlzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChheGlzW2pdID09PSBpICYmIHNoYXBlW2ldID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHNxdWVlemUgYXhpcyBcIiArIGkgKyBcIiBzaW5jZSBpdHMgZGltICdcIiArIHNoYXBlW2ldICsgXCInIGlzIG5vdCAxXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChheGlzW2pdID09IG51bGwgfHwgYXhpc1tqXSA+IGkpICYmIHNoYXBlW2ldID09PSAxKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICAgICAga2VwdERpbXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChheGlzW2pdIDw9IGkpIHtcbiAgICAgICAgICAgICAgICBqKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlW2ldID4gMSkge1xuICAgICAgICAgICAgbmV3U2hhcGUucHVzaChzaGFwZVtpXSk7XG4gICAgICAgICAgICBrZXB0RGltcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IG5ld1NoYXBlOiBuZXdTaGFwZSwga2VwdERpbXM6IGtlcHREaW1zIH07XG59XG5leHBvcnRzLnNxdWVlemVTaGFwZSA9IHNxdWVlemVTaGFwZTtcbmZ1bmN0aW9uIGdldFR5cGVkQXJyYXlGcm9tRFR5cGUoZHR5cGUsIHNpemUpIHtcbiAgICB2YXIgdmFsdWVzID0gbnVsbDtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoc2l6ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBJbnQzMkFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHZhbHVlcyA9IG5ldyBVaW50OEFycmF5KHNpemUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkYXRhIHR5cGUgXCIgKyBkdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnRzLmdldFR5cGVkQXJyYXlGcm9tRFR5cGUgPSBnZXRUeXBlZEFycmF5RnJvbURUeXBlO1xuZnVuY3Rpb24gaXNUZW5zb3JJbkxpc3QodGVuc29yLCB0ZW5zb3JMaXN0KSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0ZW5zb3JMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh0ZW5zb3JMaXN0W2ldLmlkID09PSB0ZW5zb3IuaWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaXNUZW5zb3JJbkxpc3QgPSBpc1RlbnNvckluTGlzdDtcbmZ1bmN0aW9uIGNoZWNrRm9yTmFOKHZhbHMsIGR0eXBlLCBuYW1lKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWxzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc1ZhbE5hTih2YWxzW2ldLCBkdHlwZSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHJlc3VsdCBvZiB0aGUgJ1wiICsgbmFtZSArIFwiJyBoYXMgTmFOcy5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmNoZWNrRm9yTmFOID0gY2hlY2tGb3JOYU47XG5mdW5jdGlvbiBmbGF0dGVuTmFtZUFycmF5TWFwKG5hbWVBcnJheU1hcCwga2V5cykge1xuICAgIHZhciB4cyA9IFtdO1xuICAgIGlmIChuYW1lQXJyYXlNYXAgaW5zdGFuY2VvZiB0ZW5zb3JfMS5UZW5zb3IpIHtcbiAgICAgICAgeHMucHVzaChuYW1lQXJyYXlNYXApO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHhNYXAgPSBuYW1lQXJyYXlNYXA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgeHMucHVzaCh4TWFwW2tleXNbaV1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geHM7XG59XG5leHBvcnRzLmZsYXR0ZW5OYW1lQXJyYXlNYXAgPSBmbGF0dGVuTmFtZUFycmF5TWFwO1xuZnVuY3Rpb24gdW5mbGF0dGVuVG9OYW1lQXJyYXlNYXAoa2V5cywgZmxhdEFycmF5cykge1xuICAgIGlmIChrZXlzLmxlbmd0aCAhPT0gZmxhdEFycmF5cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVuZmxhdHRlbiBUZW5zb3JbXSwga2V5cyBhbmQgYXJyYXlzIGFyZSBub3Qgb2Ygc2FtZSBsZW5ndGguXCIpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtrZXlzW2ldXSA9IGZsYXRBcnJheXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLnVuZmxhdHRlblRvTmFtZUFycmF5TWFwID0gdW5mbGF0dGVuVG9OYW1lQXJyYXlNYXA7XG5mdW5jdGlvbiBoYXNFbmNvZGluZ0xvc3Mob2xkVHlwZSwgbmV3VHlwZSkge1xuICAgIGlmIChuZXdUeXBlID09PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobmV3VHlwZSA9PT0gJ2ludDMyJyAmJiBvbGRUeXBlICE9PSAnZmxvYXQzMicpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAobmV3VHlwZSA9PT0gJ2Jvb2wnICYmIG9sZFR5cGUgPT09ICdib29sJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5oYXNFbmNvZGluZ0xvc3MgPSBoYXNFbmNvZGluZ0xvc3M7XG5mdW5jdGlvbiBjb3B5VHlwZWRBcnJheShhcnJheSwgZHR5cGUpIHtcbiAgICBpZiAoZHR5cGUgPT0gbnVsbCB8fCBkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGFycmF5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBuZXcgSW50MzJBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChpc1ZhbE5hTih2YWwsICdpbnQzMicpKSB7XG4gICAgICAgICAgICAgICAgdmFsc1tpXSA9IGdldE5hTignaW50MzInKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHNbaV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHM7XG4gICAgfVxuICAgIGVsc2UgaWYgKGR0eXBlID09PSAnYm9vbCcpIHtcbiAgICAgICAgdmFyIGJvb2wgPSBuZXcgVWludDhBcnJheShhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2wubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBhcnJheVtpXTtcbiAgICAgICAgICAgIGlmIChpc1ZhbE5hTih2YWwsICdib29sJykpIHtcbiAgICAgICAgICAgICAgICBib29sW2ldID0gZ2V0TmFOKCdib29sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChNYXRoLnJvdW5kKHZhbCkgIT09IDApIHtcbiAgICAgICAgICAgICAgICBib29sW2ldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm9vbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gZGF0YSB0eXBlIFwiICsgZHR5cGUpO1xuICAgIH1cbn1cbmV4cG9ydHMuY29weVR5cGVkQXJyYXkgPSBjb3B5VHlwZWRBcnJheTtcbmZ1bmN0aW9uIGlzVHlwZWRBcnJheShhKSB7XG4gICAgcmV0dXJuIGEgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHwgYSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcbiAgICAgICAgYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG59XG5leHBvcnRzLmlzVHlwZWRBcnJheSA9IGlzVHlwZWRBcnJheTtcbmZ1bmN0aW9uIGJ5dGVzUGVyRWxlbWVudChkdHlwZSkge1xuICAgIGlmIChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnaW50MzInKSB7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbiAgICBlbHNlIGlmIChkdHlwZSA9PT0gJ2Jvb2wnKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkdHlwZSBcIiArIGR0eXBlKTtcbiAgICB9XG59XG5leHBvcnRzLmJ5dGVzUGVyRWxlbWVudCA9IGJ5dGVzUGVyRWxlbWVudDtcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oZikge1xuICAgIHJldHVybiAhIShmICYmIGYuY29uc3RydWN0b3IgJiYgZi5jYWxsICYmIGYuYXBwbHkpO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmZ1bmN0aW9uIGV4dHJhY3RUZW5zb3JzRnJvbUNvbnRhaW5lcihyZXN1bHQpIHtcbiAgICByZXR1cm4gZXh0cmFjdFRlbnNvcnNGcm9tQW55KHJlc3VsdCk7XG59XG5leHBvcnRzLmV4dHJhY3RUZW5zb3JzRnJvbUNvbnRhaW5lciA9IGV4dHJhY3RUZW5zb3JzRnJvbUNvbnRhaW5lcjtcbmZ1bmN0aW9uIGV4dHJhY3RUZW5zb3JzRnJvbUFueShyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0XTtcbiAgICB9XG4gICAgdmFyIGxpc3QgPSBbXTtcbiAgICB2YXIgcmVzdWx0T2JqID0gcmVzdWx0O1xuICAgIGlmICghaXNJdGVyYWJsZShyZXN1bHRPYmopKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgZm9yICh2YXIgayBpbiByZXN1bHRPYmopIHtcbiAgICAgICAgdmFyIHN1Ymxpc3QgPSBmbGF0dGVuKHJlc3VsdE9ialtrXSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4IGluc3RhbmNlb2YgdGVuc29yXzEuVGVuc29yOyB9KTtcbiAgICAgICAgbGlzdC5wdXNoLmFwcGx5KGxpc3QsIHN1Ymxpc3QpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbn1cbmV4cG9ydHMuZXh0cmFjdFRlbnNvcnNGcm9tQW55ID0gZXh0cmFjdFRlbnNvcnNGcm9tQW55O1xuZnVuY3Rpb24gaXNJdGVyYWJsZShvYmopIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShvYmopIHx8IHR5cGVvZiBvYmogPT09ICdvYmplY3QnO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdmVyc2lvbiA9ICcwLjUuMSc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbnZhciBfX2dlbmVyYXRvciA9ICh0aGlzICYmIHRoaXMuX19nZW5lcmF0b3IpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBib2R5KSB7XG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcbiAgICAgICAgd2hpbGUgKF8pIHRyeSB7XG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSB5W29wWzBdICYgMiA/IFwicmV0dXJuXCIgOiBvcFswXSA/IFwidGhyb3dcIiA6IFwibmV4dFwiXSkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBvcHNfMSA9IHJlcXVpcmUoXCIuL29wcy9vcHNcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG52YXIgRFRZUEVfVkFMVUVfU0laRV9NQVAgPSB7XG4gICAgJ2Zsb2F0MzInOiA0LFxuICAgICdpbnQzMic6IDRcbn07XG5mdW5jdGlvbiBsb2FkV2VpZ2h0cyhtYW5pZmVzdCwgZmlsZVBhdGhQcmVmaXgsIHdlaWdodE5hbWVzKSB7XG4gICAgaWYgKGZpbGVQYXRoUHJlZml4ID09PSB2b2lkIDApIHsgZmlsZVBhdGhQcmVmaXggPSAnJzsgfVxuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGdyb3VwSW5kaWNlc1RvRmV0Y2hNYXAsIGdyb3VwV2VpZ2h0c1RvRmV0Y2gsIHdlaWdodHNGb3VuZCwgYWxsTWFuaWZlc3RXZWlnaHROYW1lcywgd2VpZ2h0c05vdEZvdW5kLCBncm91cEluZGljZXNUb0ZldGNoLCByZXF1ZXN0cywgcmVzcG9uc2VzLCBidWZmZXJzLCB3ZWlnaHRzVGVuc29yTWFwLCBidWZmZXJJbmRleE9mZnNldDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcCA9IG1hbmlmZXN0Lm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGdyb3VwV2VpZ2h0c1RvRmV0Y2ggPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0ZvdW5kID0gd2VpZ2h0TmFtZXMgIT0gbnVsbCA/IHdlaWdodE5hbWVzLm1hcChmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfSkgOiBbXTtcbiAgICAgICAgICAgICAgICAgICAgYWxsTWFuaWZlc3RXZWlnaHROYW1lcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBtYW5pZmVzdC5mb3JFYWNoKGZ1bmN0aW9uIChtYW5pZmVzdEdyb3VwQ29uZmlnLCBncm91cEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RHcm91cENvbmZpZy53ZWlnaHRzLmZvckVhY2goZnVuY3Rpb24gKHdlaWdodHNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHRzQnl0ZXMgPSBEVFlQRV9WQUxVRV9TSVpFX01BUFt3ZWlnaHRzRW50cnkuZHR5cGVdICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXRpbC5zaXplRnJvbVNoYXBlKHdlaWdodHNFbnRyeS5zaGFwZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVucXVldWVXZWlnaHRzRm9yRmV0Y2hpbmdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcFtncm91cEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChncm91cFdlaWdodHNUb0ZldGNoW2dyb3VwSW5kZXhdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwV2VpZ2h0c1RvRmV0Y2hbZ3JvdXBJbmRleF0gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cFdlaWdodHNUb0ZldGNoW2dyb3VwSW5kZXhdLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFuaWZlc3RFbnRyeTogd2VpZ2h0c0VudHJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQ6IGdyb3VwT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZUJ5dGVzOiB3ZWlnaHRzQnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0TmFtZXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZWlnaHROYW1lcy5mb3JFYWNoKGZ1bmN0aW9uICh3ZWlnaHROYW1lLCB3ZWlnaHRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdlaWdodE5hbWUgPT09IHdlaWdodHNFbnRyeS5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVdlaWdodHNGb3JGZXRjaGluZ0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c0ZvdW5kW3dlaWdodEluZGV4XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5xdWV1ZVdlaWdodHNGb3JGZXRjaGluZ0ZuKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbE1hbmlmZXN0V2VpZ2h0TmFtZXMucHVzaCh3ZWlnaHRzRW50cnkubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ3JvdXBPZmZzZXQgKz0gd2VpZ2h0c0J5dGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXdlaWdodHNGb3VuZC5ldmVyeShmdW5jdGlvbiAoZm91bmQpIHsgcmV0dXJuIGZvdW5kOyB9KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c05vdEZvdW5kID0gd2VpZ2h0TmFtZXMuZmlsdGVyKGZ1bmN0aW9uICh3ZWlnaHQsIGkpIHsgcmV0dXJuICF3ZWlnaHRzRm91bmRbaV07IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGQgbm90IGZpbmQgd2VpZ2h0cyBpbiBtYW5pZmVzdCB3aXRoIG5hbWVzOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHdlaWdodHNOb3RGb3VuZC5qb2luKCcsICcpICsgXCIuIFxcblwiKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJNYW5pZmVzdCBKU09OIGhhcyB3ZWlnaHRzIHdpdGggbmFtZXM6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYWxsTWFuaWZlc3RXZWlnaHROYW1lcy5qb2luKCcsICcpICsgXCIuXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBncm91cEluZGljZXNUb0ZldGNoID0gZ3JvdXBJbmRpY2VzVG9GZXRjaE1hcC5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBzaG91bGRGZXRjaCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWNjdW11bGF0b3IucHVzaChpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgICAgICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBncm91cEluZGljZXNUb0ZldGNoLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hbmlmZXN0W2ldLnBhdGhzLmZvckVhY2goZnVuY3Rpb24gKGZpbGVwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZldGNoVXJsID0gZmlsZVBhdGhQcmVmaXggK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoIWZpbGVQYXRoUHJlZml4LmVuZHNXaXRoKCcvJykgPyAnLycgOiAnJykgKyBmaWxlcGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0cy5wdXNoKGZldGNoKGZldGNoVXJsKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCwgUHJvbWlzZS5hbGwocmVxdWVzdHMpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlcyA9IF9hLnNlbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBQcm9taXNlLmFsbChyZXNwb25zZXMubWFwKGZ1bmN0aW9uIChyZXNwb25zZSkgeyByZXR1cm4gcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTsgfSkpXTtcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHdlaWdodHNUZW5zb3JNYXAgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVySW5kZXhPZmZzZXQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBncm91cEluZGljZXNUb0ZldGNoLmZvckVhY2goZnVuY3Rpb24gKGkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBudW1CdWZmZXJzID0gbWFuaWZlc3RbaV0ucGF0aHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQnl0ZXMgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaV8xID0gMDsgaV8xIDwgbnVtQnVmZmVyczsgaV8xKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEJ5dGVzICs9IGJ1ZmZlcnNbYnVmZmVySW5kZXhPZmZzZXQgKyBpXzFdLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoZ3JvdXBCeXRlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZ3JvdXBCeXRlQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoZ3JvdXBCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGdyb3VwQnVmZmVyT2Zmc2V0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlfMiA9IDA7IGlfMiA8IG51bUJ1ZmZlcnM7IGlfMisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcnNbYnVmZmVySW5kZXhPZmZzZXQgKyBpXzJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBncm91cEJ5dGVCdWZmZXIuc2V0KGJ1ZmZlciwgZ3JvdXBCdWZmZXJPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdyb3VwQnVmZmVyT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdlaWdodHNFbnRyaWVzID0gZ3JvdXBXZWlnaHRzVG9GZXRjaFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlaWdodHNFbnRyaWVzLmZvckVhY2goZnVuY3Rpb24gKHdlaWdodHNFbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBieXRlQnVmZmVyID0gZ3JvdXBCdWZmZXIuc2xpY2Uod2VpZ2h0c0VudHJ5Lmdyb3VwT2Zmc2V0LCB3ZWlnaHRzRW50cnkuZ3JvdXBPZmZzZXQgKyB3ZWlnaHRzRW50cnkuc2l6ZUJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZWRBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkuZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IEZsb2F0MzJBcnJheShieXRlQnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAod2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkuZHR5cGUgPT09ICdpbnQzMicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBJbnQzMkFycmF5KGJ5dGVCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiV2VpZ2h0IFwiICsgd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkubmFtZSArIFwiIGhhcyB1bmtub3duIGR0eXBlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICh3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5kdHlwZSArIFwiLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB3ZWlnaHROYW1lID0gd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAod2VpZ2h0c1RlbnNvck1hcFt3ZWlnaHROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSB3ZWlnaHQgd2l0aCBuYW1lIFwiICsgd2VpZ2h0TmFtZSArIFwiLiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlBsZWFzZSBtYWtlIHN1cmUgd2VpZ2h0cyBuYW1lcyBhcmUgdW5pcXVlIGluIHRoZSBtYW5pZmVzdCBKU09OLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2VpZ2h0c1RlbnNvck1hcFt3ZWlnaHROYW1lXSA9IG9wc18xLnRlbnNvcih0eXBlZEFycmF5LCB3ZWlnaHRzRW50cnkubWFuaWZlc3RFbnRyeS5zaGFwZSwgd2VpZ2h0c0VudHJ5Lm1hbmlmZXN0RW50cnkuZHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJJbmRleE9mZnNldCArPSBudW1CdWZmZXJzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyLCB3ZWlnaHRzVGVuc29yTWFwXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRXZWlnaHRzID0gbG9hZFdlaWdodHM7XG4iLCIvLyBBIGxpYnJhcnkgb2Ygc2VlZGFibGUgUk5HcyBpbXBsZW1lbnRlZCBpbiBKYXZhc2NyaXB0LlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciBzZWVkcmFuZG9tID0gcmVxdWlyZSgnc2VlZHJhbmRvbScpO1xuLy8gdmFyIHJhbmRvbSA9IHNlZWRyYW5kb20oMSk7IC8vIG9yIGFueSBzZWVkLlxuLy8gdmFyIHggPSByYW5kb20oKTsgICAgICAgLy8gMCA8PSB4IDwgMS4gIEV2ZXJ5IGJpdCBpcyByYW5kb20uXG4vLyB2YXIgeCA9IHJhbmRvbS5xdWljaygpOyAvLyAwIDw9IHggPCAxLiAgMzIgYml0cyBvZiByYW5kb21uZXNzLlxuXG4vLyBhbGVhLCBhIDUzLWJpdCBtdWx0aXBseS13aXRoLWNhcnJ5IGdlbmVyYXRvciBieSBKb2hhbm5lcyBCYWFnw7hlLlxuLy8gUGVyaW9kOiB+Ml4xMTZcbi8vIFJlcG9ydGVkIHRvIHBhc3MgYWxsIEJpZ0NydXNoIHRlc3RzLlxudmFyIGFsZWEgPSByZXF1aXJlKCcuL2xpYi9hbGVhJyk7XG5cbi8vIHhvcjEyOCwgYSBwdXJlIHhvci1zaGlmdCBnZW5lcmF0b3IgYnkgR2VvcmdlIE1hcnNhZ2xpYS5cbi8vIFBlcmlvZDogMl4xMjgtMS5cbi8vIFJlcG9ydGVkIHRvIGZhaWw6IE1hdHJpeFJhbmsgYW5kIExpbmVhckNvbXAuXG52YXIgeG9yMTI4ID0gcmVxdWlyZSgnLi9saWIveG9yMTI4Jyk7XG5cbi8vIHhvcndvdywgR2VvcmdlIE1hcnNhZ2xpYSdzIDE2MC1iaXQgeG9yLXNoaWZ0IGNvbWJpbmVkIHBsdXMgd2V5bC5cbi8vIFBlcmlvZDogMl4xOTItMl4zMlxuLy8gUmVwb3J0ZWQgdG8gZmFpbDogQ29sbGlzaW9uT3ZlciwgU2ltcFBva2VyLCBhbmQgTGluZWFyQ29tcC5cbnZhciB4b3J3b3cgPSByZXF1aXJlKCcuL2xpYi94b3J3b3cnKTtcblxuLy8geG9yc2hpZnQ3LCBieSBGcmFuw6dvaXMgUGFubmV0b24gYW5kIFBpZXJyZSBMJ2VjdXllciwgdGFrZXNcbi8vIGEgZGlmZmVyZW50IGFwcHJvYWNoOiBpdCBhZGRzIHJvYnVzdG5lc3MgYnkgYWxsb3dpbmcgbW9yZSBzaGlmdHNcbi8vIHRoYW4gTWFyc2FnbGlhJ3Mgb3JpZ2luYWwgdGhyZWUuICBJdCBpcyBhIDctc2hpZnQgZ2VuZXJhdG9yXG4vLyB3aXRoIDI1NiBiaXRzLCB0aGF0IHBhc3NlcyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RtYXRpYyBmYWlsdXJlcy5cbi8vIFBlcmlvZCAyXjI1Ni0xLlxuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB4b3JzaGlmdDcgPSByZXF1aXJlKCcuL2xpYi94b3JzaGlmdDcnKTtcblxuLy8geG9yNDA5NiwgYnkgUmljaGFyZCBCcmVudCwgaXMgYSA0MDk2LWJpdCB4b3Itc2hpZnQgd2l0aCBhXG4vLyB2ZXJ5IGxvbmcgcGVyaW9kIHRoYXQgYWxzbyBhZGRzIGEgV2V5bCBnZW5lcmF0b3IuIEl0IGFsc28gcGFzc2VzXG4vLyBCaWdDcnVzaCB3aXRoIG5vIHN5c3RlbWF0aWMgZmFpbHVyZXMuICBJdHMgbG9uZyBwZXJpb2QgbWF5XG4vLyBiZSB1c2VmdWwgaWYgeW91IGhhdmUgbWFueSBnZW5lcmF0b3JzIGFuZCBuZWVkIHRvIGF2b2lkXG4vLyBjb2xsaXNpb25zLlxuLy8gUGVyaW9kOiAyXjQxMjgtMl4zMi5cbi8vIE5vIHN5c3RlbWF0aWMgQmlnQ3J1c2ggZmFpbHVyZXMgcmVwb3J0ZWQuXG52YXIgeG9yNDA5NiA9IHJlcXVpcmUoJy4vbGliL3hvcjQwOTYnKTtcblxuLy8gVHljaGUtaSwgYnkgU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLCBpcyBhIGJpdC1zaGlmdGluZyByYW5kb21cbi8vIG51bWJlciBnZW5lcmF0b3IgZGVyaXZlZCBmcm9tIENoYUNoYSwgYSBtb2Rlcm4gc3RyZWFtIGNpcGhlci5cbi8vIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG4vLyBQZXJpb2Q6IH4yXjEyN1xuLy8gTm8gc3lzdGVtYXRpYyBCaWdDcnVzaCBmYWlsdXJlcyByZXBvcnRlZC5cbnZhciB0eWNoZWkgPSByZXF1aXJlKCcuL2xpYi90eWNoZWknKTtcblxuLy8gVGhlIG9yaWdpbmFsIEFSQzQtYmFzZWQgcHJuZyBpbmNsdWRlZCBpbiB0aGlzIGxpYnJhcnkuXG4vLyBQZXJpb2Q6IH4yXjE2MDBcbnZhciBzciA9IHJlcXVpcmUoJy4vc2VlZHJhbmRvbScpO1xuXG5zci5hbGVhID0gYWxlYTtcbnNyLnhvcjEyOCA9IHhvcjEyODtcbnNyLnhvcndvdyA9IHhvcndvdztcbnNyLnhvcnNoaWZ0NyA9IHhvcnNoaWZ0NztcbnNyLnhvcjQwOTYgPSB4b3I0MDk2O1xuc3IudHljaGVpID0gdHljaGVpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNyO1xuIiwiLy8gQSBwb3J0IG9mIGFuIGFsZ29yaXRobSBieSBKb2hhbm5lcyBCYWFnw7hlIDxiYWFnb2VAYmFhZ29lLmNvbT4sIDIwMTBcbi8vIGh0dHA6Ly9iYWFnb2UuY29tL2VuL1JhbmRvbU11c2luZ3MvamF2YXNjcmlwdC9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ucXVpbmxhbi9iZXR0ZXItcmFuZG9tLW51bWJlcnMtZm9yLWphdmFzY3JpcHQtbWlycm9yXG4vLyBPcmlnaW5hbCB3b3JrIGlzIHVuZGVyIE1JVCBsaWNlbnNlIC1cblxuLy8gQ29weXJpZ2h0IChDKSAyMDEwIGJ5IEpvaGFubmVzIEJhYWfDuGUgPGJhYWdvZUBiYWFnb2Uub3JnPlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbi8vIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbi8vIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbi8vIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vIFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy8gXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4vLyBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbi8vIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuLy8gQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuLy8gTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbi8vIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbi8vIFRIRSBTT0ZUV0FSRS5cblxuXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIEFsZWEoc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzLCBtYXNoID0gTWFzaCgpO1xuXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IDIwOTE2MzkgKiBtZS5zMCArIG1lLmMgKiAyLjMyODMwNjQzNjUzODY5NjNlLTEwOyAvLyAyXi0zMlxuICAgIG1lLnMwID0gbWUuczE7XG4gICAgbWUuczEgPSBtZS5zMjtcbiAgICByZXR1cm4gbWUuczIgPSB0IC0gKG1lLmMgPSB0IHwgMCk7XG4gIH07XG5cbiAgLy8gQXBwbHkgdGhlIHNlZWRpbmcgYWxnb3JpdGhtIGZyb20gQmFhZ29lLlxuICBtZS5jID0gMTtcbiAgbWUuczAgPSBtYXNoKCcgJyk7XG4gIG1lLnMxID0gbWFzaCgnICcpO1xuICBtZS5zMiA9IG1hc2goJyAnKTtcbiAgbWUuczAgLT0gbWFzaChzZWVkKTtcbiAgaWYgKG1lLnMwIDwgMCkgeyBtZS5zMCArPSAxOyB9XG4gIG1lLnMxIC09IG1hc2goc2VlZCk7XG4gIGlmIChtZS5zMSA8IDApIHsgbWUuczEgKz0gMTsgfVxuICBtZS5zMiAtPSBtYXNoKHNlZWQpO1xuICBpZiAobWUuczIgPCAwKSB7IG1lLnMyICs9IDE7IH1cbiAgbWFzaCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmMgPSBmLmM7XG4gIHQuczAgPSBmLnMwO1xuICB0LnMxID0gZi5zMTtcbiAgdC5zMiA9IGYuczI7XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IEFsZWEoc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSB4Zy5uZXh0O1xuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpICogMHgxMDAwMDAwMDApIHwgMDsgfVxuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBwcm5nKCkgKyAocHJuZygpICogMHgyMDAwMDAgfCAwKSAqIDEuMTEwMjIzMDI0NjI1MTU2NWUtMTY7IC8vIDJeLTUzXG4gIH07XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5mdW5jdGlvbiBNYXNoKCkge1xuICB2YXIgbiA9IDB4ZWZjODI0OWQ7XG5cbiAgdmFyIG1hc2ggPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gKz0gZGF0YS5jaGFyQ29kZUF0KGkpO1xuICAgICAgdmFyIGggPSAwLjAyNTE5NjAzMjgyNDE2OTM4ICogbjtcbiAgICAgIG4gPSBoID4+PiAwO1xuICAgICAgaCAtPSBuO1xuICAgICAgaCAqPSBuO1xuICAgICAgbiA9IGggPj4+IDA7XG4gICAgICBoIC09IG47XG4gICAgICBuICs9IGggKiAweDEwMDAwMDAwMDsgLy8gMl4zMlxuICAgIH1cbiAgICByZXR1cm4gKG4gPj4+IDApICogMi4zMjgzMDY0MzY1Mzg2OTYzZS0xMDsgLy8gMl4tMzJcbiAgfTtcblxuICByZXR1cm4gbWFzaDtcbn1cblxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLmFsZWEgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcIlR5Y2hlLWlcIiBwcm5nIGFsZ29yaXRobSBieVxuLy8gU2FtdWVsIE5ldmVzIGFuZCBGaWxpcGUgQXJhdWpvLlxuLy8gU2VlIGh0dHBzOi8vZWRlbi5kZWkudWMucHQvfnNuZXZlcy9wdWJzLzIwMTEtc25mYTIucGRmXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGIgPSBtZS5iLCBjID0gbWUuYywgZCA9IG1lLmQsIGEgPSBtZS5hO1xuICAgIGIgPSAoYiA8PCAyNSkgXiAoYiA+Pj4gNykgXiBjO1xuICAgIGMgPSAoYyAtIGQpIHwgMDtcbiAgICBkID0gKGQgPDwgMjQpIF4gKGQgPj4+IDgpIF4gYTtcbiAgICBhID0gKGEgLSBiKSB8IDA7XG4gICAgbWUuYiA9IGIgPSAoYiA8PCAyMCkgXiAoYiA+Pj4gMTIpIF4gYztcbiAgICBtZS5jID0gYyA9IChjIC0gZCkgfCAwO1xuICAgIG1lLmQgPSAoZCA8PCAxNikgXiAoYyA+Pj4gMTYpIF4gYTtcbiAgICByZXR1cm4gbWUuYSA9IChhIC0gYikgfCAwO1xuICB9O1xuXG4gIC8qIFRoZSBmb2xsb3dpbmcgaXMgbm9uLWludmVydGVkIHR5Y2hlLCB3aGljaCBoYXMgYmV0dGVyIGludGVybmFsXG4gICAqIGJpdCBkaWZmdXNpb24sIGJ1dCB3aGljaCBpcyBhYm91dCAyNSUgc2xvd2VyIHRoYW4gdHljaGUtaSBpbiBKUy5cbiAgbWUubmV4dCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBhID0gbWUuYSwgYiA9IG1lLmIsIGMgPSBtZS5jLCBkID0gbWUuZDtcbiAgICBhID0gKG1lLmEgKyBtZS5iIHwgMCkgPj4+IDA7XG4gICAgZCA9IG1lLmQgXiBhOyBkID0gZCA8PCAxNiBeIGQgPj4+IDE2O1xuICAgIGMgPSBtZS5jICsgZCB8IDA7XG4gICAgYiA9IG1lLmIgXiBjOyBiID0gYiA8PCAxMiBeIGQgPj4+IDIwO1xuICAgIG1lLmEgPSBhID0gYSArIGIgfCAwO1xuICAgIGQgPSBkIF4gYTsgbWUuZCA9IGQgPSBkIDw8IDggXiBkID4+PiAyNDtcbiAgICBtZS5jID0gYyA9IGMgKyBkIHwgMDtcbiAgICBiID0gYiBeIGM7XG4gICAgcmV0dXJuIG1lLmIgPSAoYiA8PCA3IF4gYiA+Pj4gMjUpO1xuICB9XG4gICovXG5cbiAgbWUuYSA9IDA7XG4gIG1lLmIgPSAwO1xuICBtZS5jID0gMjY1NDQzNTc2OSB8IDA7XG4gIG1lLmQgPSAxMzY3MTMwNTUxO1xuXG4gIGlmIChzZWVkID09PSBNYXRoLmZsb29yKHNlZWQpKSB7XG4gICAgLy8gSW50ZWdlciBzZWVkLlxuICAgIG1lLmEgPSAoc2VlZCAvIDB4MTAwMDAwMDAwKSB8IDA7XG4gICAgbWUuYiA9IHNlZWQgfCAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFN0cmluZyBzZWVkLlxuICAgIHN0cnNlZWQgKz0gc2VlZDtcbiAgfVxuXG4gIC8vIE1peCBpbiBzdHJpbmcgc2VlZCwgdGhlbiBkaXNjYXJkIGFuIGluaXRpYWwgYmF0Y2ggb2YgNjQgdmFsdWVzLlxuICBmb3IgKHZhciBrID0gMDsgayA8IHN0cnNlZWQubGVuZ3RoICsgMjA7IGsrKykge1xuICAgIG1lLmIgXj0gc3Ryc2VlZC5jaGFyQ29kZUF0KGspIHwgMDtcbiAgICBtZS5uZXh0KCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuYSA9IGYuYTtcbiAgdC5iID0gZi5iO1xuICB0LmMgPSBmLmM7XG4gIHQuZCA9IGYuZDtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAodHlwZW9mKHN0YXRlKSA9PSAnb2JqZWN0JykgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnR5Y2hlaSA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cblxuIiwiLy8gQSBKYXZhc2NyaXB0IGltcGxlbWVudGFpb24gb2YgdGhlIFwieG9yMTI4XCIgcHJuZyBhbGdvcml0aG0gYnlcbi8vIEdlb3JnZSBNYXJzYWdsaWEuICBTZWUgaHR0cDovL3d3dy5qc3RhdHNvZnQub3JnL3YwOC9pMTQvcGFwZXJcblxuKGZ1bmN0aW9uKGdsb2JhbCwgbW9kdWxlLCBkZWZpbmUpIHtcblxuZnVuY3Rpb24gWG9yR2VuKHNlZWQpIHtcbiAgdmFyIG1lID0gdGhpcywgc3Ryc2VlZCA9ICcnO1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdCA9IG1lLnggXiAobWUueCA8PCAxMSk7XG4gICAgbWUueCA9IG1lLnk7XG4gICAgbWUueSA9IG1lLno7XG4gICAgbWUueiA9IG1lLnc7XG4gICAgcmV0dXJuIG1lLncgXj0gKG1lLncgPj4+IDE5KSBeIHQgXiAodCA+Pj4gOCk7XG4gIH07XG5cbiAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAvLyBJbnRlZ2VyIHNlZWQuXG4gICAgbWUueCA9IHNlZWQ7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RyaW5nIHNlZWQuXG4gICAgc3Ryc2VlZCArPSBzZWVkO1xuICB9XG5cbiAgLy8gTWl4IGluIHN0cmluZyBzZWVkLCB0aGVuIGRpc2NhcmQgYW4gaW5pdGlhbCBiYXRjaCBvZiA2NCB2YWx1ZXMuXG4gIGZvciAodmFyIGsgPSAwOyBrIDwgc3Ryc2VlZC5sZW5ndGggKyA2NDsgaysrKSB7XG4gICAgbWUueCBePSBzdHJzZWVkLmNoYXJDb2RlQXQoaykgfCAwO1xuICAgIG1lLm5leHQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb3B5KGYsIHQpIHtcbiAgdC54ID0gZi54O1xuICB0LnkgPSBmLnk7XG4gIHQueiA9IGYuejtcbiAgdC53ID0gZi53O1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3IxMjggPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIFJpY2hhcmQgQnJlbnQncyBYb3JnZW5zIHhvcjQwOTYgYWxnb3JpdGhtLlxuLy9cbi8vIFRoaXMgZmFzdCBub24tY3J5cHRvZ3JhcGhpYyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyBkZXNpZ25lZCBmb3Jcbi8vIHVzZSBpbiBNb250ZS1DYXJsbyBhbGdvcml0aG1zLiBJdCBjb21iaW5lcyBhIGxvbmctcGVyaW9kIHhvcnNoaWZ0XG4vLyBnZW5lcmF0b3Igd2l0aCBhIFdleWwgZ2VuZXJhdG9yLCBhbmQgaXQgcGFzc2VzIGFsbCBjb21tb24gYmF0dGVyaWVzXG4vLyBvZiBzdGFzdGljaWFsIHRlc3RzIGZvciByYW5kb21uZXNzIHdoaWxlIGNvbnN1bWluZyBvbmx5IGEgZmV3IG5hbm9zZWNvbmRzXG4vLyBmb3IgZWFjaCBwcm5nIGdlbmVyYXRlZC4gIEZvciBiYWNrZ3JvdW5kIG9uIHRoZSBnZW5lcmF0b3IsIHNlZSBCcmVudCdzXG4vLyBwYXBlcjogXCJTb21lIGxvbmctcGVyaW9kIHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9ycyB1c2luZyBzaGlmdHMgYW5kIHhvcnMuXCJcbi8vIGh0dHA6Ly9hcnhpdi5vcmcvcGRmLzEwMDQuMzExNXYxLnBkZlxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vIHZhciB4b3I0MDk2ID0gcmVxdWlyZSgneG9yNDA5NicpO1xuLy8gcmFuZG9tID0geG9yNDA5NigxKTsgICAgICAgICAgICAgICAgICAgICAgICAvLyBTZWVkIHdpdGggaW50MzIgb3Igc3RyaW5nLlxuLy8gYXNzZXJ0LmVxdWFsKHJhbmRvbSgpLCAwLjE1MjA0MzY0NTA1Mzg1NDcpOyAvLyAoMCwgMSkgcmFuZ2UsIDUzIGJpdHMuXG4vLyBhc3NlcnQuZXF1YWwocmFuZG9tLmludDMyKCksIDE4MDY1MzQ4OTcpOyAgIC8vIHNpZ25lZCBpbnQzMiwgMzIgYml0cy5cbi8vXG4vLyBGb3Igbm9uemVybyBudW1lcmljIGtleXMsIHRoaXMgaW1wZWxlbWVudGF0aW9uIHByb3ZpZGVzIGEgc2VxdWVuY2Vcbi8vIGlkZW50aWNhbCB0byB0aGF0IGJ5IEJyZW50J3MgeG9yZ2VucyAzIGltcGxlbWVudGFpb24gaW4gQy4gIFRoaXNcbi8vIGltcGxlbWVudGF0aW9uIGFsc28gcHJvdmlkZXMgZm9yIGluaXRhbGl6aW5nIHRoZSBnZW5lcmF0b3Igd2l0aFxuLy8gc3RyaW5nIHNlZWRzLCBvciBmb3Igc2F2aW5nIGFuZCByZXN0b3JpbmcgdGhlIHN0YXRlIG9mIHRoZSBnZW5lcmF0b3IuXG4vL1xuLy8gT24gQ2hyb21lLCB0aGlzIHBybmcgYmVuY2htYXJrcyBhYm91dCAyLjEgdGltZXMgc2xvd2VyIHRoYW5cbi8vIEphdmFzY3JpcHQncyBidWlsdC1pbiBNYXRoLnJhbmRvbSgpLlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdyA9IG1lLncsXG4gICAgICAgIFggPSBtZS5YLCBpID0gbWUuaSwgdCwgdjtcbiAgICAvLyBVcGRhdGUgV2V5bCBnZW5lcmF0b3IuXG4gICAgbWUudyA9IHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2ID0gWFsoaSArIDM0KSAmIDEyN107XG4gICAgdCA9IFhbaSA9ICgoaSArIDEpICYgMTI3KV07XG4gICAgdiBePSB2IDw8IDEzO1xuICAgIHQgXj0gdCA8PCAxNztcbiAgICB2IF49IHYgPj4+IDE1O1xuICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgLy8gVXBkYXRlIFhvciBnZW5lcmF0b3IgYXJyYXkgc3RhdGUuXG4gICAgdiA9IFhbaV0gPSB2IF4gdDtcbiAgICBtZS5pID0gaTtcbiAgICAvLyBSZXN1bHQgaXMgdGhlIGNvbWJpbmF0aW9uLlxuICAgIHJldHVybiAodiArICh3IF4gKHcgPj4+IDE2KSkpIHwgMDtcbiAgfTtcblxuICBmdW5jdGlvbiBpbml0KG1lLCBzZWVkKSB7XG4gICAgdmFyIHQsIHYsIGksIGosIHcsIFggPSBbXSwgbGltaXQgPSAxMjg7XG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIE51bWVyaWMgc2VlZHMgaW5pdGlhbGl6ZSB2LCB3aGljaCBpcyB1c2VkIHRvIGdlbmVyYXRlcyBYLlxuICAgICAgdiA9IHNlZWQ7XG4gICAgICBzZWVkID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RyaW5nIHNlZWRzIGFyZSBtaXhlZCBpbnRvIHYgYW5kIFggb25lIGNoYXJhY3RlciBhdCBhIHRpbWUuXG4gICAgICBzZWVkID0gc2VlZCArICdcXDAnO1xuICAgICAgdiA9IDA7XG4gICAgICBsaW1pdCA9IE1hdGgubWF4KGxpbWl0LCBzZWVkLmxlbmd0aCk7XG4gICAgfVxuICAgIC8vIEluaXRpYWxpemUgY2lyY3VsYXIgYXJyYXkgYW5kIHdleWwgdmFsdWUuXG4gICAgZm9yIChpID0gMCwgaiA9IC0zMjsgaiA8IGxpbWl0OyArK2opIHtcbiAgICAgIC8vIFB1dCB0aGUgdW5pY29kZSBjaGFyYWN0ZXJzIGludG8gdGhlIGFycmF5LCBhbmQgc2h1ZmZsZSB0aGVtLlxuICAgICAgaWYgKHNlZWQpIHYgXj0gc2VlZC5jaGFyQ29kZUF0KChqICsgMzIpICUgc2VlZC5sZW5ndGgpO1xuICAgICAgLy8gQWZ0ZXIgMzIgc2h1ZmZsZXMsIHRha2UgdiBhcyB0aGUgc3RhcnRpbmcgdyB2YWx1ZS5cbiAgICAgIGlmIChqID09PSAwKSB3ID0gdjtcbiAgICAgIHYgXj0gdiA8PCAxMDtcbiAgICAgIHYgXj0gdiA+Pj4gMTU7XG4gICAgICB2IF49IHYgPDwgNDtcbiAgICAgIHYgXj0gdiA+Pj4gMTM7XG4gICAgICBpZiAoaiA+PSAwKSB7XG4gICAgICAgIHcgPSAodyArIDB4NjFjODg2NDcpIHwgMDsgICAgIC8vIFdleWwuXG4gICAgICAgIHQgPSAoWFtqICYgMTI3XSBePSAodiArIHcpKTsgIC8vIENvbWJpbmUgeG9yIGFuZCB3ZXlsIHRvIGluaXQgYXJyYXkuXG4gICAgICAgIGkgPSAoMCA9PSB0KSA/IGkgKyAxIDogMDsgICAgIC8vIENvdW50IHplcm9lcy5cbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgaGF2ZSBkZXRlY3RlZCBhbGwgemVyb2VzOyBtYWtlIHRoZSBrZXkgbm9uemVyby5cbiAgICBpZiAoaSA+PSAxMjgpIHtcbiAgICAgIFhbKHNlZWQgJiYgc2VlZC5sZW5ndGggfHwgMCkgJiAxMjddID0gLTE7XG4gICAgfVxuICAgIC8vIFJ1biB0aGUgZ2VuZXJhdG9yIDUxMiB0aW1lcyB0byBmdXJ0aGVyIG1peCB0aGUgc3RhdGUgYmVmb3JlIHVzaW5nIGl0LlxuICAgIC8vIEZhY3RvcmluZyB0aGlzIGFzIGEgZnVuY3Rpb24gc2xvd3MgdGhlIG1haW4gZ2VuZXJhdG9yLCBzbyBpdCBpcyBqdXN0XG4gICAgLy8gdW5yb2xsZWQgaGVyZS4gIFRoZSB3ZXlsIGdlbmVyYXRvciBpcyBub3QgYWR2YW5jZWQgd2hpbGUgd2FybWluZyB1cC5cbiAgICBpID0gMTI3O1xuICAgIGZvciAoaiA9IDQgKiAxMjg7IGogPiAwOyAtLWopIHtcbiAgICAgIHYgPSBYWyhpICsgMzQpICYgMTI3XTtcbiAgICAgIHQgPSBYW2kgPSAoKGkgKyAxKSAmIDEyNyldO1xuICAgICAgdiBePSB2IDw8IDEzO1xuICAgICAgdCBePSB0IDw8IDE3O1xuICAgICAgdiBePSB2ID4+PiAxNTtcbiAgICAgIHQgXj0gdCA+Pj4gMTI7XG4gICAgICBYW2ldID0gdiBeIHQ7XG4gICAgfVxuICAgIC8vIFN0b3Jpbmcgc3RhdGUgYXMgb2JqZWN0IG1lbWJlcnMgaXMgZmFzdGVyIHRoYW4gdXNpbmcgY2xvc3VyZSB2YXJpYWJsZXMuXG4gICAgbWUudyA9IHc7XG4gICAgbWUuWCA9IFg7XG4gICAgbWUuaSA9IGk7XG4gIH1cblxuICBpbml0KG1lLCBzZWVkKTtcbn1cblxuZnVuY3Rpb24gY29weShmLCB0KSB7XG4gIHQuaSA9IGYuaTtcbiAgdC53ID0gZi53O1xuICB0LlggPSBmLlguc2xpY2UoKTtcbiAgcmV0dXJuIHQ7XG59O1xuXG5mdW5jdGlvbiBpbXBsKHNlZWQsIG9wdHMpIHtcbiAgaWYgKHNlZWQgPT0gbnVsbCkgc2VlZCA9ICsobmV3IERhdGUpO1xuICB2YXIgeGcgPSBuZXcgWG9yR2VuKHNlZWQpLFxuICAgICAgc3RhdGUgPSBvcHRzICYmIG9wdHMuc3RhdGUsXG4gICAgICBwcm5nID0gZnVuY3Rpb24oKSB7IHJldHVybiAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwOyB9O1xuICBwcm5nLmRvdWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRvIHtcbiAgICAgIHZhciB0b3AgPSB4Zy5uZXh0KCkgPj4+IDExLFxuICAgICAgICAgIGJvdCA9ICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDAsXG4gICAgICAgICAgcmVzdWx0ID0gKHRvcCArIGJvdCkgLyAoMSA8PCAyMSk7XG4gICAgfSB3aGlsZSAocmVzdWx0ID09PSAwKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICBwcm5nLmludDMyID0geGcubmV4dDtcbiAgcHJuZy5xdWljayA9IHBybmc7XG4gIGlmIChzdGF0ZSkge1xuICAgIGlmIChzdGF0ZS5YKSBjb3B5KHN0YXRlLCB4Zyk7XG4gICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gY29weSh4Zywge30pOyB9XG4gIH1cbiAgcmV0dXJuIHBybmc7XG59XG5cbmlmIChtb2R1bGUgJiYgbW9kdWxlLmV4cG9ydHMpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBpbXBsO1xufSBlbHNlIGlmIChkZWZpbmUgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBpbXBsOyB9KTtcbn0gZWxzZSB7XG4gIHRoaXMueG9yNDA5NiA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3aW5kb3cgb2JqZWN0IG9yIGdsb2JhbFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG4iLCIvLyBBIEphdmFzY3JpcHQgaW1wbGVtZW50YWlvbiBvZiB0aGUgXCJ4b3JzaGlmdDdcIiBhbGdvcml0aG0gYnlcbi8vIEZyYW7Dp29pcyBQYW5uZXRvbiBhbmQgUGllcnJlIEwnZWN1eWVyOlxuLy8gXCJPbiB0aGUgWG9yZ3NoaWZ0IFJhbmRvbSBOdW1iZXIgR2VuZXJhdG9yc1wiXG4vLyBodHRwOi8vc2FsdWMuZW5nci51Y29ubi5lZHUvcmVmcy9jcnlwdG8vcm5nL3Bhbm5ldG9uMDVvbnRoZXhvcnNoaWZ0LnBkZlxuXG4oZnVuY3Rpb24oZ2xvYmFsLCBtb2R1bGUsIGRlZmluZSkge1xuXG5mdW5jdGlvbiBYb3JHZW4oc2VlZCkge1xuICB2YXIgbWUgPSB0aGlzO1xuXG4gIC8vIFNldCB1cCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gIG1lLm5leHQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBVcGRhdGUgeG9yIGdlbmVyYXRvci5cbiAgICB2YXIgWCA9IG1lLngsIGkgPSBtZS5pLCB0LCB2LCB3O1xuICAgIHQgPSBYW2ldOyB0IF49ICh0ID4+PiA3KTsgdiA9IHQgXiAodCA8PCAyNCk7XG4gICAgdCA9IFhbKGkgKyAxKSAmIDddOyB2IF49IHQgXiAodCA+Pj4gMTApO1xuICAgIHQgPSBYWyhpICsgMykgJiA3XTsgdiBePSB0IF4gKHQgPj4+IDMpO1xuICAgIHQgPSBYWyhpICsgNCkgJiA3XTsgdiBePSB0IF4gKHQgPDwgNyk7XG4gICAgdCA9IFhbKGkgKyA3KSAmIDddOyB0ID0gdCBeICh0IDw8IDEzKTsgdiBePSB0IF4gKHQgPDwgOSk7XG4gICAgWFtpXSA9IHY7XG4gICAgbWUuaSA9IChpICsgMSkgJiA3O1xuICAgIHJldHVybiB2O1xuICB9O1xuXG4gIGZ1bmN0aW9uIGluaXQobWUsIHNlZWQpIHtcbiAgICB2YXIgaiwgdywgWCA9IFtdO1xuXG4gICAgaWYgKHNlZWQgPT09IChzZWVkIHwgMCkpIHtcbiAgICAgIC8vIFNlZWQgc3RhdGUgYXJyYXkgdXNpbmcgYSAzMi1iaXQgaW50ZWdlci5cbiAgICAgIHcgPSBYWzBdID0gc2VlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VlZCBzdGF0ZSB1c2luZyBhIHN0cmluZy5cbiAgICAgIHNlZWQgPSAnJyArIHNlZWQ7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgc2VlZC5sZW5ndGg7ICsraikge1xuICAgICAgICBYW2ogJiA3XSA9IChYW2ogJiA3XSA8PCAxNSkgXlxuICAgICAgICAgICAgKHNlZWQuY2hhckNvZGVBdChqKSArIFhbKGogKyAxKSAmIDddIDw8IDEzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gRW5mb3JjZSBhbiBhcnJheSBsZW5ndGggb2YgOCwgbm90IGFsbCB6ZXJvZXMuXG4gICAgd2hpbGUgKFgubGVuZ3RoIDwgOCkgWC5wdXNoKDApO1xuICAgIGZvciAoaiA9IDA7IGogPCA4ICYmIFhbal0gPT09IDA7ICsraik7XG4gICAgaWYgKGogPT0gOCkgdyA9IFhbN10gPSAtMTsgZWxzZSB3ID0gWFtqXTtcblxuICAgIG1lLnggPSBYO1xuICAgIG1lLmkgPSAwO1xuXG4gICAgLy8gRGlzY2FyZCBhbiBpbml0aWFsIDI1NiB2YWx1ZXMuXG4gICAgZm9yIChqID0gMjU2OyBqID4gMDsgLS1qKSB7XG4gICAgICBtZS5uZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgaW5pdChtZSwgc2VlZCk7XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLnguc2xpY2UoKTtcbiAgdC5pID0gZi5pO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIGlmIChzZWVkID09IG51bGwpIHNlZWQgPSArKG5ldyBEYXRlKTtcbiAgdmFyIHhnID0gbmV3IFhvckdlbihzZWVkKSxcbiAgICAgIHN0YXRlID0gb3B0cyAmJiBvcHRzLnN0YXRlLFxuICAgICAgcHJuZyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMDsgfTtcbiAgcHJuZy5kb3VibGUgPSBmdW5jdGlvbigpIHtcbiAgICBkbyB7XG4gICAgICB2YXIgdG9wID0geGcubmV4dCgpID4+PiAxMSxcbiAgICAgICAgICBib3QgPSAoeGcubmV4dCgpID4+PiAwKSAvIDB4MTAwMDAwMDAwLFxuICAgICAgICAgIHJlc3VsdCA9ICh0b3AgKyBib3QpIC8gKDEgPDwgMjEpO1xuICAgIH0gd2hpbGUgKHJlc3VsdCA9PT0gMCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgcHJuZy5pbnQzMiA9IHhnLm5leHQ7XG4gIHBybmcucXVpY2sgPSBwcm5nO1xuICBpZiAoc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUueCkgY29weShzdGF0ZSwgeGcpO1xuICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoeGcsIHt9KTsgfVxuICB9XG4gIHJldHVybiBwcm5nO1xufVxuXG5pZiAobW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gaW1wbDtcbn0gZWxzZSBpZiAoZGVmaW5lICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gaW1wbDsgfSk7XG59IGVsc2Uge1xuICB0aGlzLnhvcnNoaWZ0NyA9IGltcGw7XG59XG5cbn0pKFxuICB0aGlzLFxuICAodHlwZW9mIG1vZHVsZSkgPT0gJ29iamVjdCcgJiYgbW9kdWxlLCAgICAvLyBwcmVzZW50IGluIG5vZGUuanNcbiAgKHR5cGVvZiBkZWZpbmUpID09ICdmdW5jdGlvbicgJiYgZGVmaW5lICAgLy8gcHJlc2VudCB3aXRoIGFuIEFNRCBsb2FkZXJcbik7XG5cbiIsIi8vIEEgSmF2YXNjcmlwdCBpbXBsZW1lbnRhaW9uIG9mIHRoZSBcInhvcndvd1wiIHBybmcgYWxnb3JpdGhtIGJ5XG4vLyBHZW9yZ2UgTWFyc2FnbGlhLiAgU2VlIGh0dHA6Ly93d3cuanN0YXRzb2Z0Lm9yZy92MDgvaTE0L3BhcGVyXG5cbihmdW5jdGlvbihnbG9iYWwsIG1vZHVsZSwgZGVmaW5lKSB7XG5cbmZ1bmN0aW9uIFhvckdlbihzZWVkKSB7XG4gIHZhciBtZSA9IHRoaXMsIHN0cnNlZWQgPSAnJztcblxuICAvLyBTZXQgdXAgZ2VuZXJhdG9yIGZ1bmN0aW9uLlxuICBtZS5uZXh0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHQgPSAobWUueCBeIChtZS54ID4+PiAyKSk7XG4gICAgbWUueCA9IG1lLnk7IG1lLnkgPSBtZS56OyBtZS56ID0gbWUudzsgbWUudyA9IG1lLnY7XG4gICAgcmV0dXJuIChtZS5kID0gKG1lLmQgKyAzNjI0MzcgfCAwKSkgK1xuICAgICAgIChtZS52ID0gKG1lLnYgXiAobWUudiA8PCA0KSkgXiAodCBeICh0IDw8IDEpKSkgfCAwO1xuICB9O1xuXG4gIG1lLnggPSAwO1xuICBtZS55ID0gMDtcbiAgbWUueiA9IDA7XG4gIG1lLncgPSAwO1xuICBtZS52ID0gMDtcblxuICBpZiAoc2VlZCA9PT0gKHNlZWQgfCAwKSkge1xuICAgIC8vIEludGVnZXIgc2VlZC5cbiAgICBtZS54ID0gc2VlZDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdHJpbmcgc2VlZC5cbiAgICBzdHJzZWVkICs9IHNlZWQ7XG4gIH1cblxuICAvLyBNaXggaW4gc3RyaW5nIHNlZWQsIHRoZW4gZGlzY2FyZCBhbiBpbml0aWFsIGJhdGNoIG9mIDY0IHZhbHVlcy5cbiAgZm9yICh2YXIgayA9IDA7IGsgPCBzdHJzZWVkLmxlbmd0aCArIDY0OyBrKyspIHtcbiAgICBtZS54IF49IHN0cnNlZWQuY2hhckNvZGVBdChrKSB8IDA7XG4gICAgaWYgKGsgPT0gc3Ryc2VlZC5sZW5ndGgpIHtcbiAgICAgIG1lLmQgPSBtZS54IDw8IDEwIF4gbWUueCA+Pj4gNDtcbiAgICB9XG4gICAgbWUubmV4dCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LnggPSBmLng7XG4gIHQueSA9IGYueTtcbiAgdC56ID0gZi56O1xuICB0LncgPSBmLnc7XG4gIHQudiA9IGYudjtcbiAgdC5kID0gZi5kO1xuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaW1wbChzZWVkLCBvcHRzKSB7XG4gIHZhciB4ZyA9IG5ldyBYb3JHZW4oc2VlZCksXG4gICAgICBzdGF0ZSA9IG9wdHMgJiYgb3B0cy5zdGF0ZSxcbiAgICAgIHBybmcgPSBmdW5jdGlvbigpIHsgcmV0dXJuICh4Zy5uZXh0KCkgPj4+IDApIC8gMHgxMDAwMDAwMDA7IH07XG4gIHBybmcuZG91YmxlID0gZnVuY3Rpb24oKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIHRvcCA9IHhnLm5leHQoKSA+Pj4gMTEsXG4gICAgICAgICAgYm90ID0gKHhnLm5leHQoKSA+Pj4gMCkgLyAweDEwMDAwMDAwMCxcbiAgICAgICAgICByZXN1bHQgPSAodG9wICsgYm90KSAvICgxIDw8IDIxKTtcbiAgICB9IHdoaWxlIChyZXN1bHQgPT09IDApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG4gIHBybmcuaW50MzIgPSB4Zy5uZXh0O1xuICBwcm5nLnF1aWNrID0gcHJuZztcbiAgaWYgKHN0YXRlKSB7XG4gICAgaWYgKHR5cGVvZihzdGF0ZSkgPT0gJ29iamVjdCcpIGNvcHkoc3RhdGUsIHhnKTtcbiAgICBwcm5nLnN0YXRlID0gZnVuY3Rpb24oKSB7IHJldHVybiBjb3B5KHhnLCB7fSk7IH1cbiAgfVxuICByZXR1cm4gcHJuZztcbn1cblxuaWYgKG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGltcGw7XG59IGVsc2UgaWYgKGRlZmluZSAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIGltcGw7IH0pO1xufSBlbHNlIHtcbiAgdGhpcy54b3J3b3cgPSBpbXBsO1xufVxuXG59KShcbiAgdGhpcyxcbiAgKHR5cGVvZiBtb2R1bGUpID09ICdvYmplY3QnICYmIG1vZHVsZSwgICAgLy8gcHJlc2VudCBpbiBub2RlLmpzXG4gICh0eXBlb2YgZGVmaW5lKSA9PSAnZnVuY3Rpb24nICYmIGRlZmluZSAgIC8vIHByZXNlbnQgd2l0aCBhbiBBTUQgbG9hZGVyXG4pO1xuXG5cbiIsIi8qXG5Db3B5cmlnaHQgMjAxNCBEYXZpZCBCYXUuXG5cblBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZ1xuYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG5cIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbndpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbmRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0b1xucGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvXG50aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG5pbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCxcbkVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULlxuSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTllcbkNMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsXG5UT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRVxuU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbiovXG5cbihmdW5jdGlvbiAocG9vbCwgbWF0aCkge1xuLy9cbi8vIFRoZSBmb2xsb3dpbmcgY29uc3RhbnRzIGFyZSByZWxhdGVkIHRvIElFRUUgNzU0IGxpbWl0cy5cbi8vXG52YXIgZ2xvYmFsID0gdGhpcyxcbiAgICB3aWR0aCA9IDI1NiwgICAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICBjaHVua3MgPSA2LCAgICAgICAgIC8vIGF0IGxlYXN0IHNpeCBSQzQgb3V0cHV0cyBmb3IgZWFjaCBkb3VibGVcbiAgICBkaWdpdHMgPSA1MiwgICAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICBybmduYW1lID0gJ3JhbmRvbScsIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICBzdGFydGRlbm9tID0gbWF0aC5wb3cod2lkdGgsIGNodW5rcyksXG4gICAgc2lnbmlmaWNhbmNlID0gbWF0aC5wb3coMiwgZGlnaXRzKSxcbiAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgbWFzayA9IHdpZHRoIC0gMSxcbiAgICBub2RlY3J5cHRvOyAgICAgICAgIC8vIG5vZGUuanMgY3J5cHRvIG1vZHVsZSwgaW5pdGlhbGl6ZWQgYXQgdGhlIGJvdHRvbS5cblxuLy9cbi8vIHNlZWRyYW5kb20oKVxuLy8gVGhpcyBpcyB0aGUgc2VlZHJhbmRvbSBmdW5jdGlvbiBkZXNjcmliZWQgYWJvdmUuXG4vL1xuZnVuY3Rpb24gc2VlZHJhbmRvbShzZWVkLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICB2YXIga2V5ID0gW107XG4gIG9wdGlvbnMgPSAob3B0aW9ucyA9PSB0cnVlKSA/IHsgZW50cm9weTogdHJ1ZSB9IDogKG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIEZsYXR0ZW4gdGhlIHNlZWQgc3RyaW5nIG9yIGJ1aWxkIG9uZSBmcm9tIGxvY2FsIGVudHJvcHkgaWYgbmVlZGVkLlxuICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4oXG4gICAgb3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6XG4gICAgKHNlZWQgPT0gbnVsbCkgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgLy8gVXNlIHRoZSBzZWVkIHRvIGluaXRpYWxpemUgYW4gQVJDNCBnZW5lcmF0b3IuXG4gIHZhciBhcmM0ID0gbmV3IEFSQzQoa2V5KTtcblxuICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gIC8vIHJhbmRvbW5lc3MgaW4gZXZlcnkgYml0IG9mIHRoZSBtYW50aXNzYSBvZiB0aGUgSUVFRSA3NTQgdmFsdWUuXG4gIHZhciBwcm5nID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIG4gPSBhcmM0LmcoY2h1bmtzKSwgICAgICAgICAgICAgLy8gU3RhcnQgd2l0aCBhIG51bWVyYXRvciBuIDwgMiBeIDQ4XG4gICAgICAgIGQgPSBzdGFydGRlbm9tLCAgICAgICAgICAgICAgICAgLy8gICBhbmQgZGVub21pbmF0b3IgZCA9IDIgXiA0OC5cbiAgICAgICAgeCA9IDA7ICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGFuZCBubyAnZXh0cmEgbGFzdCBieXRlJy5cbiAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkgeyAgICAgICAgICAvLyBGaWxsIHVwIGFsbCBzaWduaWZpY2FudCBkaWdpdHMgYnlcbiAgICAgIG4gPSAobiArIHgpICogd2lkdGg7ICAgICAgICAgICAgICAvLyAgIHNoaWZ0aW5nIG51bWVyYXRvciBhbmRcbiAgICAgIGQgKj0gd2lkdGg7ICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGRlbm9taW5hdG9yIGFuZCBnZW5lcmF0aW5nIGFcbiAgICAgIHggPSBhcmM0LmcoMSk7ICAgICAgICAgICAgICAgICAgICAvLyAgIG5ldyBsZWFzdC1zaWduaWZpY2FudC1ieXRlLlxuICAgIH1cbiAgICB3aGlsZSAobiA+PSBvdmVyZmxvdykgeyAgICAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgbiAvPSAyOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgbGFzdCBieXRlLCBzaGlmdCBldmVyeXRoaW5nXG4gICAgICBkIC89IDI7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICByaWdodCB1c2luZyBpbnRlZ2VyIG1hdGggdW50aWxcbiAgICAgIHggPj4+PSAxOyAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIHdlIGhhdmUgZXhhY3RseSB0aGUgZGVzaXJlZCBiaXRzLlxuICAgIH1cbiAgICByZXR1cm4gKG4gKyB4KSAvIGQ7ICAgICAgICAgICAgICAgICAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgfTtcblxuICBwcm5nLmludDMyID0gZnVuY3Rpb24oKSB7IHJldHVybiBhcmM0LmcoNCkgfCAwOyB9XG4gIHBybmcucXVpY2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGFyYzQuZyg0KSAvIDB4MTAwMDAwMDAwOyB9XG4gIHBybmcuZG91YmxlID0gcHJuZztcblxuICAvLyBNaXggdGhlIHJhbmRvbW5lc3MgaW50byBhY2N1bXVsYXRlZCBlbnRyb3B5LlxuICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgLy8gQ2FsbGluZyBjb252ZW50aW9uOiB3aGF0IHRvIHJldHVybiBhcyBhIGZ1bmN0aW9uIG9mIHBybmcsIHNlZWQsIGlzX21hdGguXG4gIHJldHVybiAob3B0aW9ucy5wYXNzIHx8IGNhbGxiYWNrIHx8XG4gICAgICBmdW5jdGlvbihwcm5nLCBzZWVkLCBpc19tYXRoX2NhbGwsIHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgIC8vIExvYWQgdGhlIGFyYzQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gc3RhdGUgaWYgaXQgaGFzIGFuIFMgYXJyYXkuXG4gICAgICAgICAgaWYgKHN0YXRlLlMpIHsgY29weShzdGF0ZSwgYXJjNCk7IH1cbiAgICAgICAgICAvLyBPbmx5IHByb3ZpZGUgdGhlIC5zdGF0ZSBtZXRob2QgaWYgcmVxdWVzdGVkIHZpYSBvcHRpb25zLnN0YXRlLlxuICAgICAgICAgIHBybmcuc3RhdGUgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGNvcHkoYXJjNCwge30pOyB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiBjYWxsZWQgYXMgYSBtZXRob2Qgb2YgTWF0aCAoTWF0aC5zZWVkcmFuZG9tKCkpLCBtdXRhdGVcbiAgICAgICAgLy8gTWF0aC5yYW5kb20gYmVjYXVzZSB0aGF0IGlzIGhvdyBzZWVkcmFuZG9tLmpzIGhhcyB3b3JrZWQgc2luY2UgdjEuMC5cbiAgICAgICAgaWYgKGlzX21hdGhfY2FsbCkgeyBtYXRoW3JuZ25hbWVdID0gcHJuZzsgcmV0dXJuIHNlZWQ7IH1cblxuICAgICAgICAvLyBPdGhlcndpc2UsIGl0IGlzIGEgbmV3ZXIgY2FsbGluZyBjb252ZW50aW9uLCBzbyByZXR1cm4gdGhlXG4gICAgICAgIC8vIHBybmcgZGlyZWN0bHkuXG4gICAgICAgIGVsc2UgcmV0dXJuIHBybmc7XG4gICAgICB9KShcbiAgcHJuZyxcbiAgc2hvcnRzZWVkLFxuICAnZ2xvYmFsJyBpbiBvcHRpb25zID8gb3B0aW9ucy5nbG9iYWwgOiAodGhpcyA9PSBtYXRoKSxcbiAgb3B0aW9ucy5zdGF0ZSk7XG59XG5tYXRoWydzZWVkJyArIHJuZ25hbWVdID0gc2VlZHJhbmRvbTtcblxuLy9cbi8vIEFSQzRcbi8vXG4vLyBBbiBBUkM0IGltcGxlbWVudGF0aW9uLiAgVGhlIGNvbnN0cnVjdG9yIHRha2VzIGEga2V5IGluIHRoZSBmb3JtIG9mXG4vLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbi8vXG4vLyBUaGUgZyhjb3VudCkgbWV0aG9kIHJldHVybnMgYSBwc2V1ZG9yYW5kb20gaW50ZWdlciB0aGF0IGNvbmNhdGVuYXRlc1xuLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuLy8gdGhhdCBpcyBpbiB0aGUgcmFuZ2UgMCA8PSB4IDwgKHdpZHRoIF4gY291bnQpLlxuLy9cbmZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gIHZhciB0LCBrZXlsZW4gPSBrZXkubGVuZ3RoLFxuICAgICAgbWUgPSB0aGlzLCBpID0gMCwgaiA9IG1lLmkgPSBtZS5qID0gMCwgcyA9IG1lLlMgPSBbXTtcblxuICAvLyBUaGUgZW1wdHkga2V5IFtdIGlzIHRyZWF0ZWQgYXMgWzBdLlxuICBpZiAoIWtleWxlbikgeyBrZXkgPSBba2V5bGVuKytdOyB9XG5cbiAgLy8gU2V0IHVwIFMgdXNpbmcgdGhlIHN0YW5kYXJkIGtleSBzY2hlZHVsaW5nIGFsZ29yaXRobS5cbiAgd2hpbGUgKGkgPCB3aWR0aCkge1xuICAgIHNbaV0gPSBpKys7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHdpZHRoOyBpKyspIHtcbiAgICBzW2ldID0gc1tqID0gbWFzayAmIChqICsga2V5W2kgJSBrZXlsZW5dICsgKHQgPSBzW2ldKSldO1xuICAgIHNbal0gPSB0O1xuICB9XG5cbiAgLy8gVGhlIFwiZ1wiIG1ldGhvZCByZXR1cm5zIHRoZSBuZXh0IChjb3VudCkgb3V0cHV0cyBhcyBvbmUgbnVtYmVyLlxuICAobWUuZyA9IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgdmFyIHQsIHIgPSAwLFxuICAgICAgICBpID0gbWUuaSwgaiA9IG1lLmosIHMgPSBtZS5TO1xuICAgIHdoaWxlIChjb3VudC0tKSB7XG4gICAgICB0ID0gc1tpID0gbWFzayAmIChpICsgMSldO1xuICAgICAgciA9IHIgKiB3aWR0aCArIHNbbWFzayAmICgoc1tpXSA9IHNbaiA9IG1hc2sgJiAoaiArIHQpXSkgKyAoc1tqXSA9IHQpKV07XG4gICAgfVxuICAgIG1lLmkgPSBpOyBtZS5qID0gajtcbiAgICByZXR1cm4gcjtcbiAgICAvLyBGb3Igcm9idXN0IHVucHJlZGljdGFiaWxpdHksIHRoZSBmdW5jdGlvbiBjYWxsIGJlbG93IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBkaXNjYXJkcyBhbiBpbml0aWFsIGJhdGNoIG9mIHZhbHVlcy4gIFRoaXMgaXMgY2FsbGVkIFJDNC1kcm9wWzI1Nl0uXG4gICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgfSkod2lkdGgpO1xufVxuXG4vL1xuLy8gY29weSgpXG4vLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuLy9cbmZ1bmN0aW9uIGNvcHkoZiwgdCkge1xuICB0LmkgPSBmLmk7XG4gIHQuaiA9IGYuajtcbiAgdC5TID0gZi5TLnNsaWNlKCk7XG4gIHJldHVybiB0O1xufTtcblxuLy9cbi8vIGZsYXR0ZW4oKVxuLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuLy9cbmZ1bmN0aW9uIGZsYXR0ZW4ob2JqLCBkZXB0aCkge1xuICB2YXIgcmVzdWx0ID0gW10sIHR5cCA9ICh0eXBlb2Ygb2JqKSwgcHJvcDtcbiAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgIGZvciAocHJvcCBpbiBvYmopIHtcbiAgICAgIHRyeSB7IHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTsgfSBjYXRjaCAoZSkge31cbiAgICB9XG4gIH1cbiAgcmV0dXJuIChyZXN1bHQubGVuZ3RoID8gcmVzdWx0IDogdHlwID09ICdzdHJpbmcnID8gb2JqIDogb2JqICsgJ1xcMCcpO1xufVxuXG4vL1xuLy8gbWl4a2V5KClcbi8vIE1peGVzIGEgc3RyaW5nIHNlZWQgaW50byBhIGtleSB0aGF0IGlzIGFuIGFycmF5IG9mIGludGVnZXJzLCBhbmRcbi8vIHJldHVybnMgYSBzaG9ydGVuZWQgc3RyaW5nIHNlZWQgdGhhdCBpcyBlcXVpdmFsZW50IHRvIHRoZSByZXN1bHQga2V5LlxuLy9cbmZ1bmN0aW9uIG1peGtleShzZWVkLCBrZXkpIHtcbiAgdmFyIHN0cmluZ3NlZWQgPSBzZWVkICsgJycsIHNtZWFyLCBqID0gMDtcbiAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgIGtleVttYXNrICYgal0gPVxuICAgICAgbWFzayAmICgoc21lYXIgXj0ga2V5W21hc2sgJiBqXSAqIDE5KSArIHN0cmluZ3NlZWQuY2hhckNvZGVBdChqKyspKTtcbiAgfVxuICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbn1cblxuLy9cbi8vIGF1dG9zZWVkKClcbi8vIFJldHVybnMgYW4gb2JqZWN0IGZvciBhdXRvc2VlZGluZywgdXNpbmcgd2luZG93LmNyeXB0byBhbmQgTm9kZSBjcnlwdG9cbi8vIG1vZHVsZSBpZiBhdmFpbGFibGUuXG4vL1xuZnVuY3Rpb24gYXV0b3NlZWQoKSB7XG4gIHRyeSB7XG4gICAgdmFyIG91dDtcbiAgICBpZiAobm9kZWNyeXB0byAmJiAob3V0ID0gbm9kZWNyeXB0by5yYW5kb21CeXRlcykpIHtcbiAgICAgIC8vIFRoZSB1c2Ugb2YgJ291dCcgdG8gcmVtZW1iZXIgcmFuZG9tQnl0ZXMgbWFrZXMgdGlnaHQgbWluaWZpZWQgY29kZS5cbiAgICAgIG91dCA9IG91dCh3aWR0aCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dCA9IG5ldyBVaW50OEFycmF5KHdpZHRoKTtcbiAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgfVxuICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdmFyIGJyb3dzZXIgPSBnbG9iYWwubmF2aWdhdG9yLFxuICAgICAgICBwbHVnaW5zID0gYnJvd3NlciAmJiBicm93c2VyLnBsdWdpbnM7XG4gICAgcmV0dXJuIFsrbmV3IERhdGUsIGdsb2JhbCwgcGx1Z2lucywgZ2xvYmFsLnNjcmVlbiwgdG9zdHJpbmcocG9vbCldO1xuICB9XG59XG5cbi8vXG4vLyB0b3N0cmluZygpXG4vLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbi8vXG5mdW5jdGlvbiB0b3N0cmluZyhhKSB7XG4gIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xufVxuXG4vL1xuLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbi8vIGZyb20gdGhlIGJ1aWx0LWluIFJORyBpbnRvIHRoZSBlbnRyb3B5IHBvb2wuICBCZWNhdXNlIHdlIGRvXG4vLyBub3Qgd2FudCB0byBpbnRlcmZlcmUgd2l0aCBkZXRlcm1pbmlzdGljIFBSTkcgc3RhdGUgbGF0ZXIsXG4vLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuLy8gaW5pdGlhbGl6YXRpb24uXG4vL1xubWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4vL1xuLy8gTm9kZWpzIGFuZCBBTUQgc3VwcG9ydDogZXhwb3J0IHRoZSBpbXBsZW1lbnRhdGlvbiBhcyBhIG1vZHVsZSB1c2luZ1xuLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4vL1xuaWYgKCh0eXBlb2YgbW9kdWxlKSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHNlZWRyYW5kb207XG4gIC8vIFdoZW4gaW4gbm9kZS5qcywgdHJ5IHVzaW5nIGNyeXB0byBwYWNrYWdlIGZvciBhdXRvc2VlZGluZy5cbiAgdHJ5IHtcbiAgICBub2RlY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG4gIH0gY2F0Y2ggKGV4KSB7fVxufSBlbHNlIGlmICgodHlwZW9mIGRlZmluZSkgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gIGRlZmluZShmdW5jdGlvbigpIHsgcmV0dXJuIHNlZWRyYW5kb207IH0pO1xufVxuXG4vLyBFbmQgYW5vbnltb3VzIHNjb3BlLCBhbmQgcGFzcyBpbml0aWFsIHZhbHVlcy5cbn0pKFxuICBbXSwgICAgIC8vIHBvb2w6IGVudHJvcHkgcG9vbCBzdGFydHMgZW1wdHlcbiAgTWF0aCAgICAvLyBtYXRoOiBwYWNrYWdlIGNvbnRhaW5pbmcgcmFuZG9tLCBwb3csIGFuZCBzZWVkcmFuZG9tXG4pO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgXG5cdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cblx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWBcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxuXHQvLyBhbmQgdXNlIGl0IGFzIGByb290YFxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBzdHJpbmdGcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdO1xuXHRcdHZhciBjb3VudGVyID0gMDtcblx0XHR2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcblx0XHR2YXIgdmFsdWU7XG5cdFx0dmFyIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciBpbmRleCA9IC0xO1xuXHRcdHZhciB2YWx1ZTtcblx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0d2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuXHRcdFx0dGhyb3cgRXJyb3IoXG5cdFx0XHRcdCdMb25lIHN1cnJvZ2F0ZSBVKycgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgK1xuXHRcdFx0XHQnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZSdcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuXHRcdHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQpIHtcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG5cdFx0XHRyZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHZhciBzeW1ib2wgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkY4MDApID09IDApIHsgLy8gMi1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuXHRcdH1cblx0XHRlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2Vcblx0XHRcdGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50KTtcblx0XHRcdHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG5cdFx0XHRzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTgpICYgMHgwNykgfCAweEYwKTtcblx0XHRcdHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuXHRcdFx0c3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcblx0XHR9XG5cdFx0c3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcblx0XHRyZXR1cm4gc3ltYm9sO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcpIHtcblx0XHR2YXIgY29kZVBvaW50cyA9IHVjczJkZWNvZGUoc3RyaW5nKTtcblx0XHR2YXIgbGVuZ3RoID0gY29kZVBvaW50cy5sZW5ndGg7XG5cdFx0dmFyIGluZGV4ID0gLTE7XG5cdFx0dmFyIGNvZGVQb2ludDtcblx0XHR2YXIgYnl0ZVN0cmluZyA9ICcnO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcblx0XHRcdGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiBieXRlU3RyaW5nO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0ZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG5cdFx0aWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHR2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcblx0XHRieXRlSW5kZXgrKztcblxuXHRcdGlmICgoY29udGludWF0aW9uQnl0ZSAmIDB4QzApID09IDB4ODApIHtcblx0XHRcdHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcblx0XHR9XG5cblx0XHQvLyBJZiB3ZSBlbmQgdXAgaGVyZSwgaXTigJlzIG5vdCBhIGNvbnRpbnVhdGlvbiBieXRlXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGRlY29kZVN5bWJvbCgpIHtcblx0XHR2YXIgYnl0ZTE7XG5cdFx0dmFyIGJ5dGUyO1xuXHRcdHZhciBieXRlMztcblx0XHR2YXIgYnl0ZTQ7XG5cdFx0dmFyIGNvZGVQb2ludDtcblxuXHRcdGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcblx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcblx0XHR9XG5cblx0XHRpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIFJlYWQgZmlyc3QgYnl0ZVxuXHRcdGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuXHRcdGJ5dGVJbmRleCsrO1xuXG5cdFx0Ly8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG5cdFx0aWYgKChieXRlMSAmIDB4ODApID09IDApIHtcblx0XHRcdHJldHVybiBieXRlMTtcblx0XHR9XG5cblx0XHQvLyAyLWJ5dGUgc2VxdWVuY2Vcblx0XHRpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuXHRcdFx0Ynl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuXHRcdFx0Y29kZVBvaW50ID0gKChieXRlMSAmIDB4MUYpIDw8IDYpIHwgYnl0ZTI7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4ODApIHtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gMy1ieXRlIHNlcXVlbmNlIChtYXkgaW5jbHVkZSB1bnBhaXJlZCBzdXJyb2dhdGVzKVxuXHRcdGlmICgoYnl0ZTEgJiAweEYwKSA9PSAweEUwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwRikgPDwgMTIpIHwgKGJ5dGUyIDw8IDYpIHwgYnl0ZTM7XG5cdFx0XHRpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuXHRcdFx0XHRjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCk7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIDQtYnl0ZSBzZXF1ZW5jZVxuXHRcdGlmICgoYnl0ZTEgJiAweEY4KSA9PSAweEYwKSB7XG5cdFx0XHRieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRieXRlNCA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG5cdFx0XHRjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuXHRcdFx0XHQoYnl0ZTMgPDwgMHgwNikgfCBieXRlNDtcblx0XHRcdGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhyb3cgRXJyb3IoJ0ludmFsaWQgVVRGLTggZGV0ZWN0ZWQnKTtcblx0fVxuXG5cdHZhciBieXRlQXJyYXk7XG5cdHZhciBieXRlQ291bnQ7XG5cdHZhciBieXRlSW5kZXg7XG5cdGZ1bmN0aW9uIHV0ZjhkZWNvZGUoYnl0ZVN0cmluZykge1xuXHRcdGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG5cdFx0Ynl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcblx0XHRieXRlSW5kZXggPSAwO1xuXHRcdHZhciBjb2RlUG9pbnRzID0gW107XG5cdFx0dmFyIHRtcDtcblx0XHR3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbCgpKSAhPT0gZmFsc2UpIHtcblx0XHRcdGNvZGVQb2ludHMucHVzaCh0bXApO1xuXHRcdH1cblx0XHRyZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciB1dGY4ID0ge1xuXHRcdCd2ZXJzaW9uJzogJzIuMS4yJyxcblx0XHQnZW5jb2RlJzogdXRmOGVuY29kZSxcblx0XHQnZGVjb2RlJzogdXRmOGRlY29kZVxuXHR9O1xuXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHV0Zjg7XG5cdFx0fSk7XG5cdH1cdGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmICFmcmVlRXhwb3J0cy5ub2RlVHlwZSkge1xuXHRcdGlmIChmcmVlTW9kdWxlKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSB1dGY4O1xuXHRcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXG5cdFx0XHR2YXIgb2JqZWN0ID0ge307XG5cdFx0XHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdXRmOCkge1xuXHRcdFx0XHRoYXNPd25Qcm9wZXJ0eS5jYWxsKHV0ZjgsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSB1dGY4W2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QudXRmOCA9IHV0Zjg7XG5cdH1cblxufSh0aGlzKSk7XG4iXX0=
